{"pages":[{"title":"404","text":"","link":"/404.html"},{"title":"About","text":"Vitan 数码爱好者 Google，Andriod，OnePlus 粉 规则长方体固体物质空间移动工程师 关于本站 本博客是采用 Hexo + Icarus 搭建 本博客主要是用来记录学习和生活的过程 本博客文章有些原创,有些来源自网络,若侵犯了您的版权,告知后会在第一时间删除 联系方式 Email：ivitan.me#gmail.com Github：https://github.com/ivitan Telegram：ivitan","link":"/about/index.html"}],"posts":[{"title":"Termux","text":"简介Termux是一个 Android 下一个高级的终端模拟器, 开源且不需要 root, 支持apt 管理软件包，十分方便安装软件包, 完美支持 Python,PHP,Ruby,Go,Nodejs,MySQL 等。 命令基本命令 12345678910pkg search &lt;query&gt; #搜索包pkg install &lt;package&gt; #安装包pkg uninstall &lt;package&gt; #卸载包pkg reinstall &lt;package&gt; #重新安装包pkg update #更新源pkg upgrade #升级软件包pkg list-all #列出可供安装的所有包pkg list-installed #列出已经安装的包pkg shoe &lt;package&gt; #显示某个包的详细信息pkg files &lt;package&gt; #显示某个包的 手动安装 *.deb 文件 123dpkg -i ./package.deb #安装dpkg --remove [package name] #卸载dpkg --remove [package name] #列出所有已安装的包 换源清华源设置默认编辑器 1export EDITOR=vim 编辑源文件 1apt edit-sources 然后 https://mirrors.tuna.tsinghua.edu.cn/termux 代替原文中的 https://termux.net，保存退出 官方其他源123pkg install root-repopkg install x11-repopkg install unstable-repo its-pointless123pkg install wget$PREFIX/bin/wget https://its-pointless.github.io/setup-pointless-repo.shbash setup-pointless-repo.sh 库包括 gcc-7，gfortran，octave，r-cran（R语言），rustc，scipy 和许多游戏. Extra1234567# 将PGP密钥添加到APT的密钥环中pkg install dirmngrapt-key adv --keyserver pool.sks-keyservers.net --recv 9D6D488416B493F0# 手动下载公钥并添加它curl -LO https://raw.githubusercontent.com/xeffyr/termux-extra-packages/master/pubkey.ascapt-key add pubkey.asc apt edit-sources 加入下方内容 12# Xeffyr&apos;s Extra packagesdeb https://termux.xeffyr.ml/ extra main x11 库有 OpenJDK 修改启动问候语修改 1vim $PREFIX/etc/motd 不显示 1touch ~/.hushlogin 恢复双层键盘Termux在 0.66 取消了双层键盘 12mkdir $HOME/.termuxecho \"extra-keys = [['ESC','/','-','HOME','UP','END','PGUP'],['TAB','CTRL','ALT','LEFT','DOWN','RIGHT','PGDN']]\" &gt;&gt; $HOME/.termux/termux.properties 管理员权限 root 问题虚拟管理员(未root) 12pkg install proottermux-chroot # 启动命令 模拟root环境的同时，还会模拟linux的文件路径。 普通文件路径是【/data/data/com.termux/file/home】 开启后的文件路径是【/home】 真实管理员(已root) 12pkg install tsutsu # 启动命令 执行后文件路径不变，因此可以进入手机的任何一个目录 安装 SSH安装 1apt install openssh 设置 SSH Key配置账户信息 12git config --global user.name \"Vitan\"git config --global user.email \"ivitan95@gmail.com\" 创建 SSH 1ssh-keygen -t rsa -C \"ivtan95@gmail.com\" 复制 key 1cat ~/.ssh/id_rsa.pub 验证 SSH 1ssh -T git@github.com SSH 基础使用远程主机登录 12345ssh root@hostssh host#本地用户名与远程用户名一致，登录时可以省略用户名ssh -p 2222 root@host# SSH 的默认端口是22，使用 p 参数，可以修改这个端口。 公钥登录 12ssh-copy-id user@host#将公钥传送到远程主机 host 上面 如果还是不行，就打开远程主机的 /etc/ssh/sshd_config 这个文件，检查下面几行前面”#”注释是否取掉。 1234RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile.ssh/authorized_keys 然后，重启远程主机的ssh服务。 Ubuntu系统 service ssh restart Debian系统 /etc/init.d/ssh restart Oh-My-ZSH123apt install git zsh curl -ysh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"chsh -s zsh 安装 OpenJDK JDK1.8 aarch64谷歌云盘 aarch64百度云盘密码:ryea JDK1.9 aarch64下载 安装 12cd storage/下载目录dpkg -i openjdk9_9.2017.8.20_aarch64.deb 安装 Nodejs123pkg install nodejspkg install nodejs-lts 解决 npm 出现 npm err! cannot read property ‘length’ of undefined 问题 复制下面内容 1(require('os').cpus() || { length: 1 }).length 1vim ../usr/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js 修改如下 安装 Hexo12345678910111213mkdir blogcd blognpm install hexo-cli -gnpm initnpm installnpm install hexo-deployer-githexo g #生成静态文件hexo s #启动 Hexohexo d #部署到 Githubhexo new \"my blog\" #新建文章hexo s #开启本地服务hexo clean #清除 publicnpm update -g #版本更新 安装mariadb(MySQL)1pkg install mariadb 安装基本数据 1mysql_install_db mysqld: Can’t read dir ofソdata/data/com . termux/files/usr/e tc/my.cnf.d’ (Errcode: 2 “No such file or directory”) Fatal error in defaults handling. Program aborted 先在my.cnf所在目录下新建my.cnf.d文件夹，然后执行mysql_install_db 启动mariadb服务 1mysqld 启动mysql后，该回话便无法进行任何操作，需要左滑唤醒会话菜单，开启新的回话。而倘若不在一个会话里启动mysqld，而是直接运行mysql，则会2002错误。 修改mysql密码 12345678910mysql_secure_installation# 输入旧密码，空则直接回车Set root password? [Y/n] yNew password:Re-enter new password:# 两次输入新密码Remove anonymous users? [Y/n] Y #是否移除匿名用户Disallow root login remotely? [Y/n] n #是否不允许root远程登录Remove test database and access to it? [Y/n] n #是否移除test数据库Reload privilege tables now? [Y/n] y #是否重新加载表的权限 登录mysql 12mysql -uroot -pEnter password: ***apache2 或者使用 1mysql -uroot -p****** Python 环境部署安装 python2.7 1pkg install python2 安装 python3 1pkg install python 升级 pip 版本 12python2 -m pip install --upgrade pippython -m pip install --upgrade pip pip 版本查看 12pip -vpip3.6 -v ipythonipython 是一个 python 的交互式 shell，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。学习 ipython 将会让我们以一种更高的效率来使用 python。先安装clang, 否则直接使用pip安装ipython会失败报错. 安装 123pkg install clangpip install ipythonpip3.6 install ipython 使用 别使用ipython和ipython2进入py2和py3控制台: PHP部署安装 12pkg install php # 可采用phpinfo进行测试php -S 127.0.0.1:8080 -t www/ 编写测试文件 在家目录下建一个www文件夹:mkdir www 在www文件夹下新建一个index.php文件, 其内容为1&lt;?php phpinfo();?&gt; Nmap(口扫描必备工具)1pkg install nmap hydraHydra 是著名的黑客组织 THC 的一款开源暴力破解工具这是一个验证性质的工具，主要目的是：展示安全研究人员从远程获取一个系统认证权限。 安装 1pkg install hydra sslscanSSLscan 主要探测基于 ssl 的服务，如 https。SSLscan 是一款探测目标服务器所支持的 SSL 加密算法工具。 安装 1pkg install sslscan whatportiswhatportis 是一款可以通过服务查询默认端口，或者是通过端口查询默认服务的工具，简单易用。在渗透测试过程中，如果需要查询某个端口绑定什么服务器，或者某个应用绑定的默认端口，可以使用 whatportis 查询。 安装 1pip2 install whatportis RouterSploitRouteSploit 框架是一款开源的路由器等嵌入式设备漏洞检测及利用框架。 安装 1234pip2 install requestsgit clone https://github.com/reverse-shell/routersploitcd routersploitpython2 rsf.py Slowloris 低带宽的 DoS 工具123git clone https://github.com/gkbrk/slowloris.gitcd slowlorischmod +x slowloris.py 参考 Termux Wike android上的终端——termux Termux 高级终端安装使用配置教程","link":"/posts/Termux.html"},{"title":"Win10 v2ray/SSR/SS 开热点给手机翻墙","text":"在 Windows 10 中使用 V2ray、SSR、SS共享热点给手机实现翻墙,解决刷机后开机登录 Google 账号。 方法 电脑端 右键SSR/SS –&gt; 选项设置 –&gt; 勾选 允许来自局域网连接,V2ray 同样在设置中勾选 允许来自局域网的连接 CMD –&gt; 输入 ipconfig 获取 无线的IPV4地址 正常开启热点 手机端 长按连接的 WiFi 名,点修改网络 显示高级选项 代理 手动 服务器主机IP输入刚刚获取的 IPV4地址, 端口 1080 保存 跳过谷歌验证 方法一 即上述 Windows 10 开热点的方法 方法二 12adb shell settings put secure user_setup_complete 1adb shell settings put global device_provisioned 1 方法三 开机前不插入 SIM 卡,开机后不连接 WIFI,在开机导向时可以有选择跳过登录 Google 账号 方法四 顺时针方向，从左上角开始,连点屏幕四角","link":"/posts/Win10-Share-WiFI.html"},{"title":"Batch 计划任务","text":"Batch 计划任务 语法12345SCHTASKS /Create [/S system [/U username [/P [password]]]][/RU username [/RP password]] /SC schedule [/MO modifier] [/D day][/M months] [/I idletime] /TN taskname /TR taskrun [/ST starttime][/RI interval] [ {/ET endtime | /DU duration} [/K] [/XML xmlfile] [/V1]][/SD startdate] [/ED enddate] [/IT | /NP] [/Z] [/F] [/HRESULT] [/?] 描述:允许管理员在本地或远程系统上创建计划任务。 1schtasks /create /tn TaskName /tr TaskRun /sc minute [/mo {1 - 1439}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 参数列表 参数 含义 /S system 指定要连接到的远程系统。如果省略这个系统参数，默认是本地系统。 /U username 指定应在其中执行 SchTasks.exe 的用户上下文。 /P [password] 指定给定用户上下文的密码。如果省略则提示输入。 /RU username 指定任务在其下运行的“运行方式”用户,帐户(用户上下文)。对于系统帐户，有效值是 “”、”NT AUTHORITY\\SYSTEM” 或”SYSTEM”。对于 v2 任务，”NT AUTHORITY\\LOCALSERVICE”和 “NT AUTHORITY\\NETWORKSERVICE”以及常见的 SID 对这三个也都可用。 /RP [password] 指定“运行方式”用户的密码。要提示输入密码，值必须是 “*” 或无。系统帐户会忽略该密码。必须和 /RU 或 /XML 开关一起使用。 /RU/XML /SC schedule 指定计划频率。有效计划任务: MINUTE、 HOURLY、DAILY、WEEKLY、 MONTHLY, ONCE, ONSTART, ONLOGON, ONIDLE, ONEVENT. /MO modifier 改进计划类型以允许更好地控制计划重复周期。有效值列于下面“修改者”部分中。 /D days 指定该周内运行任务的日期。有效值:MON、TUE、WED、THU、FRI、SAT、SUN和对 MONTHLY 计划的 1 - 31(某月中的日期)。通配符“*”指定所有日期。 /M months 指定一年内的某月。默认是该月的第一天。有效值: JAN、FEB、MAR、APR、MAY、JUN、JUL、 AUG、SEP、OCT、NOV 和 DEC。通配符 “*” 指定所有的月。 /I idletime 指定运行一个已计划的 ONIDLE 任务之前要等待的空闲时间。有效值范围: 1 到 999 分钟。 /TN taskname 以路径\\名称形式指定对此计划任务进行唯一标识的字符串。 /TR taskrun 指定在这个计划时间运行的程序的路径和文件名。例如: C:\\windows\\system32\\calc.exe /ST starttime 指定运行任务的开始时间。时间格式为 HH:mm (24 小时时间)，例如 14:30 表示 2:30 PM。如果未指定 /ST，则默认值为当前时间。/SC ONCE 必需有此选项。 /RI interval 用分钟指定重复间隔。这不适用于计划类型: MINUTE、HOURLY、ONSTART, ONLOGON, ONIDLE, ONEVENT.有效范围: 1 - 599940 分钟。如果已指定 /ET 或 /DU，则其默认值为10 分钟。 /ET endtime 指定运行任务的结束时间。时间格式为 HH:mm (24 小时时间)，例如，14:50 表示 2:50 PM。这不适用于计划类型: ONSTART、ONLOGON, ONIDLE, ONEVENT. /DU duration 指定运行任务的持续时间。 时间格式为 HH:mm。这不适用于 /ET 和 计划类型: ONSTART, ONLOGON, ONIDLE, ONEVENT.对于 /V1 任务，如果已指定 /RI，则持续时间默认值为1 小时。 /K 在结束时间或持续时间终止任务。这不适用于计划类型: ONSTART、ONLOGON, ONIDLE, ONEVENT.必须指定 /ET 或 /DU。 /SD startdate 指定运行任务的第一个日期。格式为 yyyy/mm/dd。默认值为当前日期。这不适用于计划类型: ONCE、ONSTART, ONLOGON, ONIDLE, ONEVENT. /ED enddate 指定此任务运行的最后一天的日期。格式是 yyyy/mm/dd。这不适用于计划类型:ONCE、ONSTART、ONLOGON、ONIDLE。 /EC ChannelName 为 OnEvent 触发器指定事件通道。 /IT 仅有在 /RU 用户当前已登录且作业正在运行时才可以交互式运行任务。此任务只有在用户已登录的情况下才运行。 /NP 不储存任何密码。任务以给定用户的身份非交互的方式运行。只有本地资源可用。 /Z 标记在最终运行完任务后删除任务。 /XML xmlfile 从文件的指定任务 XML 中创建任务。可以组合使用 /RU 和 /RP 开关，或者在任务 XML 已包含主体时单独使用 /RP。 /V1 创建 Vista 以前的平台可以看见的任务。不兼容 /XML。 /F 如果指定的任务已经存在，则强制创建任务并抑制警告。 /RL level 为作业设置运行级别。有效值为 LIMITED 和 HIGHEST。默认值为 LIMITED。 /DELAY delaytime 指定触发触发器后延迟任务运行的等待时间。时间格式为mmmm:ss。此选项仅对计划类型ONSTART, ONLOGON, ONEVENT. /HRESULT 为获得更出色的故障诊断能力，处理退出代码将采用 HRESULT 格式。 /? 显示此帮助消息。 修改者: 按计划类型的 /MO 开关的有效值: 参数 有效值 MINUTE 1 到 1439 分钟 HOURLY 1 - 23 小时 DAILY 1 到 365 天 WEEKLY 1 到 52 周 ONCE 无修改者 ONSTART 无修改者 ONLOGON 无修改者 ONIDLE 无修改者 MONTHLY 1 到 12，或FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY ONEVENT XPath 事件查询字符串 示例 在远程机器 “ABC” 上创建计划任务 “doc”， “runasuser” 用户下运行 notepad.exe。 12SCHTASKS /Create /S ABC /U user /P password /RU runasuser /RP runaspassword /SC HOURLY /TN doc /TR notepad 远程机器 “ABC” 上创建计划任务 “accountant”， 在指定的开始日期和结束日期之间的开始时间和结束时间内，每隔五分钟运行 calc.exe。 123SCHTASKS /Create /S ABC /U domain\\user /P password /SC MINUTE /MO 5 /TN accountant /TR calc.exe /ST 12:00 /ET 14:00 /SD 06/06/2006 /ED 06/06/2006 /RU runasuser /RP userpassword 创建计划任务 “gametime”，在每月的第一个星期天运行“空当接龙”。 12SCHTASKS /Create /SC MONTHLY /MO first /D SUN /TN gametime /TR c:\\windows\\system32\\freecell 在远程机器 “ABC” 创建计划任务 “report”，每个星期运行 notepad.exe。 12SCHTASKS /Create /S ABC /U user /P password /RU runasuser/RP runaspassword /SC WEEKLY /TN report /TR notepad.exe 在远程机器 “ABC” 创建计划任务 “logtracker”，每隔五分钟从指定的开始时间到无结束时间，运行 notepad.exe。将提示输入 /RP 密码。 1234SCHTASKS /Create /S ABC /U domain\\user /P password /SC MINUTE/MO 5 /TN logtracker/TR c:\\windows\\system32\\notepad.exe /ST 18:30/RU runasuser /RP 创建计划任务 “gaming”，每天从 12:00 点开始到14:00 点自动结束，运行 freecell.exe。 12SCHTASKS /Create /SC DAILY /TN gaming /TR c:\\freecell /ST 12:00/ET 14:00 /K 创建计划任务“EventLog”以开始运行 wevtvwr.msc只要在“系统”通道中发布事件 101 12SCHTASKS /Create /TN EventLog /TR wevtvwr.msc /SC ONEVENT/EC System /MO *[System/EventID=101] 文件路径中可以加入空格，但需要加上两组引号，一组引号用于 CMD.EXE，另一组用于 SchTasks.exe。用于 CMD的外部引号必须是一对双引号；内部引号可以是一对单引号或一对转义双引号: 123SCHTASKS /Create/tr \"'c:\\program files\\internet explorer\\iexplorer.exe'\\\"c:\\log data\\today.xml\\\"\" ... 令计划安全脚本 Sec.vbs 每 20 分钟运行一次。由于命令没有包含起始日期或时间，任务在命令完成 20 分钟后启动，此后每当系统运行它就每 20 分钟运行一次。请注意，安全脚本源文件位于远程计算机上，但任务在本地计算机上计划并执行。 1schtasks /create /sc minute /mo 20 /tn \"Security Script\" /tr \\\\central\\data\\scripts\\sec.vbs 其他实例转载自:https://blog.csdn.net/lionzl/article/details/40896893 schtasks create hourly1schtasks /create /tn TaskName /tr TaskRun /sc hourly [/mo {1 - 365}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 计划命令在每小时过五分的时候运行。 下面的命令将计划 MyApp 程序从午夜过后五分钟起每小时运行一次。因为忽略了 /mo 参数，命令使用了小时计划的默认值，即每 (1) 小时。如果该命令在 12:05 A.M 之后生成，程序将在第二天才会运行。 1schtasks /create /sc hourly /st 00:05:00 /tn \"My App\" /tr c:\\apps\\myapp.exe 计划命令每五小时运行一次 下面的命令计划 MyApp 程序从 2001 年 3 月的第一天起每五小时运行一次。它使用 /mo 参数来指定间隔时间，使用 /sd 参数来指定起始日期。由于命令没有指定起始时间，当前时间被用作起始时间。 1schtasks /create /sc hourly /mo 5 /sd 03/01/2001 /tn \"My App\" /tr c:\\apps\\myapp.exe schtasks create daily1schtasks /create /tn TaskName /tr TaskRun /sc daily [/mo {1 - 365}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 计划任务每天运行一次 下面的范例计划 MyApp 程序在每天的 8:00 A.M. 运行一次，直到 2001 年 12 月 31 日结束。由于它忽略了 /mo 参数，所以使用默认间隔 1 来每天运行命令。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc daily /st 08:00:00 /ed 12/31/2001 计划任务每隔一天运行一次 下面的范例计划 MyApp 程序从 2001 年 12 月 31 日起每隔一天在 1:00 P.M. (13:00) 运行。命令使用 /mo 参数来指定两 (2) 天的间隔。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc daily /mo 2 /st 13:00:00 /sd 12/31/2001 schtasks create weekly1schtasks /create /tn TaskName /tr TaskRun /sc weekly [/d {MON - SUN | *}] [/mo {1 - 52}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 计划任务每六周运行一次 下面的命令计划 MyApp 程序在远程计算机上每六周运行一次。该命令使用 /mo 参数来指定间隔。它也使用 /s 参数来指定远程计算机，使用 /ru 参数来计划任务以用户的 Administrator 帐户权限运行。因为忽略了 /rp 参数，SchTasks.exe 会提示用户输入 Administrator 帐户密码。 另外，因为命令是远程运行的，所以命令中所有的路径，包括到 MyApp.exe 的路径，都是指向远程计算机上的路径。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc weekly /mo 6 /s Server16 /ru Admin01 计划任务每隔一周在周五运行 下面的命令计划任务每隔一周在周五运行。它使用 /mo 参数来指定两周的间隔，使用 /d 参数来指定是一周内的哪一天。如计划任务在每个周五运行，要忽略 /mo 参数或将其设置为 1。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc weekly /mo 2 /d FRI schtasks create monthly常规月计划语法1schtasks /create /tn TaskName /tr TaskRun /sc monthly [/mo {FIRST | SECOND | THIRD | FOURTH | LAST | LASTDAY] [/d {MON - SUN | 1 - 31}] [/m {JAN - DEC[,JAN - DEC...] | *}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 指定周的语法 1schtasks /create /tn TaskName /tr TaskRun /sc monthly /mo {FIRST | SECOND | THIRD | FOURTH | LAST} /d {MON - SUN} [/m {JAN - DEC[,JAN - DEC...] | *}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] Lastday 语法 1schtasks /create /tn TaskName /tr TaskRun /sc monthly /mo LASTDAY /m {JAN - DEC[,JAN - DEC...] | *} [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 指定日期的语法 1schtasks /create /tn TaskName /tr TaskRun /sc monthly /d {1 - 31} [/m {JAN - DEC[,JAN - DEC...] | *}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 计划任务在每月的第一天运行下面的命令计划 MyApp 程序在每月的第一天运行。因为默认修饰符是 none（即：没有修饰符），默认天是第一天，默认的月份是每个月，所以该命令不需要任何其它的参数。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly 计划任务在每月的最后一天运行下面的命令计划 MyApp 程序在每月的最后一天运行。它使用 /mo 参数指定在每月的最后一天运行程序，使用通配符 (*) 与 /m 参数表明在每月的最后一天运行程序。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /mo lastday /m * 计划任务每三个月运行一次下面的命令计划 MyApp 程序每三个月运行一次。.它使用 /mo 参数来指定间隔。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /mo 3 计划任务在每月的第二个周日运行下面的命令计划 MyApp 程序在每月的第二个周日运行。它使用 /mo 参数指定是每月的第二周，使用 /d 参数指定天。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /mo SECOND /d SUN 计划任务在五月和六月的第 15 天运行。下面的命令计划 MyApp 程序在五月 15 日和六月 15 日的 3:00 PM (15:00) 运行。它使用 /d 参数来指定日期，使用 /m 参数指定月份。它也使用 /st 参数来指定开始时间。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /d 15 /m MAY,JUN /st 15:00:00 schtasks create once1schtasks /create /tn TaskName /tr TaskRun /sc once /st StartTime /sd StartDate [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 计划任务运行一次下面的命令计划 MyApp 程序在 2002 年 1 月 1 日午夜运行一次。它使用 /ru 参数指定以用户的 Administrator 帐户权限运行任务，使用 /rp 参数为 Administrator 帐户提供密码。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc once /st 00:00:00 /sd 01/01/2002 /ru Admin23 /rp p@ssworD1 schtasks create onstart1schtasks /create /tn TaskName /tr TaskRun /sc onstart [/sd StartDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 计划任务在每次系统启动的时候运行下面的命令计划 MyApp 程序在每次系统启动的时候运行，起始日期是 2001 年 3 月 15 日。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc onstart /sd 03/15/2001 schtasks create onlogon1schtasks /create /tn TaskName /tr TaskRun /sc onlogon [/sd StartDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 计划任务在用户登录到远程计算机的时候运行下面的命令计划批处理文件在用户（任何用户）每次登录到远程计算机上的时候运行。它使用 /s 参数指定远程计算机。因为命令是远程的，所以命令中所有的路径，包括批处理文件的路径，都指定为远程计算机上的路径。 1schtasks /create /tn \"Start Web Site\" /tr c:\\myiis\\webstart.bat /sc onlogon /s Server23 schtasks create onidle1schtasks /create /tn TaskName /tr TaskRun /sc onidle /iIdleTime [/sd StartDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] 计划某项任务在计算机空闲的时候运行下面的命令计划 MyApp 程序在计算机空闲的时候运行。它使用必需的 /i 参数指定在启动任务之前计算机必需持续空闲十分钟。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc onidle /i 10 创建以 System 权限运行的任务下面的命令计划 MyApp 程序以 NT Authority\\System 帐户权限运行。在这个范例中，任务计划在每月的第一天运行，但对于以系统权限运行的任务可以使用所有的计划类型。 该命令使用 /ru “System” 参数指定系统安全上下文。因为系统任务不需要密码，所以忽略了 /rp 参数。 1schtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /d 1 /ru \"System\" 作为响应，SchTasks.exe 显示一个信息性消息和一个成功消息。它不提示输入密码。信息：此任务将被创建于用户名下 (“NT AUTHORITY\\SYSTEM”)。 成功：计划任务 “My App” 已成功创建。 创建运行多个程序的任务每个任务只能运行一个程序。但是可以创建一个运行多个程序的批处理文件，然后计划一个任务来运行该批处理文件。下面的过程说明了这个方法： 创建一个启动要运行程序的批处理文件。 在这个范例中创建了一个启动“事件查看器”(Eventvwr.exe) 和“系统监视器”(Perfmon.exe) 的批处理文件。 启动文本编辑器，例如“记事本”。 键入每个程序的名称和指向可执行文件的完全合格的路径。在这种情况下，文件包含有下列语句。 MyApp.bat12C:\\Windows\\System32\\Eventvwr.exeC:\\Windows\\System32\\Perfmon.exe 使用 SchTasks.exe 创建一个运行 MyApps.bat 的任务。 下面的命令创建了 Monitor 任务，每当有人登录它就运行。它使用 /tn 参数命名任务，使用 /tr 参数运行 MyApps.bat。它使用 /sc 参数来指明 OnLogon 计划类型，使用 /ru 参数指定 Administrator 帐户。 1chtasks /create /tn Monitor /tr C:\\MyApps.bat /sc onlogon /ru Reskit\\Administrator 该命令的结果是，每当用户登录到计算机，任务就启动“事件查看器”和“系统监视器”。 更改计划任务更改一个或多个下列任务属性。 任务运行的程序 (/tr)。 任务运行的用户帐户 (/ru)。 用户帐户的密码 (/rp)。 语法 1schtasks /change /tn TaskName [/s computer [/u [domain\\]user /p password]] [/tr TaskRun] [/ru [Domain\\]User | \"System\"] [/rp Password] 参数 含义 /tn TaskName 标识要更改的任务。输入任务名 /s Computer 指定远程计算机的名称或 IP 地址（带有或者没有反斜杠）。默认值是本地计算机 /u [domain\\]user 使用特定用户帐户的权限运行命令。默认情况下，使用已登录到运行 SchTasks 的计算机上的用户的权限运行命令 /p password 指定在 /u 参数中指定的用户帐户的密码。如果使用 /u 参数，则需要该参数 /tr TaskRun 更改任务运行的程序。输入可执行文件、脚本文件或批处理文件的完全合格的路径和文件名。如果忽略了路径，SchTasks.exe 假定文件在 Systemroot\\System32 目录下指定的程序替换任务最初运行的程序 /ru [Domain\\]User &quot;System&quot; 更改用于任务的用户帐户。 [domain]User 指定用户帐户”System” or “ 指定为操作系统所使用的 NT Authority\\System 帐户。在更改用户帐户的时候，必须也要更改用户密码。如果命令带有 /ru 参数，但没有 /rp 参数，SchTasks.exe 提示要求输入新的密码而且不显示键入的文本。任务以不需要密码的 NT Authority\\System 帐户权限运行，SchTasks.exe 不会提示输入密码 /p Password 更改用于任务的帐户密码。输入新的密码 /? 在命令提示符显示帮助 注释 XOX /tn 和 /s 参数标识该任务。/tr、/ru 和 /rp 参数指定可以更改的任务属性。 使用 change 操作的命令必须至少更改一个任务属性。 NT Authority\\System 帐户没有交互式登录权限。用户看不到以系统权限运行的程序，不能与其交互。 更改任务运行的程序下面的命令将 Virus Check 任务运行的程序由 VirusCheck.exe 更改为 VirusCheck2.exe。此命令使用 /tn 参数标识任务，使用 /tr 参数指定任务的新程序。（不能更改任务名称。） 1schtasks /change /tn \"Virus Check\" /tr C:\\VirusCheck2.exe","link":"/posts/WinTask.html"},{"title":"Batch","text":"Batch 批量处理 %~dp0[获取当前路径] %~dp0 “d”为Drive的缩写，即为驱动器，磁盘、“p”为Path缩写，即为路径，目录 cd %~dp0 ：进入批处理所在目录 cd %~dp0bin\\ ：进入批处理所在目录的bin目录 1234REM 作用：以管理员身份安装Apached:cd %~dp0bin\\httpd.exe -k install -n \"Apache24\" 以管理员身份运行 示例.bat ，执行结果如下： 123C:\\Windows\\system32&gt;d:D:\\&gt;cd D:\\Server\\Apache24\\bin\\D:\\Server\\Apache24\\bin&gt;httpd.exe -k install -n \"Apache24\" 常用命令%cd%[执行的路径]当前执行的路径，并非目标文件的路径 taskill12taskkill /f /im notepad.exe [终止进程]taskkill /?打开帮助 获取命令帮助 xxx /?遇到记不清楚的命令，但记得名字，就可以键入 命令名 空格 /?就会有详细的该命令的帮助了，比如：ping /? , cd /? 查看内置命令帮助信息12345678910ver /?cmd /?set /?rem /?if /?echo /?goto /?for /?shift /?call /? 其他常用的命令1234type /?find /?findstr /?copy /? 基础语法 批处理文件是一个“.bat”结尾的文本文件，这个文件的每一行都是一条DOS命令。可以使用任何文本文件编辑工具创建和修改。 批处理是一种简单的程序，可以用 if 和 goto 来控制流程，也可以使用 for 循环。 批处理的编程能力远不如C语言等编程语言，也十分不规范。 每个编写好的批处理文件都相当于一个DOS的外部命令，把它所在的目录放到DOS搜索路径(path)中，即可在任意位置运行。 C:\\AUTOEXEC.BAT 是每次系统启动时都会自动运行的，可以将每次启动时都要运行的命令放入该文件中。 大小写不敏感(命令符忽略大小写) 批处理的文件扩展名为 .bat 或 .cmd。 在命令提示下键入批处理文件的名称，或者双击该批处理文件，系统就会调用Cmd.exe来运行该文件。 参数系统参数1234567891011121314%SystemRoot% ===&gt; C:\\WINDOWS (%windir% 同样)%ProgramFiles% ===&gt; C:\\Program Files%USERPROFILE% ===&gt; C:\\Documents and Settings\\Administrator (子目录有“桌面”,“开始菜单”,“收藏夹”等)%APPDATA% ===&gt; C:\\Documents and Settings\\Administrator\\Application Data%TEMP% ===&gt; C:\\DOCUME~1\\ADMINI~1\\LOCALS~1\\Temp (%TEM% 同样)%APPDATA% ===&gt; C:\\Documents and Settings\\Administrator\\Application Data%OS% ===&gt; Windows_NT (系统)%Path% ===&gt; %SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem (原本的设置)%HOMEDRIVE% ===&gt; C: (系统盘)%HOMEPATH% ===&gt; \\Documents and Settings\\AdministratorREM 枚举当前的环境变量setlocal enabledelayedexpansionFOR /F \"usebackq delims==\" %%i IN (`set`) DO @echo %%i !%%i! 传递参数给批处理文件%[1-9]表示参数，参数是指在运行批处理文件时在文件名后加的以空格(或者Tab)分隔的字符串。 变量可以从%0到%9，%0表示批处理命令本身，其它参数字符串用 %1 到 %9 顺序表示。 12REM 执行同目录下的“test2.bat”文件，并输入两个参数call test2.bat \"hello\" \"haha\" 在“test2.bat”文件里写: 1234echo %1 (打印: \"hello\")echo %2 (打印: \"haha\")echo %0 (打印: test2.bat)echo %19 (打印: \"hello\"9) 批处理基本命令help 命令/? 命令，语法： 命令 /? 可显示此命令的帮助信息 12REM 把 type 命令的帮助信息写入到tmp.txt文件里type /? &gt;&gt;tmp.txt 1help type (显示跟“type /?”一样) Echo 命令语法: 12345678echo [{on|off}] [message]ECHO [ON | OFF] 打开回显或关闭回显功能。ECHO 显示当前回显设置。ECHO [message] 显示信息。echo off 表示在此语句后所有运行的命令都不显示命令行本身；默认是on，on时会显示如： C:\\文件夹路径&gt;命令行。 在实际应用中我们会把这条命令和重定向符号( 也称为管道符号，一般用 &gt; &gt;&gt; ^ )结合来实现输入一些命令到特定格式的文件中。 123456789echo offREM 显示出“hello world”echo hello world echo Windows Registry Editor Version 5.00 &gt; c:\\setupreg.reg REM 追加内容进 setupreg.reg 这个文件echo \"SourcePath\"=\"D:\\\\Win2003\\\\\" &gt;&gt; c:\\setupreg.reg @ 命令表示不显示@后面的命令 @ 与 echo off 相象，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行(只能影响当前行)。 12345@echo off REM 此语句常用于开头，表示不显示所有的命令行信息，包括此句@echo please wait a minite...@format X: /q/u/autoset format 这个命令是不可以使用/y这个参数的，可喜的是微软留了个autoset这个参数给我们，效果和/y是一样的。 Goto 命令语法：goto label (label是参数，指定所要转向的批处理程序中的行。) 指定跳转到标签行，找到标签行后，程序将处理从下一行开始的命令。 label标签的名字可以随便起，但是最好是有意义的，字母前必须加个冒号“:”来表示这个字母是标签。 goto命令就是根据这个冒号来寻找下一步跳到到那里。经常与 if 配合使用，根据不同的条件来执行不同的命令组。 Rem 命令语法：Rem Message…(小技巧：用::代替rem) 注释命令，在C语言中相当与/…/,它并不会被执行，只是起一个注释的作用，便于别人阅读和自己日后修改。 1@Rem Here is the description. Pause 命令会暂停批处理的执行并在屏幕上显示Press any key to continue…的提示，等待用户按任意键后继续 123456@echo off:begincopy a:*.* d:\\backecho Please put a new disk into driver Apausegoto begin 在这个例子中，驱动器 A 中磁盘上的所有文件均复制到d:\\back中。 显示的信息提示您将另一张磁盘放入驱动器 A 时，pause 命令会使程序挂起，以便您更换磁盘，然后按任意键再次复制。 Call 命令语法: 1call [[Drive:][Path] FileName [BatchParameters]] [:label [arguments]] 参数: [Drive:][Path] FileName 指定要调用的批处理程序的位置和名称。filename 参数必须具有 .bat 或 .cmd 扩展名。 调用另一个批处理程序，并且不终止父批处理程序。如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令。call 命令接受用作调用目标的标签。如果在脚本或批处理文件外使用 Call，它将不会在命令行起作用。 12345REM 调用指定目录下的 test2.bat，且输入3个参数给他call=\"%cd%\\test2.bat\" haha kkk aaaREM 调用同目录下的 test2.bat，且输入2个参数给他call test2.bat arg1 arg2 注：可以调用自身(死循环、递归) Start 命令调用外部程序，所有的 DOS命令 和 命令行程序 都可以由 start命令 来调用。 常用参数： MIN 开始时窗口最小化 SEPARATE 在分开的空间内开始 16 位 Windows 程序 HIGH 在 HIGH 优先级类别开始应用程序 REALTIME 在 REALTIME 优先级类别开始应用程序 WAIT 启动应用程序并等候它结束 parameters 这些为传送到命令/程序的参数 12345REM 调用同目录下的 test2.bat，且输入2个参数给他，且本窗口最小化start /MIN test2.bat arg1 arg2REM 文件路径名有空格时e:\\\"program files\"\\qq.exe If 命令if 表示将判断是否符合规定的条件，从而决定执行不同的命令。有三种格式: 语法: 1if [not] \"参数\" == \"字符串\" 待执行的命令 参数如果等于(not表示不等，下同)指定的字符串，则条件成立，运行命令，否则运行下一句。(注意是两个等号) 123if \"%1\" == \"a\" format a:if {%1} == {} goto noparms If exist语法: if [not] exist [路径]文件名 待执行的命令 如果有指定的文件，则条件成立，运行命令，否则运行下一句。 12345REM 存在这文件，则编辑它，用很难看的系统编辑器if exist config.sys edit config.sysREM 如果存在这文件，则显示它的内容if exist config.sys type config.sys If errorlevel number语法: if [not] errorlevel &lt;数字&gt; 待执行的命令 如果程序返回值等于指定的数字，则条件成立，运行命令，否则运行下一句。(返回值必须按照从大到小的顺序排列) 123456@echo offXCOPY F:\\test.bat D:\\IF ERRORLEVEL 1 (ECHO 文件拷贝失败) Else IF ERRORLEVEL 0 ECHO 成功拷贝文件pause 很多DOS程序在运行结束后会返回一个数字值用来表示程序运行的结果(或者状态)，称为错误码errorlevel或称返回码。 常见的返回码为0、1。通过if errorlevel命令可以判断程序的返回值，根据不同的返回值来决定执行不同的命令。 Else语法： if 条件 (成立时执行的命令) else (不成立时执行的命令) 如果是多个条件，建议适当使用括号把各条件包起来，以免出错。 1234567if 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) else (echo comment3 )REM 如果 else 的语句需要换行，if 执行的行尾需用“^”连接，并且 if 执行的动作需用(括起来)，否则报错if 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) ^else (echo comment3 ) 比较运算符:123456EQU - 等于 (一般使用“==”)NEQ - 不等于 (没有 “!=”,改用“ if not 1==1 ”的写法)LSS - 小于LEQ - 小于或等于GTR - 大于GEQ - 大于或等于 Choice 命令choice 使用此命令可以让用户输入一个字符(用于选择)，从而根据用户的选择返回不同的 errorlevel，然后配合 if errorlevel 选择运行不同的命令。 注意：choice命令为DOS或者Windows系统提供的外部命令，不同版本的choice命令语法会稍有不同，请用choice /?查看用法。choice 使用此命令可以让用户输入一个字符，从而运行不同的命令。使用时应该加/c:参数，c:后应写提示可输入的字符，之间无空格。它的返回码为1234…… 1choice /c:dme defrag,mem,end 将显示: defrag,mem,end[D,M,E]? 12345choice /c:dme defrag,mem,endif errorlevel 3 goto defrag (应先判断数值最高的错误码)if errorlevel 2 goto memif errotlevel 1 goto end For 命令for 命令是一个比较复杂的命令，主要用于参数在指定的范围内循环执行命令。 1for {%variable | %%variable} in (set) do command [command-parameters] %variable 指定一个单一字母可替换的参数。变量名称是区分大小写的，所以 %i 不同于 %I,在批处理文件中使用 FOR 命令时，指定变量建议用 %%variable而不要用 %variable set 指定一个或一组文件。可以使用通配符 command 指定对每个文件执行的命令 command-parameters 为特定命令指定参数或命令行开关。 如果命令扩展名被启用，额外的 FOR 命令格式会受到支持a. 1FOR /D %variable IN (set) DO command [command-parameters] 如果集里面包含通配符，则指定与目录名匹配，而不与文件名匹配。 b. 1FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters] 检查以 [drive:]path 为根的目录树，指向每个目录中的FOR 语句。 如果在 /R 后没有指定目录，则使用当前目录。如果集仅为一个单点(.)字符，则枚举该目录树。 c. 1FOR /L %variable IN (start,step,end) DO command [command-parameters] 该集表示以增量形式从开始到结束的一个数字序列。 如：(1,1,5) 将产生序列 1 2 3 4 5； 而(5,-1,1) 将产生序列 (5 4 3 2 1)。 d.有或者没有 usebackq 选项: 123FOR /F [\"options\"] %variable IN (file-set) DO commandFOR /F [\"options\"] %variable IN (\"string\") DO commandFOR /F [\"options\"] %variable IN (command) DO command 参数”options”为: eol=c - 指一个行注释字符的结尾(就一个,如“;”) skip=n - 指在文件开始时忽略的行数。 delims=xxx - 指分隔符集。这个替换了空格和跳格键的默认分隔符集。 tokens=x,y,m-n - 指每行的哪一个符号被传递到每个迭代的 for 本身。这会导致额外变量名称的分配。 m-n格式为一个范围。通过 nth 符号指定 mth。 如果符号字符串中的最后一个字符星号，那么额外的变量将在最后一个符号解析之后分配并接受行的保留文本。 usebackq - 指定新语法已在下类情况中使用: 在作为命令执行一个后引号的字符串并且一个单引号字符为文字字符串命令并允许在 filenameset中使用双引号扩起文件名称。 显示当前目录下所有以bat或者txt为扩展名的文件名 1for %%c in (*.bat *.txt) do (echo %%c) a. 显示当前目录下所有包含有 e 或者 i 的目录名 1for /D %%a in (*e* *i*) do echo %%a b. 显示 E盘test目录 下所有以bat或者txt为扩展名的文件名。 12for /R E:\\test %%b in (*.txt *.bat) do echo %%bfor /r %%c in (*) do (echo %%c) :: 遍历当前目录下所有文件 c. 如下命令行将产生序列 1 2 3 4 5 1for /L %%c in (1,1,5) do echo %%c d. 以下两句，显示当前的年月日和时间 123For /f \"tokens=1-3 delims=-/. \" %%j In ('Date /T') do echo %%j年%%k月%%l日For /f \"tokens=1,2 delims=: \" %%j In ('TIME /T') do echo %%j时%%k分 e. 把记事本中的内容每一行前面去掉8个字符 1234567891011setlocal enabledelayedexpansionfor /f %%i in (zhidian.txt) do (set atmp=%%iset atmp=!atmp:~8!if {!atmp!}=={} ( echo.) else echo !atmp!)REM 读取记事本里的内容(使用 delims 是为了把一行显示全,否则会以空格为分隔符)for /f \"delims=\" %%a in (zhidian.txt) do echo.%%a continue 和 break利用 goto 实现程序中常用的 continue 和 break 命令, 其实非常简单 continue 在 for 循环的最后一行写上一个标签，跳转到这位置即可 break 在 for 循环的外面的下一句写上一个标签，跳转到这位置即可 12345678for /F [\"options\"] %variable IN (command) DO (... do command ...if ... goto continueif ... goto break... do command ...:continue):break 其它命令ping 命令测试网络联接状况以及信息包发送和接收状况。但是不能够测试端口。 1ping IP地址或主机名 [-t] [-a] [-n count] [-l size] 参数含义： -t 不停地向目标主机发送数据； -a 以IP地址格式来显示目标主机的网络地址； -n count 指定要Ping多少次，具体次数由count来指定； -l size 指定发送到目标主机的数据包的大小。 12345REM 不停的测试192.168.0.1，按ctrl+c停止ping 192.168.0.1 -t ()REM ping一下所有的局域网电脑for /L %%a in (0,1,255) do ping 192.168.0.%%a -n 1 &gt;&gt; tmp.txt telnet 命令测试端口使用 telnet IP地址或主机名 端口，使用tcp协议的 1telnet 192.168.0.1 80 (测试192.168.0.1的80端口) color 命令设置背景及字体颜色 1color bf b 是指定背景色的十六进制数字； f 指定前景颜色(即字体颜色)。 颜色值: 0:黑色 1:蓝色 2:绿色 3:湖蓝 4:红色 5:紫色 6:** 7:白色 8:灰色 9:淡蓝 A:淡绿 B:浅绿 C:淡红 D:淡紫 E:淡黄 F:亮白 如果没有给定任何参数，该命令会将颜色还原到 CMD.EXE 启动时的颜色。 如果两参数一样，视为无效输入。只有一个参数时，设置字体。 random 命令产生随机数(正整数0~) exit 命令结束程序。即时是被调用的程序，结束后也不会返回原程序 shutdown命令12REM关机shutdown -s 字符串处理分割字符串，以查看时间为例%源字符串:~起始值,截取长度% (起始值从0开始；截取长度是可选的，如果省略逗号和截取长度，将会从起始值截取到结尾； 截取长度如果是负数，表示截取到倒数第几个。) %time% 显示如：”11:04:23.03” (完整的时间”hh:mm:ss.tt”) %time:~0,5% 显示”hh:mm”(即”11:04”)，其中0表示从右向左移位操作的个数，5表示从左向右移位操作的个数 %time:~0,8% 显示标准时间格式”hh:mm:ss”(即”11:04:23”，前8个字符串) %time:~3,-3% 显示”mm:ss”(即从第4个开始,截去最后3个的字符串) %time:~3% 显示”04:23.03”(即去掉前4个字符串) %time:~-3% 显示”.tt”(即最后3个字符串) 上面的字串分割格式，也可以用于其它地方，如目录路径：”%cd:~0,10%” 替换字符串1234set a=\"abcd1234\"echo %a% 显示：\"abcd1234\"set a=%a:1=kk% 替换“1”为“kk”echo %a% 显示：\"abcdkk234\" 字符串合并由于没有直接的字符串合并函数，只能用笨方法了。 1set str1=%str1%%str2% (合并 str1 和 str2) 计算字符串长度没有现成的函数。如下程序利用 goto形成循环，不断将字符串截短1，并记录截短的次数，到字符串变成空时的次数即长度。 12345678910111213141516171819set testStr=This is a test stringREM 将 testStr 复制到str，str 是个临时字符串set str=%testStr%REM 标签，用于goto跳转:next1REM 判断str是不是空，如果不是则执行下边的语句if not \"%str%\"==\"\" (REM 算术运算，使num的值自增1，相当于num++或者++num语句set /a num+=1REM 截取字符串，每次截短1set \"str=%str:~1%\"REM 跳转到next1标签: 这里利用goto和标签，构成循环结构goto next1)REM 当以上循环结构执行完毕时，会执行下边的语句echo testStr=%testStr%echo testStr的长度为：%num% 截取字符串时，需要传递参数直接 echo %args:~%num%,-5% 没办法想要的字符串，需要如下两步 12setlocal enabledelayedexpansionecho !args:~%num%,-5! 注册表操作备份注册表 将[HKEY_LOCAL_MACHINE … Run]的内容，备份到“c:\\windows\\1.reg” 12reg export HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run c:\\windows\\1.regreg export HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run c:\\windows\\2.reg 修改/添加注册表内容 一般的添加或修改1reg add \"HKCU\\Environment\" /v Java_Home /t reg_sz /d \"D:\\Java\\jdk1.6.0_07\" /f 上句解析：“HKCU”是“HKEY_CURRENT_USER”的缩写，不用缩写用全称也可以； 添加名称为“Java_Home”的变量；类型为“reg_sz”，另一种常见类型是“reg_dword”；值为 D:\\Java\\jdk1.6.0_07； 使用变量12set SoftWareHome=HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft\\Javareg add \"%SoftWareHome%Web Start\\1.6.0_07\" /v Home /t reg_sz /d \"%cd%\\jre1.6.0_07\\bin\" /f 注册表的名称有空格，或者数据用特殊符号时123456reg add \"%SoftWareHome2%\\HelpCommands\" /v \"01:Online Documentation\" /t reg_sz /d \"\\\"%cd%\\Documentation\\Index.htm\\\"\" /fREM 传入值为(值用双引号括起来的)：\"D:\\ProgramFiles\\1.work_soft\\Sybase\\PowerDesigner_12\\Documentation\\Index.htm\"reg add \"%SoftWareHome2%\\Paths\" /v ReportTemplates /t reg_sz /d \"%cd%\\Resource Files\\Report Templates\\\\\" /f传入值为(“\\”结尾的)： E:\\Holemar\\1.notes\\90. Windows\\Resource Files\\Report Templates\\ 增加空的内容1reg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Shared Tools\\MSConfig\\startupreg\\IMJPMIG8.1\" 添加或修改默认值1reg add \"%vpath%InstallPath\" /ve /t reg_sz /d \"%cd%\" /f 这里用“/ve”来代替一般修改时的“/v 变量名”,即可修改默认值了 删除注册表的内容双引号里面的是注册表的目录，下面两句将删除这目录下的所有信息 12reg delete \"HKEY_CURRENT_USER\\Software\\RealVNC\" /freg delete \"HKEY_LOCAL_MACHINE\\SOFTWARE\\RealVNC\" /f 双引号里面的是注册表的目录，下面一句将删除这目录下指定的某个信息 1reg delete \"HKEY_LOCAL_MACHINE\\Software\\RealVNC\" /v VNC_Server /f 注册表的常用位置系统启动项： 123[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run][HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run]example: REG ADD HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v VNC_Server /t REG_SZ /d \"%cd%\\VNC_Server.bat\" /f 系统环境变量：1[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment] 当前用户的环境变量：1[HKEY_CURRENT_USER\\Environment] 刷新注册表修改注册表之后，结束并重新加载explorer.exe进程，可刷新注册表，令其生效 12taskkill /f /im explorer.exe &gt;nulstart \"\" \"explorer.exe\" 系统服务停止/启动12345REM 停止服务NET STOP 服务名REM 启动服务NET Start 服务名 设置启动类型12345678REM 自动： SC CONFIG 服务名 START= autoREM 手动： SC CONFIG 服务名 START= demandREM 已禁用：SC CONFIG 服务名 START= disabled 附：“START= ”等号后面必须要有一个空格。(start还有boot,system两个值) 12REM 打印机加载项，设置成手动，默认自动SC CONFIG Spooler START= demand 查看系统服务：1start %SystemRoot%\\system32\\services.msc /s setlocal与变量延迟在没有开启变量延迟的情况下，某条命令行中的变量改变，必须到下一条命令才能体现。另外例如for命令等，其后用一对圆括号闭合的所有语句也当作一行。 12set a=4set a=5 &amp; echo %a% 结果：4 也可以对这种机制加以利用，如下的变量交换 12345set var1=abcset var2=123echo 交换前： var1=%var1% var2=%var2%set var1=%var2%&amp; set var2=%var1%echo 交换后： var1=%var1% var2=%var2% 启动批处理文件中环境变量的本地化。本地化将持续到出现匹配的 endlocal 命令或者到达批处理文件结尾为止。 语法: 1setlocal {enableextension | disableextensions} {enabledelayedexpansion | disabledelayedexpansion} enableextension 启用命令扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。 disableextensions 禁用命令扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。 enabledelayedexpansion 启用延迟的环境变量扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。 disabledelayedexpansion 禁用延迟的环境变量扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。 为了能够感知环境变量的动态变化，批处理设计了变量延迟。简单来说，在读取了一条完整的语句之后，不立即对该行的变量赋值，而会在某个单条语句执行之前再进行赋值，也就是说“延迟”了对变量的赋值。 123setlocal enabledelayedexpansionset a=4set a=5 &amp; echo !a! 结果： 5 变量延迟的启动语句是“setlocal enabledelayedexpansion”，并且变量要用一对叹号“!!”括起来 由于启动了变量延迟，所以批处理能够感知到动态变化，即不是先给该行变量赋值，而是在运行过程中给变量赋值，因此此时a的值就是5了 另外，启动变量延迟，“%”的变量还是不变 12345setlocal enabledelayedexpansionfor /l %%i in (1,1,5) do (set a=%%iecho !a!) 结果，打印从1到5；如果不变量延迟，一个变量也没有打印 文件处理删除 删除一个文件或多个文件 1del /s /q /f d:\\test\\a.bat 将直接删除d:\\test\\a.bat，没有任务提示 1del temp\\* /q /f /s 将直接删除 本目录的 temp 目录的所有文件，没有任务提示删除文件的时候可以使用“*”作通配符 删除一个空目录 1rd /q /s d:\\test\\log 将直接删除d:\\test\\log目录，如果log目录里面有文件将无法删除 删除一个非空目录 (必须指定目录名称) 1rmdir /q /s d:\\test\\logs 必须指定目录名称，不能使用通配符 /S 除目录本身外，还将删除指定目录下的所有子目录 /Q 安静模式，带 /S 删除目录树时不要求确认 无论里面是否有文件或文件夹将全部直接删除 创建目录12MKDIR [drive:]pathMD [drive:]path 路径有空格时，可以用双引号括起来，也可以用 &nbsp; 替代 实践部分 调用其他程序时，对文件的大小写不敏感，文件后缀也可忽略,如：start LeapFTP.exe 与 start leapftp 效果一样，都是运行“LeapFTP.exe”文件。每行的开头的字符串会自动查找程序来运行，还可用双引号引起来(文件名或目录名含空格时必须用),如：”D:\\Program Files\\Leap FTP.exe” “LeapFTP.exe” 可正常运行文件，start “” “LeapFTP.exe” 也可以正常运行文件(注意，第一个参数是窗口显示的标题) copy C:\\test\\*.* D:\\back (复制C盘test文件夹的所有文件(不包括文件夹及子文件夹里的东西)到D盘的back文件夹) dir c:\\*.* &gt; a.txt (将c盘文件列表写入 a.txt 中) &gt; 生成文件并写入内容(如果有这文件则覆盖)，&gt;&gt; 文件里追加内容 md d:\\aa (创建文件夹) 在命令末尾加上 &gt;NUL 2&gt;NUL，表示隐蔽返回信息。 等待用户输入：set /p 变量名=屏幕显示信息 1set /p pass=请输入密码: 让用户按回车退出,小技巧(替代pause)，文件的最后一句： 1set /p tmp=操作结束，请按回车键退出... 设置标题： title JDK安装 设置屏幕显示颜色，如绿色: color 0a 清屏： cls 查看自己的IP 12for /f \"tokens=15\" %%i in ('ipconfig ^| find /i \"ip address\"') do set ip=%%iecho %ip% (这时的 %ip% 就是自己的IP地址) 修改文件的更新日期 1copy 文件名+,,&gt;nul (修改为当前时间，如果要修改为指定时间，先修改系统时间，再改回系统时间) 修改文件的后缀名 123ren C:\\test\\*.jpg *.JPGfor /r %%c in (*.jpg) do (ren %%c *.JPG) :: 修改当前目录下的所有文件的后缀名，包括子目录的 修改文件的文件名 12rename test.jpg test2.JPGrename *.jpg *.888.JPG 查看DNS、IP、Mac等 123456REM Win08winipcfgIpconfig /allNSLOOKUP 查看IP上的共享资源，就可以 1net view 192.168.10.8 共享 A. 查看你机器的共享资源: 1net share B. 手工删除共享 1net share 共享资源名称$ /d 注意$后有空格。 C. 增加一个共享： 1net share mymovie=e:\\downloads\\movie /users:3 mymovie 共享成功。 同时限制链接用户数为3人。 打开某网站 1start iexplore.exe http://www.baidu.com 实例 生成 reg 文件，运行它，再删除它 1234567891011echo \"更改windows安装文件的路径\"echo Windows Registry Editor Version 5.00 &gt; c:\\setupreg.regecho [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup] &gt;&gt; c:\\setupreg.regecho \"ServicePackSourcePath\"=\"D:\\\\Win2003\\\\\" &gt;&gt; c:\\setupreg.regecho \"SourcePath\"=\"D:\\\\Win2003\\\\\" &gt;&gt; c:\\setupreg.regREM 写入注册表regedit /S c:\\setupreg.regREM 删除注册表文件del c:\\setupreg.reg 调用了exe文件,结束后没有关闭，解决方法:用start命令运行文件，如 1start LeapFTP.exe 192.168.0.100 设置系统环境变量 1234567891011121314151617REM 有这个环境变量，则不需再设置，直接结束if not \"%JAVA_HOME%\" == \"\" exitREM 设置环境变量的地址set inputJavaHome=%cd%\\jdk1.6.0_07REM 设置环境变量，也可以设置当前用户的变量set EnvironmentHome=HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environmentecho 正在设置环境变量，请稍候......reg add \"%EnvironmentHome%\" /v JAVA_HOME /t reg_sz /d \"%inputJavaHome%\" /freg add \"%EnvironmentHome%\" /v ClassPath /t reg_sz /d \".;%%JAVA_HOME%%\\lib\" /freg add \"%EnvironmentHome%\" /v Path /t reg_sz /d \"%%JAVA_HOME%%\\bin;%Path%\" /f]REM 刷新，令环境变量生效taskkill /f /im explorer.exe &gt;nulstart \"\" \"explorer.exe\" 隐藏某目录的所有文件及文件夹 12cd /d 要隐藏的目录(如：D:)for /f \"usebackq delims=\" %%A in (`dir /a /b`) do (attrib \"%%A\" -r +h -s) 在批处理中使用密码。密码为admin，输入正确，跳转到next1 ，若输入密码错误3次，则锁屏。 1234567891011121314@echo offset num=0:11set /p pass=请输入密码:if \"%pass%\"==\"admin\" goto next1set /a num=%num% + 1if %num%==3 goto no1goto 11:no1%windir%\\system32\\rundll32.exe user32.dll,LockWorkStationgoto 11:next1echo 密码正确，执行下面的程式pause 清空回收站(未成功) 12345678@echo offdel /f /s /q c:\\recycler\\*.*del /f /s /q %systemdrive%\\recycled\\*.*REM 新屏幕taskkill /f /im explorer.exe &gt;nulstart \"\" \"explorer.exe\" 让系统断断续续地鸣叫 12345678@echo off:beginREM 发出鸣叫(“”实际就是ASCII码值为7的特殊字符（蜂鸣键beep）echoREM 让程序暂停一小阵子ping -n 1 -l 1 127.1&gt;nulgoto :begin 将 FAT 卷转换成 NTFS 利用“CONVERT.exe”进行,解析如下： 1CONVERT volume /FS:NTFS [/V] [/CvtArea:filename] [/NoSecurity] [/X] volume 指定驱动器号(后面跟一个冒号)、装载点或卷名 /FS:NTFS 指定要被转换成 NTFS 的卷 /V 指定 Convert 应该用详述模式运行 /CvtArea:filename将根目录中的一个接续文件指定为NTFS 系统文件的占位符 /NoSecurity 指定每个人都可以访问转换的文件和目录的安全设置 /X 如果必要，先强行卸载卷。该卷的所有打开的句柄则无效 12345678910111213@ ECHO OFF@ ECHO.@ ECHO. 说 明@ ECHO --------------------------------------------------------------------------@ ECHO NTFS是一种磁盘格式。该格式能存放大于4G的单个文件(如高清电影文件)，并可对@ ECHO 文件夹进行加密，但有个缺点是DOS下无法访问。建议D盘及其后的盘使用NTFS格式，@ ECHO C盘如非必要可以不转换，FAT32与NTFS这两种格式的读写速度几乎是没有差别的。@ ECHO --------------------------------------------------------------------------@ ECHO.convert c: /fs:ntfsREM D盘也转成 NTFSconvert d: /fs:ntfs 获取我的文档 123456SET SF=\"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\"FOR /F \"tokens=2,*\" %%I IN ('REG QUERY %SF% /v Personal 2^&gt;NUL^|FIND /I \"Personal\"') DO SET \"myDoc=%%~J\"REM 复制文件到我的文档XCOPY /D /E /R /Y /C \"%cd%\\test.txt\" \"%myDoc%\\test\\\" 10 获取当前目录路径 12cd ./set CURR_PATH=%cd% IF-ERRORLEVEL 123@ECHO OFFXCOPY C:\\AUTOEXEC.BAT D:IF ERRORLEVEL 1 ECHO 文件拷贝失败IF ERRORLEVEL 0 ECHO 成功拷贝文件 如果文件拷贝成功，屏幕就会显示“成功拷贝文件”，否则就会显示“文件拷贝失败”。 IF ERRORLEVEL 是用来测试它的上一个DOS命令的返回值的，注意只是上一个命令的返回值，而且返回值必须依照从大到小次序顺序判断。因此下面的批处理文件是错误的： 12345678910111213@echo off //不显示shell的命令。Setlocal //环境改变只适用于这个文件。%OS% //为当前的操作系统。Rem //注释一行文本。Goto 标签 //改变执行顺序，去标签位置.：标签 //定义一个标签。Set 变量名=值 //定义变量Not //取反Netstat –na //显示当前被点用的端口.%0 %1 %2 //用于表示批处理文件的参数0为命令,共1-9个参数。Shift //用于向前一个参数，原1变0，原2变1.每调用一次shift向前一移动一位。Call //调用其他批处理文件或命令。Start 命令 参数 //指示出在另一个窗口中开始运行命令。 自动设置Java环境变量 12345678910111213141516171819202122@echo offIF EXIST %1\\bin\\java.exe (rem 如输入正确的 Java2SDK 安装目录，开始设置环境变量@setx JAVA_HOME %1@setx path %path%;%JAVA_HOME%\\bin@setx classpath %classpath%;.@setx classpath %classpath%;%JAVA_HOME%\\lib\\tools.jar@setx classpath %classpath%;%JAVA_HOME%\\lib\\dt.jar@setx classpath %classpath%;%JAVA_HOME%\\jre\\lib\\rt.jar@echo on@echo Java 2 SDK 环境参数设置完毕，正常退出。) ELSE (IF \"%1\"==\"\" (rem 如没有提供安装目录，提示之后退出@echo on@echo 没有提供 Java2SDK 的安装目录,不做任何设置，现在退出环境变量设置。) ELSE (rem 如果提供非空的安装目录但没有bin\\java.exe，则指定的目录为错误的目录@echo on@echo 非法的 Java2SDK 的安装目录,不做任何设置，现在退出环境变量设置。)) 本文部分内容转载自：http://m18333611647.blog.163.com/blog/static/225533041201422111365439/","link":"/posts/Batch.html"},{"title":"如何高效寻找开源项目","text":"Github 中高效寻找搜索开源项目 in:name搜索时使用 in:name 可以搜索名字包含的内容 1in:name vue 搜索过滤 Stars 数 12#匹配start书大于1000in:name vue stasr&gt;1000 Forks 数 12#匹配Forkt书大于1000in:name vue forks&gt;1000 条件并行使用12#匹配Forkt书大于1000in:name vue stars&gt;1000 forks&gt;1000 in:description在描述中搜索 1in:description 前端 language1in:description 前端 language:vue pushed更新时间 1in:description 前端 language:vue pushed &gt;2019-10-01 条件并行使用1in:description 爬虫 language:python star&gt;1000 pushed &gt;2019-10-01 in:readme在 READMME 中搜索 1in:readme security stars&gt;1000","link":"/posts/OpenSourceSearch.html"},{"title":"CMD","text":"CMD 基础转载自:可可西 基础命令12# 中断命令Crtl + z 文件/目录cd 命令 含义 cd 显示当前目录 cd .. 上一级目录 cd /d d: 进入上次D盘所在的目录 cd /d d:\\ 进入d盘根目录 cd d: 显示上次d盘所在的目录 cd /d d:\\data 进入d:\\data目录 md12345# e盘新建file目录md e:\\file md movie filmmd d:\\test\\movie pushd/popd使用栈来维护当前目录 12pushd e:\\file # 当前目录切换到e:\\filepopd # 将刚才保存的e:\\file弹栈，并设置为当前目录 dir1234567891011121314151617181920212223242526272829 # 显示当前目录中的子文件夹与文件 dir # 只显示当前目录中的子文件夹与文件的文件名dir /b # 分页显示当前目录中的子文件夹与文件dir /p # 显示当前目录中的子文件夹dir /ad# 显示当前目录中的文件dir /a-d #/ 显示c:\\test目录中的内容dir c:\\test # 显示当前目录中keys.txt的信息dir keys.txt#/ 递归显示当前目录中的内容dir /S # 显示当前目录下以key开头的文件和文件夹的信息dir key* # 只显示当前目录中隐藏的文件和目录，并按照文件大小从小到大排序dir /AH /OS tree 显示目录结构12# 显示目录结构tree d:\\file ren 文件或目录重命名123ren 1.txt 1.batren c:\\test test_01ren Logs.txt Logs-%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%.txt rd 删除目录12rd movierd /s /q d:\\test # 使用安静模式删除 move 移动1234move *.png pngmove /Y *.png testmove 1.png d:\\png\\2.png # 移动并重命名move test d:\\new # d:\\new不存在则移动并重命名 del 删除1234567891011del testdel /f test# 删除当前目录下的test文件夹中所有文件及d:\\test2中所有doc文件（含只读文件；递归子目录下的文件；删除前不确认）del /f /s /q test d:\\test2\\*.doc # 删除当前目录下所有只读文件del /ar *.*# 删除当前目录下除系统文件以外的所有文件del /a-s *.* /ar、/ah、/as、/aa 分别表示删除只读、隐藏、系统、存档文件 /a-r、/a-h、/a-s、/a-a 分别表示删除除只读、隐藏、系统、存档以外的文件 replace 替换12# 替换为d:\\png中的1.pngreplace d:\\1.png d:\\png attrib 查看或修改文件或目录的属性12345678 # 查看当前目录下1.txt的属性attrib 1.txt # 去掉1.txt的只读属性attrib -R 1.txt # 隐藏movie文件夹attrib +H movie A：存档 R：只读 S：系统 H：隐藏 assoc 设置’文件扩展名’关联到的’文件类型’1234567891011121314# 显示所有'文件扩展名'关联assoc# 显示.txt代表的'文件类型'，结果显示.txt=txtfileassoc .txt #显示.doc代表的'文件类型'，结果显示.doc=Word.Document.8assoc .doc # 显示.exe代表的'文件类型'，结果显示.exe=exefileassoc .exe# 恢复.txt的正确关联assoc .txt=txtfile forfiles 递归目录执行命令12345#在当前目录下查找含有.svn的文件或目录（递归子目录），并对该目录执行指定版本号svn更新forfiles /p . /m .svn /s /c \"cmd /c svn up -r12005\" # 在c:\\myfiles目录下查找含有.svn的文件或目录（递归子目录），并对该目录执行指定版本号svn更新forfiles /p c:\\myfiles /m .svn /s /c \"cmd /c svn up -r12005\" 文件查看 type 显示文本文件内容 12345678#显示c盘中11.txt的文本内容type c:\\11.txt # 显示当前目录下conf.ini的文本内容type conf.ini # 分页显示c盘中11.txt的文本内容type c:\\11.txt | more more 逐屏的显示文本文件内容 12more con.txt# Space:下一屏 q:退出 拷贝copy 拷贝文件123456789copy test.txt d:\\txtcopy movie d:\\copy /Y test.txt d:\\txt# 将当前目录下的art_2.7z.开头的所有文件（按照名称升序排序）依次合并生成art_2.7zcopy /B art_2.7z.* art_2.7z # 将当前目录下的art_2.7z.001、art_2.7z.002文件合并生成art_2.7zcopy /B art_2.7z.001+art_2.7z.002 art_2.7z xcopy12345# 将c:\\bat\\hai中的所有内容拷贝到d:\\hello中 注意：需要在hello后加上\\ 表示hello为一个目录，否则xcopy会询问hello是F，还是Dxcopy c:\\bat\\hai d:\\hello\\ /y /h /e /f /c # 将c:\\bat\\hai中的2019年11月3日后更改的文件拷贝到d:\\hello中xcopy c:\\bat\\hai d:\\hello\\ /d:11-03-2019 robocopy12345# 将当前目录下Plugins中所有内容（排除名为Intermediate和Binaries的文件夹）保留目录结构拷贝到当前目录下的PluginsDest中（PluginsDest不存在会自动创建）robocopy .\\Plugins .\\PluginsDest /MIR /xd Intermediate Binaries # 将c:\\test中所有内容（排除名为UE4Editor-SGame-Win64-DebugGame.dll和pdb后缀的文件）保留目录结构拷贝到d:\\test2中（d:\\test2不存在会自动创建）robocopy c:\\test d:\\test2 /MIR /xd Intermediate /xf UE4Editor-SGame-Win64-DebugGame.dll *.pdb mklink 符号链接12# 创建D盘Users目录链接到C盘，并命名为Usersmklink /j \"C:\\Users\" \"D:\\Users\" mklink [[/d] | [/h] | [/j]] Link Target /d 创建目录符号链接。黙认为文件符号链接。 /h 创建硬链接，而不是符号链接。 /j 创建目录联接。 Link 指定新的符号链接名称。 Target 指定新链接引用的路径(相对或绝对)。 注册表命令 参数 含义 KeyName [\\Machine]FullKey Machine为远程机器的机器名 - 忽略默认到当前机器。远程机器上只有 HKLM 和 HKU。FullKey ROOTKEY+SubKey。ROOTKEY [ HKLM | HKCU| HKCR| HKU | HKCC ]。SubKey 所选ROOTKEY下注册表项的完整名 /v 所选项之下要添加的值名 /ve 为注册表项添加空白值名&lt;无名称&gt; /t RegKey 数据类型: [ REG_SZ | REG_MULTI_SZ | REG_DWORD_BIG_ENDIAN| REG_DWORD| REG_BINARY| REG_DWORD_LITTLE_ENDIAN| REG_NONE | REG_EXPAND_SZ ]如果忽略，则采用 REG_SZ /s 指定一个在 REG_MULTI_SZ 数据字符串中, 用作分隔符的字符；如果忽略，则将””用作分隔符 /d 要分配给添加的注册表ValueName的数据 /f 不提示，强行改写现有注册表项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 强制添加一条开机启动c:\\tools\\myapp.exe程序的注册表项reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v MyApp /t REG_SZ /d \"c:\\tools\\myapp.exe\" /f # 解决32位xp打开ioa后，弹出的框关不掉问题reg add \"HKLM\\SOFTWARE\\ScmClient\" /v AgreementConfirmed /t REG_SZ /d 1 /f # 强制添加一条加速关闭应用程序的注册表项reg add \"HKCU\\ControlPanel\\Desktop\" /v WaitToKIllAppTimeOut /t REG_SZ /d 10000 /f # 将JdkPath_h4127442381设置为空reg add \"hkcu\\software\\Unity Technologies\\Unity Editor 4.x\" /v JdkPath_h4127442381 /t REG_SZ /f# 强制添加windbg打开dump文件到右键菜单的注册表项（不指明/v，键值将写入默认值名中）reg add \"HKCR\\*\\shell\\WinDbg\\command\" /t REG_SZ /d \"\\\"D:\\Program Files (x86)\\windbg\\windbg.exe\\\" -z \\\"%1\\\" \" /f # 强制添加winhex到右键菜单的注册表项（不指明/v，键值将写入默认值名中）reg add \"HKCR\\*\\shell\\WinHex\\command\" /t REG_SZ /d \"\\\"D:\\software-setup\\system\\winhex\\winhex.exe\\\" \\\"%1\\\" \" /f #为IE设置代理：http://txp-01.tencent.com/proxy.pacreg add \"hkcu\\software\\microsoft\\windows\\currentversion\\internet settings\" /v AutoConfigURL /t REG_SZ /d \"http://txp-01.tencent.com/proxy.pac\" /f # 关闭IE代理服务器选项reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\" /v ProxyEnable /t REG_DWORD /d 0 /f # 为Procmon.exe工具（Process Monitor为其属性面板上的描述名）添加License同意reg add \"hkcu\\software\\Sysinternals\\Process Monitor\" /v EulaAccepted /t REG_DWORD /d 1 /f #强制删除值名的MyApp的注册表项reg delete \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v MyApp /f # 强制删除让任务栏里的任务管理器为灰色的注册表项reg delete \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe\" /f # 删除http代理reg delete HKEY_CURRENT_USER\\Environment /v HTTP_proxy /f # 删除https代理reg delete HKEY_CURRENT_USER\\Environment /v HTTPS_proxy /f # 强制复制winmine下所有的子项与值到winminebk中reg copy \"hkcu\\software\\microsoft\\winmine\" \"hkcu\\software\\microsoft\\winminebk\" /s /f # 导出winmine下所有的子项与值到reg export \"hkcu\\software\\microsoft\\winmine\" c:\\regbak\\winmine.reg c:\\regbak\\winmine.reg文件中# 导入c:\\regbak\\winmine.reg文件到注册表中reg import c:\\regbak\\winmine.reg #查询ie的安装路径reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE\" /s # 查询.dsw默认值reg query HKCR\\.dsw /ve # 查询QQGame安装路径reg query HKEY_CURRENT_USER\\Software\\Tencent\\QQGame\\SYS /v GameDirectory 注册表中%1 %2 %3 %4的含义：– %1表示文件列表，%2表示默认打印机，%3表示驱动器，%4表示端口 命令顺序@#@1cd /d d:\\src&amp;work.exe /o c:\\result.txt # 先将当前工作目录切换到d:\\src下，然后执行work.exe /o c:\\result.txt命令 &amp;&amp;&amp;&amp; 顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令 12# 如果找到了\"ok\"字样，就显示\"成功\"，找不到就不显示find \"ok\" c:\\test.txt &amp;&amp; echo 成功 |||| 顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令 12# 如果找不到\"ok\"字样，就显示\"不成功\"，找到了就不显示find \"ok\" c:\\test.txt || echo 不成功 |12dir *.* /s/a | find /c \".exe\"dir *.* /s/a 2&gt;&amp;1 | find /c \".exe\" 重定向&gt;将当前命令输出以覆盖的方式重定向 1234567891011121314151617181920212223tasklist &gt; p1.txttasklist 1&gt; p1.txt # 等同于：tasklist &gt; p1.txt #输出结果（stdout）打印在屏幕上，错误信息（stderr）以覆盖的方式重定向到p1.txt中（注：bin目录不存在时，会输出错误信息）dir bin 2&gt; p1.txt # 将错误信息（stderr）重定向到输出结果（stdout），然后将输出结果（stdout）以覆盖的方式重定向到p1.txt中（注：bin目录不存在时，会输出错误信息）dir bin &gt; p1.txt 2&gt;&amp;1 # 将输出结果（stdout）重定向到错误信息（stderr），然后将错误信息（stderr）以覆盖的方式重定向到p1.txt中（注：bin目录不存在时，会输出错误信息） 注：与上条命令结果一致dir bin 2&gt; p1.txt 1&gt;&amp;2 # 屏幕上不打印tasklist的输出结果（stdout），错误信息（stderr）仍会打印tasklist &gt;nul # 屏幕上不打印命令的错误信息（stderr），输出结果（stdout）仍会打印（注：bin目录不存在时，会输出错误信息）dir bin 2&gt;nul # 将命令的错误信息（stderr）重定向到输出结果（stdout），然后不打印输出结果（stdout）【屏幕上错误信息（stderr）和输出结果（stdout）都不打印】（注：bin目录不存在时，会输出错误信息）dir bin &gt;nul 2&gt;&amp;1 # 将命令的输出结果（stdout）重定向到错误信息（stderr），然后不打印错误信息（stderr）【屏幕上错误信息（stderr）和输出结果（stdout）都不打印】（注：bin目录不存在时，会输出错误信息）dir bin 2&gt;nul 1&gt;&amp;2 &gt;&gt;将当前命令输出以追加的方式重定向 12345678910111213# 将tasklist的输出结果（stdout）以追加的方式重定向到p2.txt文件中（注：tasklist的输出结果就不会打印到屏幕上了）tasklist &gt;&gt; p2.txt tasklist 1&gt;&gt; p2.txt # 等同于：tasklist &gt;&gt; p2.txt# 输出结果（stdout）打印在屏幕上，错误信息（stderr）以追加的方式重定向到p2.txt中（注：bin目录不存在时，会输出错误信息）dir bin 2&gt;&gt; p2.txt # 将错误信息（stderr）重定向到输出结果（stdout），然后将输出结果（stdout）以追加的方式重定向到p2.txt中（注：bin目录不存在时，会输出错误信息）dir bin &gt;&gt; p2.txt 2&gt;&amp;1 # 将输出结果（stdout）重定向到错误信息（stderr），然后将错误信息（stderr）以追加的方式重定向到p2.txt中（注：bin目录不存在时，会输出错误信息） 注：与上条命令结果一致dir bin 2&gt;&gt; p2.txt 1&gt;&amp;2 &lt; 从文件中获得输入信息，而不是从屏幕上，一般用于date time label等需要等待输入的命令 1date &lt;temp.txt // temp.txt中的内容为2005-05-01 @ @ 命令修饰符 在执行命令前，不打印出该命令的内容 1@cd /d d:\\me // 执行该命令时，不打印出命令的内容：cd /d d:/me ,在某些特殊的情况下可以用来代替空格使用 1dir,c:\\ // 相当于：dir c:\\ ;当命令相同的时候,可以将不同的目标用;隔离开来但执行效果不变。如执行过程中发生错误则只返回错误报告但程序还是会继续执行 1dir c:\\;d:\\;e:\\ // 相当于顺序执行：dir c:\\ dir d:\\ dir e:\\ 时间日期time12345time # 显示或设置当前时间time /t # 显示当前时间time # 设置新的当前时间（格式：hh:mm:ss），直接回车则表示放弃设置 date123date /t # 显示当前日期date # 设置新的当前日期（格式：YYYY/MM/DD），直接回车则表示放弃设置 BAT显示1234567cls # 清除屏幕ver # 显示当前windows系统的版本号winver # 弹框显示当前windows系统信息hostname # 显示当前机器名vol # 显示当前分区的卷标label # 显示当前分区的卷标，同时提示输入新卷标label c:system # 设置c盘的卷标为system echo1234567891011121314151617181920 # 输出一个\"回车换行\"，空白行echo. # 后续所有命令在执行前，不打印出命令的内容echo off # 后续所有命令在执行前，打印出命令的内容echo on #/ 输出123到终端屏幕echo 123 # 输出Hello World!!!到终端屏幕echo \"Hello World!!!\" #每个命令运行结束，可以用这个命令行格式查看返回码；默认值为0，一般命令执行出错会设errorlevel为1echo %errorlevel% # 输出test的字符串到当前目录中的p1.txt文件中（以覆盖的方式）echo test &gt; p1.txt 1234567891011121314151617181920212223# 显示变量p代表的字符串，即aa1bb1aa2bb2echo %p%#显示变量p中第6个字符以后的所有字符，即aa2bb2echo %p:~6% # 显示第6个字符以后的3个字符，即aa2echo %p:~6,3% # 显示最后面的2个字符，即b2echo %p:~-2%# 显示除了最后2个字符以外的其它字符，即aa1bb1aa2becho %p:~0,-2%# 用c替换变量p中所有的aa，即显示c1bb1c2bb2echo %p:aa=c%# 将变量p中的所有aa字符串置换为空，即显示1bb12bb2echo %p:aa=% echo %p:*bb=c%# 第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2 set1234567891011121314151617# 显示当前用户所有的环境变量set # 查看path的环境变量值（准确的说是查看以path开头的环境变量）set path #清空path变量set path= # 将path变量设置为d:\\execute（注：修改的path只会影响当前回话，也不会存储到系统配置中去；当前cmd窗口关闭，新设置的path也就不存在了set path=d:\\execute ）# 在path变量中添加d:\\execute（注：修改的path只会影响当前回话，也不会存储到系统配置中去；当前cmd窗口关闭，新设置的path也就不存在了）set path=%path%;d:\\execute # 设置变量p，并赋值为aa1bb1aa2bb2set p=aa1bb1aa2bb2 1234567891011121314# 设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2set p=%p:*bb=c% # 设置p为数值型变量，值为39set /a p=39 # 支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3set /a p=39/10 # 用 /a 参数时，在 = 后面的变量可以不加%直接引用set /a p=p/10# &amp;运算要加引号。其它支持的运算符参见set/?set /a p=\"1&amp;0\" path12345678# 显示当前path变量的值path # 清除所有搜索路径设置并指示cmd.exe只在当前目录中搜索path ;#将d:\\xxx路径添加到path中path d:\\xxx;%PATH% 12345678910title 正在做命令行测试 # 修改当前cmd窗口的标题栏文字为正在做命令行测试prompt orz: # 将命令提示符修改为orz:print 1.txt #使用设置好的打印机来打印1.txt文本文件call ff.bat # 调用执行ff.bat脚本（ff.bat脚本执行完原脚本才会往下执行）exit # 退出当前CMD实例pause # 暂停批处理程序，并显示出：请按任意键继续.... start12345678910111213141516171819202122start # 运行某程序或命令# 最大化的方式启动记事本start /max notepad.exe # 最小化的方式启动计算器start /min calc.exe # 最小化的方式启动Proxifier代理工具start /min \"\" d:\\Proxifier.exe # 启动一个cmd实例窗口，并运行taskliststart tasklist # 调用资源管理器打开f盘start explorer f:\\ # 启动ie并打开www.qq.com网址strat iexplore \"www.qq.com\" #启动开始执行ff.bat（启动ff.bat脚本后，原脚本继续执行，不会等ff.bat脚本执行完）start ff.bat color设置当前cmd窗口背景色和前景色（前景色即为字体的颜色） 1color 02 # 将背景色设为黑色，将字体设为绿色 代码 颜色 代码 颜色 0 黑色 8 灰色 1 蓝色 9 淡蓝色 2 绿色 A 淡绿色 3 浅绿色 B 淡浅绿色 4 红色 C 淡红色 5 紫色 D 淡紫色 6 黄色 E 淡黄色 7 白色 F 亮白色 设置DOS窗口颜色为9f，大小：200行 60列（若屏幕缓冲区大小的宽度w&lt;200或高度h&lt;60,最终DOS的窗口就会为w行，h列） 1mode con cols=200 lines=60 &amp; color 9f chcp 字符编码936 – GBK(一般情况下为默认编码)437 – 美国英语65001 – utf-81200 – utf-161201 – utf-16(Big-Endian)12000 – utf-3212001 – utf-32(Big-Endian) 12345# 设置当前命令行环境编码为GBK 执行完该命令后还需要将字体设置为点阵字体，才能真正将编码环境切成utf8chcp 936 # 设置当前命令行环境编码为utf8 执行完该命令后还需要将字体设置为Lucida Console，才能真正将编码环境切成utf8chcp 65001 wmic 查看进程信息12345678# 查看名为\"buyticket.exe\"所有进程命令行，exe全路径，PID及线程数wmic process where Caption=\"buyticket.exe\" get commandline,ExecutablePath,ProcessId,ThreadCount /value# 查看名为\"buyticket.exe\"所有进程的exe全路径及当前打开的句柄数wmic process where Caption=\"buyticket.exe\" get ExecutablePath,HandleCount /value # 查看名为\"buyticket.exe\"所有进程的exe全路径、当前虚拟地址空间占用及物理内存工作集wmic process where Caption=\"buyticket.exe\" get ExecutablePath,VirtualSize,WorkingSetSize /value shutdown1234567891011121314#关闭计算机shutdown /s # 一小时后，关闭本地计算机shutdown /s /t 3600# 终止系统关闭shutdown /a # 关闭并重启本地计算shutdown /r 机# 关闭并重启ip为192.168.1.166的计算机shutdown /m 192.168.1.166 /r 1234567891011# 关闭并重启计算机，重启后重新启动所有注册的应用程序shutdown /g # 注销本地计算机shutdown /l # 休眠本地计算机（强制正在运行的应用程序关闭，不前台警告用户）shutdown /h /f # 关闭计算机shutdown /s regsvr32 注册或反注册com组件12345# 以无声的方式注册clock.ocx组件regsvr32 /s clock.ocx # 卸载myCommon.dll组件 regsvr32 /u myCommon.dll format 格式化磁盘12345# 以ntfs类型格式化J盘 【类型有:FAT、FAT32、exFAT、NTFS或UDF】format J: /FS:ntfs # 以fat32类型快速格式化J盘format J: /FS:fat32 /Q chkfsk 检查磁盘并显示状态报告1chkdsk /f D: # 检查磁盘D并显示状态报告；加参数/f表示同时会修复磁盘上的错误 subsetsubst 磁盘映射 – 磁盘映射信息都保存在注册表以下键值中：HKEY_CURRENT_USER\\Network 1234567891011# 显示目前所有的映射subst # 将\\\\com\\software共享映射为本地z盘subst z: \\\\com\\software # 将e:\\src映射为本地y盘subst y: e:\\src # 删除z盘映射subst z: /d cmdkey 凭据Credential（保存的用户名和密码） 1234567891011121314# 列出可用的凭据cmdkey /list # 列出指定目标的凭据cmdkey /list:10.12.190.82 # 列出指定目标的凭据cmdkey /list:Domain:target=10.12.190.82 # 若target为10.12.190.82的凭据不存在，则添加；否则就将10.12.190.82凭据的用户名修改为LiLei，密码修改为123456cmdkey /add:Domain:target=10.12.190.82 /user:LiLei /pass:123456 # 删除指定目标的凭据cmdkey /delete:Domain:target=10.12.190.82 cscript 执行vbs脚本12# 执行mac.vbs脚本，显示本机mac地址cscript /Nologo mac.vbs mac.vbs12345678Dim mc,moSet mc=GetObject(\"Winmgmts:\").InstancesOf(\"Win32_NetworkAdapterConfiguration\")For Each mo In mcIf mo.IPEnabled=True ThenMsgBox \"本机网卡MAC地址是: \" &amp; mo.MacAddressExit ForEnd IfNext powercfg 设置电源方案12345678# 列出当前用户环境中的所有电源方案的GUID以及当前使用的是哪一个电源方案powercfg -list # 查询GUID为8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c的电源方案的详细内容powercfg -query 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c # 设置禁止休眠powercfg -h off 123456789101112131415# 设置硬盘从不关闭powercfg -change -disk-timeout-dc 0powercfg -change -disk-timeout-ac 0# 设置显示器从不关闭powercfg -change -monitor-timeout-dc 0powercfg -change -monitor-timeout-ac 0# 设置从不进入待机powercfg -change -standby-timeout-dc 0powercfg -change -standby-timeout-ac 0# 设置从不进入休眠powercfg -change -hibernate-timeout-dc 0powercfg -change -hibernate-timeout-ac 0 dc代表直流电源 即使用电池供电；ac代表交流电源 即直接连接电源 后面数字为时间，单位为分钟；设置为0表示从不 netsh advfirewall 设置防火墙windows防火墙规则顺序：阻止规则的优先级高于允许规则 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#将防火墙当前的所有配置导出到d:\\test\\advfirewall.pol文件netsh advfirewall export \"d:\\test\\advfirewall.pol\" # 将d:\\test\\advfirewall.pol文件中规则导入到防火墙中netsh advfirewall import \"d:\\test\\advfirewall.pol\" # 将防火墙还原为默认策略netsh advfirewall reset# 关闭所有类型网络的防火墙（域网络【Domain】、家庭或工作的专用网络【Private】、公用网络都关闭【Public】）netsh advfirewall set allprofiles state offnetsh advfirewall set allprofiles state on # 开启所有类型网络的防火墙#关闭当前类型网络的防火墙netsh advfirewall set currentprofile state off # 开启当前类型网络的防火墙netsh advfirewall set currentprofile state on # 开启域网络的防火墙netsh advfirewall set domainprofile state on # 关闭域网络的防火墙netsh advfirewall set domainprofile state off# 开启家庭或工作的专用网络的防火墙netsh advfirewall set privateprofile state on # 关闭家庭或工作的专用网络的防火墙netsh advfirewall set privateprofile state off # 开启公用网络的防火墙netsh advfirewall set publicprofile state on # 关闭公用网络的防火墙netsh advfirewall set publicprofile state off #显示所有规则netsh advfirewall firewall show rule name=all # 显示名为foxmail的所有规则netsh advfirewall firewall show rule name=foxmail # 开启ping回显netsh advfirewall firewall set rule name=\"文件和打印机共享(回显请求 - ICMPv4-In)\" new enable=yes # 删除所有名为NiZhanBrowser的规则netsh advfirewall firewall delete rule name=NiZhanBrowser # 删除所有名为NiZhanBrowser的入站规则netsh advfirewall firewall delete rule name=NiZhanBrowser dir=in# 删除所有名为NiZhanBrowser且操作为阻止的规则netsh advfirewall firewall delete rule name=NiZhanBrowser action=block # 添加名为TCP-In-8888入站规则：允许TCP端口8888netsh advfirewall firewall add rule name=TCP-In-8888 protocol=TCP localport=8888 dir=in action=allow # 添加名为TCP-In-8888入站规则：阻止TCP端口8888netsh advfirewall firewall add rule name=TCP-In-8888 protocol=TCP localport=8888 dir=in action=block # 添加名为TCP-In-8888出站规则：允许TCP端口8888netsh advfirewall firewall add rule name=TCP-In-8888 protocol=TCP localport=8888 dir=out action=allow # 添加名为TCP-In-8888出站规则：阻止TCP端口8888netsh advfirewall firewall add rule name=TCP-In-8888 protocol=TCP localport=8888 dir=out action=block # 添加名为test1入站规则：允许TCP端口8888、远程IP地址在10.96.208.0/23,10.96.154.0/23区间、远程Port在1024-2048,2050-65535netsh advfirewall firewall add rule name=test1 protocol=TCP localport=8888 remoteip=10.96.208.0/23,10.96.154.0/23 remoteport=1024-2048,2050-65535 dir=in action=allow # 添加名为test2入站规则：允许TCP端口8888、本地IP地址在10.46.50.32、本地Port在3702netsh advfirewall firewall add rule name=test2 protocol=TCP localport=8888 localip=10.46.50.32 localport=3702 dir=in action=allow # 添加名为test3入站规则：允许TCP端口8888、程序路径为：D:\\tools\\test3.exenetsh advfirewall firewall add rule name=test2 protocol=TCP localport=8888 program=\"D:\\tools\\test3.exe\" dir=in action=allow 注：netsh advfirewall firewall add rule ?可用来查看帮助信息 schtasks 任务计划1234567891011121314151617181920# 以较为详细易于阅读的格式显示本机所有任务计划信息schtasks /query /fo LIST /v # 创建一个名为Soda Build的任务计划：该任务计划每20分钟执行一下d:\\check.vbs脚本schtasks /create /sc minute /mo 20 /tn \"Soda Build\" /tr d:\\check.vbs # 强制创建一个名为Soda Build的任务计划（不进行确认）：该任务计划每天凌晨2点06分执行一下D:\\updateall.bat脚本schtasks /create /tn \"Soda Build\" /tr D:\\updateall.bat /sc daily /st 02:06 /f # 强制删除Soda Build名称的任务计划（不进行确认）schtasks /delete /tn \"Soda Build\" /f #将名为Soda Build的任务计划的执行脚本修改为d:\\check2.vbsschtasks /change /tn \"Soda Build\" /tr d:\\check2.vbs #执行名为Soda Build的任务计划schtasks /run /tn \"Soda Build\" #终止执行名为Soda Build的任务计划schtasks /end /tn \"Soda Build\" net1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 查看已经启动的服务net start # 开启任务计划服务net start \"Task Scheduler\" # 不询问，直接关闭任务计划服务net stop \"Task Scheduler\" /y # 开启dns缓存服务net start dnscache # 不询问，直接关闭dns缓存服务net stop dnscache /y # 开启Remote Desktop Services服务net start TermService # 不询问，直接关闭Remote Desktop Services服务net stop TermService /y # 查看当前用户下的共享目录net share # 取消名为workFile的共享状态net share workFile /delete # 将c:\\360Downloads设为共享，并取名为xxxnet share xxx=c:\\360Downloads # 开启ipc$共享net share ipc$ # 删除ipc$共享net share ipc$ /del # 删除c盘共享net share c$ /del # 建立192.168.1.166的ipc空链接net use \\\\192.168.1.166\\ipc$ \" \" /user:\" \"# 直接登陆后建立192.168.1.166的ipc非空链接（用户名为administrator 密码为123456）net use \\\\192.168.1.166\\ipc$ \"123456\" /user:\"administrator\" # 直接登陆后映射192.168.1.166的c盘到本地为h盘（用户名为administrator 密码为123456）net use h: \\\\192.168.1.166\\c$ \"123456\" /user:\"administrator\" # 登陆后映射192.168.1.166的c盘到本地为h盘net use h: \\\\192.168.1.166\\c$ # 删除ipc链接net use \\\\192.168.1.166\\ipc$ /del # 删除本地的h盘的映射net use h: /del # 查看本地局域网内开启了哪些共享net view # 查看192.168.1.166的机器上在局域网内开启了哪些共享net view \\\\192.168.1.166 # 查看本地机器的日期及时间net time \\\\127.0.0.1 # 查看本地机器的日期及时间net time \\\\localhost # 查看192.168.1.166机器的日期及时间net time \\\\192.168.1.166 # 设置本地计算机时间与192.168.1.166主机的时间同步，加上参数/yes可取消确认信息net time \\\\192.168.1.166 /set # 查看当前机器上的用户net user # 查看当前机器上的Administrator用户的信息net user Administrator # 启用Guest用户net user Guest /active:yes # 新建一个名为dev，密码为123456的用户net user dev 123456 /add # 把名为dev的用户添加到管理员用户组中，使其具有管理员权限net localgroup administrators dev /add # 删除名为dev的用户net user dev /del 进程操作1234567891011121314# 显示当前运行的进程信息（可查看PID）tasklist #结束指定的进程taskkill # 结束名为notepad.exe的进程taskkill /im notepad.exe # 结束pid为1230、1241和1253的进程以及由它们启动起来的子进程taskkill /pid 1230 /pid 1241 /pid 1253 /t # 强制结束有名为cmd.exe的进程以及由它启动起来的子进程taskkill /f /im cmd.exe /t 网络1234567891011121314151617# 测试与baidu服务器的连接情况ping baidu.com # 测试机器名为chen-pc0的连接情况ping chen-pc0 # 测试与ip为220.181.111.86的连接情况ping 220.181.111.86 # 向qq.com发送10次65500字节的pingping -l 65500 -n 10 qq.com # 对当前主机执行6次ping操作（花费时间为5s）ping -n 6 127.0.0.1 # 不断地测试baidu服务器的连接情况 【Ctrl+Pause Break：查看ping的统计信息；Ctrl+C：终止当前任务】ping -t baidu.com 1234567891011121314151617181920212223242526272829303132# 查看本地ip地址等详细信息ipconfig /all# 显示本地dns缓存的内容ipconfig /displaydns # 清除本地dns缓存的内容ipconfig /flushdns# 获取www.cnblogs.com的域名解析nslookup www.cnblogs.com # 打印出www.cnblogs.com的域名解析所有记录nslookup -d www.cnblogs.com# 查看开启了哪些端口netstat -a # 查看端口的网络连接情况netstat -n # 查看正在进行的工作netstat -v # 查看tcp协议的使用情况netstat -p tcp # 查看本机到达182.140.167.44的路由路径tracert 182.140.167.44 #显示出IP路由route print arparp 显示和修改地址解析协议(ARP)使用的“IP到mac”的地址转换表 12# 显示arp缓存表arp -a at 计划任务（必须保证“Task Scheduler”服务启动 net start “task scheduler”） 1234567891011121314151617181920212223242526# 查看所有的计划任务at # 停止所有任务计划（不需要确认）at /delete /yes # 开启id为1的计划任at 1 # 停止id为1的计划任务（不需要确认）at 1 /delete /yes # 到12:42 ，电脑会出现“ 系统关机 ”对话框，并默认 30 秒延时自动关机at 12:42 shutdown –s –t30 # 如果命令不是exe文件，必须在命令前加上cmd /cat cmd /c dir &gt; c:\\test.out # 在每周六早上6点，电脑定时启动task.bat批处理文件at 6:00AM /every:Saturday task.bat # 到12:00时，关闭名为chen的计算机at \\\\chen 12:00 shutdown /r # 到12:00时，关闭ip为192.168.1.166的计算机at \\\\192.168.1.166 12:00 shutdown /r 文本处理12# 编辑config.ini文件（会进入edit字符编辑器；按alt，可以选择对应的菜单） win7 x64下没有该命令edit config.ini find 文件中搜索字符串 12345678910111213141516171819202122232425# 在1.txt文件中忽略大小写查找pid字符串，并带行号显示查找后的结果find /N /I \"pid\" 1.txt # 只显示在1.txt文件中查找到exe字符串的次数find /C \"exe\" 1.txt # 显示未包含1.txt文件中未包含exe字符串的行find /V \"exe\" 1.txtfindstr 文件中搜索字符串# 在1.txt文件中搜索hello或worldfindstr \"hello world\" 1.txt # 在1.txt文件中搜索hello或world# 在1.txt文件中搜索hello worldfindstr /c:\"hello world\" 1.txt # 在1.txt文件中搜索hello world，并在每行结果前打印出1.txt: 注：findstr只有在2个及以上文件中搜索字符串时才会打印出每个文件的文件名，nul表示一个空文件findstr /c:\"hello world\" 1.txt nul # 在1.txt文件中搜索hello world，并在每行结果前打印出1.txt: 注：findstr只有在2个及以上文件中搜索字符串时才会打印出每个文件的文件名，nul表示一个空文件# 不区分大小写，在当前目录和所有子目录中的所有文件中的hellofindstr /s /i \"Hello\" *.* # 不区分大小写，在当前目录和所有子目录中的所有文件中的hello# 在1.txt中搜索以1个数字+1个小写字母开头子串的行findstr \"^[0-9][a-z]\" 1.txt # 在1.txt中搜索以1个数字+1个小写字母开头子串的行 控制台命令窗口中一些技巧在文件夹空白处按住Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”命令参数的路径：要使用反斜杠\\，不要使用正斜杠’/‘ 如：del d:\\test2\\file\\my.txt命令参数的路径：若存在空格，应使用双引号将路径引起来 如：del “d:\\program files\\file\\my.txt” 文件及目录名中不能包含下列任何字符：\\ / : * ? &quot; &lt; &gt; | rem 在批处理文件中添加注解，其后的命令不会被执行，但会回显:: 也可以起到rem的注释作用，且不会有回显任何以冒号: 开头的字符行, 在批处理中都被视作标号（label）, 而直接忽略其后的所有内容有效标号：冒号后紧跟一个以字母数字开头的字符串，goto语句可以识别无效标号：冒号后紧跟一个非字母数字的一个特殊符号，goto无法识别的标号，可以起到注释作用，::常被用作注释符号","link":"/posts/CMD.html"},{"title":"HCNA NOTE","text":"HCNA 学习笔记 网络整体架构企业网络企业网络：包括小型办公室、教育、政府、银行等行业或机构 企业网络远程互联： 总公司与分公司使用广域网链路(WAN)互联 企业网络基本架构 小型企业：通常采用扁平网络结构，扩展能力低。 大型企业：通常采用层次化结构以支撑网络的扩展和用户的增长。 结构图(左小右大) 网络基本管理及模拟器使用常用的传输介质双绞线、光纤、Radio(蓝牙等)、同轴电缆(几乎淘汰) 双绞线(8芯)有多种类型，不同类型传输速度不同和，超5类、6类最常用。RJ-45水晶头 568A标准：白绿，绿，白橙，蓝，白蓝，橙，白棕，棕568B标准：白橙，橙，白绿，蓝，白蓝，绿，白棕，棕 交叉线：一头采用568A标准，一头采用568B标准平行线/直通线：两头采用同样的标准（同为568A标准或568B标准） 相同设备使用交叉线，不同设备使用直通线，现在很多设备都有自适应。 光纤单模光纤(S)：颜色多为黄色，连接头多为蓝色或绿色，只能传输一种模式的广。不存在模间色散，适用于 长距离高速传输多模光纤(M):线缆颜色千兆多位橙色、万兆多为水蓝色，连接头多位灰白色，允许不同模式的光在一根光纤上传输，由于模间色散较大而导致信号脉冲展宽严重，因此主要用于局域网的短距离传输。 区别：主要在传输距离，单模长距离，多模短距离。单模和多模差异在传输距离 洲际的传输使用的是 光缆，不是光纤。 常用光纤连接器：ST，FC，SC，LC连接器。连接器有帽子，要拿掉才能连接。 串口电缆网络通信中常用和推荐的串口电缆标准为 RS-232，但传输速率有限仅为6米。RS-422和RS-485的传输距离可达1200米。接头常用V.35(80年代淘汰)，但仍在帧中继、ATM等传统网络上使用。V.24为RS-232标准的欧洲版，RS-232本身没有定义接头标准，RS-232逐渐被FireWire，USB等取代。新产品和设备已经普遍使用USB标准。 ENSP 模拟器关闭Windows防火墙，不要装各种管家。尽量少运行软件，可能会干扰 virtunal-box。重新注册要关闭ENSP，个人文件夹下的.VirtualBox彻底删除。注册完毕之后关闭ENSP然后再开启。 冲突域 应用场景：多点接入网络(MA),如交换机(Switch) 冲突域与半双工搭配 单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。 半双工和全双工都支持双向数据传输。 共享式网络中，不同的主机同时发送数据时，就会产生信号冲突的问题，解决方法一般是：采用载波侦听多路访问/冲突检测技术(CAMA/CD)的基本工作过程如下： 终端设备不同地检测共享网路的状态。如果线路空闲，则可以发送数据，线路不空闲，则等待一段时间后据徐检测(延时时间由退避算法决定)。 如有另一个设备同时发送数据，两个设备发送的数据会产生冲突。 终端设备检测到冲突之后，马上停止发送自己的数据，并发送特俗阻塞信息，以强化冲突信号，使线路上的其他站点能够尽早检测冲突。 终端设备检测到冲突后，等待一段时间后再将进行数据发送(延时时间由退避算法决定)。 CSMA/CD 的工作原理：先听后发，边发边听，冲突停发，随机延迟后重发。 Q:用串行线路能否构建MA网络A:肯定可以 NBMA(非广播多路访问)：物理架构(ATM、帧中继网络)—-NMBMA(网络设计)—VPN(DSVPN)。 熟悉以及远程管理设备的实验123system-viewinterface GigabitEnternet0/0/0/0 # 进入接口ip address 10.1.1.1 255.255.255.0 常用命令 1234567891011121314151617sysname R1 # 修改设备名字ip address 10.1.1.1.7 # 配置IP地址ip address mask 10.1.1.1.7 24 # 配置IP地址和掩码diaplay this # 显示当前模式dis ip int bri # 查看接口开启情况undo shutdown # q # 退出user-interface # 用户接口user-interface ？ # 查看帮助user-interface vty 0 4 # 开启虚拟终端管理set authentication password cipher pass # 设置认证密码为passtalent 10.1.1.1 # 远程管理设备，不能进入system-viewdiaplay ip routting0table # 查看路由表 网络各种分层结构网络分层基础 网络的层次化不要以设备最为标准，要以协议作为分层的标准。 OSI(开放式系统互联模型) 七层模型： 应用层：为应用程序提供网络服务 表示层：数据格式化，加密、解密，如：jpg，gif 会话层：建立、维护、管理会话连接,系统(Linux,iOS,Android)在此 传输层：建立、维护、管理端到端连接，单位：段(segment)，TCP/UDP连个协议 网络层：IP寻址和路由选择,单位：包，有200多个协议 数据链路层：控制网络层与物理层之间的通讯，单位：帧(frame) 物理层：比特流传输，单位：比特(bit) 应用层、表示层、会话层：单位统称为：协议数据单元(PDU)物理层在TCP/IP中被称为互联网层(Internet Protocal) TCP/IP(工业标准) 应用层 (TELNET、FTP、SMTP) 传输层 (TCP、UDP) 互联网层 (IP、ICMP),路由 网络接口层 (PPP)，交换 数据封装 每一层都有一个头部 TCP与UDP的概念相互的区别及优劣 TCP面向连接，UDP面向无链接 TCP面向报文，UDP面向字节流 TCP提供可靠传输服务（数据顺序、正确性），UDP传输不可靠 TCP协议传输速度慢，UDP协议传输速度快 TCP协议对系统资源要求多（头部开销大），UDP协议要求少* VRP 的操作管理vlan(虚拟局域网) SW112345system-viewsysname SW1interface vlanif 1ip address 10.1.1.1 24display this SW21234system-viewsysname SW2interface vlan 1ip address 10.1.1.2 24 ENSP自带了网络报文解析器。右键设备-数据抓包 Ehternet基础 网络中传输数据时需要定义并遵循一些标准，以太网是根据IEEE802.3 标准来管理和控制数据帧的。了解IEEE802.3标准是充分理解以太网中链路层通讯的标准。 IEEE 是局域网标准 以太网帧以太网(最流行，最常用，效率最高)，它的数据链路层基于MAC地址进行帧的传输。PR：FR(MA网络)：帧中继靠的是DLCIPPP(ppp网络)、HDLC(ppp网络)：什么都不靠 以太网MAC地址以太网的MAC地址(Media Access Control Address)：由两部分组成:前24位的供应商代码、后24位的序列号。供应商代码由IEEE管理和分配。 OUI：厂商序号 MAC分类单一的源段发送到单一的目的端，每个主机接口由一个MAC地址唯一标识，MAC地址的OUI中第一字节第8个比特表示地址类型，对于主机MAC地址这个比特固定为0如，表示目的的MAC地址为此MAC地址的帧都是发送到某个唯一的端。在冲突域中，所有主机都能收到源主机发送的单播帧，但其他主机发现目的地址与本地MAC地址不一致后会丢弃收到的帧，只有真正的目的主机才会接收并处理收到的帧 单播MAC(1 V 1)：01001100 第一字节的最后一位：0组播MAC(1 V n): 00000001 第一字节的最后一位：1广播MAC(1 V all): F1111111 第一字节的最后一位：1 01005E:经典的组播MAC 以太网封装格式以太网两种最常用的以太网封装格式：以太2型和802.3 80年代初：DIX v2，1983年：提出IEEE8.2.3 类型的位置除了IP(0800)还有ARP(0806),PPPoE,MP,IPv6c 两种协议的主要区别在于： EnternetII格式中包含一个Type字段，标识以太网帧处理完成值后将被发送到哪个上层协议进行处理。IEEE802.3格式同样的位置是长度字段。 以太网帧中的Type字段为0X0800，表示该帧的网络层协议为IP协议。 不同的Type字段值可以用来区别这两种帧的类型: EnternetII格式: Length/Type &gt;= 1536(0x0600) IEEE802.3格式: Length/Type &lt;= 1500(0x05DC) 以太网帧中还包括源和目的的MAC地址，分别代表发送者和接受者的MAC，此外还有帧校验序列字段，用于检验传输过程中的完整性。 以太网IP地址网络基础和FTPIP编制IP编制组成 IP 地址分为网络部分和主机部分 IP 地址由32个二进制位组成，通常用点分十进制形式表示。 IP报文头部 Tyep[Data] 的 1500 包括IP报头 以太网IPv4基础和分类/8：代表掩码，作用：区分网络和主机，代表8个连续的1(255.0.0.0)127.0.0.0/8 ：网络(主机位全为0)127.255.255.255/8 ：广播地址(主机全为1) 每个网段上有两个特俗地址不能分配给主机或网络设备。(除网络地址和广播地址外的其他IP地址可以作为网络设备的IP地址) IP地址主机位全为0(而不是无端一定为0)，表示一个网段。 该网段中的广播地址，目的地址为广播地址的报文会被该网段中的所有网络设备接受，广播地址的主机位全为1. 网络的进制二进制，十进制，十六进制(MAC) IPv4地址分类 地址范围A类：1.0.0.1126.255.255.254B类：128.1.0.1191.255.255.254C类：192.0.1.1223.255.255.254D类：224.0.0.0～239.255.255.255E类：240.0.0.1255.255.255.254 NET: ABCDE的有类网络 subset：即子网(一个大的网络划分成小的网络) 10.2.8.3/24 可以容纳的主机：2^8-2 IP地址类型互联网标准：RFC 私有地址 10.0.0.0~10.255.255.255 127.16.0.0~127.31.55.255 192.168.0.0~192.158.255.255 特俗地址 127.0.0.0~127.255.255.255, 127.0.0.1主机环回地址 0.0.0.0 255.255.2555.255(本地广播地址，是0.0.0.0的广播地址) 子网掩码(subset mask) 默认子网掩码 A类：8位B类：16位C类：24位 地址规划 举例 由子网掩码可知：172.10.1.7/16，所以网络地址为：172.16.0.0(主机位全为0)，主机数：2^16,可用主机数: 2^16-2 例子：10.1.8.3/24的网络是什么？第一个可用主机是？最后一个可用主机？可用主机是多少？10.1.8.0，10.1.8.1，10.1.8.254，$2^8$-2=254 变长子网掩码 192.168.1.7/25 有类IP编址的缺陷在设计网络时使用有类IP地址会造成地址的浪费。 划分子网方法 根据需要的子网数目来确定子网位数，但是要确保每个子网可用的IP地址数目大于等于本机数。优点：简单缺点：每个子网的实际主机数不同，但分配的IP地址数目相同，可能浪费IP地址 根据每个子网的主机数目来确定主机数位，然后确定子网数位。优点：比较充分地利用IP地址缺点：复杂 计算科学但麻烦的方法要转换二进制二进制:1代表网络，0代表主机。 子网的数目 = $2^x$ (x代表子网位数) 可用主机数目 = $2^y$-2 (y代表主机位数) 主机位为全1的地址时广播地址=下个子网号-1 主机位全为0的地址是网络地址。 利用子网数目计算子网掩码 把B类地址172.16.0.0划分成30个子网络，它的子网掩码是多少？ 将子网络数目30转换成二进制表示11110统计一下这个二进制的数共有5位注意：当二进制数中只有一个1的时候，所统计的位数需要减1（例如：10000要统计为4位）将B类地址的子网掩码255.255.0.0主机地址部分的前5位变成1这就得到了所要的子网掩码（11111111.11111111.11111000.00000000）255.255.248.0。 利用主机数目计算子网掩码 把B类地址172.16.0.0划分成若干子网络，每个子网络能容纳500台主机，它的子网掩码是多少？ 把500转换成二进制表示111110100统计一下这个二进制的数共有9位将子网掩码255.255.255.255从后向前的9位变成0这就得到了所要的子网掩码（11111111.11111111.11111110.00000000）255.255.254.0。 利用子网掩码计算最大有效子网数 A类IP地址，子网掩码为255.224.0.0，它所能划分的最大有效子网数是多少？ 将子网掩码转换成二进制表示11111111.11100000.00000000.00000000统计一下它的网络位共有11位A类地址网络位的基础数是8，二者之间的位数差是3最大有效子网数就是$2^3$，即最多可以划分8个子网络。 利用子网掩码计算最大可用主机数 A类IP地址，子网掩码为255.252.0.0，将它划分成若干子网络，每个子网络中可用主机数有多少？ 将子网掩码转换成二进制表示11111111.11111100.00000000.00000000统计一下它的主机位共有18位最大可用主机数就是 2^18-2（除去全是0的网络地址和全是1广播地址），即每个子网络最多有262142台主机可用。 利用子网掩码确定子网络的起止地址 B类IP地址172.16.0.0，子网掩码为255.255.192.0，它所能划分的子网络起止地址是多少？ 利用子网掩码计算，最多可以划分4个子网络利用子网掩码计算，每个子网络可容纳16384台主机（包括网络地址和广播地址）用16384除以256（网段内包括网络地址和广播地址的全部主机数），结果是64具体划分网络起止方法如下：172.16.0.0～172.16.63.255172.16.64.0～172.16.127.255172.16.128.0～172.16.191.255172.16.192.0～172.16.255.255 参考来源 快速但需要检验的方法快的方式(Block):几个主机位,算B类地址比较麻烦. 例子 132.56.45.7/30,网络位，主机位多少？ 30转成二进制：1111，1100，后两位的0的块：$2^2$,一块最多4个主机(0-3,4-7,8-11) CIDR 无类域间路由cidrreport.org无间路由(Classless Inter Domain Routing):由RFC1871定义。突破传统的地址分类边界，将路由表中的若干条线路汇聚成一条路由，减少了路由表的规模，提高了路由的可扩展性。 图中：转成二进制：10.24.0000，0000.010.24.0000，0001.010.24.0000，0010.010.24.0000，0011.0 转二进制部分只有后两位不一样。把网络往前推（子网是Mask边长汇总是Mask变短),原来是24，变短就是22. 网关(Gateway)用来转发来自不同网段之间的数据包。 实施FTP 文件传输 FTP：文件传输协议 (华为居多)，基于TCP，两个端口号,控制端口一般为21，而数据端口不一定是20，和FTP的应用模式有关，如果是主动模式，应该为20，如果为被动模式，由服务器端和客户端协商而定。TFTP：简单文件传输协议 (思科居多)，基于UDP 网络连通性···bash SW1interface vlanf1ip address 10.1.1.1 255.255.255.0123```bash SW2interface vlanf1ip address 10.1.1.2 255.255.255.0 测试连通性 1ping 10.1.1.1.2 开启FTP服务 12ftp server enablediaplay ftp-servver # 查看状态 实施FTP开启3A（认证，授权，统计） SW1123456aaalocal-user Endar password simple userName # 增加用户名和密码local-user Endar level 15 # 设置最高的访问权限，0-15级local-user Endar ftp-directory flash: # 共享所有目录，后面可以指定其他local-user Endar server-type ftp # 设置用户服务用于ftp协议save Endar.zip # 保持配置文件 客户端测试 SW21234ftp 10.1.1.1 # 后输入用户名、密码dir # 查考目录get Endar.zip # 获取文件q # 退出 以太网IP头部概述和VRP相关讲解一公司四个部门，5、25、27、15人，规划每个部门vlan，给固定长度掩码：192.168.1.0/27，192.168.1.32/27，192.168.1.64/27，192.168.1.96/27 IP包头的重要字段VRP基础(应用)VRP(通用路由平台)的FTP应用可以Web、Cli登录常用密码：Admin@huawei 设备初始化启动bios 自检内存检测copy 数据(VRP包拷贝)解压缩到内存CTRL + B 停止自动启动(后可以初始密码) 命令行视图 用户视图 清除、display、保存 系统视图(system-view) 以中括号显示。可以display，但不能清除、保存配置系统参数 接口视图 协议视图OSPF、BGP、is-is 123system-viewospf # 进入 osp 协议设置bgp # 将进入 bgp协议设置 命令行功能 命令 解释 CTRL + A 光标移动到当前目录行最前端 CTRL + E 光标移动到当前目录行最末端 CTRL + C 停止当前命令的运行 CTRL + Z 回到用户视图 CTRL + ] 终止当前连接或切换连接 Backspace 删除光标左边的第一个字符 ⬅ Or CTRL + B 光标左移一位 ➡ Or CRTL + F 光标右移一位 TAB 输入一个不完整的命令按TAB进行补全 命令行在线帮助 部分帮助 12&lt;Huawei&gt;d?&lt;Huawei&gt;display h? 完全帮助 12&lt;Huawei&gt;?&lt;Huawei&gt;dislay? 命令等级 用户等级 命令等级 名称 0 0 访问级 1 0 and 1 监控级 2 0，1 and 2 配置级 3-15 0，1，2 and 3 管理级 允许某管理员保存系统配置，则可以将save命令的级别提高到4级，并定义只有该管理员有4级权限。就可以在不影响其他用户的情况下，实现命令的使用控制。 12system-viewcommand-privileage level 2 view user save 用户界面VTY接口最大可配范围：0~4 用户界面类型 编号 Console 0 VTY 0~4 R1123system-viewuser-intetface vty 0 4set authentication password clipher pass R21talnet 12.1.1.1 R112diaplay users # 查看用户user privilege level 2 # 设置用户登陆权限 user-interface maximum-vty number 可以配置同时登陆到设备的VTY类型用户界面的最大个数，如最大登录用户数设为0，则任何用户都不能通过Telnet或者SSH登陆到路由器。 配置用户界面命令 命令 功能 idle-tineout 设置超时时间默认十分钟 screen-length 设置指定终端屏幕的临时显示行数(0不显示) history-command max-size 设置历史命令缓冲区的大小 1234system-viewuser-interface console 0histoty-command max-size 20indle-timeout 1 30 # 1分20秒(最好不要改)) 123system-viewuser-interface console 0screen-length 512 # 最大行数512 CTR 快捷键 命令 解释 CTRL + TAB 到达后一标签 CTRL + SHIFT + TAB 前一标签 ALT + 数字 直接到达某标签 配置标题消息12345# 配置在用户登录前显示的标题信息header login information \"Welcome to huawei certification\"# 配置在用户登陆后显示的标题信息header shell information \"Please dont't reboot this devices\" dis current-configuration | ?dis current-configuration | include header 显示包含 header 的命令有哪些 文件系统管理基本命令 命令 功能 pwd 查看当前目录 dir 显示当前目录下的文件信息 more 查看文本文件的具体内容 cd 修改当前用户当前界面的工作目录 mkdir 创建新目录 rmdir 删除目录 copy 复制文件 move 移动文件 rename 村民们文件 delete / unreserved 删除/永久删除文件 undelete 恢复删除的文件 reset recycle-bin 彻底删除回收站的文件 save 保存配置，要在用户模式下 配置文件管理 配置文件查询 命令 功能 diaplay curremt-contiguration 显示当前配置文件 diaplay saved-configuration 显示保存的配置文件 1234567save Endar.zip # 保存配置# 查看当前配置diaplay current-configuration# 显示保存的配置文件diaplay saved-configuration 系统启动文件查查 命令 功能 display startup 查看系统启动参数 系统启动配置文件修改 startuo ? : path # 加载补丁 save-configuration # 加载下次的配置 system-software # 加载下次启动的软件 123# 配置系统下次启动时使用的配置文件startup save-configuration Ender.zipdis startup 比较当前配置和保存的配置 1compare configuration 配置文件重装 12# 清楚下次启动时加载的配置文件reset save-contiguration 设置环回地址123system-viewinterface loopback 0ip address 10.1.1.1 32 存储设备SDRAM、Flash、NVRAM、SD Card、USB 12# 显示存储设备信息diaplay version 存储设备修复 123fixdisk flash:fixdisk ad1:","link":"/posts/HCNA_Note.html"},{"title":"LAMP","text":"Linux 编译安装 LAMP Apache准备编译工具&amp;开发包 1yum -y install make gcc openssl 依赖包 包 描述 httpd Apache 主程序包 apr Apache 依赖包 apr-util Apache 依赖包 pcre Apache 依赖包 Install apr 1234tar zxvf apr-1.5.2.tar.gzcd apr-1.5.2./configure --prefix=/usr/local/aprmake &amp;&amp; make install apr-util 12345tar zxvf apr-util-1.5.4.tar.gzcd apr-tuil-1.5.4./configure --prefix=/usr/local/apr-util/\\--with-apr=/usr/local/apr/bin/apr-1-configmake &amp;&amp; make install pcre 1234unzip -o pcre-8.38.zipcd pcre-8.38./cofigure --prefix=/usr/local/pcremake &amp;&amp; make install Apache 12345678tar zxvf httpd-2.4.18.tar.gz -C /usr/local/src/cd /usr/local/src/httpd-2.4.18/./configure --prefix=/usr/local/apache2 \\--enable-so \\--enable-ssl \\--with-apr=/usr/local/apr/ \\--with-apr-util=/usr/local/apr-util/ \\--with-pcre=/usr/local/pcre/ 注:–enable-so # 支持动态加载模块哦–enable-rewrite # 支持网站地址重写–with-apr=/usr/local/apr # 关联 apr 配置文件1ls /usr/local/apache2/conf/httpd.conf 网站根目录1ls /usr/local/apache2/htdocs/ 生成启动脚本12cp /usr/local/apache2/bin/apachectl /etc/init.d/chmod +x /etc/init.d/apachectl vim /etc/init.d/apachectl apachectl12# chkconfig: 2345 64 36# descroption: apache service 将服务添加到系统启动列表1234chkconfig --add apachectlchkconfig apachectl onchkconfig --list apachectl service apachectl start MySQLDownloadboostMySQL 12yum -y remove boostyum -y remove mysql Install添加用户和组12groupadd mysqluseradd -M -s /sbin/nologin -r -g mysql mysql 创建安装目录和数据存放目录12345mkdir /servermount /dev/sdb2 /server/# 开机自动挂载echo \"/dev/sdb2 /server ext4 defaults 0 0\" &gt;&gt; /etc/fstab 安装1234567891011121314151617181920212223mkdir -p /server/mysql/datatar -zxvf boost_1_59_0.tar.gzmv booboost_1_59_0 boosttar -zxvf mysql-5.7.11.tar.gzcd mysql-5.7.11 cmake . \\-DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\-DSYSCONFDIR=/server/mysql/data \\-DSYCONFDIR=/etc \\-DWITH_MYISAM_STORAGE_ENGINE=1 \\-DWITH_INNOBASE_STORAGE_ENGINE=1 \\-DWITH_MEMORY_STORAGE_ENGINE=1 \\-DWITH_READLINE=1 \\-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \\-DMYSQL_TCP_PORT=3306 \\-DENABLED_LOCAL_INFILE=1 \\-DWITH_PARTITION_STORAGE_ENGINE=1 \\-DEXTRA_CHARSETS=all \\-DDEFAULT_CHARSET=utf8 \\-DDEFAULT_COLLATION=utf8_general_ci \\-DDOWNLOAD_BOOST=1 \\DWITH_BOOST=/server/boost 安装 12345make -j 4 # 多核心安装# 查看核心数grep processor /proc.cpuinfo | wc -lmake install 修改目录权限 1chown -R mysql:mysql /server/mysql/ 生成配置文件 12mv /etc/my.cnf{,.bak}cp /server/mysql/support-files/my-default.cnf /etc/my.cnf 生成服务启动脚本 123cp /server/mysql/support-files/mysql.server /etc/init.d/mysqldchkcongig mysqld onchkconfig --list mysqld 初始化数据库 1/server/mysqk/bin/mysqld --initialize-insecure --user=mysql --basedir=/server/mysql --datadir=/server/mydql/data 启动服务 1server mysqld start 添加 path 路径 方法一 vimlink12export MYSQL_HOME=/server/mysqlexport PATH=$PATH:$MYSQL_HOMW/bin 使修改生效 1source /etc/profile 方法二1ln -s /server/mysql/bin/* /user/local/bin 修改密码 方法一 1mysqladmin -u roor password \"123456\" 方法二 12mysqlset password=password('123456'); PHP安装依赖包1yum -y install php-mcrypt libmcrypt libmcrypt-devel autoconf freetype gd libmcrypt libpng libpng-devel libjpeg libxml2 libxml2-devel zlib curl curl-devel Install1tar zxvf php-7.05.tar.gz 编译123456789101112cd php-7.05./configure --prefix=/server/php7/ \\--with-apx2=/use/local/apache2/bin/apxs \\--enable-mbstring \\--with-curl \\--with-gd \\--enable-fpm \\--enab;e-musqld \\--with-pdo-mysql=mysqld \\--with-config-file-path=/server/php7/etc/ \\--with-mysqli=mysqlnd \\--with-mysql-socl=/server/mysql/mysql.sock 安装12make -j 4make install 生成配置文件 1cp php.ini-production /server/php7/etc/php.int 添加 Apache 支持 123vim /usr/local/apache2/cong/httpd.confAddtype application/x-httpd=php .php .phtml 创建测试页面 1234cd /usr/local/apache2/htdocs/echo \"&lt;?php phpinfo();?&gt;","link":"/posts/LAMP.html"},{"title":"解决Python Pip 速度慢","text":"解决 Python 安装库时速度慢或者超时问题 设置超时时间1pip --default-timeout=1000 install jieba -i 指定源1pip install wordcloud -i https://pypi.tuna.tsinghua.edu.cn/simple/ 更改默认设置~/.pip/pip.conf1234[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com","link":"/posts/PipInstall.html"},{"title":"Matplotlib 中文乱码","text":"Linux 解决 matplotlib 中文乱码问题 安装字体 安装中文字体，例如 SimHei 检测本机中文字体 1234567891011121314from matplotlib.font_manager import FontManagerimport subprocessfm = FontManager()mat_fonts = set(f.name for f in fm.ttflist)#print(mat_fonts)output = subprocess.check_output('fc-list :lang=zh -f \"%{family}\\n\"', shell=True)#print( '*' * 10, '系统可用的中文字体', '*' * 10)#print (output)zh_fonts = set(f.split(',', 1)[0] for f in output.decode('utf-8').split('\\n'))available = mat_fonts &amp; zh_fontsprint ('*' * 10, '可用的字体', '*' * 10)for f in available: print (f) 配置字体 复制字体 12sudo cp font.ttf /usr/share/fontssudo cp font.ttf /usr/lib/python3.7/site-packages/matplotlib/mpl-data/fonts 配置/usr/lib/python3.7/site-packages/matplotlib/mpl-data1sudo nvim matplotlibrc matplotlibrc 12345font.family : sans-serif font.serif▏ : serif font.serif : SimHei,Source Code Pro,DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopiafont.sans-serif : SimHei,Source Code Pro,DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica 清楚缓存1rm -rf ~/.cache/matplotlib 使用1234# 中文乱码的处理from pylab import mplmpl.rcParams['font.sans-serif'] = ['Source Code Pro'] # 指定默认字体mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题 参考资料 Linux下解决matplotlib中文乱码的方法","link":"/posts/MatplotlibZh.html"},{"title":"Linux Wine 调整分辨率","text":"Linux Wine 调整分辨率 终端输入 应用设置 1env WINEPREFIX=\"$HOME/.deepinwine/Deepin-WeChat\" winecfg 全局设置 1winecfg 设置分辨率","link":"/posts/Wine-dpi.html"},{"title":"Xpath 升格用法","text":"xpath 升格用法 匹配当前节点下所有子节点 .//1xpath('//div//') # div 当前节点 // 标签下的所有标签 匹配某标签的属性值 /@属性名称12# 获取 input valuexpath('//input/@value') 匹配多个路径 |1xpath('//div/text() | //div/div/text()') 按属性匹配 @12# 获取所有id=\"test\"的所有文本内容xpath('//*[@id=\"test\"]//text()') 匹配不包含某个属性的标签 not12# 多用于表格中匹配中不包含表头信息的数据xpath('//table/tr[not(@class=\"tbhead\")]') 匹配包含多个属性的标签 and12# 匹配所有的tr中不包含 tbhead 属性 和包含 head 的tr标签xpath('//table/tr[not(@class=\"tbhead\") and @class=\"head\"]') 匹配包含不同属性的名称相同的标签 or12# 匹配包含class=\"speedbar\" 或者 class=\"content-wrap\" 的标签xpath（'//div[@class=\"speedbar\" or @class=\"content-wrap\"]'） 将对象还原为字符串 etree.tostring（）123# 将匹配到的对象，作为etree.tostring（）的参数即可， 注： 返回字符串sObj = xml.xpath('//*[@id=\"test\"]')[0]# 使用xpath定位一个节点sStr = etree.tostring(sObj) 按轴(Axes)匹配选取当前节点的所有子元素 child1234# 获取div下的tr的标签xpath('//div[@id=\"testid\"]/child::tr/td/text()')# 感觉这种方法鸡肋， 也可以实现xpath('//div[@id=\"testid\"]//tr/td') 选取当前节点的所有属性 attribute123# 获取div标签所有的属性值xpath('//div/attribute::*') # 感觉这种方法鸡肋，//div/@* 同样能实现 ancestor：父辈元素 / ancestor-or-self：父辈元素及当前元素123# 获取父辈元素的div的所有属性值， 在不好定位的情况下，通过孩子标签定位，这种方法可以用xpath('//div[@id=\"test\"]/ancestor::div/@*')xpath('//div[@id=\"test\"]/ancestor-or-self::div/@*') descendant：后代 / descendant-or-self：后代及当前节点本身123# 获取孩子元素的div的所有属性值，感觉鸡肋xpath('//div[@id=\"test\"]/descendant::div/@*')xpath('//div[@id=\"test\"]/descendant-or-self::div/@*') 选取当前节点的所有命名空间节点 namespace1xpath('//div[@id=\"test\"]/namespace::*') 定位 position12# 和通过下标定位一样， 方法鸡肋xpath('//*[@id=\"test\"]/ol/li[position()=2]/text()') Xpath 函数统计数量 count12# 统计符合要求节点的数量,返回字符串xpath('count(//tr[@info])') 字符串拼接 concat12# 统计出来的两个内容的字符串进行“ + ”处理,返回字符串xpath('concat(//li[@id=\"one\"]/text(),//li[@id=\"three\"]/text())') 解析当前节点下的字符 string12# string()直解析匹配的第一个标签的值， 注： 返回字符串xpath('string(//tr)') 获取当前节点的节点名称 local-name12# 返回当前属性的节点名称， 注： 返回字符串xpath('local-name(//*[@id=\"test\"])') 以指定的字符开头 starts-with12# starts-with定位属性值以8开头的li元素xpath('//tr[starts-with(@code,\"one\")]/text()') 小于 &lt;12# 匹配所有tr标签属性info小于200的内容xpath('//tr[@info&lt;200]/text()') 根据指定的文本内容选择12# 指定的文本内容可以是文本内容的部分， 也可以是全部xpath('//div[2]/ul/li[contains(text(), \"指定的文本内容\")]/span/text()' Via 作者:董小贱","link":"/posts/Xpath.html"},{"title":"Hexo SEO 优化","text":"Hexo SEO 优化 添加站点地图安装插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 配置_config.yml12345#hexo sitemapsitemap: path: sitemap.xmlbaidusitemap: path: bdmap.xml 添加 robots站点 source 下添加 robots.txt robots.txt12345678910111213141516User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://vitan.me/sitemap.xmlSitemap: https://vitan.me/bdmap.xml 添加到 Google 在 Google Search Console 添加站点地图 在 百度 添加站点地图","link":"/posts/HexoSEO.html"},{"title":"撤销 Google AdSense","text":"AdSense 账户撤销原因更换了邮箱之后重新申请了一个，但是提示有多个 AdSense 账户 常规撤销登录 Google AdSense 点击菜单-&gt;账号-&gt;撤销账号 个人情况我遇到的情况比较特俗，AdSense 页面的 账号 按钮不可点击，为灰色。 摸索的方法 在 Google 账号 的 数据和个性化 -&gt; 下载数据、删除数据或为数据制定方案 -&gt; 删除某项服务或您的帐号 关闭自己的 Google 付款资料 可以发现 AdSense 页面中的 账号 按钮变为可点击了，撤销成功！","link":"/posts/GoogleAdSense.html"},{"title":"RaspberryPi 搭建 Gogs Git 服务","text":"树莓派搭建 Gogs Git 服务 安装 MySQL1sudo apt install mariadb-server mariadb-client 配置 123sudo vi /etc/mysql/mariadb.conf.d/50-server.cnf 注释掉 bind-address = 127.0.0.1 修改 root 密码 1sudo mysqladmin -u root -p password 新建 gogs 数据库 12mysql -h127.0.0.1 -uroot -p123456create database gogs; 重启 MySQL 1sudo service mysql restart golang1sudo apt install golang -y gogs1wget https://cdn.gogs.io/0.11.79/gogs_0.11.79_raspi2_armv6.zip 解压 1tar -xzvf gogs_0.11.79_raspi2_armv6.zip 安装 12cd 解压后的目录./gogs web 配置 浏览器打开 http://ip:3000 后台运行 1nohup ./gogs web &gt; nohup.out 2&gt;&amp;1 &amp; Frp 内网穿透下载安装 1234wget https://github.com/fatedier/frp/releases/download/v0.27.1/frp_0.27.1_linux_386.tar.gz # 解压安装tar -zxvf frp_0.27.1_linux_386.tar.gz 配置 12cd frp_0.27.1_linux_386vim frps.ini 123456789101112[common]server_addr = gogs.vitan.meserver_port = 8000token = [gogs]type =httpprivilege_mode = truelocal_ip = localhostlocah_port = 3000custom_domain = gogs.vitan.me 启动 1./frps -c ./frps.ini 配置好服务器端后,可以在浏览中(http://IP:8000/static/#/) 打开 frp 的控制台 参考 gogs Frp","link":"/posts/GogsOnPi.html"},{"title":"Termux 局域网共享文件","text":"Android 跨设备局域网共享文件 http-server安装 12pkg install nodejs-ltsnpm install http-server -g 启动服务 1http-server 同一局域网同一局域网下浏览器登录启动服务后的提示的 ip 即可访问手机的文件，相反电脑同理。","link":"/posts/Termux-Httpd.html"},{"title":"Shell","text":"Shell 总结 变量替换和测试变量替换 变量测试 字符串处理计算字符串长度方法一 1${#string} 方法二 1expr length \"$string\" string 有空格，则必须加双引号 子串获取子串在字符串中的索引位置 1expr index $string $substring 抽取子串 总结计算字符串长度 123var1=\"This is a app\"len=${#$var1}len=`expr length \"$var1\"` 子串索引 12var1=\"quicstart is a app\"ind=`expr index \"$var1\" start` 子串长度 12var1=\"quicstart is a app\"ind=`expr match \"$$var1\" app` 抽取字符串中的子串 12345var1=\"quicstart is a app\"substr1=${var1:10}substr2=${var1:10:6}substr1=${var1:-5}substr1=${var1:-10:4} expr 索引1开始,${string:position}从0开始 实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#! /bin/bashstring=\"Bigdata process framework is Hadoop,Hadoop is an open source project\"function print_tips{ echo \"***********************\" echo \"(1) 打印string长度\" echo \"(2) 删除字符串中所有Hadoop\" echo \"(3) 替换第一个Hadoop为Mapreduce\" echo \"(4) 替换全部Hadoop为Mapreduce\" echo \"**********************\" }function len_of_string{ echo \"${#string}\"}function del_hadoop{ echo \"${string/Hadoop/}\"}function rep_hadoop_mapreduce_first{ echo \"${string/Hadoop/Mapreduce}\" }function rep_hadoop_mapreduce_all{ echo \"${string//Hadoop/Mapreduce}\" }while truedo echo \"【string=$string】\" echo print_tips read -p \"Pls input your choice(1|2|3|4|q|Q):\" choice case $choice in 1) len_of_string ;; 2) del_hadoop ;; 3) rep_hadoop_mapreduce_first ;; 4) rep_hadoop_mapreduce_all ;; q|Q) exit ;; *) echo \"Error,input only in {1|2|3|4|q|Q}\" ;; esacdone 命令替换语法格式 例题获取系统所有用户并输出 12cat /etc/passwd | cut -d “:” -^C #分割的第一个cat /etc/passwd | cut -d “:” -f 1 #分段 1234567#! /bin/bash# 判断进程是否存在，否则启动nginx_process_num=$(ps -ef | grep nginx | grep -v grep | wc -l)if [ $nginx_process_num -eq 0 ];then systemctl start nginxfi 总结\\`和$()` ``和$()是等价的，但初学推荐$() $(())用于进行整数运算，包括加减乘除 $(((100 + 30) / 12)) 有类型变量declare 和 typeset 命令两者关系:两者等价，都是用来定义变量类型 declare参数表 123456789101112131415161718192021222324252627282930313233# 声明整数型变量declare -i ab #声明整数型变量ab=56 #改变变量内容echo $ab #显示变量内容56# 改变变量属性declare -i ef #声明整数型变量ef=1 #变量赋值（整数值）echo $ef #显示变量内容1ef=\"wer\" #变量赋值（文本值）echo $ef 0declare +i ef #取消变量属性ef=\"wer\"echo $efwer# 设置变量只读declare -r ab #设置变量为只读ab=88 #改变变量内容echo $ab #显示变量内容56# 声明数组变量declare -a cd='([0]=\"a\" [1]=\"b\" [2]=\"c\")' #声明数组变量echo ${cd[1]}b #显示变量内容echo ${cd[@]} #显示整个数组变量内容a b c declare -x 声明为环境变量，可在脚本中直接使用 取消声明的变量1234declare +rdeclare +ideclare +adeclare +X 数学运算语法格式 expr操作符对照表 例子 Bash运算之bcbc 操作 123scale=2 #精确到小数点后两位echo “20+22” | bcecho “scale=3;23+33” | bc 函数函数定义和使用Linux Shell中的函数和大多数编程语言中的函数一样，将相似的任务或代码封装到函数中，供其他地方调用 语法一 1234567name(){ command1 command2 .... commandn} 语法二 1234567function name{ command1 command2 .... commandn} 如何调用 直接使用函数名调用，可以将其想象成 Shell 中的一条命令 函数内部可以直接使用函数 $1,$2…$n 调用函数：function_name $1 $2 例题12345678910111213141516171819#!/bin/bash# 判断进程是否存在，否则启动#脚本名含有nginx会返回0# echo $$ 运行脚本产生的进程idthis_pid=$$while truedops -eff | grep nginx | grep -v grep | grep -v $this_pid &amp;&gt; /dev/nullif [ $? -eq 0];then echo \"Nignx is running well\" sleepp 3else systemctl start nginx echo \"Nginx is down,start it..\"fidone 判断进程 12netstat -tnlp | grep :80curl localhost/index.html 向函数传递参数shell传参12345function name{ echo \"Hello $1\" echo \"Hello $2\"} 函数返回值 return echo reutrn 返回值 只能返回1-255的整数 通常智能用来供其他地方调用获取状态，因此仅返回0（成功)，1(失败) echo 返回值 可以返回任何字符串结果 通常用于返回数据，如一个字符串值或列表值 局部变量全局变量全局变量 不做特殊处理，shell 中变量为全局变量 大型脚本程序慎用 局部变量 定义时，使用local关键字 函数内外如果存在同名变量，册函数内部变量覆盖外部变量 函数库 为什么要定义函数库 经常使用的重复代码封装成函数文件 一般不直接执行，而是由其他脚本调用 实例 库文件123456789101112131415161718192021222324252627282930function add{ echo \"`expr $1 + $2`\"}function reduce{ echo \"`expr $1 - $2`\"}function multiple{ echo \"`expr $1 \\* $2`\"}function diveid{ echo \"`expr $1 / $2`\"}function sys_load{ echo \"Memory Info\" free -m echo echo \"Disk Usage\" echo df -h } 1234567#!/bin/bash. /home/vitan/workplace/Shell/learn/function/base_functionadd 122 3reduce 9 3multiple 22 11diveid 12 3sys_load 注意事项 库文件名的后缀是任意的，但一般用 .lib 库文件通常没有可执行权限 库文件无需和脚本在同级目录，只需在脚本中引时指定 第一行一般使用 #!/bin/bash/echo ，输出警告信息，避免用户执行 文件查找之find命令find [路径][选项][操作] 实例 查找 /etc 目录下 conf 结尾的文件 1fing /etc -name '.conf' 查找当前目录下文件名为 aa 的文件，不区分大小写 1find . -name aa 查找文件属主为 hdfs 的所有文件 1find . -user hdfs 查找文件属组为 yarn 的所有文件 1find . -group yarm 选项 -type f 文件 find . -type f d 目录 dind . -type d c 字符设备文件 dind . -type c b 块设备文件 dind . -type b l 链接文件 dind . -type l p 管道文件 dind . -type p -size -n 大小小于n的文件 +n 大小大于n的文件 n 大小等于n的文件 1234# 小于10000字节的文件find /etc -size -10000c# 大于1M的文件find /etc -size +1M -mtime -n n天以内修改的文件 +n n天以外修改的文件 n 正好n天修改的文件 1234#查找/etc下5天内修改的conf结尾的文件find /etc -mtime -5 -name '*.conf' # 查找10天之前修改且属主为root的文件find /etc -mtime +10 -user root -mmin -n n分种内修改的文件 +n n分钟外修改的文件 1234# 30分钟前修改的文件find /etc -mmin +30# 30分钟内修改的目录find /etc -mmin -3o -type d -mindepth n 表示从n级子目录开始搜索 1find /etc -mindepth 3 -maxdepth n 表示最多搜索n-1级子目录 123find /etc -maxdepth 3 -name '*.conf'find ./etc -type f -name '.*conf' -size +10k -maxdepth 2find . -type f -nogroup -perm find .perm 644 -prune 通常和-path一起用，用于将特定目录排除在搜索条件之外 12345678# 查找当前目录下所有普通文件，排除test目录find . -path ./etc -prune -o -type f# 查找当前目录下所有普通文件，但排除etc和opt目录find . -path ./etc -prune -o -path ./opt -prune -o -type f# 当前目录所有普通文件，排除etc和opt目录，但属主为hdfsfind . -path ./etc -prune -o -path ./opt -prune -o -type -f -a -user hdfs# 当前目录所有普通文件，排除etc和opt目录，但属主为hdfs,文件大小大于find . -path ./etc -prune -o -path ./opt -prune -o -type -f -a -user hdfs -a -size +2M -newer file1 1find /etc -newer a 操作 12345# 搜索/etc下的文件非目录，以conf结尾，大于19k，然后删除find ./etc -type -f -name '*.conf' -size +10k -exec rm -rf {} \\;find /var/log/ -name '*.log' -mtime +7 -exec rm -rf {} \\;find /etc -size +10k -type -f -name '*.conf' -exec cp {} /root/conf/ \\; -print 打印输出 -exec 对搜索的文件执行特定的操作 -ok 和exec功能一样，但每次操作都会给用户提示 逻辑运算符 -a 与 -o 或 -not|! 非 find locate whereis和 which 总结及使用场景分析locate 文件查找命令，所属软件包mlocate 不同于find命令是在整块磁盘中搜索，locate在数据库文件中查找 find默认全部匹配，locate默认部分匹配 updatedb命令 用于更新/var/lib/mlocate/mlocate.db 所使用配置文件/etc/update.conf 该命令在后台cron计划任务定期执行 whereis选项和含义 -b 只返回二进制文件 -m 只返回帮助文档文件 -s 只返回源码文件 which 仅查找二进制程序文件 选项 -b 只返回二进制文件 各命令使用场景推荐 grep和egrepgrep语法 grep [option] [pattern] [file1,file2…] command | grep [option] [pattern] grep参数 grep -E “python | PYTHON” file egrepegrep语法 1egrep(选项)(查找模式)(文件名1，文件名2，……) sedsed(Stream Editor)，流编辑器，对标准输出或文件逐行进行处理 语法 stdot | sed [option] “pattern command” sed [option] “pattern command” file 选项 123456789101112131415sed ‘p’ sed.tet # p打印出来sed -n‘p’ sed.tet# 不加参数，原行也会再打印一次sed ‘/python/p’sed.txt #查找行sed -n‘/python/p’sed.txt #查找行# 多个匹配条件sed -n -e ‘/python/p’ -e ‘/PYTHON/p’ sed.txt#文件中的Vim edit.sed/python/pSed -n -f edit.sed sed.txtSed -n -r‘/python|PYTHON/p’ sed.txt #使用扩展正则表达式# 修改sed -n ‘s/love/like/g’ sed.txt # love替换为likesed -i‘s/love/like/g’ sed.txt #修改源文件 sed 的pattern详解 1234567891011121314# 打印file的17行sed -n \"17p\" file# 打印10到20行sed -n \"10,20p\" file# 打印第10行开始，往后加5行的内容sed -n \"10,+5p\" file# 以root开头的行sed -n \"/^root/p\" file# 打印第一个匹配到ftp开头的行sed -n \"/^root/,/^ftp/p\" file# 打印第四行开始，到以hdgs开头的sed -n \"4,/^hdfs/p\" file# 匹配root的行，直到第10行结束sed -n \"/root/,10p\" file sed 中的编辑命令 1234567891011121314151617181920sed -i‘1d/ sed.txt # 删除第一行sed -i ‘1,3d’sed.txt # 删除1-3行sed -i ‘/\\/sbin\\/nologin/d’passwd # 把不可登录的账号删除sed -i ‘/^mail,/^ftp/d’pssswd #mail到ftp文本追加sed -i ‘/\\/bin\\/bash/a This is user which can login to system’pssswd # 行后追加sed -i ‘/^hdfs/,/&amp;yarn/i AAAAAA’ pssswd # 行间追加sed -i ‘/root/r list’ passwd #把list内容追加root行后面sed -n‘/\\/bin\\/bash/w /tmp/user_login.txt’passwd #保存sed -i ‘s/\\/bin\\/bash/\\/BIN\\/BASH/g’passwd # 小写的替换为大写sed -i ‘a/root/ROOT/’passwd # 替换第一个root为大写sed -i ‘a/root/ROOT/2’passwd # 替换前两个个root为大写sed -i ‘s/hadoop/HADOOP/ig’str.txt #不区分大小写sed -n ‘/\\/sbin\\/nologin/=’passwd # 查看行号,不显示内容sed -i ‘s/had..p/hadoops/g’ sed.txt #.任意一个字符sed -i ‘s/had..p/&amp;s/g’ sed.txt #hadXXp后面加s，反向引用sed -i ‘s\\/(had..ps\\)\\/1O/g’ sed.txt #后加Osed -i ‘s/\\(had\\)...../\\1doop/g’sed.txt # had后面替换 反向引用 是什么 &amp;和\\1 引用模式匹配到的整个串 123# file中寻找1开头的后跟两任意字符以e结尾的字符sed \"s/1..e/&amp;r/g\" filesed \"s/\\(1...e\\)/\\1r/g\" file # 使用\\1代表搜寻到的字符串 上面两种方法实现一样的功能，分别使用&amp;和\\1代表搜寻到的整个字符串 区别在于&amp;只能表示匹配到的完整字符串，只能引用整个字符串，而\\1可以使用()对匹配到的 要替换匹配的字符串的一部分，name必须使用\\1，不能使用&amp; sed 引用变量 注意 匹配模式中存在变量，则建议使用双引号 sed中需要引入自定义变量时，如外面使用单引号，则自定义变量必须使用单引号 用 sed 查询特定内容查询命令 实例 123456789# 打印/etc/passwd中的第20行内容sed -n \"20p\" /etc/passwdsed -n \"8,15p\" /etc/passwdsed -n \"8,+5p\" /etc/passwdsed -n '/^hdfs/p' /etc/passwdsed -n '^root/,/^hdfs/p' /etc/passwdsed -n '8,/\\sbin\\/nologin/p' /etc/passwdsed -n '\\bin\\/bash/,5p' /etc/passwd 1234567891011121314151617181920212223242526#!/bin/bashFILE_NAME=/root/my.cnffunction get_all_segments{ echo \"`sed -n '/\\[.*\\]/p' $FILE_NAME | sed -e 's/\\[//g' -e 's/\\]//g'`\"}function count_items_in_segment{ items=`sed -n '/\\['$1'\\]/,/\\[.*\\]/p' $FILE_NAME | grep -v \"^#\" | grep -v ^$ | grep -v \"\\[.*\\]\"` index=0 for item in $items do index=`expr $index +1` done echo $index}number=0for segment in `get_all_segments`do num=`expr $number + 1` items_count=`coubt_items_in_segment $segment` echo \"$number: $segment $items_count\"done sed 删除特定内容 12345678sed -i '15d' passwdsed -i '8,14d' passwdsed -i '/\\sbin\\/nologin/d' passwdsed -i '/^mail/,/^yarn/d' passwdsed -i '/\\sbin\\/nologin/,13d' passwdsed -i '5,/^ftp/d' passwd# yarn开头到最后sed -i '/^yarn/,$' /etc/passwd 删除配置文件中所有的注释行和空行 在配置文件中所有不以#开头的行前面加×符合，主要以#开头的行不添加 123sed -i ‘/^#/d;/^$/d’ nginx.conf #删除注释sed -i ‘/[:blank:]*#/d’ nginx.conf #删除空行sed -i ‘/^[^#]/\\*&amp;/g’nginx.conf #非井号开头 sed 修改文件内容 实例 123456789101112#修改第一行的root为ROOTsed -i '1s/root/ROOT/' passwd#修改5到10行中所有的/sbin/nologin为/bin/bashsed -i '5,10s/\\/sbin\\/nologin/\\bin\\/bash/g' passed#修改匹配到/sbin/nologin的行，将匹配到行中的login改为LOGINsed -i '/\\sbin\\/nologin/s/login/LOGIN/g' passwd#修改以root开头的行，到15行中的所有行，修改行中的nologin为SPARKsed -i '/^root/,15s/nologin/SPARK/g' passwd#从15行开始到匹配以yarn开头的所有行，修改行中的bin为BINsed -i '15,/^yarn/s/bin/BIN/g' passwdsed -i 's/[0-9]*//g' file.txt sed 追加文本内容 语法 a 123456# 第十行后追加\"Add lind behind\"sed -i '10a Add lind behind' passwd# 第10到20行，每一行后面都追加\"Test line behind\"sed -i '10,20a Test line behind' passws# 匹配到/bin/bash的行后面追加\"insert line for /bin/bash behind\"sed -i '/\\bin\\/bash/a insert line for /bin/bash behind' passws i 1234# 匹配yarn开头的行，在匹配航后面追加\"Add lind behind\"sed -i 'yarn/i Add lind behind' passwd# 每一行前面都追加“insert line before every line\"sed -i 'i insert line before every line' passwd r 123456#将/etc/fstab文件的内容追加到passwd的第20行后面sed -i '20r /etc/fstab' passwd#将/etc/inittab文件内容追加到passwd文件匹配/bin/bash行后面sed -i '/\\bin\\/bash/r /etc/inittab' passwd#将/etc/vconsol.conf文件内容追加到passwd文件中特定行的后面，匹配以ftp开头的行后面sed -i /^ftp/,18r /etc.vconsole.conf’ pssswd w 1234# 将passwd文件匹配到/bin/bash的行追加到/tmp/sed.txt文件中sed -i '/\\bin\\/bash/w /tmp/sed.txt' passwd# 将passwd文件从10行还是到匹配到hsfs开头的所有行内容追加到/tmp/sed-1.txtsed -i '10,/^hsfs/w /tmp/sed-1.txt' passwd awkawk 的工作模式 awk 为一个文本处理工具，通常用于处理数据并产生结果报告。 命名是由三个创始人姓氏首字母组成 语法 awk ‘BEGIN{}pattern{commands}END{}’ file_name standard outpu | awk ‘BEGIN{}pattern{commands}END{}’ file_name 语法格式说明 awk 内置变量内置变量对照表 12345678910111213141516171819202122232425262728293031awk '{print $0}END{}' /etc/passwd# 指定分隔符，输出第一个(既所有用户名)awk 'BEGIN{FS=\":\"}{print $1}' /etc/passwd# 默认空格为分割符awk '{print $1' list.txt# NF每一个行字段个数（number Filed）awk '{print NF}' list.txt # 返回字段个数# NR(Number Row)awk '{print NR}' list.txt /etc/passwd # 返回行号# FNR(File Number Row)对每一个文件单独计数awk '{print FNR}' list.txt /etc/passwd# FS(File Separator)awk 'BEGIN{FS=\"|\"}{print $2}' list.txt #指定分割符|# RS(Row Separator) 行分隔符awk 'BEGIN{FS=\"|\";RS=\"--\"}{print $2}' list.txt# ORS(Output Row Separatot) 输出行分割符awk 'BEGIN{FS=\"|\";RS=\"--\"；ORS=\"&amp;\"}{print $2}' list.txtawk 'BEGIN{FS=\"|\";RS=\"--\"；ORS=\"&amp;\";OFS=\":\"}{print $2，$3}' list.txtawk '{print FILENAME}' list.txt #对每一行输出文件名awk '{print ARGC}' list.txt # 输出行参数个数awk 'BEGIN{FS=\":\"}{print $NF}' /etc/passwd # 输出行最大自的断 awk 格式化输出printf(默认不带分隔符) 语法 修饰符 实例 12345678910111213# 不加任何修饰输出 awk 'BEGIN{FS=\":\"}{printf $1}' /etc/passwd# 换行输出awk 'BEGIN{FS=\":\"}{printf \"%s\\n\",$1}' /etc/passwd# 输出两个变量awk 'BEGIN{FS=\":\"}{printf \"%s%s\\n\",$1,$7}' /etc/passwd# 第一个第二个变量长度20(默认右对齐)awk 'BEGIN{FS=\":\"}{printf \"%20s %20s\\n\",$1,$7}' /etc/passwd# 第一个第二个变量长度20(左对齐)awk 'BEGIN{FS=\":\"}{printf \"%-20s %-20s\\n\",$1,$7}' /etc/passwd 12345678910111213141516# 以字符串格式打印/etc/passwd中的第七个字段，以\":\"为分隔符awk 'BEGIN{FS=\":\"}{printf \"%s\\n\",$7}' /etc/passwd# 以10进制格式打印/etc/passwd中的第3个字段，以\":\"为分隔符awk 'BEGIN{FS=\":\"} {printf \"%d\\n\",$3}' /etc/passwd #不指定位数默认左对齐（指定位数右对齐 %-d) # 浮点数awk 'BEGIN{FS=\":\"} {printf \"%o.3f\\n\",$3}' /etc/passwd # 16进制awk 'BEGIN{FS=\":\"} {printf \"%x\\n\",$3}' /etc/passwd # 8进制awk 'BEGIN{FS=\":\"} {printf \"%o\\n\",$3}' /etc/passwd# 科学计数法awk 'BEGIN{FS=\":\"} {printf \"%e\\n\",$3}' /etc/passwd awk模式匹配的两种用法 语法 RegExp 含义：按正则表达式匹配 关系运算 含义：按关系运算匹配 实例 RegExp 12345# 匹配/etc/passwd文件中含有root字符串的所有行awk 'BEGIN{FS=\":\"}/root/{print $0}' /etc/passwd#匹配/etc/passwd中yarn开头的所有行awk 'BEGIN{FS=\":\"}/^yarn/{print $0}' /etc/passwd (运算符)关系运算 关系运算符：&lt;,&gt;&lt;=,&gt;=,==,!=,~(匹配正则表达式),!~ 1234567891011# 以：为分隔符，匹配第3个字段小于50的所有行信息awk 'BEGIN{FS=\":\"}$3&lt;50{print $0}' /etc/pssswdawk 'BEGIN{FS=\":\"}$7==\"/bin/bash\"{print $0}' /etc/pssswdawk 'BEGIN{FS=\":\"}$7!=\"/bin/bash\"{print $0}' /etc/pssswd# 第三个字符包含3个以上数字的所有行信息awk 'BEGIN{FS=\":\"}$3~/[0-9]{3,}/{print $0}' /etc/passwd # {3,}重复3次awk 'BEGIN{FS=\":\"}$0~/\\sbin\\/nologin/{print $0}' /etc/passwd 布尔运算:||(或),&amp;&amp;(与),!(非) 1234567# 以：为分隔符，匹配文件中包含hdfs或者yarn的所有行信息awk 'BEGIN{FS=\":\"}$1==\"hdfs\" || $1==\"yarn\" {print $0}' /etc/passwd# 第三字段小于50且第四字段大于50的所有行信息awk 'BEGIN{FS=\":\"}$3&lt;50 &amp;&amp; $4&gt;50 {print $0}' /etc/passwdawk 'BEGIN{FS=\":\"}$3&lt;50 &amp;&amp; $7~/\\bin\\/bash/ {print $0}' /etc/passwd awk 动作中的表达式用法算术运算符 运算符 含义 + 加 - 减 * 乘 / 除 % 模 ^或** 乘方 ++X 再返回X变量之前，X变量加1 X++ 再返回X变量之后，X变量加1 实例 1234567891011awk 'BEGIN{var=20;var1=\"hello\";print var,var1}' awk 'BEGIN{num1=20;num2+=num1;print num2,num2}'awk 'BEGIN{num1=20;num2+=num1;print num2+num2}'awk 'BEGIN{num1=20;num2=30;printf \"%0.2f\\n\",num1/num2}'awk 'BEGIN{x=2;y=x++;print x,y}'awk 'BEGIN{x=2;y=x--;print x,y}' 1234567# 计算文件中空白行数量awk '/^$/{sumx=0;sum++}END{print sum}' /etc/services # 计算课程的平均分awk '{total=S2+$3+$5+$5;AVG=total/4;printf \"%-8s,%-5d%-5d%-5d%-8d%0.2f\\n\",$1,$2,$3,$4.$5,AVG}' stu.txtawk 'BEGIN{printf \"%-8s%-8s%-8s%-8s%-8s%s\\n\",\"姓名\",\"语文\",\"数学\",\"英语\",\"物理\",\"平均分\"}{total=$2+$3+$4+$5;AVG=total/4;printf \"%-8s%-8d%-8d%-8d%-8d%0.2f\\n\",$1,$2,$3,$4.$5,AVG}' stu.txt awk 动作中的条件及循环语句 条件语句 123456if(条件表达式) 动作1else if(条件表达式) 动作2else 动作3 实例 12345678910# 以：为分隔符只打印第3个字段的数值在50-100范围内的行信息awk 'BEFIN{FS=\":\"}{if($3&gt;50 &amp;&amp; $3&lt;100&gt;) print $0}' /etc/passwdawk 'BEFIN{FS=\":\"}{if($3&gt;50 || $3&lt;100&gt;) print $0}' /etc/passwd# 小于50的UIDawk 'BEGIN{FS=\":\"}{if($3&lt;50) printf \"%-10s%-5d\\n\",\"小于50的UID:\",$3}' /etc/passwd awk 'BEGIN{FS=\":\"}{if($3&lt;50) printf \"%-10s%-10s%-5d\\n\",\"小于50的UID:\",$1,$3}' /etc/passwdawk 'BEGIN{FS=\":\"}{if($3&lt;50) printf \"%-10s%-10s%-5d\\n\",\"小于50的UID:\",$1,$3}' /etc/passwd vim scripts.awk 1234567891011121314151617BEGIN{ FS=\":\"}{ f($3&lt;50) { printf \"%-30s%-20s%-5d\\n\",\"小于50的UID\",$1,$3 } else if($3&gt;50 &amp;&amp; $3&lt;100) { printf \"%-30s%-20s%-5d\\n\",\"大于50且小于100的UID\",$1,$3 } else { printf \"%-30s%-20s%-5d\\n\",\"大于100的UID\",$1,$3 }} 使用 1awk -f scripts.awk /etc/passed 循环语句 do while 循环 1234do while do 动作 while(条件表达式) for 循环 12for (初始化计数器;测试计数器;计数器变更) 动作 实例 1+2+…100的和 while 1234567BEGIN{ while(i&lt;=100) { sum+=1 } print sum} awk -f while.wak for 1234567BEGIN{ for(i0;i&lt;=100;i++) { sum+=1 } print sum} awk -f for.awk do while 12345678BEGIN{ do { sum+=1 i++ }while(i&lt;=100) print sum} awk -f do_while.awk 计算每个同学平均分，仅显示大于90 student.awk1234567891011BEGIN{ printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Chinese\",\"English\",\"Math\",\"Physical\",\"Average\"}{ total=$2+$3+$4+$5 avg=total/4 if(avg&gt;90) { printf \"%-10s%-10d%-10d%-10d%-10d%-0.2f\\n\",$1,$2,$3,$4,$5,avg }} 计算平均分大于90的各科总分 student.awk123456789101112131415161718BEGIN{ printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Chinese\",\"English\",\"Math\",\"Physical\",\"Average\"}{ total=$2+$3+$4+$5 avg=total/4 if(avg&gt;90) { printf \"%-10s%-10d%-10d%-10d%-10d%-0.2f\\n\",$1,$2,$3,$4,$5,avg score_chinese+=$2 score_english+=$3 score_math+=$4 score_physical+=$5 }}END{ printf \"%-10s%-10d%-10d%-10d%-10d\\n\",\"\",score_chinese,score_english,score_math,score_physical} awk 中的字符串函数字符串函数对照表 例子 以:为分隔符，返回文件中每行中的字段长度 1.awk12345678910111213141516# NF 字段个数BEGIN{ FS=\":\"}{ i=1 while(i&lt;=NF) { if(i==NF) printf \"%d\",length($i) else printf \"%d:\",length($i) i++ } print \"\"} 搜索字符串”I have a dream”中出现”ea”子串的位置 12345# 方法1awk 'BEGIN{str=\"I have a dream\";location=index(str,\"ea\");print location}'#方法2awk 'BEGIN{str=\"I have a dream\";location=match(str,\"ea\");print location}' 将字符串”Hadoop is a bigdata Framework”全部转为小写 1awk 'BEGIN{str=\"Hadoop is a bigdata Framework\";print tolower(str)}' 上一题转为大写 1awk 'BEGIN{str=\"Hadoop is a bigdata Framework\";print toupper(str)}' 将字符串”Hadoop Kafka Spark Storm”按空格为分隔符，分割每一部分保存到数组arr中 1234awk 'BEGIN{str=\"Hadoop Kafka Spark Storm\";split(str,arr,\" \");print arr[0]}'# 遍历(awk 下标从1开始)awk 'BEGIN{str=\"Hadoop Kafka Spark Storm\";split(str,arr,\" \");for(a in arr) print arr[a]}' 搜索字符串”Tranction 2345 start:select * from master”第一个数字出现的位置 1awk 'BEGIN{str=\"Tranction 2345 start:select * from master\";location=match(str,/[0-9]/);print location}' 正则表达式要用 // 引起来 截图字符串”transaction start”的子串，条件从第4个字符开始，截取5为 1awk 'BEGIN{str=\"transaction start\";print substr(str,4,5)}' 替换”Tranction 243 start，Event ID：9002”中第一个匹配到的数字为$符号 1234awk 'BEGIN{str=\"Tranction 243 start，Event ID：9002\";count=sub(/[0-9]+/,\"$\",str);print count,str}' # gsu所有awk 'BEGIN{str=\"Tranction 243 start，Event ID：9002\";count=gsub(/[0-9]+/,\"$\",str);print count,str}' awk中的常用选项 选项 解释 -v 参数传递 -f 指定脚本文件 -F 指定分隔符 -V 查看awk的版本号 实例 -v 把外部变量引入 终端中123num1=20var=\"Hello World\"awk -v num2=\"$num1\" -v var1=\"$var\" 'BEGIN{print num2,var1}' -f 引入文件 1awk -f student.awk /etc/passws -F 1234awk -F \":\" '{print $7}' /etc/passwdawk -F : '{print $7}' /etc/passwd# 等价于awk 'BEGIN{FS=\":\"}{print $7}' /etc/passwd Shell 数组的用法 array=(“Mike”,”Bell”,”Hellen”) 下面的 井 为 # 解释 代码 打印元素 echo ${井array[2]} 打印元素个数 echo ${井array[@]} / echo ${井array[*]} 打印元素长度 echo ${井array[3]} 给元素赋值 array[3]=”LI” 删除元素 unset array[2];unset array 分片访问 echo ${井array[@]:1:3} 元素内容替换 ${array[@]/e/E} #只替换第一个e;${array[@]//e/E}替换全部e 数组遍历 1234for a in arraydo echo $adone awk 数组用法 awk中使用数组时，不仅可以使用数字作为数组下标，也可以使用字符串作为数组下标 统计主机上所有TCP连接状态，按照每个TCP状态分类 1netstat -an | grep tcp | awk '{arrary[$6]++}END{for(a in arrary) print a,arrary[a]}' 计算横向数总和，计算纵向数据总和 数据123456Allen 80 90 96 98Mike 93 98 92 91Zhang 78 76 87 92Jerry 86 89 68 92Han 85 95 75 90Li 78 88 98 100 stu.awk1234567891011121314BEGIN{ printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Chinese\",\"Math\",\"English\",\"Physical\",\"Total\"}{ total=$2+$3+$4+$5 yuwen_sum+=$2 math_sum+=$3 english_sum+=$4 physical_sum+=$5 printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",$1,$2,$3,$4,$5,total}END{ printf \"%-10s%-10d%-10d%-10d%-10d\\n\",\"\",yuwen_sum,math_sum,english_sum,physical_sum} awk 处理数据例子生成随机数据 12345678910111213141516171819202122#!/bin/bashfunction create_random(){ min=$1 max=$(($2-$min+1)) num=$(date +%s%N) echo $(($num%$max+$min))}INDEX=1while truedo for user in Allen Mike Jerry Tracy Hanmeimei Lilei do COUNT=$RANDOM NUM1=`create_random 1 $COUNT` NUM2=`expr $COUNT - $NUM1` echo \"`date '+%y-%m-%d %H:%M:%S'` $INDEX Batches: user $user insert $COUNT records into databases:product table:datail,insert $NUM1 records successfully,failed $NUM2 records\" &gt;&gt; ./db.log.`date +%Y%m%d` INDEX=`expr $INSEX + 1` donedone 统计每个用户分别插入多少record tesst.awk12345678910BEGIN{ printf \"%-10s%-10s\\n\",\"User\",\"Total Records\"}{ USER[$6]+=$8}END{ for(u in USER) printf \"%-20s%-20d\\n\",u,USER[u]} 统计每个用户分别插入成功和失败各多少record 2.awk1234567891011BEGIN{ printf \"%-10s%-20s%-20s\\n\",\"User,\"Success_Records\",\"Filed_records\"}{ SUCCESS[$6]+=$14 FAILED[$6]+=$17}END{ for(u in SUCCESS) printf \"%-10s%-20d%-20d\\n\",u,SUCCESS[u],FAILED[u]} 将例子1,2结合，一起输出每个用户分别插入多少条数据，成功失败各多少条 3.awk123456789101112 BEGIN{ printf \"%-30s%-30s%-30s%-30s\\n\",\"Name\",\"total records\",\"success records\",\"failed records\"}{ TOTAL_RECORDS[$6]+=$8 SUCCESS[$6]+=$14 FAILED[$6]+=$17}END{ for(u in TOTAL_RECORDS) printf \"%-30s%-30d%-30d%-30d\\n\",u,TOTAL_RECORDS[u],SUCCESS[u],FAILED[u]} 在例子3的基础上，加上结尾，统计全部插入记录数，成功记录数，失败记录数 方法一 3.awk1234567891011121314151617181920BEGIN{ printf \"%-30s%-30s%-30s%-30s\\n\",\"Name\",\"total records\",\"success records\",\"failed records\"}{ TOTAL_RECORDS[$6]+=$8 SUCCESS[$6]+=$14 FAILED[$6]+=$17}END{ for(u in TOTAL_RECORDS) { # 在统计出的结果数组中进行累加 records_sum+=TOTAL_RECORDS[u] success_sum+=SUCCESS[u] failed_sum+=FAILED[u] printf \"%-30s%-30d%-30d%-30d\\n\",u,TOTAL_RECORDS[u],SUCCESS[u],FAILED[u] } printf \"%-30s%-30d%-30d%-30d\\n\",\"\",records_sum,success_sum,failed_sum} 方法二 123456789101112131415161718192021BEGIN{ printf \"%-30s%-30s%-30s%-30s\\n\",\"Name\",\"total records\",\"success records\",\"failed records\"}{ RECORDS[$6]+=$8 SUCCESS[$6]+=$14 FAILED[$6]+=$17 # 在原始数据中进行汇总计算 records_sum+=$8 success_sum+=$14 failed_sum+=$17 }END{ for(u in RECORDS) printf \"%-30s%-30d%-30d%-30d\\n\",u,RECORDS[u],SUCCESS[u],FAILED[u] printf \"%-30s%-30d%-30d%-30d\\n\",\"total\",records_sum,success_sum,failed_sum} 查找丢失数据的现象，也就是成功+失败的记录数不等于一共插入的记录数，找出这些数据并显示行号和对应行的日志信息 1awk '{if($8!=$14+$17) print NR,$0}' db.log.20190722","link":"/posts/Shell.html"},{"title":"斐讯 N1 盒子降级刷机","text":"斐讯 N1 盒子降级刷机 降级 打开 ADB,点击官方固件的 版本号 4 次 重启至 Bootloader 先下载 ADB 连接设备并进入 fastboot123cd adbadb connect ip:5555adb shell reboot fastboot 刷入降级 双公头 USB 数据线与电脑连接，务必连接至靠近 HDMI 接口的那个 USB 接口12345fastboot devices #查看是否识别到设备fastboot flash boot boot.imgfastboot flash bootloader bootloader.imgfastboot flash recovery recovery.imgfastboot reboot 刷入 w大固件 先安装 Usb Burning Tool 打开设备管理器 ==&gt; 操作 ==&gt;添加过时硬件 ==&gt; 下一步 ==&gt; 选择 安装我手动从列表选择的硬件 ==&gt; 下一步 ==&gt; 选择 libusb-win32 Usb Devices ==&gt; 下一步 ==&gt; 选择 WorldCup Device ==&gt; 下一步 ==&gt; 下一步 打开 Usb Burining Tool,去除勾选右边烧录配置的 擦除flash 和 擦除bootloader w大固件","link":"/posts/N1Box.html"},{"title":"Grub 双系统选项、美化","text":"添加 Win10 菜单到 Grub 安装 os-prober1sudo pacman -S os-prober 扫面并添加到菜单1sudo grub-mkconfig -o /boot/grub/grub.cfg 美化下载主题 Gnome-Look 配置有的主题有安装脚本，运行即可 12sudo cp -r 主题包名 /boot/grub/themes/ sudo vim /etc/grub.d/00_header 上一步添加如下内容12GRUB_THEME=\"/boot/grub/themes/主题包名/theme.txt\"GRUB_GFXMODE=\"1920x1080x32\" 更新配置1sudo grub-mkconfig -o /boot/grub/grub.cfg 效果","link":"/posts/Grub.html"},{"title":"Git 更换设备后怎么做","text":"Git 更换设备后怎么做 旧仓库1234567891011git init 仓库名字# 建立远程连接git remote add origin https://github.com/user/repo.git #获取远程更新git fetch origin # 把更新的内容合并到本地分支git merge origin/master # 加入差异的文件,就是本地修改的文件git add . git commit -m \"Commit message\" git push origin master 新仓库12345git init()git remote add origin https://github.com/user/repo.gitgit add .git commit -m \"Commit message\"push origin master 建议 拉取时推荐 12git fetch origin mastergit merge origin/master 不推荐 1git pull","link":"/posts/Git-Change.html"},{"title":"ArchLinux Docker","text":"ArchLinux 安装 Docker 安装1sudo pacman -S docker start server 1systemctl restart docker 镜像123docker pull ubuntu:18.04docker pull centos # latestdicker pull centos:6 运行1sudo docker run -i -t centos /bin/bash -it, -i：交互式操作， -t 终端","link":"/posts/Docker.html"},{"title":"Vim Summary","text":"Vim 重新学习笔记 三个模式Insert 编辑模式12a i o # 进入编辑模式ESc # 进入 normal 模式 i (insert) a (append) o (oppen a line below) Command 模式12345:wq # 保存退出:vs # vertical split 横向分频:sp # 纵向分频:% s/foo/bar/g # 全局替换:h option-list # 查找所有设置选项 Visual (可视)模式123v # 进入 visual 模式V # 选择行ctrl v # 进行快选择 如何快速纠错a/i/o 进入插入模式 123ctrl h # 删除上一个字符ctrl w # 删除上一个单词ctrl u # 删除当前行 快速切换 Insert 和 Normal 12ctrl c / ctrl [ # 代替 Escgi # 快速跳转到你最后一次编辑的地方并进入插入模式 使用 hjkl 移动 1234h # 左j # 下k # 上l # 右 在单词之间飞舞123w/W # 移到下一 word/WORD 开头e/E # 下一个 word/WORD 尾b/B # 回到上一个word/WORD 开头 word 指以非空白符分割的单词 WORD 以空白符分割的单词 行间搜索移动 123f{char} # 移到 char 字符上t # 移到 char 前一个字符F # 反过来搜索前面的字符 ; 该行下一个 , 该行上一个 水平移动 12340 # 移到行首第一个字符^ # 第一个非空白字符$ # 移到行尾g_ # 移到行尾非空白字符 垂直移到 12() # 在句子间移动{} # 在段落间移到 插件 easy-motion 页面移动 1234567gg、G # 文件开头/结尾ctrl o # 快速返回H/M/L # 跳到屏幕开头(Head)中间(Middle)结尾(Lower)ctrl u # 上翻页ctrl f # 下翻页zz # 把屏幕置为中间 增删查改增 12a/i/oA/I/O 快速删除 normal 模式下123x # 快速删一个字符d # 删除daw # 删除一个单词 d x 可以搭配数字执行多次 快速修改 1r(replace) c(change) s(substitute) # 常用 normal 下 r 可以替换一个字符，s 替换并进入插入模式 使用 c 配合文本对象可以快速进行修改 查询 12/ # 前向搜索? # 反向搜索 n/N 跳转上一个或者上一个匹配 或者 # 进行当前单词的前向和后向匹配 替换命令substitute 1:[range]s[ubsitite]/{pattern}/{string}/[flags] range 范围(:10,20),10-20行,% 全部 pattern 要替换的模式 string 是替换后的文本 替换标志位Flags 常用标志 123g(global) # 全局c(confirm) # 表示确认，可以确认或拒绝修改n(number) # 报告匹配到的次数而不替换，可以用来匹配次数 :1,6 s/self// 查询1-6行有几个 self :% s/&lt;quack&gt;/jiao/g 替换所有 quack 为 jiao Buffer Windows Tab文件操作相关 Buffer 是打开的一个文件的内存缓冲区 窗口是 Buffer 可视化的分割区域 Tab 可以组织窗口为一个工作区 在 Buffer 之间切换 使用 :ls 列举当前缓冲区，后 :b n跳转到第 n 个 :bpre :bnext :bfirst :blast 或者 :b buffer_name 加上 tab 补全来跳转 Windows 窗口 s 水平分割 v 垂直分割 或者 :sp :vs 宏(macro)可以看做一系列命令合集 How q 录制、技术录制 q{register} 选择要保存的寄存器，把录制的命令保存其中 @{register} 回放寄存器中的一系列命令123456q I\" A\"VG # 全选: I\":t # 重复上一命令:A\" 常见的补全 命令 补全类型 ctrl n 普通关键字 ctrl x/n 当前缓冲区关键字 ctrl x/i 包含文件关键字 ctrl x/J 标签文件关键字 ctrl x/k 字典查找 ctrl x/l 整行补全 ctrl x/f 文件名补全 ctrl x/o 全能(Omni)补全 最常用 ctrl n 和 ctrl p 补全单词 ctrl x 和 ctrl f 补全文件名 ctrl x 和 ctrl o 补全代码 更换配色123:colorscheme # 显示当前主题配色:colorscheme &lt;ctrl+d&gt; # 显示所有配色:colorscheme 配色名 # 修改配色 映射基本映射 normal 模式下(leadser键即 , ) map 可以实现映射，:map -x 然后按下 - 就会删除一个字符 :map &lt;space&gt; viw 按下空格键时选中整个单词 `:map dd 删除 消除映射 unmap - imap &lt;c-d&gt; &lt;Esc&gt;ddi insert 模式映射 ctrl+d 删除一行 模式映射映射 用 namap/vmap/imap 定义映射只在normal/visual/insert分别有效 :vmap \\U 把 visusal 模式下选中的文本大小(u/U转换大小写) 递归与非递归映射*map 系列有递归风险,如果安装了一个插件，插件映射了同一个按键的不同行为，有冲突就会有一个失效。 非递归映射 *map 对应的 nnoremap/vnoremao/inoremap 任何时候都建议使用非递归映射 示例 12345678910111213141516171819202122let mapleader = \",\"inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt; # 插入模式保存inoremap jj &lt;Esc&gt; # 使用jj直接进入 normal# 使用 leader+w 直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt;noremap &lt;leader&gt;w :w&lt;cr&gt;# 切换 Buffernnoremap &lt;slient&gt; [b :bprevious&lt;CR&gt;nnoremap &lt;slient&gt; [n :bnext&lt;CR&gt;# 分屏noremap &lt;C-h&gt; &lt;C-w&gt;hnoremap &lt;C-j&gt; &lt;C-w&gt;jnoremap &lt;C-k&gt; &lt;C-w&gt;knoremap &lt;C-l&gt; &lt;C-w&gt;l# json 格式化comr FormatJSON %!python3 -m json.tool# sudo to writecnoremap w!! w !sudo tee % &gt;/dev/null 插件常见的插件管理器vim-plug,Vundle,Pathogen,Deim vim-plug 安装 vim-plug 12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 安装插件.vimrc1234call plug#begin('~/.vim/plugged')Plug 'mhinz/vim-startify' # 插件\" Initialize plugin systemcall plug#end() source ~/.vimrc 并 :PlugInstall vim 美观插件 外观 修改启动界面: vim-startify 状态栏美化：vim-airline 增加但代码缩进线条：indentline 配色方案 vim-hybird solarized grubbox 插件推荐网站vimawesome 文件目录和搜索插件 文件目录 nerdtree 1234&quot; 查找文件所在位置nnoremap &lt;leader&gt;v :NERDTreeFind&lt;cr&gt;&quot; 切换设置nnoremap &lt;leader&gt;g :NERDTreeToggle&lt;cr&gt; 模糊搜索器 ctrip.vim 12let g:ctrlp_map = &apos;&lt;c-p&gt;&apos;let g:ctrlp_cmd = &apos;CtrlP&apos; Crtl + P 后输入要搜索的内容 模糊搜索fzf.vim 12Files . # 搜索当前目录:Ag content # 搜索字符串 快速跳转位置插件 vim-easymotion 映射 1unmap ss &lt;Plus&gt;(easymotion-s2) 修改成对内容 vim-surround 123ds # delete a surroundingcs # change a surroundingys # you add a surrounding 替换 far.vim12vim duck.go gua.py:Far [替换] [替换成的] **/*.py 代码浏览代码targbar vimrc1nonormal &lt;leader&gt;t :TagbarToggle&lt;CR&gt; vim-interestingwords 可以高亮单词 补全补全插件 deoplete.nvim 多语言，模糊搜索 coc.vim 多语言插件支持 快速注释vim-commentary gc 注释或取消注释 格式化与静态检查格式化 Neoformat 需要安装对应语言的格式化库，python的autopep8,js的prettier等 静态检查Lint neomake、ale 需要安装对应语言的 lint 库如 eslint/pylint/golint Python 相关Python-mode 具有基本的补全，跳转，重构，格式化功能 .vimer123456789\" Python-modelet g:pymode_python = 'python3'let g:pymode_trim_whitespaces = 1let g:pymode_doc = 1let g:pymode_doc_bind = 'k'let g:pymode_rope_goto_definition_bind = \"&lt;C-J&gt;\"let g:pymode_lint = `let g:pymode_lint_checkers = ['pyflakers','pep8','mccabe','plylint']let g:pymode_options_max_line_length = 120 GitFugitive 命令 :Gedit,:Gdiff,:Gblame,:Gcommit 等 vim-gitgutter 显示文件变动 gv.vim :GV 查看提交记录 学习视频 玩转Vim 从放弃到爱不释手","link":"/posts/Vim-Mooc.html"},{"title":"Cat 追加与覆盖","text":"Cat 追加与覆盖 追加 cat &lt;&gt; 1234#!/bin/bashcat &lt;&lt; EOF &gt;&gt; cat.txtvitan.meEOF cat &gt;&gt; 1234#!/bin/bashcat &gt;&gt; cat.txt &lt;&lt; EOFvitan.meEOF 覆盖 cat &lt;&gt; 1234#!/bin/bashcat &lt;&lt; EOF &gt; cat.txtvitan.meEOF cat &gt;&gt; 1234#!/bin/bashcat &gt; cat.txt &lt;&lt; EOFvitan.meEOF 使用变量 Warnning追加和覆盖若要使用变量必须加 \\ 如 \\$var","link":"/posts/CatEOF.html"},{"title":"Terminal Socks5 Proxy","text":"Some Socks5 Proxy setting Git1234git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080git config --global --unset http.proxygit config --global --unset https.proxy Curl.curlrc1echo 'socks5 = \"127.0.0.1:1080\"' &gt;&gt; ~/.curlrc ALL_PROXY 1export ALL_PROXY=socks5://127.0.0.1:1080 WgetEVN Config12xport http_proxy=http://127.0.0.1:1080xport http_proxy=httpS://127.0.0.1:1080 .wgetrc~/.wgetrc123456https_proxy = http://127.0.0.1:8087/http_proxy = http://127.0.0.1:8087/ftp_proxy = http://127.0.0.1:8087/# If you do not want to use proxy at all, set this to off.use_proxy = on -e 1wget -c -r -np -k -L -p -e \"http_proxy=http://127.0.0.1:1080\" url Pip1sudo pacman -S proxychains vim /etc/proxychains.conf /etc/proxychains.conf12[ProxyList]socks5 127.0.0.1 1080 usage 1proxychains pip install &lt;package_name&gt; 参考 为wget使用代理","link":"/posts/CurlSocks5.html"},{"title":"CentOS DNS","text":"CentOS DNS BindInstall 1yum install bind bind bind-chroot -y Start Service 123service named startsystemctl name start # CentOs 7systemctl enable named-chroot Bind 配置named.conf1vim /var/named/chroot/etc/named.conf /var/named/chroot/etc/named.conf1234567891011121314151617181920212223242526272829303132333435options { listen-on port 53 { any; };# 监听任何ip对53端口的请求 listen-on-v6 port 53 { ::1; }; directory \"/var/named\"; dump-file \"/var/named/data/cache_dump.db\"; statistics-file \"/var/named/data/named_stats.txt\"; memstatistics-file \"/var/named/data/named_mem_stats.txt\"; allow-query { any; }; # 接收任何来源查询dns记录 recursion yes; dnssec-enable yes; dnssec-validation yes; /* Path to ISC DLV key */ bindkeys-file \"/etc/named.iscdlv.key\"; managed-keys-directory \"/var/named/dynamic\";};//以下用于限定 bind 服务器的日志参数logging { channel default_debug { file \"data/named.run\"; severity dynamic; };};//用于指定根服务器的配置信息，一般不能改动zone \".\" IN { type hint; file \"named.ca\";};include \"/etc/named.zones\"; //指定住配置文件，按实际改动include \"/etc/named.root.key\"; 配置主配置文件123cd /var/named/chroot/etc/cp -p named.rfc1912.zones named.zonesvim named.zones /var/named/chroot/etc/named.zones1234567891011zone \"vitan.me\" IN { type master; file \"vitan.me.zone\"; allow-update { none; };};zone \"197.28.149.in-addr.arpa\" IN { type master; file \"149.28.197.zone\"; allow-update { none; };}; 区域配置文件 正向解析域 123cd /var/named/chroot/var/namedcp -p named.localhost vitan.me.zonevim vitan.me.zone /var/named/chroot/var/named/vitan.me.zone12345678910111213$TTL 1D@ IN SOA www.vitan.me. mail.vitan.me. ( 2007101100 ; serial 1D ; refresh # 主从刷新时间 1H ; retry # 主从通讯失败后重试间隔 1W ; expire # 缓存过期时间 3H ) ; minimum # 没有TTL定义时的最小生存周期@ IN NS www.vitan.me.@ IN MX 10 www.vitan.me.www IN A 149.28.197.1mail IN A 149.28.197.1www1 IN CNAME www.vitan.me. 反向向解析域 123cd /var/named/chroot/var/namedcp -p named.loopback 149.28.197.zonevim /var/named/chroot/var/named/149.28.197zone /var/named/chroot/var/named/149.28.197.zone12345678910111213$TTL 1D@ IN SOA www.vitan.me. mail.vitan.me. ( 2007101100 ; serial 1D ; refresh # 主从刷新时间 1H ; retry # 主从通讯失败后重试间隔 1W ; expire # 缓存过期时间 3H ) ; minimum # 没有TTL定义时的最小生存周期@ IN NS www.vitan.me.@ IN MX 10 www.vitan.me.www IN A 149.28.197.1mail IN A 149.28.197.1www1 IN CNAME www.vitan.me. 重启 DNS 服务12service named restart/reloadsystemctl named restart # CentOs 7 客户端配置与测试 以便能使用 nslookup dig 和 host 1yum install bind-utils -y /etc/resolv.conf1vim /etc/resolv.conf /etc/resolv.conf12search vitan.menameserver 149.28.197.1 Test12dig www.vitan.menslookup www.vitan.me","link":"/posts/Linux-DNS.html"},{"title":"CentOS  DHCP","text":"CentOS DHCP 安装12yum updateyum install dhcp -y 修改 ip1vim /etc/sysconfig/network-scripts/ifcfg-eth2 123456789DEVICE=\"eth2\"BOOTPROTO=staticHWADDR=\"00:0D:29:G1:2D:3B\"NM_CONTROLLED=\"yes\"ONBOOT=\"yes\"BOOTPROTO=\"none\"IPADDR=192.168.22.11NETMASK=255.255.255.0GATEWAY=192.168.22.1 重启网络 12service network restartsystemctl network restart 服务端配置 路径 dhcpd.conf1/etc/dhcp/dhcpd.conf 复制 dhcpd.conf.samplle 1cp -p /usr/share/doc/dhcp-6.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf 配置文件设置 /etc/dhcp/dhcpd.conf12345678910111213141516171819ddns-update-style interim;// dhcp 服务器和dns 服务器的动态信息更新模式 ignore client-updates; default-lease-time 259200; #预设租约为 3 天max-lease-time 518400; # 最大租约为 6 天subnet 192.168.22.0 netmask 255.255.255.0 { option routers 192.168.22.254;#预设路由 option subnet-mask 255.255.255.0; option domain-search \"vitan.me\"; # 给予一个领域名 option domain-name-servers 192.168.22.1; option time-offset -18000; #时区 range 192.168.1.10 192.168.1.100; # 关于固定的 IP host win7 { hardware ethernet 08:00:27:11:EB:C2; #客户端网卡 MAC fixed-address 192.168.100.30; #给予固定的 IP }} 启动 1234service dhcpd startsystemctl start dhcp #CentOs 7dhcpd # 检测错误chkconfig --levels 235 dhcpd on # 开机启动 客户端配置ifcfg.eth21vim /etc/sysconfig/network-scripts/ifcfg-eth2 123456789DEVICE=\"eth2\"BOOTPROTO=dhcpHWADDR=\"00:0D:29:G1:2D:3B\"NM_CONTROLLED=\"yes\"ONBOOT=\"yes\"BOOTPROTO=\"none\"IPADDR=192.168.22.100NETMASK=255.255.255.0GATEWAY=192.168.22.1 重启网络 1234ifdown eth2ifup eth2service network restart 查看租约情况1cat /var/pib/dhcpd/dhcpd.leases","link":"/posts/Linux-DHCP.html"},{"title":"Vim 增删查改、翻页和寄存器","text":"Vim 增删查改、复制捏贴、翻页和寄存器。 Vim 里剪切 (cut) 复制(copy) 粘贴(psate) 分别对应 delete/yank/put 复制粘贴Normal 模式下 yp dp vp 1234y # 复制(yank)p # 粘贴(put)d # 剪贴vp # v(visual) 命令选中要复制的地方，后 p 配合文本对象 123456yyiw # 复制一个单词yy # 复制一行dd # 删除一行o # 下一行V # 快选两行v # 选择文本 Insert 模式下 保留复制内容的缩进 vimrc 设置了自动缩进 :set autoindent 会使复制的代码缩进错乱 12:set paste :set nopaste # 取消 增删查改翻页移动增删查改增（大写相反） 123a# append 当前字母后面插入i # insert 当前字母前面插入o # open a line 向下打开新一行 删 123456d # 删除dw # 删除单词diw # delete inner word 删除不包含空格的一个单词daw # delete around worddd # 删除一行x # 删除一个字符 改 1234cciw # Change inner wordct # 括号里面的内容（修改到右边括号）ci” # 删除双引号里的内容 查 1234fs # 查找当前行第一个出现的 s ，使用 ； 查找下一个Fs # 往回查/word # 查找所以单词 word?word #往回查 移动翻页移动 12345678910hjkl # 上下左右w # word 移动单词b #back word 往回移动单词:18 # 移动到18行18G # 移动到14行0 # 回到开头$ # 行尾gg # 文件开头G # 文件结尾Ctrl o # 返回刚刚的位置 翻页 12ctrl + f # forwardctrl + u # upward Vim 寄存器使用 d 删除或者 y 复制的内容都放在了 “无名寄存器” 调换两字符 12x # 删除一个字符放到无名寄存器p # 粘贴 寄存器(register)&quot;{register} 可以指定寄存器，不指定默认使用无名寄存器，&quot;&quot; 表示 无名寄存器12345\"ayiw # 复制一个单词到寄存器 a \"bdd # 删除当前行到寄存器 b\"a p # 粘贴寄存器 a 的内容\"b p # 粘贴寄存器 b 的内容 其他寄存器 ”a-z 有名寄存器 “0 复制专业寄存器（y复制的文本会拷到复制及长期0） “+ 系统剪切板 （可以再复制前加上 “+ 复制到系统剪切板） :set cliboard=unnamed 可直接复制系统剪切板内容 ”% 当前文件名 “. 上次插入的文本 查看寄存器内容12:reg a # 查看 a 寄存器内容:reg b # 查看 b 寄存器内容 查看是否支持 clipboard1:echo has('clipboard') 1 为支持","link":"/posts/vimcopyppaste.html"},{"title":"Git Clone Error","text":"Failed to receive SOCKS4 connect request ack. 解决方法12git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos; git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos; error: RPC failed; curl 18 transfer closed with outstanding read data remaining 解决方法 –depth 1 123456789101112# 关闭压缩git config --global core.compression 0# 部分克隆git clone --depth 1 http://github.com/large-repository cd large-repository# 进入新目录并检索其余的克隆git fetch --unshallow# 或者git fetch --depth=2147483647# 做一个定期拉git pull --all 切换使用 ssh(git clone username@mydomain.com:my_group/my_repository.git) 增加缓冲区大小 1git config --global http.postBuffer 524288000 参考 stackoverflow","link":"/posts/GitSOCKS4.html"},{"title":"Hexo Post 模板","text":"在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件. 1hexo new photo \"My Gallery\" 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，可以在模版中使用的变量： layout 文章的布局，可以取值post（默认值）或page，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 title 文章的标题 date 创建日期，文件的创建日期 updated 修改日期，文件的修改日期 comments 是否开启评论，默认值true tags 标签 categories 分类 permalink url中的名字，默认值文件名 模板1234567891011title: {{ title }}date: {{ date }}tags:- Linuxcategories:- notesauthor:- Vitanenable_unread_badge: truethumbnail:- /images/Hexo.svg","link":"/posts/Hexo-Post.html"},{"title":"Spyder","text":"spyder3 No module named ‘PyQt5.QtWebKitWidgets’ 解决 Spyder3 无法启动 1sudo pip install pyqt5==5.11.2 相关 issue 6990","link":"/posts/spyder.html"},{"title":"Linus Wine","text":"Linux Wine ArchLinux 1sudo pacman -S wine wine_gecko wine-mono winetricks 字体乱码 1touch zh.reg 内容 1234567891011121314REGEDIT4 [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] \"Lucida Sans Unicode\"=\"wqy-microhei.ttc\" \"Microsoft Sans Serif\"=\"wqy-microhei.ttc\" \"Microsoft YaHei\"=\"SourceHanSansCN-Medium.otf\" \"MS Sans Serif\"=\"wqy-microhei.ttc\" \"Tahoma\"=\"wqy-microhei.ttc\" \"Tahoma Bold\"=\"wqy-microhei.ttc\" \"SimSun\"=\"wqy-microhei.ttc\" \"Arial\"=\"wqy-microhei.ttc\" \"Arial Black\"=\"wqy-microhei.ttc\" \"宋体\"=\"SourceHanSansCN-Medium.otf\" \"新细宋体\"=\"SourceHanSansCN-Medium.otf\" Run 1egedit zh.reg","link":"/posts/wine.html"},{"title":"Git Pull 覆盖本地文件","text":"放弃对于本地的项目中修改，Git pull强制覆盖 123git fetch --allgit reset --hard origin/mastergit pull","link":"/posts/GitPull.html"},{"title":"Termux ADB","text":"Termux ADB 下载 arm 版 ADB Download 提取码: 9ej2 Installation 解压后 mv arm/adb $PREFIX/bin 添加权限 chmod +x $PREFIX/bin/adb Usage 远程连接设备（已开启USB网络调试） 1adb connect ip ADBCommand","link":"/posts/Termux-ADB.html"},{"title":"jQuery Selector","text":"jQuery 选择器 #元素选择器 1234567891011121314// id 选择器$(\"#myELement\")// 元素选择器$(\"div\")$(\"span\")$(\"button\")...// .class 选择$(\".myClass\")// 通配符选择(选取所有元素)$(\"*\") 层叠选择器123456789101112//所有form元素中的input元素 $(\"form input\") //id值为main的所有的子元素$(\"#main &gt; *\") /*所有的label元素的下一个input元素节点，返回的是label标签后面直接跟一个input标签的所有input标签元素 */ $(\"label + input\") //同胞选择器，返回id为prev的标签元素的所有的属于同一个父元素的div标签$(\"#prev ~ div\") 基本过滤选择器12345678910111213141516171819202122232425//所有tr元素的第一个$(\"tr:first\")//所有tr元素的最后一个 s$(\"tr:last\") //过滤掉：checked的选择器的所有的input元素 $(\"input:not(:checked) + span\") //所有的tr元素的第1，3，5... ...个元素 (\"tr:odd\") //所有的td元素中序号为2的那个td元素$(\"td:eq(2)\") //td元素中序号大于4的所有td元素 $(\"td:gt(4)\") td元素中序号小于4的所有的td元素 $(\"td:ll(4)\") //所有标题元素（h1 - h6）$(\":header\") $(\"div:animated\") 内容过滤选择器1234567891011//所有div中含有John文本的元素$(\"div:contains('John')\")//所有的为空（也不包括文本节点）的td元素的数组 $(\"td:empty\") //所有含有p标签的div元素 $(\"div:has(p)\") //所有的以td为父节点的元素数组 $(\"td:parent\") 可视化过滤选择器12345//所有的被hidden的div元素 $(\"div:hidden\") //所有的可视化的div元素 $(\"div:visible\") 属性过滤选择器1234567891011121314151617181920//含有id属性的div元素 $(\"div[id]\")//name属性等于'newsletter'的input元素 $(\"input[name='newsletter']\") //name属性不等于'newsletter'的input元素 $(\"input[name!='newsletter']\") //name属性以'news'开头的input元素 $(\"input[name^='news']\") // name属性以'news'结尾的input元素 $(\"input[name$='news']\") //name属性包含'news'的input元素 $(\"input[name*='man']\") //可以使用多个属性进行联合选择，得到所有的含有id属性并且属性以man结尾的元素 $(\"input[id][name$='man']\") 子元素过滤选择器12345678910$(\"ul li:nth-child(2)\"),$(\"ul li:nth-child(odd)\"),$(\"ul li:nth-child(3n + 1)\") //返回所有的div元素的第一个子节点的数组$(\"div span:first-child\") //返回所有的div元素的最后一个节点的数组 $(\"div span:last-child\") //返回所有的div中只有唯一一个子节点的所有子节点的数组 $(\"div button:only-child\") 表单元素选择器：1234567891011121314151617181920212223242526272829303132//所有的表单输入元素，包括input, textarea, select 和 button $(\":input\") //所有的text input元素 $(\":text\") //所有的password input元素 $(\":password\") //所有的radio input元素$(\":radio\") //所有的checkbox input元素$(\":checkbox\") //所有的submit input元素 $(\":submit\") // 所有的image input元素 $(\":image\") //所有的reset input元素 $(\":reset\") //所有的button input元素 $(\":button\") // 所有的file input元素 $(\":file\") // 所有类型为hidden的input元素或表单的隐藏域 $(\":hidden\") 表单元素过滤选择器1234567891011//所有的可操作的表单元素 $(\":enabled\") //所有的不可操作的表单元素 $(\":disabled\") //所有的被checked的表单元素$(\":checked\") //所有的select 的子元素中被selected的元素 $(\"select option:selected\") 12345678//选取一个 name 为”S_03_22″的input text框的上一个td的text值$(”input[@ name =S_03_22]“).parent().prev().text() //名字以”S_”开始，并且不是以”_R”结尾的$(”input[@ name ^=&apos;S_&apos;]“).not(”[@ name $=&apos;_R&apos;]“) //一个名为 radio_01的radio所选的值$(”input[@ name =radio_01][@checked]“).val(); 1234567891011//查找A元素下面的所有子节点，包括非直接子节点$(&quot;A B&quot;) //查找A元素下面的直接子节点$(&quot;A&gt;B&quot;) //查找A元素后面的兄弟节点，包括非直接子节点$(&quot;A+B&quot;) //查找A元素后面的兄弟节点，不包括非直接子节点$(&quot;A~B&quot;)","link":"/posts/jQuerySelector.html"},{"title":"Git Commit Emoji","text":"Git Commit Emoji Emoji emoji emoji 代码 commit 说明 :tada: (庆祝) :tada: 初次提交 :sparkles: (火花) :sparkles: 引入新功能 :bookmark: (书签) :bookmark: 发行/版本标签 :bug: (bug) :bug: 修复 bug :ambulance: (急救车) :ambulance: 重要补丁 :globe_with_meridians: (地球) :globe_with_meridians: 国际化与本地化 :lipstick: (口红) :lipstick: 更新 UI 和样式文件 :clapper: (场记板) :clapper: 更新演示/示例 :rotating_light: (警车灯) :rotating_light: 移除 linter 警告 :wrench: (扳手) :wrench: 修改配置文件 :heavy_plus_sign: (加号) :heavy_plus_sign: 增加一个依赖 :heavy_minus_sign: (减号) :heavy_minus_sign: 减少一个依赖 :arrow_up: (上升箭头) :arrow_up: 升级依赖 :arrow_down: (下降箭头) :arrow_down: 降级依赖 :zap: (闪电):racehorse: (赛马) :zap::racehorse: 提升性能 :chart_with_upwards_trend: (上升趋势图) :chart_with_upwards_trend: 添加分析或跟踪代码 :rocket: (火箭) :rocket: 部署功能 :white_check_mark: (白色复选框) :white_check_mark: 增加测试 :memo: (备忘录) :memo: 撰写文档 :hammer: (锤子) :hammer: 重大重构 :art: (调色板) :art: 改进代码结构/代码格式 :fire: (火焰) :fire: 移除代码或文件 :pencil2: (铅笔) :pencil2: 修复 typo :construction: (施工) :construction: 工作进行中 :construction_worker: (工人) :construction_worker: 添加 CI 构建系统 :green_heart: (绿心) :green_heart: 修复 CI 构建问题 :lock: (锁) :lock: 修复安全问题 :whale: (鲸鱼) :whale: Docker 相关工作 :apple: (苹果) :apple: 修复 macOS 下的问题 :penguin: (企鹅) :penguin: 修复 Linux 下的问题 :checkered_flag: (旗帜) :checked_flag: 修复 Windows 下的问题 Via Git-commit-emoji Emoji-Log配置.bash/.zshrc123456789101112131415161718192021222324252627282930#.# Better Git Logs.### Using EMOJI-LOG (https://github.com/ahmadawais/Emoji-Log).# Git Commit, Add all and Push — in one step.function gcap() { git add . &amp;&amp; git commit -m \"$*\" &amp;&amp; git push}# NEW.function gnew() { gcap \"📦 NEW: $@\"}# IMPROVE.function gimp() { gcap \"👌 IMPROVE: $@\"}# FIX.function gfix() { gcap \"🐛 FIX: $@\"}# RELEASE.function grlz() { gcap \"🚀 RELEASE: $@\"}# DOC.function gdoc() { gcap \"📖 DOC: $@\"}# TEST.function gtst() { gcap \"✅ TEST: $@\"} 别名到 ~/.gitconfig1234567891011121314# Git Commit, Add all and Push — in one step.cap = \"!f() { git add .; git commit -m \\\"$@\\\"; git push; }; f\"# NEW.new = \"!f() { git cap \\\"📦 NEW: $@\\\"; }; f\"# IMPROVE.imp = \"!f() { git cap \\\"👌 IMPROVE: $@\\\"; }; f\"# FIX.fix = \"!f() { git cap \\\"🐛 FIX: $@\\\"; }; f\"# RELEASE.rlz = \"!f() { git cap \\\"🚀 RELEASE: $@\\\"; }; f\"# DOC.doc = \"!f() { git cap \\\"📖 DOC: $@\\\"; }; f\"# TEST.tst = \"!f() { git cap \\\"✅ TEST: $@\\\"; }; f\" gitmoji-cliinstall1npm i -g gitmoji-cli usage12gitmoji --helpgitmoji -c Via OpenSource.com gitmoji-cli","link":"/posts/GitEmoji.html"},{"title":"ArchLinux NTFS","text":"解决 ArchLInux 无法挂载 NTFS 的U盘和硬盘 方法sudo pacman -Syu sudo pacman -S ntfs-3g","link":"/posts/ArchNtfs.html"},{"title":"Vue.Js","text":"Vue 安装与新建项目 Vue 安装1234567891011# 安裝 Vue CLI 到全局npm i vue-cli -g# 创建一个基于 webpack 模板的新项目vue init webpack &lt;Project&gt;# 进入项目,安装依赖npm install# 运行npm run dev 参考 Vue.js`","link":"/posts/Vue-Js.html"},{"title":"Hexo 同时部署到 Github Coding","text":"Hexo 同时部署到 Github Coding 添加 SSH 公钥 Github Coding添加同一个 SSH 公钥 Github Coding 都部署好相关的仓库 设置 _config.yml _config.yml123456deploy:type: gitrepository: github: ssh://git@github.com/ivitan/ivitan.github.io,master coding: git@git.coding.net:Vitan/vitan.coding.me.git,masterbranch: master 效果 Github Page Coding Page","link":"/posts/HexoGithubCoding.html"},{"title":"数据分析(是否出险)","text":"以下是相关分析步骤与过程 将Hw4文件导入 使用auto_ins作如下分析 1、首先对loss重新编码为1/0，有数值为1，命名为loss_flag 2、对loss_flag列进行描述分析（计数计频次） 3、分析是否出险和年龄、驾龄、性别、婚姻状态等变量之间的关系 导入数据Hw4文件导入 12345678910import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport matplotlibimport seaborn as snsimport osos.chdir('/home/vitan/Python/Python/HW4')# 将auto_ins.csv读取进来,命名为autoauto = pd.read_csv('auto_ins.csv',encoding='gbk') 数据处理 定义codeMy(x)函数，其作用是对auto里的loss重新编码为1/0，有数值为1，命名为loss_flag 12345def codeMy(x): if x &gt; 0: return 1 else: return 0 - 对auto里的loss重新编码为1/0，有数值为1，命名为loss_flag 1auto.loss_flag = auto.Loss.map(codeMy) - 应用匿名函数的方法对loss重新编码为1/0，有数值为1，命名为loss_flag1 1auto[\"loss_flag1\"]= auto.Loss.map(lambda x:1 if x &gt; 0 else 0)画图分析 对loss_flag列进行描述分析（计数计频次） 1auto.loss_flag.value_counts() 对loss_flag出险情况进行百分比统计 1auto.loss_flag.value_counts()/auto.loss_flag.count() 绘制是否出险柱形图 1auto.loss_flag.value_counts().plot(kind=\"bar\") 分析是否出险和年龄、驾龄、性别、婚姻状态等变量之间的关系 1234567891011#设置画布figfig = plt.figure()#将画布设计成1行2列结构，增加第一个子图层ax1ax1 = fig.add_subplot(1,2,1)#将画布设计成1行2列结构，增加第二个子图层ax2ax2 = fig.add_subplot(1,2,2)#是否出险和年龄关系：绘制箱形图（盒须图），分析出险和年龄的关系sns.boxplot(x=\"loss_flag\",y=\"Age\",data=auto,ax =ax1)#是否出险和驾龄：绘制箱形图（盒须图），分析出险和驾龄的关系sns.boxplot(x=\"loss_flag\",y=\"exp\",data=auto,ax =ax2) 是否出险和性别：绘制面积堆积柱形图，分析出险和性别的关系 12from stack2dim import *stack2dim(auto,\"Gender\",\"loss_flag\") 是否出险和婚姻状态：绘制面积堆积柱形图，分析出险和婚姻的关系 1stack2dim(auto,\"Marital\",\"loss_flag\")","link":"/posts/Spyder-1.html"},{"title":"常用算法","text":"Python 排序 冒泡排序12345def bubble_sort(li):for i in range(len(li)-1): # i表示第几趟 for j in range(len(li)-i-1): # j表示图中的箭头 if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j] 冒泡排序(优化) 123456789def bubble_sort_1(li):for i in range(len(li)-1): # i表示第几趟 exchange = False for j in range(len(li)-i-1): # j表示图中的箭头 if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j] exchange = True if not exchange: return 选择排序123456789def select(li):for i in range(len(li)): # 第i趟开始时 无序区：li[i:] # 找无序区最小值，保存最小值的位置 min_index = i for j in range(i + 1, len(li)): if li[j] &lt; li[min_index]: min_index = j li[min_index], li[i] = li[i], li[min_index] 插入排序123456789101112131415def insert_sort(li):for i in range(1, len(li)): # i是摸到的牌的下标 tmp = li[i] # tmp是摸到牌的值 # 方法一 j = i - 1 # j是手里最后一张牌的下标 li[j]是手里最后一张牌的值 while j &gt;= 0 and li[j] &gt; tmp: # 两个终止条件：j小于0表示tmp是最小的 顺序不要乱 li[j+1] = li[j] j -= 1 # 方法二 # for j in range(i-1, -1, -1): # if li[j] &gt; tmp: # li[j+1] = li[j] # else: # break li[j+1] = tmp #将摸到的牌 插入到 往前挪过之后的 j 的后一位 快速排序123456789101112131415161718def quick_sort(lists, left, right): # 快速排序 if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return lists 12345678910111213141516171819202122232425def part(li, left, right): # 列表,最左索引,最右索引 tmp = li[left] # 先找个临时变量把第一个元素存起来 while left &lt; right: # 当最左小于最右 while left &lt; right and li[right] &gt;= tmp: # 当最左&lt;最右 且 最右边的值大于等于临时变量 right -= 1 # 最右 往左 挪 1 个单位长度 li[left] = li[right] # 都不满足:把挪完之后的最右的值 赋值给 最左的值(即最右的值小于临时变量时,这个值挪到当前最左的值) while left &lt; right and li[left] &lt;= tmp: # 当最左&lt;最右 且 最左边的值小于等于临时变量 left += 1 # 最左 往右 挪 1 个单位长度 li[right] = li[left] # 都不满足:把挪完之后的最左的值 赋值给 最右的值(即最左的值大于临时变量时,这个值挪到当前最右的值) li[left] = tmp # 当前最左最右的值相等时,把这个值赋给临时变量 return left # 返回当前临时变量的索引def quick(li, left, right): if left &lt; right: # 如果左索引&lt;右索引 mid = part(li, left, right) # 调用part进行分区 返回一个索引赋给mid quick(li, left, mid - 1) # 递归调用quick 直到left=mid-1 quick(li, mid + 1, right) # 递归调用quick 直到mid+1=rightli = list(range(1000))import randomrandom.shuffle(li)print(li)quick(li, 0, len(li) - 1)print(li) 堆排序12345678910111213141516171819202122232425262728def sift(li, low, high): tmp = li[low] i = low j = 2 * i + 1 while j &lt;= high: # 退出条件2：当前i位置是叶子结点，j位置超过了high # j 指向更大的孩子 if j + 1 &lt;= high and li[j+1] &gt; li[j]: j = j + 1 # 如果右孩子存在并且更大，j指向右孩子 if tmp &lt; li[j]: li[i] = li[j] i = j j = 2 * i + 1 else: # 退出条件1：tmp的值大于两个孩子的值 break li[i] = tmp@cal_timedef heap_sort(li): # 1. 建堆 n = len(li) for i in range(n//2-1, -1, -1): # i 是建堆时要调整的子树的根的下标 sift(li, i, n-1) # 2.挨个出数 for i in range(n-1, -1, -1): #i表示当前的high值 也表示棋子的位置 li[i], li[0] = li[0], li[i] # 现在堆的范围 0~i-1 sift(li, 0, i-1) 归并排序12345678910111213141516171819202122232425262728293031323334def merge(li, low, mid, high): i = low j = mid + 1 ltmp = [] while i &lt;= mid and j &lt;= high: if li[i] &lt; li[j]: ltmp.append(li[i]) i += 1 else: ltmp.append(li[j]) j += 1 while i &lt;= mid: ltmp.append(li[i]) i += 1 while j &lt;= high: ltmp.append(li[j]) j += 1 # for k in range(low, high+1): # li[k] = ltmp[k-low] li[low:high+1] = ltmpdef merge_sort(li, low, high): if low &lt; high: mid = (low + high) // 2 merge_sort(li, low, mid) merge_sort(li, mid+1, high) merge(li, low, mid, high)# li = list(range(10000))# random.shuffle(li)# merge_sort(li, 0, len(li)-1)# print(li)li = [10,4,6,3,8,2,5,7]merge_sort(li, 0, len(li)-1) Via 掘金","link":"/posts/PythonAlgorithm.html"},{"title":"常用实现","text":"常用实现 九九乘法表1234for i in range(1, 10): for j in range(1, i+1): print('{}x{}={}\\t'.format(j, i, i*j), end='') print() 列出目录文件 路径下的所有文件和文件夹的路径 123path = &apos;~/path&apos;for i in os.listdir(path): print(os.path.join(path,i)) 读取路径下的文本 123456789101112131415def txt_processing(folder_path):folder_list = os.listdir(folder_path)# 遍历文件夹for folder in folder_list: new_folder_path = os.path.join(folder_path,folder) # 拼接路径 files = os.listdir(new_folder_path) # 258/分类 for file in files: # if j &gt; 1000000000000000: # 要读的每个分类的文件个数 # break if not os.path.isdir(file): # 判断是否是文件夹，不是文件夹才打开 TxtPath = os.path.join(new_folder_path, file) with open(TxtPath,'r',encoding='UTF-8') as fp: Txt = fp.read() 输出以 xxx 为后缀的文件 1234for i in os.listdir(filepath): path = os.path.join(fillepath,i)if path.endswith('.xxx'): print(path) 判断奇偶数12345number = int(input('输入数字:'))if (num % 2 ) == 0: print('{}：是偶数'.format(number))else: print('{}：是奇数'.format(number)) 字符串判断12345678str = \"runoob.com\"print(str.isalnum()) # 判断所有字符都是数字或者字母print(str.isalpha()) # 判断所有字符都是字母print(str.isdigit()) # 判断所有字符都是数字print(str.islower()) # 判断所有字符都是小写print(str.isupper()) # 判断所有字符都是大写print(str.istitle()) # 判断所有单词都是首字母大写，像标题print(str.isspace()) # 判断所有字符都是空白字符、\\t、\\n、\\r 字符串到小写转换str = 'vitan.me' # 把所有字符中的小写字母转换成大写字母 print(str.upper()) # 把所有字符中的大写字母转换成小写字母 print(str.lower()) # 把第一个字母转化为大写字母，其余小写 print(str.capitalize()) # 把每个单词的第一个字母转化为大写，其余小写 print(str.title())","link":"/posts/PythonCommonlyUse.html"},{"title":"Date Types","text":"数据类型 数值类型Int 整形整数类型 声明： 十进制：0~9 var = 十进制数字 var = 进制数字 二进制：0~1, 符号: 0b 八进制：0~7,符号: 0o 十六进制：0~9A~F,符号: 0x Float 浮点型即小数 声明： var = 小数 Bool 布尔类型只有两个值：True 和 False Complex 复数类型复数的完整结构:实数部分+虚数部分 声明： var = 实数 + 虚数 如：var = 5 + 4j var = complex(实数，虚数值) 如：var = complex(5,3) String类型,字符类型String 字符串类型即文字类型 声明： var = ‘str…’ var = “str…” var = ‘’’str…’’’ or var = “””str…””” 转义字符某种特定的格式使得字符的意义发生改变 符号 含义 \\ 续行符 \\\\ 反斜杠符号() \\' 单引号 \\&quot; 双引号 \\a 响铃 \\b 退格(backspace) \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，yy代表的字符，例如：\\o12代表换行 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 元字符串任意字符串之前添加字母r或者R，则当前字符串中所有转义字符在使用时都不会进行转义操作 列表类型(List)一系列数据的顺序组合，并且组合之后可以修改 声明： list = [] 元组类型(Tuple)一系列数据的顺序组合，但是组合之后不可以修改 声明: tuple = () 字典类型(Dict)具有键值映射关系的一组无序数据组合，可以修改 声明: dict = {‘key1’:’value1’,’key2’:’value2’…} 集合类型(Set)一组特定数据的无序组合，所有数据不会重复 声明: var = {value1,value2…}","link":"/posts/PythonDateTypes.html"},{"title":"Regression Validation","text":"回归分析 导入数据123import pandas df = pandas.read_csv('house-prices.csv')df.head() one-hot 处理12345678910111213#对Brick与Neighborhood两列数据进行one-hot处理house = pandas.concat([df,pandas.get_dummies(df['Brick']),pandas.get_dummies(df['Neighborhood'])] ,axis=1)#删除No列del house['No']#删除West列del house['West']#删除Brick列del house['Brick']#删除Neighborhood列del house['Neighborhood']#删除Home列del house['Home']house.head() statsmodels.api1234#X为house的'SqFt', 'Bedrooms', 'Bathrooms', 'Offers', 'Yes', 'East', 'North'列X = house[['SqFt', 'Bedrooms', 'Bathrooms', 'Offers', 'Yes', 'East', 'North']]#Y为house的Price列的valuesY = house['Price'] 12345678910111213import numpy.core.multiarrayfrom pandas.core import datetools#导入statsmodels.api里面的sm，用于评估模型import statsmodels.api as sm#利用sm.add_constant为X增加一列名为const,值为1的数据X2 = sm.add_constant(X)#调用sm的OLS函数对Y,X2进行模型创建est = sm.OLS(Y,X2)#调用est的fit函数创建回归结果est2 = est.fit()#输出打印est2的概要信息print(est2.summary())est2.aic 最优组合12345predictorcols = ['SqFt', 'Bedrooms', 'Bathrooms', 'Offers', 'Yes', 'East', 'North']import itertoolsfor i in range(1,len(predictorcols)+1): for variables in itertools.combinations(predictorcols,i): print(variables) 123456789101112131415161718import itertools#导入itertools库#创建字典AICs ，用于保存每个列名组合的aic结果AICs = {}#for循环，循环变量i从1到predictorcols列表的长度加1for i in range(1,len(predictorcols)+1): #再次for循环，循环变量var的范围为predictorcols的各种i个元素组合集合itertools.combinations(predictorcols,i) for var in itertools.combinations(predictorcols,i): #predictors为数据框X里的var列的数据，记得要先将var转换成list predictors = X[list(var)] #利用sm.add_constant为predictors增加一列名为const,值为1的数据 predictors2 = sm.add_constant(predictors) #调用sm的OLS函数对y,predictors2进行模型创建 est = sm.OLS(Y,predictors2) #调用est的fit函数创建回归结果 res = est.fit() print(res.aic) # 每种组合的aic值 #将res.aic的结果赋值给 AICs的每一个var AICs[var] = res.aic 123456#导入collections的Counterfrom collections import Counter#调用Counter，对AICs进行降序排序c = Counter(AICs)#调用排序后的c倒数10个数据对象c.most_common()[::-10]","link":"/posts/RegressionValidation.html"},{"title":"安居客二手房","text":"Scrapy anjuke.com 广州二手房数据(保存为 csv) Spiders12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-from scrapy import Spider,Requestfrom anjuke.items import AnjukeItemclass AnjukehouseSpider(Spider): name = 'anjukeHouse' allowed_domains = ['anjuke.com'] start_urls = ['https://guangzhou.anjuke.com/sale/p1-rd1/#filtersort'] def parse(self, response): # 所有房子URL urls = response.xpath('//div[@class=\"house-title\"]/a/@href').extract() for url in urls: yield Request(url,callback=self.parse_detail) # 下一页 next = response.xpath('//*[@id=\"content\"]/div[4]/div[7]/a[7]/@href').extract() if next: next = response.urljoin(next[0]) yield Request(next,callback=self.parse) def parse_detail(self,response): item = AnjukeItem() item['date'] = response.xpath('//span[@class=\"house-encode\"]/text()').extract()[0].split() item['tittle'] = response.xpath('//h3[@class=\"long-title\"]/text()').extract() item['price'] = response.xpath('//span[@class=\"light info-tag\"]/em/text()').extract_first().split() houseInfo = response.xpath('//div[@class=\"houseInfo-content\"]/text()').extract() item['huxing'] = houseInfo[2].strip().replace(\"\\n\",\"\").replace(\"\\t\",\"\").split() item['area'] = houseInfo[7].strip().split() item['built'] = houseInfo[9].strip().replace(\"\\n\", \"\").replace(\"\\t\", \"\").split() item['chaoxiang'] = houseInfo[10].strip().split() item['leixing'] = houseInfo[-8].strip().split() item['louceng'] = houseInfo[-7].strip().split() item['zhuangxiu'] = houseInfo[-6].strip().split() print(item) return item items123456789101112131415from scrapy import Item,Fieldclass AnjukeItem(Item): # define the fields for your item here like: # name = scrapy.Field() tittle = Field() huxing = Field() area = Field() chaoxiang = Field() louceng = Field() price = Field() zhuangxiu = Field() leixing = Field() date = Field() built = Field() settings1234567891011121314151617181920212223BOT_NAME = 'anjuke'SPIDER_MODULES = ['anjuke.spiders']NEWSPIDER_MODULE = 'anjuke.spiders'# Obey robots.txt rulesROBOTSTXT_OBEY = FalseDOWNLOAD_DELAY = 3DEFAULT_REQUEST_HEADERS = { 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'en', 'user-agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9', 'cache-control': 'max-age=0',}ITEM_PIPELINES = {'anjuke.pipelines.Pipeline_ToCSV': 300,} pipelines12345678910111213141516import csvimport osclass Pipeline_ToCSV(object): def __init__(self): self.csvwriter = csv.writer(open('anjuke.csv', 'w'), delimiter=',') self.csvwriter.writerow(['date','tittle', 'price', 'huxing', 'area','built','chaoxiang','leibie','loucheng','zhuangxiu']) def process_item(self, item, ampa): rows = zip(item['date'],item['tittle'], item['price'],item['huxing'],item['area'],item['built'],item['chaoxiang'],item['leixing'],item['louceng'],item['zhuangxiu']) for row in rows: self.csvwriter.writerow(row) return item Selenium123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 18-12-28 下午6:48# @Author : Vitan# @File : anjuke.pyfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom bs4 import BeautifulSoupimport pandasimport time,randombroswer = webdriver.Chrome()wait = WebDriverWait(broswer,10)houseInfo = []def get_urls(): page_urls = [] star_url = 'https://guangzhou.anjuke.com/sale/p' for i in range(1,51): url = star_url+str(i) page_urls.append(url) return page_urlsdef HouseUrl(url): time.sleep(random.random()*10) broswer.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.curr'))) urls = broswer.find_elements_by_css_selector('.houseListTitle') # a 标签 house_urls = [] for a in urls: urls = a.get_attribute('href') house_urls.append(urls) return house_urlsdef get_detail(url): time.sleep(random.random()*10) broswer.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.houseInfoBox'))) info = {} # info['标题'] = broswer.find_element_by_css_selector('.long-title').get_attribute('textContent') # info['总价'] = broswer.find_elements_by_css_selector('.basic-info span')[0].get_attribute('textContent') # info['户型'] = broswer.find_elements_by_css_selector('.basic-info span')[1].get_attribute('textContent') # info['面积'] = broswer.find_elements_by_css_selector('.basic-info span')[2].get_attribute('textContent') # info['单价'] = broswer.find_elements_by_css_selector('.houseInfo-content')[2].get_attribute('textContent') # info['朝向'] = broswer.find_elements_by_css_selector('.houseInfo-content')[7].get_attribute('textContent') # info['月供'] = broswer.find_elements_by_css_selector('.houseInfo-content')[8].get_attribute('textContent') # info['楼层'] = broswer.find_elements_by_css_selector('.houseInfo-content')[-7].get_attribute('textContent') # info['装修'] = broswer.find_elements_by_css_selector('.houseInfo-content')[-6].get_attribute('textContent') html = broswer.page_source soup = BeautifulSoup(html,'lxml') info['标题'] = soup.select('.long-title')[0].text info['总价'] = soup.select('.basic-info span')[0].text info['户型'] = soup.select('.basic-info span')[1].text info['面积'] = soup.select('.basic-info span')[2].text info['单价'] = soup.select('.houseInfo-content')[2].text info['朝向'] = soup.select('.houseInfo-content')[7].text info['月供'] = soup.select('.houseInfo-content')[8].text info['楼层'] = soup.select('.houseInfo-content')[-7].text info['装修'] = soup.select('.houseInfo-content')[-6].text k = ['标题','总价','户型','面积','单价','朝向','月供','楼层','装修'] info_adj = dict(zip(k,list(info.values()))) houseInfo.append(info_adj) print(houseInfo) return houseInfodef save_to_csv(houseInfo): df = pandas.DataFrame(houseInfo) df.to_csv('maoming.csv')def main(): page_urls = get_urls() for url in page_urls: house_urls = HouseUrl(url) for url in house_urls: houseInfo=get_detail(url) save_to_csv(houseInfo)if __name__ == '__main__': main()","link":"/posts/ScrapyAnjuke.html"},{"title":"Visualization","text":"Python 数据可视化 读取1234567import pandas as pd#将purchase_order.tab文件里面的相关字段名赋值给m_colsm_cols = ['Time','Action','User','Product', 'Quantity','Price']#读取purchase_order.tab文件，文件间隔符为\\t，读取进来后Dates为第一列数据，文件列名为以上m_cols编码为utf-8,orders = pd.read_csv('purchase_order.tab',sep = '\\t',parse_dates = {'Dates':[0]},names = m_cols)#查看orders整个数据框的相关信息orders.head() 查看记录 12345678910111213141516171819202122232425262728293031#查看orders的Product列前5行数据orders['Product'].head()#查看Product为P0006944501的Price列数据，并获取其描述性统计信息orders.ix[orders['Product'] =='P0006944501','Product']#查看Product为P0006944501的Price列数据，求其均值orders[orders['Product']=='P0006944501']['Price'].describe()orders[orders['Product']=='P0006944501']['Price'].mea()#计算orders里面有哪些Productorders['Product'].unique()#求orders里面不同类别的Product共有多少个len(orders['Product'].unique())# select Product, avg(Price) from orders # group by Product limit 5#按Product统计其各自的销售价格均值orders.groupby('Product')['Price'].mean()# select Product, avg(Price) from orders # group by Product order by avg(Price) desc limit 5#按Product统计其各自的销售价格均值并将求得的数据进行降序排序orders.groupby('Product')['Price'].mean().sort_values(ascending=False) 增加 12#为orders增加新列Total_Price，并利用orders里面的相关数据计算求得orders['Total_Price'] = orders['Quantity'] * orders['Price'] 排序 12345#select User, sum(Total_Price) from orders#gorup by User order by sum(Total_Price) desc limit 5#按客户统计他们的消费总金额，并按降序排列orders.groupby('User')['Total_Price'].sum().sort_values(ascending = False) 再次读取12345678import pandas as pdm_cols = ['Time','Action','User','Product']#读取purchase_view.tab文件，文件间隔符为\\t，要求读取进来后Dates为第一列数据，文件列名为以上m_cols编码为utf-8,views =pd.read_csv('purchase_view.tab',sep='\\t',parse_dates={'Dates':[0]},names =m_cols,encoding='UTF-8')#查看views整个数据框的相关信息views.info()#查看前5行数据views.head() 分组、排序 12345678## SELECT User, Product, COUNT(Product) FROM Orders GROUP BY User, Product#在购买数据表中按不同用户不同产品进行分组，并统计每个用户产品的购买数量，将统计结果以“buys”作为字段名添加进统计结果中orders_cnt= orders.groupby(['User','Product'])['Action'].count().reset_index(name='buys')orders_cnt.head()## SELECT User, Product, COUNT(Product) FROM views GROUP BY User, Product#在浏览记录表数据表中按不同用户不同产品进行分组，并统计每个用户产品的浏览量，并对统计结果按浏览量降序排列，最后将统计结果以“views”作为字段名添加进统计结果中,views_cnt =views.groupby(['User','Product'])['Action'].count().sort_values(ascending=False).reset_index(name = 'views') 合并 12#将用户购买与浏览产品的数据合并在一起，生成表格merge_df,以views_cnt作为右连接表，连接结果为右连接merge_df = pd.merge(orders_cnt,views_cnt,on=['User','Product'],how='right') 数据表的连接问题 merge与concat的区别 不同日期與時間 12345678910111213views.head()#查看viewsviews.info()#查看views的相关信息# year, month, day, date, hour #查看views的Dates列数据的年、月、日期等信息views['Dates'].dt.hour# select date, count(action) from views# group by date#在views表中，统计每一天网站的用户浏览总次数views_cnt_by_date = views.groupby(views['Dates'].dt.date)['Action'].count()views_cnt_by_date.head()#查看以上统计结果 绘制图表1234%pylab inline#对每天用户浏览网站情况绘制折线图，图大小为10*5 views_cnt_by_date.plot(kind='line',figsize=[10,5]) 12345678# select hour(Dates), count(action) from views# group by hour(Dates)#在views表中，统计一天24内每个小时网站的用户浏览总次数views_cnt_by_hour = views.groupby(views['Dates'].dt.hour)['Action'].count()%pylab inline#各个小时用户浏览网站情况绘制折线图，图大小为10*5，标题为view count by hourviews_cnt_by_hour.plot(kind='line',figsize=[10,5],title='view count by hour') 123456#增加新列Total_price,并利用orders相关数据计算orders['Total_price'] = orders['Quantity'] * orders['Price']#按客户统计他们的消费总金额，并按降序排列,最终取前10个用户的统计数据g = orders.groupby('User')['Total_price'].sum().sort_values(ascending=False)[0:10]#绘制前10个用户的消费金额柱形图，图片大小10*5g.plot(kind='bar',figsize=[10,5],color='y') 统计 1234567#在views表中统计网站每天的浏览总数view_daily_cnt = views.groupby(views['Dates'].dt.date)['Action'].count()view_daily_cnt.head()#在orders表中统计网站每天用户的购买总次数orders_daily_cnt = orders.groupby(orders['Dates'].dt.date)['Action'].count()orders_daily_cnt.head() 合并 1234567#将view_daily_cnt与orders_daily_cnt表按列方向拼接,不需要按主键合并df =pd.concat([view_daily_cnt,orders_daily_cnt],axis=1) ##关于merge与concat的区别：https://blog.csdn.net/ZK_J1994/article/details/77717700df=df.dropna()#删除具有空值的行,并将删除结果覆盖原数据框df.head()df.columns=['Views','Orders']#将df的字段名命名为'Views', 'Orders' df.head() 12#对df数据绘制折线图，图的大小为10*5，设置X轴刻度的显示旋转度为30df.plot(kind='line',figsize=[10,5],rot=30) plot里面各参数的使用说明","link":"/posts/Visualization.html"},{"title":"Data Transformation","text":"数据处理 数据转换123import pandasdf = pandas.read_excel('house_sample.xlsx')#读取excel文件数据df.head() 数据运算12345678910111213#将总价*10000df['总价']*10000import numpy as np#求总价列数据的平方根np.sqrt(df['总价'])#将‘朝向’与‘户型’两列数据拼接在一起df['朝向']+df['户型']#求每套房的房价均值（记得要先将总价*10000）df['总价']*10000/df['建筑面积']#df.head() 切分12345678910#以“元”为分界对s进行切分，并获取切分后的第一个字符s = '1.5元/平米・月's.split('元')[0]#定义removeDollar函数实现对字符e按‘元’进行切分并获取切分后的第一个字符def removeDollar(e): return e.split('元')[0]removeDollar(s)#调用以上函数对s进行应用#将函数removeDollar套用到df的物业费列df['物 业 费'].map(removeDollar) 匿名函数12345def removeDollar(e):return e.split('元')[0]#将上面函数以匿名函数形式套用到df的物业费列df['物 业 费'].map(lambda e:e.split('元')[0]) 其他123456def square(e): return e * e square(2)square2 = lambda e: e * esquare2(2) 行列最值 12345df = pandas.DataFrame([ [60,70,50],\\ [80,79,68],\\ [63,66,82]], columns = ['First', 'Second', 'Third'])df 12345#对df的每一行数据应用匿名函数进行计算，匿名函数实现对每一行数据的最大值与最小值计算df.apply(lambda e:e.max()-e.min(),axis=1)#对df的每一列数据应用匿名函数进行计算，匿名函数实现对每一列数据的最大值与最小值计算df.apply(lambda e:e.max()-e.min()) 例题导入数据 123import pandasdf = pandas.read_excel('house_sample.xlsx')df.head() 实操 123456789101112import numpy as npdef convertNaN(e): if e == '暂无资料': return np.nan else: return e #将函数convertNaN应用到df的每个数据元素上df.applymap(convertNaN)#以匿名函数形式将函数套用到df的每个数据元素上df.applymap(lambda e:np.nan if e =='暂无资料' else e) 时间转换123456#导入时间处理库datetimefrom datetime import datetime#获取系统当前时间current_time = datetime.now()type(current_time) 时间&lt;—-&gt;String123456#将时间转换成字符串current_time.strftime('%Y/%m%d')s = '2017/04-22'#将字符串转换成时间print(datetime.strptime(s,'%Y/%m-%d')) 时间回溯1234567891011121314from datetime import timedelta#newday为当前时间往前回溯10天newday = current_time - timedelta(10)print(newday)current_time - newday#将current_time往后推迟10天current_time + timedelta(10)for i in range(1,10): #dt代表往前推移的每一个日期 dt = current_time - timedelta(i) #将dt转换成字符串类似格式为“2017/04/21”，并打印输出 print(dt.strftime('%Y/%m/%d')) 时间戳123456from time import mktime#利用mktime将current_time转换成unix时间戳mktime(current_time.timetuple())#将上面的unix时间戳转换成datetime，调用datetime的fromtimestampprint(datetime.fromtimestamp(1544492604.0)) 例题数据导入 1234import pandasdf = pandas.read_excel('house_sample.xlsx')df.head()df.info() 时间转换12#将df的'张贴日期'列转换成日期（datetime）形式df['张贴日期'] =pandas.to_datetime(df['张贴日期'],format='西元%Y年%m月%d日') 数据重塑数据导入123import pandas as pddf = pd.read_excel('house_sample.xlsx')df.head() 数据操作 one-hot 123456#将df的\"朝向\"列数据进行one-hot处理，即转换成虚拟变量pd.get_dummies(df['朝向'])#利用pandas的concat函数将“朝向”列数据进行one-hot处理后，与原来的df数据框合并df = jion(pd.compat([df,pd.get_dummies(['朝向'])],axis=1))df.head() 删除数据 123#删除df的'朝向'数据df = df.drop('朝向',axis=1)df.head() 数据透视表1234#利用数据透视表绘制以下表格df2 = df.pivot_table(index='张贴日期',columns='产权性质',values='总价',aggfunc=sum,fill_value=0)#表中数据为对应交叉对象的总价之和df2.head() 转换 123#将上面表格的行索引与列索引进行对换df3 = df.pivot_table(index='产权性质',columns='张贴日期',values='总价',aggfunc=sum,fill_value=0)df3.head() 利用转置函数实现上面的行索引与列索引对换1df2.T 表 123#调整上面的参数，绘制以下表格df_multi_idx = df.pivot_table(index=['装修','楼层'],columns='张贴日期',values='总价',aggfunc=sum,fill_value=0)df_multi_idx.head() unstack函数 123#利用unstack函数转换成宽表格df_wide = df_multi_idx.unstack()df_wide.head() stack函数 123#利用stack转换成长表格df_long = df_wide.stack()df_long.head() 综合练习123456import pandas#将抓取返回的数据列组合成数据框dfdf = pandas.read_excel('news.xlsx')#输出打印df的行数与列数df.shapedf.head(10) 整理文章关键词空单元格处理 123456#判断df中每一列是否有空的单元格df.isnull().any()#将具有空单元格的行数据删除df = df.dropna()df.shape 关键字处理 123456df['keyword'].head(5)#对df的keyword列提取关键词并将提取结果覆盖原keyword列 提示：先根据空格切割split再索引s = ' \\n关键字 : \\n联合报农发农业部门'df['keyword'] = df['keyword'].map(lambda e:e.split(':')[1].strip())df.head(3) 正则表达法抽取时间与源数据 1234567891011df['source'].head()#法一 对source列根据空格应用切割函数df['source'].map(lambda e:e.split()[0])df.head(3)#法二 根据正则表达式提取str.extractdf['source'].str.extract('(\\d+年\\d+月\\d+)日')#根据正则表达式提取后的数据'datetime', 'from'合并入dfdf[['datetime','from']] = df['source'].str.extract('(\\d+年\\d+月\\d+日) \\d+:\\d+\\n(\\w*)') 转换时间格式 123456#将pandas整列数据转换成日期格式# s = '2018年06月14日'# import datetime# s.strptime(s,'%Y年%m月%d日')df['datetime'] = pandas.to_datetime(df['datetime'],format='%Y年%m月%d日')df['datetime'].head() 刪除Source 1234#删除source列数据del df['source']df.head(3) 数据 链接","link":"/posts/DataTransformation.html"},{"title":"Tmux","text":"Tmux 可以复用终端、分屏、托管进程等 Tmuxalias vimrc1alias tnew='tmux new =s' 模块 名词 含义 解析 session 会话 一个服务器可以包含多个会话 window 窗口 一个会话可以包含多个窗口 pane 面板 一个窗口可以包含多个面板[强悍的分屏] 输入命令 tmux 使用工具 命令 分屏状态 Ctrl+b z 缩放窗格 Ctrl+b ? 显示快捷键帮助 Ctrl+b C-o 调换窗口位置，类似与vim 里的C-w Ctrl+b 空格键 采用下一个内置布局 Ctrl+b ! 把当前窗口变为新窗口 Ctrl+b “ 横向分隔窗口 Ctrl+b % 纵向分隔窗口 Ctrl+b q 显示分隔窗口的编号 Ctrl+b o 跳到下一个分隔窗口 Ctrl+b 上下键 上一个及下一个分隔窗口 Ctrl+b C-方向键 调整分隔窗口大小 Ctrl+b c 创建新窗口 Ctrl+b 0~9 选择几号窗口 Ctrl+b c 创建新窗口 Ctrl+b n 选择下一个窗口 Ctrl+b l 切换到最后使用的窗口 Ctrl+b p 选择前一个窗口 Ctrl+b w 以菜单方式显示及选择窗口 Ctrl+b t 显示时钟 Ctrl+b ; 切换到最后一个使用的面板 Ctrl+b x 关闭面板 Ctrl+b &amp; 关闭窗口 Ctrl+b s 以菜单方式显示和选择会话 Ctrl+b d 退出tumx，并保存当前会话，这时，tmux仍在后台运行，可以通过tmux attach进入 到指定的会话 窗格间移动 命令 分屏状态 Ctrl+b ← 选择左边的窗格 Ctrl+b → 选择右边的窗格 Ctrl+b ↑ 选择上边的窗格 Ctrl+b ↓ 选择下边的窗格 Ctrl+b { 来向左交换窗格 Ctrl+b } 来向右交换窗格 Ctrl+b o 切换到下一个窗格（从左到右，从上到下） Ctrl+b ; 移动到先前活动的窗格 打开/创建新窗口 命令 分屏状态 Ctrl+b c 创建一个新窗口 Ctrl+b n 移动到下一个窗口 Ctrl+b p 移动到上一个窗口。 Ctrl+b 0 ~ Ctrl+b 9 立即移动到特定窗口 Ctrl+b l 移动到先前选择的窗口 Ctrl+b w 以交互方式选择当前窗口","link":"/posts/tmux.html"},{"title":"数据处理","text":"数据处理 数据筛选1234567import pandas as pddf = pd.DataFrame([{'name':'frank', 'gender':'M', 'age':29}, {'name':'mary', 'gender':'F', 'age':23}, {'name':'tom', 'gender':'M', 'age':35}, {'name':'ted', 'gender':'M', 'age':33}, {'name':'jean', 'gender':'F', 'age':21}, {'name':'lisa', 'gender':'F', 'age':20}]) 筛选 查看df前5行 1df.head(5) 利用ix索引查找行号名为1的行记录 1df.ix[1] 利用ix查找行号名为1-3的行记录 1df.ix[1:3] 利用列名返回name列数据 1df['name'] 返回name与age列数据 1df[['name','age']] 返回行名号为1、2的name与age列数据 1df.ix[1:2,['name','age']] 返回gender列数据 12df['gender']df.gender 判断每行的gender列数据是否为M 1df.gender=='M' 返回男性的行数据 1df[df.gender=='M'] 判断各行记录age列是否大于30 1df.age&gt;30 返回年龄大于30岁的行数据 1df[df.age&gt;30] 返回男性且年龄大于30的行数据 1df.ix[(df.gender=='M') &amp; (df.age&gt;30),] 返回男性或年龄大于30的行数据 1df.ix[(df.gender=='M') | (df.age&gt;30),] df增加employee列，其值均为True 12345df['employee']=True```python14. 利用del删除employee列```pythondel df['employee'] 再次为df增加employee列 12df['employee']=Truedf.head()#查看df前5行 利用df.drop函数删除employee列，按列删除 1df = df.drop('employee',axis=1) 利用loc查看行号名为5的行数据 1f.loc[5] 为df增加行号名为6的行数据，数据为{‘age’:20, ‘gender’: ‘F’, ‘name’:’qoo’} 1df.loc[6]={'age':20, 'gender': 'F', 'name':'qoo'} 利用df.drop删除索引号为6的记录 1df = df.drop(6) 利用df.append增加以上行数据到df中，ignore_index为True 1df = df.append(pd.DataFrame([{'age':20, 'gender': 'F', 'name':'qoo'}]), ignore_index=True) 利用df.drop删除索引号为6的行数据 1df.drop(6) 为df增加一列数据userid，值为101-106,提示：利用range函数 1df['userid'] = range(101,107) 利用set_index设置userid为索引列，代替原来行号名 1df = df.set_index('userid') oc——通过行（行名字）标签索引行数据 iloc——通过行号（行序号，从0开始）索引行数据 ix——通过行标签或者行号索引行数据（基于loc和iloc 的混合） 12345678910111213#分别利用行名与行序号返回第一条行数据df.loc[101]df.iloc[0]#返回df第2，4，6行的数据df.iloc[[1,3,5]]df.loc[[102,104,106]]#利用ix返回行名为101,103,105的记录df.ix[[101,103,105]]#利用loc返回行名为[101,103,105]的记录df.loc[[101,103,105]] 检测缺失值12345678910import pandas as pdimport numpy as npdf = pd.DataFrame([\\ ['frank', 'M', np.nan], \\ ['mary' , np.nan, np.nan], \\ ['tom' , 'M', 35], \\ ['ted' , 'M', 33], \\ ['jean' , np.nan, 21], \\ ['lisa' , 'F', 20]])df.columns = ['name', 'gender', 'age'] 数据操作 判断df的gender列每个单元格是否为空 1df.gender.isnull() 判断df的age列是否存在空的单元格（结果只需知道有没有存在） 1df.age.isnull().any() 判断df整个数据框是否存在空的单元格（结果只需知道有没有存在） 1df.isnull().values.any() 求df的age列空的单元格的总数 1df.age.isnull().sum() 求df所有列空单元格的总数 1df.isnull().sum().sum() Imputing Missing Value12345678910import pandas as pdimport numpy as npdf = pd.DataFrame([\\ ['frank', 'M', np.nan], \\ [np.nan , np.nan, np.nan], \\ ['tom' , 'M', 35], \\ ['ted' , 'M', 33], \\ ['jean' , np.nan, 21], \\ ['lisa' , 'F', 20]])df.columns = ['name', 'gender', 'age'] 删除 123456789101112#删除df具有Nan值的行df.dropna()#删除df所有列均为空值的行记录df.dropna(how='all')#删除df空值超过2个的行记录df.dropna(thresh=2)#删除df的age列#删除df中整列值均为nan的列df.dropna(axis=1,how='all') 增加 12#在df中增加一新列employee，且值为空（np.nan） df['employee']=np.nan 填补 1234567891011121314#填补df里任意空单元格的值为0df.fillna(0)#将df的age列的均值填入该列值为空的单元格df['age'].fillna(df['age'].mean())#将df的age列的空单元格，按性别填入该类性别的平均年龄值df['age'].fillna(df.groupby('gender')['age'].transform('mean'))#使用向后填补方面对df的空值单元格进行填补df.fillna(method='backfill')#使用向前填补对df的空值单元格进行填补df.fillna(method='pad') 数据2 1234567df2 = pd.DataFrame([[1, 870],\\ [2, 900],\\ [np.nan, np.nan],\\ [4, 950],\\ [5,1080],\\ [6,1200]])df2.columns = ['time', 'val'] 12#使用内插法对df2进行填补df2.interpolate() 实例 读取数据 123456import pandasdf = pandas.read_csv('house_data.csv')#用del删除列名为'Unnamed: 0'的列del df['Unnamed: 0']df.head(3) 检视 检视前几行资料 1df.head(5) 检视后三行资料 1df.tail(3) 检视DataFrame 信息 12#查看df所有的信息(列名，各列非空计数，数据类型)df.info() 检视字段名称 12#查看df所有列名df.columns 检视字段型态 12#查看df各列数据类型df.dtypes 舍弃第一栏12#将文件读取进来，命名为df，并且在读取文件同时删除第1列df = pandas.read_csv('house_data.csv',index_col=0) 将”暂无资料”变成缺失值12345678910111213#筛选df数据框中“物业费”列的值为“暂无资料”的行记录df[df['物 业 费']=='暂无资料']# df.ix[df['物 业 费']=='暂无资料',]import numpy as np#将“物业费”列的值为“暂无资料”的单元格设置为空df.loc[df['物 业 费']=='暂无资料','物 业 费']=np.nandf.head(3)import pandas#读取文件同时，将“暂无资料”的单元格设置为空，且去掉第一列df = pandas.read_csv('house_data.csv',index_col=0,na_values='暂无资料')df.head(3) 取得叙述性统计12#对df各非字符串列进行描述性统计（计数，均值，标准差，最大最小，4分位等）df.describe() 侦测缺失值12#对事个数据框df每个单元格进行缺失值判断df.isnull() 缺失值123456789#对数据框各列分别进行判断，返回每列是否有缺失值df.isnull().any()#对数据框df按列统计各列各有多少个缺失值df.isnull().sum()#统计数据框各列缺失值与各占各列非空单元格的比例df.count() # 所有非空单元格df.isnull().sum()/df.count() 删除有缺失值的字段 12#用drop删除df的“参考月供”列数据df = df.drop('参考月供',axis=1) 筛选字段12345678910111213141516171819#对数据框df的“产权性质”列所有出现的值进行计数df['产权性质'].value_counts()#获取产权性质为'个人产权'的行记录df[df['产权性质']=='个人产权']#查看获取产权性质为'个人产权'的行记录的前3行df[df['产权性质'] == '个人产权'].head(3)df.iloc[5:7]#筛选'建筑面积'大于100且總價大于2000的行记录，查看第1行df[(df['建筑面积']&gt;100) &amp; (df['總價']&gt;2000)]df.loc[df['建筑面积'] &gt; 100].head(1)#筛选产权性质为“个人产权”的行记录df['产权性质']df.head(3) 舍弃包含缺失值的字段12345#筛选建筑类别为空的行记录，并查看前3行，问，建筑类别列数据是否均为空df[df['建筑类别'].isnull()]#利用dropna删除df的列,并将结果重新赋值给df（整列均为空的列）f.dropna(axis=1,how='all') 补齐缺失值123456789101112131415161718#对物业费为空的单元格，填补为0df['物 业 费'] = df['物 业 费'].fillna(0)#计算'總價'列为空的单元格个数df['總價'].isnull().sum()#筛选出‘總價’为空的行记录df[df['總價'].isnull()]#利用‘總價’列与‘建筑面积’列求均价(df['總價'] / df['建筑面积']).mean() df['總價'].isnull().sum()#对‘總價’列单元格为空的，按上面求的“均价”与建筑面积相乘进行计算df['總價'] = df['總價'].fillna((df['總價'] / df['建筑面积']).mean()* df['建筑面积'])#再次计算‘總價’为空的单元格个数df['總價'].isnull().sum() 将资料写入CSV 中 1df.to_csv('house_final.csv', index_label=False)","link":"/posts/PyData.html"},{"title":"Pycharm Shortcut","text":"PyCharm 快捷键 常用快捷键 快捷键 功能 Ctrl + Q 快速查看文档 Ctrl + F1 显示错误描述或警告信息 Ctrl + / 行注释 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 自动导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl + D 复制选定的区域或行到后面或下一行 Ctrl + Y 删除当前行 Shift + Enter 下一行另起一行 Ctrl +Ｊ 插入模版 Ctrl + Numpad+/- 展开折叠代码块 Ctrl + Numpad+ 全部展开 Ctrl + Numpad- 全部折叠 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Shift + F7 将当前单词在整个文件中高亮，F3移动到下一个，ESC取消高亮 Alt+Enter import模块 Alt + up/down 方法上移或下移动 Alt + Shift + up/down 当前行上移或下移动 Ctrl + B/鼠标左键 转到方法定义处 Ctrl + W 选中增加的代码块 Shift + F6 方法或变量重命名 Ctrl + E 最近访问的文件 Esc 从其他窗口回到编辑窗口 Shift + Esc 隐藏当前窗口，焦点到编辑窗口 F12 回到先前的工具窗口 运行 快捷键 功能 Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 调试 快捷键 功能 F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 编辑 快捷键 功能 Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 Shift + F1 外部文档 Ctrl + 鼠标 简介 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 自动导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行到后面或下一行 Ctrl + Y 删除当前行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 下一行另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开折叠代码块 Ctrl + Numpad+ 全部展开 Ctrl + Numpad- 全部折叠 Ctrl + F4 关闭运行的选项卡 查找/替换 快捷键 功能 F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + F 全局查找 Ctrl + Shift + R 全局替换","link":"/posts/PycharmShortcut.html"},{"title":"Scrapy","text":"Scrapy 命令 安装1sudo pip install scrapy 创建/运行创建项目1scrapy startproject projectName 项目 tree1234567891011├── scrapy.cfg 项目的配置文件└── zhihu 该项目的python模块。之后您将在此加入代码 ├── __init__.py ├── items.py 项目中的 item 文件. ├── middlewares.py ├── pipelines.py ├── __pycache__ ├── settings.py 项目的设置文件 └── spiders 放置 spider 代码的目录 ├── __init__.py └── __pycache__ 创建新的 spider1scrapy genspider mydomain mydomain.com 运行1scrapy crawl mydomain 项目操作12345678910scrapy crawl zhihu # 执行项目scrapy check [-l] &lt;zhihu&gt; # 检查错误scrapy list # 返回 spider 名称scrapy edit &lt;zhihu&gt; # 在命令行编辑scrapy fetch url # 下载网页源码scrapy fetch --nolog url # 无日志scrapy fetch --nolog --no-redirect url # 重定向scrapy view url # 下载网页后浏览器打开scrapy shell # 交互模式scrapy crawl user -o items.json # 保存数据（sv,xml,json,jsonlines,pickle,marshal） 选择器网页源码 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;base href='http://example.com/' /&gt; &lt;title&gt;Example website&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='images'&gt; &lt;a href='image1.html'&gt;Name: My image 1 &lt;br /&gt;&lt;img src='image1_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image2.html'&gt;Name: My image 2 &lt;br /&gt;&lt;img src='image2_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image3.html'&gt;Name: My image 3 &lt;br /&gt;&lt;img src='image3_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image4.html'&gt;Name: My image 4 &lt;br /&gt;&lt;img src='image4_thumb.jpg' /&gt;&lt;/a&gt; &lt;a href='image5.html'&gt;Name: My image 5 &lt;br /&gt;&lt;img src='image5_thumb.jpg' /&gt;&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 交互模式下 1crapy shell https://doc.scrapy.org/en/latest/_static/selectors-sample1.html 构建一个选择器来选择title标签内的文本 1234567# xpathresponse.selector.xpath('//title/text()')# selector 可省略response.xpath('//title/text()') # cssresponse.css('title::text') 提取文本数据，必须调用selector .extract() 方法 12response.xpath('//title/text()').extract() # 所有response.css('title::text').extract_first() # 第一个 获取属性 12345response.xpath('//a/Ahref').extract()response.css('a::attr(href)').extract()response.css('img').xpath('@src').extract()response.xpath('//div[@id=\"images\"]/a/text()').extract_first() default 默认返回值作为参数 1response.xpath('//div[@id=\"not-exists\"]/text()').extract_first(default='not-found') 获取文本内容 12response.xpath('//a/text()').extract()response.css('a::text()').estract() 模糊查找(属性名包含) 1234567# 查找三星包含imageresponse.xpath('//a[contains(@href,\"image\")]/@href').extract()response.css('a[href* = image]::attr(href)').extract()# a 标签里面的image里的src属性response.xpath(\"//a[contains(@href,'image')]/img/@src\").extract()response.css('a[href* = image] img::attr(src)').extract() 嵌套选择器 xpath,css 12345links = response.xpath('//a[contains(@href, \"image\")]')links.extract()for index, link in enumerate(links): args = (index, link.xpath('@href').extract(), link.xpath('img/@src').extract()) print 'Link number %d points to url %s and image %s' % args 具有正则表达式的选择器123456789response.css('a::text').re('Name\\:(.*)') # 返回的是列表response.css('a::text').re_first('Name\\:(.*)') # 第一个值response.css('a::text').re_first('Name\\:(.*)').strip() # 去空格# 提取图像名称response.xpath('//a[contains(@href, \"image\")]/text()').re(r'Name:\\s*(.*)')# 提取第一个匹配的字符串response.xpath('//a[contains(@href, \"image\")]/text()').re_first(r'Name:\\s*(.*)') 定义 ItemItem 是保存爬取到的数据的容器；其使用方法和python字典类似. 编辑 tutorial 目录中的 items.py 文件: 123456import scrapyclass DmozItem(scrapy.Item): title = scrapy.Field() link = scrapy.Field() desc = scrapy.Field() 官方文档 英文 中文","link":"/posts/ScrapyCommand.html"},{"title":"Python SQL","text":"Python SQL 操作 MonngoDB连接12345678910import pymongo# 普通连接client = MongoClient('localhost', 27017)# client = MongoClient('mongodb://localhost:27017/')# 密码连接client = MongoClient('mongodb://username:password@localhost:27017/dbname')db = client.mydatabase# db = client['mydatabase'] 增删查改 增(insert) 123456789# 增加一条记录person = {'name': 'zone','sex':'boy'}person_id = test.insert_one(person).inserted_idprint(person_id)# 批量插入persons = [{'name': 'zone', 'sex': 'boy'}, {'name': 'zone1', 'sex': 'boy1'}]result = test.insert_many(persons)print(result.inserted_ids) 删(delete) 1234567891011121314import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"mydatabase\"]mycol = mydb[\"customers\"]# 删除地址为“Mountain 21”的文档：myquery = { \"address\": \"Mountain 21\" }mycol.delete_one(myquery)# delete_many() 删除多个myquery = { \"address\": {\"$regex\": \"^S\"} }x = mycol.delete_many(myquery)print(x.deleted_count, \" documents deleted.\") 1234567# 删除单条记录result1 = test.delete_one({'name': 'zone'})pprint.pprint(result1)# 批量删除result1 = test.delete_many({'name': 'zone'})pprint.pprint(result1) 改(update) 1234567891011121314151617# Valley 345”更改为“Canyon 123” myquery = { \"address\": \"Valley 345\" }newvalues = { \"$set\": { \"address\": \"Canyon 123\" } }mycol.update_one(myquery, newvalues)#print \"customers\" after the update:for x in mycol.find(): print(x)# update_many() 更新多个myquery = { \"address\": { \"$regex\": \"^S\" } }newvalues = { \"$set\": { \"name\": \"Minnie\" } }x = mycol.update_many(myquery, newvalues)print(x.modified_count, \"documents updated.\") 123456# 更新单条记录res = test.update_one({'name': 'zone'}, {'$set': {'sex': 'girl girl'}})print(res.matched_count)# 更新多条记录test.update_many({'name': 'zone'}, {'$set': {'sex': 'girl girl'}}) 查(Querry) 12345678910111213141516171819202122import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"mydatabase\"]mycol = mydb[\"customers\"]# 查找地址以字母“S”或更高开头的文档：myquery = { \"address\": { \"$gt\": \"S\" } }mydoc = mycol.find(myquery)for x in mydoc: print(x)# 正则表达式过滤myquery = { \"address\": { \"$regex\": \"^S\" } }mydoc = mycol.find(myquery)for x in mydoc: print(x) 1234567import pprint# 查找多条记录pprint.pprint(test.find())# 添加查找条件pprint.pprint(test.find({\"sex\": \"boy\"}).sort(\"name\")) 排序 sort()方法 12results = collection.find().sort('name', pymongo.ASCENDING)print([result['name'] for result in results]) 示例12345678910client = pymongo.MongoClient('localhost')b = client['MaFengWoView']def save_to_mongo(view):if db['MaFengWoView'].insert_one(view): print('Saving to MongoDB',view) return Truereturn False save_to_mongo(view) MySQL连接创建 创建一个名为“customers”的表 123456789101112import mysql.connectormydb = mysql.connector.connect(host=\"localhost\",user=\"yourusername\",passwd=\"yourpassword\",database=\"mydatabase\")mycursor = mydb.cursor()mycursor.execute(\"CREATE TABLE customers (name VARCHAR(255), address VARCHAR(255))\") 检查表是否存在 123456mycursor = mydb.cursor()mycursor.execute(\"SHOW TABLES\")for x in mycursor: print(x) 创建表时创建主键(存在用ALTER TABLE) 123456789101112import mysql.connectormydb = mysql.connector.connect(host=\"localhost\",user=\"yourusername\",passwd=\"yourpassword\",database=\"mydatabase\")mycursor = mydb.cursor()mycursor.execute(\"CREATE TABLE customers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), address VARCHAR(255))\") 插入 单行 123456789mycursor = mydb.cursor()sql = \"INSERT INTO customers (name, address) VALUES (%s, %s)\"val = (\"John\", \"Highway 21\")mycursor.execute(sql, val)mydb.commit()print(mycursor.rowcount, \"record inserted.\") 多行 123456789101112131415161718192021222324mycursor = mydb.cursor()sql = \"INSERT INTO customers (name, address) VALUES (%s, %s)\"val = [ ('Peter', 'Lowstreet 4'), ('Amy', 'Apple st 652'), ('Hannah', 'Mountain 21'), ('Michael', 'Valley 345'), ('Sandy', 'Ocean blvd 2'), ('Betty', 'Green Grass 1'), ('Richard', 'Sky st 331'), ('Susan', 'One way 98'), ('Vicky', 'Yellow Garden 2'), ('Ben', 'Park Lane 38'), ('William', 'Central st 954'), ('Chuck', 'Main Road 989'), ('Viola', 'Sideway 1633') ]mycursor.executemany(sql, val)mydb.commit()print(mycursor.rowcount, \"was inserted.\") Select 所有 12345678mycursor = mydb.cursor()mycursor.execute(\"SELECT * FROM customers\")myresult = mycursor.fetchall()for x in myresult: print(x) 列 12345678mycursor = mydb.cursor()mycursor.execute(\"SELECT name, address FROM customers\")myresult = mycursor.fetchall()for x in myresult: print(x) 参考 官方文档 W3School zone","link":"/posts/PythonSQL.html"},{"title":"Qunar","text":"Selenium Qunar.com 修改版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.common.exceptions import WebDriverException,TimeoutExceptionfrom pyquery.pyquery import PyQuery as pqfrom bs4 import BeautifulSoupimport timeimport pymongodriver = webdriver.Chrome()wait = WebDriverWait(driver,10)client = pymongo.MongoClient('localhost')db = client['Qunar']def lastPage(url): driver.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.next'))) html = driver.page_source soup = BeautifulSoup(html,'lxml') total = int(soup.select('.pager a')[-2].text) return totaldef search_next(page): next = driver.find_element_by_css_selector('.next') wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.next'))) next.click() wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pager em'),str(page))) time.sleep(1)def get_url(): doc = pq(driver.page_source) doc = doc.find('.sight_item_caption') li = [] for box in doc.items(): url = 'http://piao.qunar.com'+str(box.find('.name').attr('href')) li.append(url) return lidef get_comment_last(url): # 评论总页数 driver.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.mp-pager-next.mp-pager-item'))) doc = pq(driver.page_source) doc = doc.find('#pageContainer') li = [i.text() for i in doc.find('.mp-pager-item').items()] return int(li[-2])def get_comment_next(page): try: next = driver.find_element_by_css_selector('.mp-pager-next.mp-pager-item') wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.mp-pager-next.mp-pager-item'))) next.click() wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.mp-pager em'),str(page))) time.sleep(1) except TimeoutException: get_comment_next(page) except WebDriverException: get_comment_next(page)def get_comments(): doc = pq(driver.page_source) doc = doc.find('.mp-comments-list') for item in doc.find('.mp-comments-item').items(): usr = item.find('.mp-comments-username').text() date = item.find('.mp-comments-time').text() comment = item.find('.mp-comments-desc').text() view = { 'user':usr, 'date':date, 'comment':comment } save_to_mongo(view)def save_to_mongo(view): if db['comment'].insert_one(view): print('Saving to MongoDB',view) return True return Falsedef main(): url = 'http://piao.qunar.com/ticket/list_%E6%88%90%E9%83%BD.html#from=home_remen&amp;in_track=qunar_djmp_gnmdd_%E6%88%90%E9%83%BD' total = lastPage(url) all_url = get_url() for i in range(2,total+1): search_next(i) all_url.extend(get_url()) for url in all_url: total = get_comment_last(url) get_comments() for i in range(2,total+1): get_comment_next(i) get_comments()if __name__ == '__main__': main() 自动获取页数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 18-11-20 上午11:53# @Author : Vitan# @File : Qunar.pyfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.common.exceptions import WebDriverException,NoSuchElementException,TimeoutExceptionfrom pyquery.pyquery import PyQuery as pqimport pymongoimport redriver = webdriver.Chrome()wait = WebDriverWait(driver,10)client = pymongo.MongoClient('localhost')db = client['Qunar']def lastPage(): try: url = 'http://piao.qunar.com/ticket/list_%E6%88%90%E9%83%BD.html?keyword=%E6%88%90%E9%83%BD&amp;page=1#from=home_remen&amp;in_track=qunar_djmp_gnmdd_%E6%88%90%E9%83%BD' driver.get(url) doc = pq(driver.page_source) doc = str(doc.find('.pager')) pattern = re.compile('&lt;div.*?&lt;a.*?data-pager-pageno=\"63\"&gt;(\\d+)&lt;/a&gt;', re.S) result = re.match(pattern, doc) total = int(result.group(1)) print(total) return total except TimeoutException: return totaldef get_url(): doc = pq(driver.page_source) doc = doc.find('.sight_item_caption') li = [] for box in doc.items(): url = 'http://piao.qunar.com'+str(box.find('.name').attr('href')) li.append(url) return lidef get_comment_last(): # 评论总页数 doc = pq(driver.page_source) doc = doc.find('#pageContainer') li = [i.text() for i in doc.find('.mp-pager-item').items()] return int(li[-2])def get_comment_next(i): try: next = driver.find_element_by_css_selector('.mp-pager-next.mp-pager-item') next.click() wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pager em'),str(i))) except TimeoutException: get_comment_next(i) except WebDriverException: get_comment_next(i)def get_page_comments(): doc = pq(driver.page_source) doc = doc.find('.mp-comments-list') for item in doc.find('.mp-comments-item').items(): usr = item.find('.mp-comments-username').text() date = item.find('.mp-comments-time').text() comment = item.find('.mp-comments-desc').text() view = { 'user':usr, 'date':date, 'comment':comment } print(view) save_to_mongo(view)def get_all_url(): # 所有景点 Url driver.execute_script('window.open()') # 打开新的选项卡 driver.switch_to.window(driver.window_handles[1]) total = lastPage() driver.switch_to.window(driver.window_handles[0]) all_url = [] for i in range(1, total - 60): url = 'http://piao.qunar.com/ticket/list_%E6%88%90%E9%83%BD.html?keyword=%E6%88%90%E9%83%BD&amp;page=' + str( i) + '#from=home_remen&amp;in_track=qunar_djmp_gnmdd_%E6%88%90%E9%83%BD' driver.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.next'))) all_url.extend(get_url()) print(all_url) return all_urldef get_allcomment_url(): all_url = get_all_url() # 景点所有评论 for url in all_url: driver.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.mp-pager-next.mp-pager-item'))) total = get_comment_last() # 评论页数 get_page_comments() print(total) for i in range(2, total + 1): get_comment_next(i) get_page_comments()def save_to_mongo(view): if db['comment'].insert_one(view): print('Saving to MongoDB',view) return True return Falsedef main(): get_allcomment_url() get_page_comments()if __name__ == '__main__': main() 手动设置页数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 18-11-20 上午11:53# @Author : Vitan# @File : Qunar.pyfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.common.exceptions import WebDriverException,NoSuchElementException,TimeoutExceptionfrom pyquery.pyquery import PyQuery as pqimport pymongoimport redriver = webdriver.Chrome()wait = WebDriverWait(driver,10)client = pymongo.MongoClient('localhost')db = client['Qunar']def get_url(): doc = pq(driver.page_source) doc = doc.find('.sight_item_caption') li = [] for box in doc.items(): url = 'http://piao.qunar.com'+str(box.find('.name').attr('href')) li.append(url) return lidef get_comment_last(): # 评论总页数 doc = pq(driver.page_source) doc = doc.find('#pageContainer') li = [i.text() for i in doc.find('.mp-pager-item').items()] return int(li[-2])def get_comment_next(i): try: next = driver.find_element_by_css_selector('.mp-pager-next.mp-pager-item') next.click() wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pager em'),str(i))) except TimeoutException: get_comment_next(i) except WebDriverException: get_comment_next(i)def get_page_comments(): doc = pq(driver.page_source) doc = doc.find('.mp-comments-list') for item in doc.find('.mp-comments-item').items(): usr = item.find('.mp-comments-username').text() date = item.find('.mp-comments-time').text() comment = item.find('.mp-comments-desc').text() view = { 'user':usr, 'date':date, 'comment':comment } print(view) save_to_mongo(view)def save_to_mongo(view): if db['comment'].insert_one(view): print('Saving to MongoDB',view) return True return Falsedef main(): # 所有景点 Url all_url = [] for i in range(1,2): url = 'http://piao.qunar.com/ticket/list_%E6%88%90%E9%83%BD.html?keyword=%E6%88%90%E9%83%BD&amp;page='+ str(i) +'#from=home_remen&amp;in_track=qunar_djmp_gnmdd_%E6%88%90%E9%83%BD' driver.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.next'))) all_url.extend(get_url()) # 景点所有评论Url for url in all_url: driver.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.mp-pager-next.mp-pager-item'))) total = get_comment_last() # 评论页数 print(total) get_page_comments() for i in range(2,total+1): get_comment_next(i) get_page_comments()if __name__ == '__main__': main()","link":"/posts/Qunar.html"},{"title":"读写 Excel 文件","text":"读写 Excel 读 Excel1234567import xlrddef read_file('file.xlsx'):data = xlrd.open_workbook(url)table = data.sheets()[0] # 打开第一张表nrows = table.nrows # 获取表的行数for i in range(nrows): # 循环逐行打印 print(table.row_values(i)[1:]) 写 Excel1234567891011121314import xlwtdata = xlrd.open_workbook('excelFile.xls')excel = copy(data) #使用wlrd的方法获取已有的的行数rows = data.sheet()[num].nrows #获得要操作的sheettable = excel.get_sheet(num) for value in n: #xlwt的写方法，参数为行，列，值，行 table.write(rows,num1,value) num1 = num1+1 excel.save(name)","link":"/posts/PythonExcel.html"},{"title":"Pandas","text":"Python Data.Frame panadas导入数据123import pandas as pddata = pandas.read_excel('file.xlsx')data = pandas.read_csv('file.csv') 查看前10行 1print(data.head[10]) 数据集中有多少个列(columns) 1print(data.shape[1]) 打印出全部的列名称 1print(data.columns) 数据集的索引 1print(data.index) panadas.DataFrame 构造函数 1pandas.DataFrame( data, index, columns, dtype, copy) 参数 描述 data 数据采取各种形式，如ndarray：series，map，lists，dict， ，constant和另一个DataFrame index 对于行标签，要用于结果帧的索引是可选缺省值np.arrange(n)，如果没有传递索引值 columns 对于列标签，可选的默认语法是 - np.arange(n)。这只有在没有索引传递的情况下才是这样 dtype 每列的数据类型 copy 如果默认值为False，则此命令（或任何它）用于复制数据 创建数据帧列表创建数据框 空数据帧 1234 # 空数据帧 import pandas as pddf = pd.DataFrame()print(df) 有数据 1234import pandas as pddata = [1,2,3,4,5]df = pd.DataFrame(data)print(df) 有表头 1234import pandas as pddata = [['Alex',10],['Bob',12],['Clarke',13]]df = pd.DataFrame(data,columns=['Name','Age'])print(df) df = pd.DataFrame(data,columns=[‘Name’,’Age’],dtype=float)(设置数据类型) 从ndarrays /列表的字典来创建数据帧1234import pandas as pddata = {'Name':['Tom', 'Jack', 'Steve', 'Ricky'],'Age':[28,34,29,42]}df = pd.DataFrame(data)print(df) 所有的ndarrays必须具有相同的长度。如果传递了索引（index），则索引的长度应等于数组的长度。如果没有传递索引，则默认情况下，索引将为range(n)，其中n为数组长度。 数组创建一个索引的数据帧（DataFrame）1234import pandas as pddata = {'Name':['Tom', 'Jack', 'Steve', 'Ricky'],'Age':[28,34,29,42]}df = pd.DataFrame(data, index=['rank1','rank2','rank3','rank4'])print(df) 字典列表来创建数据帧1234import pandas as pddata = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]df = pd.DataFrame(data)print(df) 字典，行索引和列索引列表创建数据帧 12345678import pandas as pddata = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]#With two column indices, values same as dictionary keysdf1 = pd.DataFrame(data, index=['first', 'second'], columns=['a', 'b'])#With two column indices with one index with other namedf2 = pd.DataFrame(data, index=['first', 'second'], columns=['a', 'b1']) 从系列的字典来创建123456import pandas as pdd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}df = pd.DataFrame(d) 字典的系列可以传递以形成一个DataFrame。 所得到的索引是通过的所有系列索引的并集。 列操作列选择1234567import pandas as pdd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}df = pd.DataFrame(d)print(df ['one']) 列添加1234567891011121314151617import pandas as pdd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}df = pd.DataFrame(d)# Adding a new column to an existing DataFrame object with column label by passing new seriesprint (\"Adding a new column by passing as Series:\")df['three']=pd.Series([10,20,30],index=['a','b','c'])print(df)print (\"Adding a new column using the existing columns in DataFrame:\")df['four']=df['one']+df['three']print(df) 列删除123456789101112131415161718192021# Using the previous DataFrame, we will delete a column# using del functionimport pandas as pdd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd']), 'three' : pd.Series([10,20,30], index=['a','b','c'])}df = pd.DataFrame(d)print (\"Our dataframe is:\")print(df)# using del functionprint (\"Deleting the first column using DEL function:\")del df['one']print(df)# using pop functionprint (\"Deleting another column using POP function:\")df.pop('two')print(df) 行操作行选择1234567import pandas as pdd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}df = pd.DataFrame(d)print(df.loc['b']) 按整数位置选择1234567import pandas as pdd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}df = pd.DataFrame(d)print(df.iloc[2]) 行切片1234567mport pandas as pdd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}df = pd.DataFrame(d)print(df[2:4]) 附加行123456import pandas as pddf = pd.DataFrame([[1, 2], [3, 4]], columns = ['a','b'])df2 = pd.DataFrame([[5, 6], [7, 8]], columns = ['a','b'])df = df.append(df2) 删除行123456789import pandas as pddf = pd.DataFrame([[1, 2], [3, 4]], columns = ['a','b'])df2 = pd.DataFrame([[5, 6], [7, 8]], columns = ['a','b'])df = df.append(df2)# Drop rows with label 0df = df.drop(0) Via Pandas数据帧（DataFrame）","link":"/posts/PythonPandas.html"},{"title":"CSS 选择器","text":"Css 选择器与权重 引入 CSS行间引入12&lt;div style = \"width:100px;height:100px;&gt;&lt;/div&gt; 页面级引入(内嵌式) &lt;head&gt; 和 &lt;/head&gt; 之间1234567&lt;style type=\"css/text\"&gt;.text{ font-size: 20px; padding-left: o; margin: 0 auto;} &lt;/style&gt; 导入式 在style元素中导入CSS文件 1234&lt;style type=\"text/css\"&gt; @import \"CSS样式文件的绝对地址\";@import url(\"样式文件的绝对地址\");&lt;/style&gt; 在CSS文件中再导入CSS文件 12345678/*某个CSS文件*/@import \"另一个CSS文件的地址\";.test{ width: 100px; height: 100px; line-height: 20px; background-color: red; } 链接式 网页的 &lt;head&gt;&lt;/head&gt; 标签对中使用&lt;link&gt; 标记来引入外部样式表文件 1&lt;link type=\"text/css\" rel=\"stylesheet\" href=\"CSS样式文件的地址\"&gt; 选择器基础选择器 选择器 含义 实例 * 通用选择器，匹配任何元素 *{font-size:16px;} E 标签选择器，匹配所有使用E标签的元素 p{font-family:arial;} .error class选择器，匹配所有class属性中包含error的元素 .error{font-weight:bold;} #correct id选择器，匹配所有id属性值为correct的元素 #correct{font-style:italic;} id(唯一) 123&lt;div id=\"only&gt;123&lt;/div&gt; 123#only{ background-color: red; } class 123&lt;div class=\"only&gt;123&lt;/div&gt; 123.only{ background-color: red;} 可以有多个 class 标准选择器 会选择所有相同元素 1234&lt;div&gt;123&lt;/div&gt;...&lt;span&gt;123 123456div { background-color: red;}span{ background-color: green; } 通配符选择器 会匹配所有的元素 123&lt;div&gt;&lt;/div&gt;...&lt;span&gt;&lt;/span&gt; 1234*{ margin:0px; padding:0px;} 组合选择器 选择器 含义 实例 E,F 多元素选择器，同时匹配所有E元素或F元素 div,p{background-attachment:fixed;} E F 后代元素选择器，匹配所有属于E元素的后代F元素 div a{background-color:blue;} E &gt; F 子元素选择器，匹配所有E元素的子元素F div&gt;p{background-image:url(xxx.gif)} E+F 毗邻元素选择器，匹配所有紧随E元素之后的同级元素F p+div{background-position:x% y%} 父子选择器/派生选择器 1234&lt;div&gt; &lt;span&gt; &lt;/span&gt;&lt;/div&gt; 123div span{ background-color: red;} 直接子元素选择器 123456&lt;div&gt; &lt;em&gt;134&lt;/em&gt; &lt;strong&gt; &lt;em&gt;323&lt;/em&gt; &lt;/strong&gt;&lt;/div&gt; 123div &gt; em{ background-color: green;} 并列选择器 123&lt;div&gt;1&lt;/div&gt;&lt;div class =\"demo\"&gt;2&lt;/div&gt;&lt;p class = \"demo1\"&gt;3&lt;/p&gt; 123div.demo{ background-color: green;} 分组选择器 123&lt;em&gt;1&lt;/em&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;spam&gt;3&lt;/spam&gt; 12345em,strong,span{ background-color: red;} 伪类选择器 选择器 含义 E:first-child 匹配父元素E下的第一个子元素 E:link 匹配所有未被点击的链接 E:visited 匹配所有已被点击的链接 E:active 匹配鼠标已经按下、还没有释放的E元素 E:hover 匹配鼠标悬停其上的E元素 E:focus 匹配获得当前焦点的E元素 E:lang(c) 匹配lang属性等于c的E元素 属性选择器 选择器 含义 实例 E[att] 匹配所有具有att属性的E元素 p[style]{background-repeat:repeat-y;} E[att=val] 匹配所有att属性等于“val”的E元素 div[class=”c1”] E[att~=val] 匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素 div[class~=c2] E[att｜=val] 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以“val”开头的E元素 p[lang｜=en] 伪元素 选择器 含义 实例 E:first-line 匹配E元素的第一行 p:first-line{color:red;} E:first-letter 匹配E元素的第一个字母 .c1:first-letter{color:blue;} E:before 在E元素之前插入生成的内容 .ctn before{content:””;display:block;;height:40px;width:40px;} E:after 在E元素之后插入生成的内容 .ctn after{content:””;display:block;;height:40px;width:40px;} 选择器的权重 !important &gt; 行间样式 &gt; id &gt; class | 属性 &gt; 标签选择器 &gt; 通配符 选择器 权重 !important Infinity 行间样式 100 id 100 class、属性、伪累 10 标签、伪属性 1 通配符 0 权重的计算 在比较样式的优先级时，只需统计选择符中的id、class和标签名的个数，然后把相应的权值相加即可，最后根据结果排出优先级 权值较大的优先级越高，权值相同的，后定义的优先级较高，样式值含有！important，优先级最高 div .class1 #people 的权值等于 1+10+100=111 颜色的三种方法纯英文单词 1color: red 十六进制颜色＃RRGGBB，其中 RR（红色），GG（绿色）和 BB（蓝色）。所有值必须介于0和FF之间。 1color: #ff4040 两位相同可以缩写 1color: # f40; RGBRGB（红，绿，蓝）。每个参数（红色，绿色和蓝色）定义颜色的亮度，可在0和255之间，或一个百分比值（从0％到100％）之间的整数。 1background-color:rgba(255,0,0,0.5); 参考 W3School CSS选择器与优先级浅析","link":"/posts/CSSselector.html"},{"title":"HTML 常用标签","text":"HTML 标签 什么是HTMLHyper Text Markup Language，超级文本标记语言 普通文本a:无特殊意义,超级文本:超链接 超文本：文本具备特殊的功能 标记：超文本的组成形式 语言：拥有自己的语法结构 HTML基础语法标记语法标记以封闭类型划分： 封闭类型标记.也称双标记，必须成对出现&lt;标记&gt;内容&lt;/标记&gt; 非封闭类型的标记,也叫做空标记/单标记&lt;标记&gt; 或 &lt;标记/&gt; 例如： 1&lt;a href=“www.baidu.com” id=“baidu-link”&gt;标签内容&lt;/a&gt; a 为标签名，也叫元素； href，id为属性； 双引号中的值为属性值 元素指尖括号及尖括号间所包围的内容部分元素可以包含文本内容和其他元素，也可以是空的a. 包含文本内容： 1&lt;p&gt;这是一段文本&lt;/p&gt; b. 元素嵌套：形成更为复杂的语法 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 注意:（1）嵌套顺序；（2）代码缩进（保证代码可读性） c.空标记 属性和值属性是用来修饰元素的 &lt;标记 属性=”值” 属性=”值”&gt; 1&lt;p align=\"center\" id=\"p1\"&gt;&lt;/p&gt; 常用的标准属性 id： 定义元素在页面中的唯一标识 title：鼠标移入到元素上时提示的文本 class：样式相关，定义元素引用的类选择器 style：样式相关，定义元素的行内样式 注释在源码中编写，但不会被浏览器所解释的内容，成为注释.可以将对代码的解释说明放在注释中 1&lt;!-- 注释内容 --&gt; 文档结构 文档类型声明 指定HTML的版本和风格&lt;!DOCTYPE html&gt; HTML页面表示HTML页面的开始与结束 语法 1&lt;html&gt;&lt;/html&gt; 位于之下 HTML页面 包含页面头部和页面主体两部分 页面头部：定义页面全局信息1&lt;head&gt;&lt;/head&gt; 紧跟在html之后，是html中的首个子元素 头部所包含的内容（子元素） 网页标题：&lt;title&gt;标题内容&lt;/title&gt; 定义网页的编码格式,关键字，描述 网页的编码格式：&lt;meta charset=&quot;utf-8&quot;&gt; 关键字：&lt;meta name=&quot;keywords&quot; content=&quot;关键字&quot;&gt; 描述：&lt;meta name=&quot;description&quot; content=&quot;描述内容&quot;&gt; 定义或引用javascript：&lt;script&gt;&lt;/script&gt; &lt;style&gt;&lt;/style&gt;定义内部样式 &lt;link&gt;引入外部样式 页面主体：网页显示的主体内容1&lt;body&gt;&lt;/body&gt; 属性 text：表示文本颜色S bgcolor：表示网页的背景颜色 简单完整写法如下123456789101112131415&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;title&gt;页面名称&lt;/title&gt; &lt;link rel=”stylesheet“ type=\"text/css\" href=\"文件路径\"/&gt; &lt;style&gt;样式&lt;/style&gt; &lt;script&gt;js脚本&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 常用标签及属性分区元素块分区元素 div ，标签用于组合其他HTML元素，本身无实在意义。 123456&lt;body&gt; &lt;div id=\"wrap\"&gt; &lt;div id=\"collapsed\"&gt;&lt;/div&gt; &lt;div id=\"expanded\"&gt;&lt;/div&gt; /div&gt;&lt;/body&gt; 行内分区元素1&lt;span&gt;&lt;/span&gt; 特点 多个元素在一行内显示 作用 设置同一行文字内的不同格式 标题12345&lt;h1&gt;H1&lt;/h1&gt;&lt;h2&gt;H2&lt;/h2&gt; ...&lt;h3&gt;H3&lt;/h3&gt;&lt;h4&gt;H4&lt;/h4&gt; 改变字号（一级最大，六级最小, 加粗显示,上下有垂直的空白距离,独立成行 链接超链接1&lt;a href = \" https://vitan.me\"&gt;Vitan&lt;/a&gt; 属性 href：链接地址 target：目标，打开新网页的形式 取值： _blank：在新标签页中打开 _self：在自身页面中打开（默认值） title：鼠标放到链接上的提示 Anchor(锚点)1234&lt;a href=\"123.html#001\"&gt;跳到001&lt;/a&gt; ...文字省略 &lt;a name=\"001\" id=\"001\" &gt; &lt;/a&gt; ...文字省略 电话邮件1234567891011&lt;!-- 点击后直接拨打 10086 --&gt;&lt;a href=\"tel:10086\"&gt;10086&lt;/a&gt; &lt;!-- 点击后直接给qq6@qq.com发邮件，主题为：TestObject --&gt;&lt;a href=\"mailto:qq@qq.com?subject=TestObject\"&gt;qq@qq.com&lt;/a&gt; &lt;!-- 点击后直接给10086发信息，消息内容默认为message_body --&gt;&lt;a href=\"sms:10086?body=message_body\"&gt;给 10086 发短信&lt;/a&gt; &lt;!-- 点击后直接发送自己的位置 --&gt;&lt;a href=\"geopoint:116.281469,39.866035\"&gt;我的位置&lt;/a&gt; 协议限定符1&lt;a href = \"javascript:while(1){alert('嘻嘻嘻')}\"&gt;点我呀&lt;/a&gt; 图片1&lt;img src=\"url\" alt=\"some_text\"&gt; url 可为网络，绝对路径，相对路径链接 width：图像宽度 height：图像高度 alt 属性 图片占位符，浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。1&lt;img src=\"boat.gif\" alt=\"Big Boat\"&gt; title 属性 图片提示符1&lt;img src=\"boat.gif\" title=\"Big Boat\"&gt; 列表ol(有序列表)1234&lt;ol type = \"1\" reversed = \"reversed\" start = “2”&gt; &lt;li&gt;Apple&lt;/li&gt; &lt;li&gt;Banana&lt;/li&gt;&lt;/ol&gt; tpye 1 阿拉伯数字 a 小写英文字母 A 大写英文字母 i 小写罗马数字 I 大写罗马数字 reversd 倒叙 start 从第几个开始 ul(无序列表)1234&lt;ul type = &quot;disc&quot;&gt; &lt;li&gt;Apple&lt;/li&gt; &lt;li&gt;Banana&lt;/li&gt;&lt;/ul&gt; type disc 实心圆 square 方形 circle 圆 自定义列表123456&lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;- black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt; 表格12345678910&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; border 不定义边框属性，表格将不显示边框 width ：设置表格的宽度 height：设置表格的高度 align：设置表格的对齐方式，取值: left/center/right border：设置表格边框宽度 cellpadding：内边距（单元格边框与内容之间的距离） cellspacing：外边距（单元格之间的距离） bgcolor：设置表格的背景颜色 包含的子元素： &lt;tr&gt;&lt;/tr&gt;（创建表行） 属性 align：该行内容水平对齐方式，取值: left/center/right valign：该行内容的垂直对齐方式，取值: top/middle/bottom bgcolor：设置表格的背景颜色 &lt;td&gt;&lt;/td&gt; （创建单元格） 属性 align：内容水平对齐方式 valign：内容垂直对齐方式 width ：宽度 height ：高度 &lt;caption&gt;&lt;/caption&gt; （表格标题） （列标题） - 行标题或列标题，字体有加粗的效果，放在tr中 &lt;thead&gt;&lt;/thead&gt;（表头） &lt;tbody&gt;&lt;/tbody&gt; 表主体） &lt;tfoot&gt;&lt;/tfoot&gt; （表尾） 表格表头1234567891011121314&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表单 表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签 来设置:12345&lt;form&gt;.input 元素.&lt;/form&gt; 常用的表单控件 控件名 code 文本框 &lt;input type=&quot;text&quot;&gt; 密码框 &lt;input type=&quot;password&quot;&gt;,专属属性:maxlength：限制输入的字符数，取值：数字，readonly：设置文本控件只读 单选按钮 &lt;input type=&quot;radio&quot;&gt; 复选框 &lt;input type=&quot;checkbox&quot;&gt;,专属属性:checked，设置默认被选中 提交按钮 &lt;input type=&quot;submit&quot;&gt; 重置按钮 &lt;input type=&quot;reset&quot;&gt; 普通按钮 &lt;input type=&quot;button&quot;&gt; 图片按钮 &lt;input type=&quot;image&quot; src=&quot;&quot;&gt; 隐藏域 &lt;input type=&quot;hidden&quot;&gt; 文件选择框 &lt;input type=&quot;file&quot;&gt; 文本域 Text Fields &lt;input type=&quot;text&quot;&gt;标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。1234567&lt;form&gt; First name: &lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br&gt; &lt;!-- 密码字段通过标签&lt;input type=&quot;password&quot;&gt; 来定义--&gt; UserName: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; Password: &lt;input type=&quot;passord&quot; name=&quot;password&quot;&gt;&lt;/form&gt; 单选按钮 Radio Buttons &lt;input type=&quot;radio&quot;&gt; 定义1234&lt;form&gt; &lt;input type=\"radio\" name=\"sex\" value=\"male\"&gt;Male&lt;br&gt; &lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt;Female&lt;/form&gt; 复选框 Checkboxes &lt;input type=&quot;checkbox&quot;&gt; 定义1234&lt;form&gt; &lt;input type=\"checkbox\" name=\"fruit\" value=\"applee\"&gt;Apple&lt;br&gt; &lt;input type=\"checkbox\" name=\"fruit\" value=\"banana\"&gt;Banana&lt;/form&gt; 提交按钮 Submit Button &lt;input type=&quot;submit&quot;&gt;定义1234&lt;form name=\"input\" action=\"html_form_action.php\" method=\"get\"&gt;Username: &lt;input type=\"text\" name=\"user\"&gt;&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt; 实例 123456789&lt;form method = \"get\" action = \"\"&gt; &lt;p&gt; UserName:&lt;input type=\"text\" name=\"username\" style=\"color:#999\" value=\"请输入用户名\" onfocus=\"if(this.value == '请输入用户名'){this.value='';this.style.color='#424242'}\" onblur=\"if(this.value==''){this.value='请输入用户名';this.style.color='#999'}\"&gt; &lt;/p&gt; &lt;p&gt; Password:&lt;input type = \"password\" name = \"password\"&gt; &lt;/p&gt; &lt;input type = \"submit\"&gt;&lt;/form&gt; UserName: Password: #段落 p 默认文字大小,独立成行,上下垂直空白12&lt;p&gt;段1&lt;/p&gt;&lt;p&gt;段2&lt;/p&gt; span1&lt;span&gt;&lt;/span&gt; br 换行 1&lt;br&gt; hr 分割线1&lt;hr&gt; size：尺寸，取值单位为 px（像素），可以省略 width：宽度，取值单位为px（像素）可以省略或百分比 color：颜色，取值自然颜色值 align：水平对齐方式，取值：left/center/right 文本字体加粗123&lt;strong&gt;加粗&lt;/strong&gt;&lt;b&gt;加粗&lt;/b&gt; ##斜体 123&lt;em&gt;斜体&lt;/em&gt;&lt;i&gt;斜体&lt;/i&gt; 删除线123&lt;del&gt;￥30&lt;del&gt;&lt;s&gt;$30&lt;/s&gt; 下划线1&lt;u&gt;&lt;/u&gt; 上下标12&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt; 地址1&lt;address&gt;地址&lt;/address&gt; 编码与解码 显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160; &lt; 小于号 &amp;lt; &amp;#60; &gt; 大于号 &amp;gt; &amp;#62; &amp; 和号 &amp;amp; &amp;#38; “ 引号 &amp;quot; &amp;#34; ‘ 撇号 &amp;apos; (IE不支持) &amp;#39; ￠ 分 &amp;cent; &amp;#162; £ 镑 &amp;pound; &amp;#163; ¥ 日圆 &amp;yen; &amp;#165; € 欧元 &amp;euro; &amp;#8364; § 小节 &amp;sect; &amp;#167; © 版权 &amp;copy; &amp;#169; ® 注册商标 &amp;reg; &amp;#174; ™ 商标 &amp;trade; &amp;#8482; × 乘号 &amp;times; &amp;#215; ÷ 除号 &amp;divide; &amp;#247; More 参考 melody瓶子 W3School","link":"/posts/HTMLTag.html"},{"title":"Excel 函数","text":"Excel 函数 数字处理取绝对值 123=ABS(数字) # 如：ABS(-2) =2 向下取整 123=INT(数字) # 如：INT(5.6)=5 ; INT(5.2)=5 四舍五入 123=ROUND(数字,小数位数) # 如： ROUND(5.6,0)=6 ; ROUND(5.2,0)=5 判断公式 把公式产生的错误值显示为空 123C2=IFERROR(A2/B2,&quot;&quot;) # 如：IFERROR(2/0,&quot;错误&quot;) = &quot;错误&quot; 说明：如果是错误值则显示为空，否则正常显示。 IF多条件判断返回值 1C2=IF(AND(A2&lt;500,B2=&quot;未到期&quot;),&quot;补款&quot;,&quot;&quot;) 说明：两个条件同时成立用AND,任一个成立用OR函数。 统计公式统计两个表格重复的内容 1B2=COUNTIF(Sheet15!A:A,A2) 说明：如果返回值大于0说明在另一个表中存在，0则不存在。 统计不重复的总人数 1C2=SUMPRODUCT(1/COUNTIF(A2:A8,A2:A8)) 说明:用COUNTIF统计出每人的出现次数，用1除的方式把出现次数变成分母，然后相加。 求和公式隔列求和 123H3=SUMIF($A$2:$G$2,H$2,A3:G3) 或=SUMPRODUCT((MOD(COLUMN(B3:G3),2)=0)*B3:G3) 说明：如果标题行没有规则用第2个公式 单条件求和 1F2=SUMIF(A:A,E2,C:C) 说明：SUMIF函数的基本用法 单条件模糊求和 123=SUMIF(A2:A4,&quot;*A*&quot;,C2:C4)=SUMIF(A2:A4,&quot;*A*&quot;,C2:C4)=SUMIF(A2:A4,&quot;*A*&quot;,C2:C4) 说明：如果需要进行模糊求和，就需要掌握通配符的使用，其中星号是表示任意多个字符，如”A“就表示a前和后有任意多个字符，即包含A。 多条件模糊求和 1C11=SUMIFS(C2:C7,A2:A7,A11&amp;&quot;*&quot;,B2:B7,B11) 说明：在sumifs中可以使用通配符* 多表相同位置求和 1b2=SUM(Sheet1:Sheet19!B2) 说明：在表中间删除或添加表后，公式结果会自动更新。 按日期和产品求和 1F2=SUMPRODUCT((MONTH($A$2:$A$25)=F$1)*($B$2:$B$25=$E2)*$C$2:$C$25) 说明：SUMPRODUCT可以完成多条件求和 查找与引用公式单条件查找公式 1C11=VLOOKUP(B11,B3:F7,4,FALSE) 说明：查找是VLOOKUP最擅长的，基本用法 双向查找公式 1=INDEX(C3:H7,MATCH(B10,B3:B7,0),MATCH(C10,C2:H2,0)) 说明：利用MATCH函数查找位置，用INDEX函数取值 查找最后一条符合条件的记录。 1C13 = LOOKUP(1,0/(C5:C10=B13),D5:D10) 说明：0/(条件)可以把不符合条件的变成错误值，而lookup可以忽略错误值 多条件查找 说明:公式原理同上一个公式 指定区域最后一个非空值查找 1B14=LOOKUP(1,0/(B2:B13&lt;&gt;&quot;&quot;),$A2:$A13) 按数字区域间取对应的值 123D9=VLOOKUP(C9,B$4:C$6,2)orD9=LOOKUP(C9,B$4:B6,C$4:C$5) 公式说明：VLOOKUP和LOOKUP函数都可以按区间取值，一定要注意，销售量列的数字一定要升序排列。 字符串处理公式多单元格字符串合并 1C2=PHONETIC(A2:A7) 说明：Phonetic函数只能对字符型内容合并，数字不可以。 截取除后3位之外的部分 1=LEFT(D1,LEN(D1)-3) 说明：LEN计算出总长度,LEFT从左边截总长度-3个 截取-前的部分 1B2=Left(A1,FIND(&quot;-&quot;,A1)-1) 说明：用FIND函数查找位置，用LEFT截取。 截取字符串中任一段的公式 1B1=TRIM(MID(SUBSTITUTE($A1,&quot; &quot;,REPT(&quot; &quot;,20)),20,20)) 说明:公式是利用强插N个空字符的方式进行截取 字符串查找 1B2=IF(COUNT(FIND(&quot;河南&quot;,A2))=0,&quot;否&quot;,&quot;是&quot;) 说明: FIND查找成功，返回字符的位置，否则返回错误值，而COUNT可以统计出数字的 个数，这里可以用来判断查找是否成功。 字符串查找一对多 1B2=IF(COUNT(FIND({&quot;辽宁&quot;,&quot;黑龙江&quot;,&quot;吉林&quot;},A2))=0,&quot;其他&quot;,&quot;东北&quot;) 说明：设置FIND第一个参数为常量数组，用COUNT函数统计FIND查找结果 日期计算公式两日期相隔的年、月、天数计算 A1是开始日期（2011-12-1），B1是结束日期(2013-6-10)。 相隔多少天？=datedif(A1,B1,&quot;d&quot;) 结果：557 相隔多少月? =datedif(A1,B1,&quot;m&quot;)结果：18 相隔多少年? =datedif(A1,B1,&quot;Y&quot;) 结果：1 不考虑年相隔多少月？=datedif(A1,B1,&quot;Ym&quot;) 结果：6 不考虑年相隔多少天？=datedif(A1,B1,&quot;YD&quot;) 结果：192 不考虑年月相隔多少天？=datedif(A1,B1,&quot;MD&quot;)结果：9 datedif函数第3个参数说明： “Y” 时间段中的整年数。 “M” 时间段中的整月数。 “D” 时间段中的天数。 “MD” 天数的差。忽略日期中的月和年。 “YM” 月数的差。忽略日期中的日和年。 “YD” 天数的差。忽略日期中的年。 扣除周末天数的工作日天数 1C2=NETWORKDAYS.INTL(IF(B2&lt;DATE(2015,1,1),DATE(2015,1,1),B2),DATE(2015,1,31),11) 说明：返回两个日期之间的所有工作日数，使用参数指示哪些天是周末，以及有多少天是周末。周末和任何指定为假期的日期不被视为工作日 Via 链接","link":"/posts/ExcelFunction.html"},{"title":"Selenium 马蜂窝评论","text":"Selenium 马蜂窝评论内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 18-11-13 上午11:56# @Author : Vitan# @File : SeleniumMaFengWo.pyfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.common.exceptions import NoSuchAttributeExceptionfrom selenium.common.exceptions import TimeoutExceptionfrom pyquery.pyquery import PyQuery as pqimport pymongobroswer = webdriver.Firefox()wait = WebDriverWait(broswer,10)client = pymongo.MongoClient('localhost')db = client['MaFengWoView']def search_first(url): try: broswer.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.pi.pg-last'))) total = int(broswer.find_element_by_css_selector('.pi.pg-last').get_attribute('data-page')) print(total) place() return total except TimeoutException: return search_first(url)def search_next(page): try: next = broswer.find_element_by_css_selector('.pi.pg-next') next.click() wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pg-current'),str(page))) place() except NoSuchAttributeException: search_next(page)def place(): anchors = broswer.find_elements_by_css_selector('.scenic-list.clearfix li a') for a in anchors: url = a.get_attribute('href') print(url) total = view_first(url) for page in range(2,total+1): view_next(page) # html = broswer.page_source # doc = pq(html) # anchors = doc('.scenic-list.clearfix li a') # for a in anchors.items(): # url = a.attr('href') # print(url)def view_first(url): try: broswer.get(url) wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.pi.pg-last'))) total = int(broswer.find_element_by_css_selector('.pi.pg-last').get_attribute('data-page')) get_view() return total except TimeoutException: return view_first(url)def view_next(page): try: next = broswer.find_element_by_css_selector('.pi.pg-next') next.click() wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pg-current'),str(page))) get_view() except NoSuchAttributeException: view_next(page)def get_view(): html = broswer.page_source doc = pq(html) lis = doc('.rev-item.comment-item.clearfix') for li in lis.items(): view = { 'name':li.find('.name').text().strip(), 'level':li.find('.level').text().strip(), 'txt':li.find('.rev-txt').text().strip() } save_to_mongo(view)def save_to_mongo(view): if db['MaFengWoView'].insert_one(view): print('Saving to MongoDB',view) return True return Falsedef main(): url = 'http://www.mafengwo.cn/jd/10088/gonglve.html' total = search_first(url) for page in range(2,total+1): search_next(page) # print('Clicking',page,'页') # url = 'http://www.mafengwo.cn/poi/449.html' # total = view_first(url) # for page in range(2,total+1): # view_next(page)if __name__=='__main__': main()","link":"/posts/PythonSeleniumMa.html"},{"title":"K-Means 图片压缩","text":"K-means 图片压缩 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 18-11-12 10:10# @Author : Vitanfrom sklearn.datasets import load_sample_imageimport matplotlib.image as imgfrom sklearn.cluster import KMeansimport numpy as npfrom matplotlib import pyplot as plt# 导入图片picture = load_sample_image('china.jpg') # 内置pic2 = img.imread('v.jpg') # 外部# 根据图片的分辨率，可适当降低分辨率。image = picture[::3,::3]# 横纵每三个点去一个颜色值plt.imshow(image)img.imsave('pure.jpg',image)plt.show()# 再用k均值聚类算法，将图片中所有的颜色值做聚类。X = image.reshape(-1,3) #reshape为一维mod = KMeans(n_clusters = 64)labels = mod.fit_predict(X) #每个点的颜色分类，0-63colors = mod.cluster_centers_ #64个聚类中心，颜色值# 还原颜色，维数，数据类型new_img = colors[labels]new_img = new_img.reshape(image.shape)new_img = new_img.astype(np.uint8)print(new_img)# 显示压缩图片plt.imshow(new_img)img.imsave('E://zip.jpg',new_img)plt.show()","link":"/posts/PythonSklearnImage.html"},{"title":"Python Matplotlib 各种图","text":"Matplotlib 各种图 垂直条形图1234567891011121314151617181920212223242526# 导入绘图模块import matplotlib.pyplot as plt# 构建数据GDP = [12406.8,13908.57,9386.87,9143.64]# 中文乱码的处理plt.rcParams['font.sans-serif'] =['SimHei']plt.rcParams['axes.unicode_minus'] = False# 绘图plt.bar(range(4), GDP, align = 'center',color='steelblue', alpha = 0.8)# 添加轴标签plt.ylabel('GDP')# 添加标题plt.title('四个直辖市GDP大比拼')# 添加刻度标签plt.xticks(range(4),['北京市','上海市','天津市','重庆市'])# 设置Y轴的刻度范围plt.ylim([5000,15000])# 为每个条形图添加数值标签for x,y in enumerate(GDP): plt.text(x,y+100,'%s' %round(y,1),ha='center')plt.savefig('垂直条形图.png')# 显示图形plt.show() 解析 由于matplotlib对中文的支持并不是很友好，所以需要提前对绘图进行字体的设置，即通过rcParams来设置字体，这里将字体设置为微软雅黑，同时为了避免坐标轴不能正常的显示负号，也需要进行设置； bar 函数指定了条形图的x轴、y轴值，设置x轴刻度标签为水平居中，条形图的填充色color为铁蓝色，同时设置透明度alpha为0.8； 添加y轴标签、标题、x轴刻度标签值，为了让条形图显示各柱体之间的差异，将y轴范围设置在5000~15000； 通过循环的方式，添加条形图的数值标签； 水平条形图1234567891011121314151617181920212223242526# 导入绘图模块import matplotlib.pyplot as plt# 构建数据price = [39.5,39.9,45.4,38.9,33.34]# 中文乱码的处理plt.rcParams['font.sans-serif'] =['SimHei']plt.rcParams['axes.unicode_minus'] = False# 绘图plt.barh(range(5), price, align = 'center',color='steelblue', alpha = 0.8)# 添加轴标签plt.xlabel('价格')# 添加标题plt.title('不同平台书的最低价比较')# 添加刻度标签plt.yticks(range(5),['亚马逊','当当网','中国图书网','京东','天猫'])# 设置Y轴的刻度范围plt.xlim([32,47])# 为每个条形图添加数值标签for x,y in enumerate(price): plt.text(y+0.1,x,'%s' %y,va='center')plt.savefig('水平条形图.png')# 显示图形 plt.show() 水平交错条形图12345678910111213141516171819202122232425262728293031323334353637# 导入绘图模块import matplotlib.pyplot as pltimport numpy as np# 构建数据Y2016 = [15600,12700,11300,4270,3620]Y2017 = [17400,14800,12000,5200,4020]labels = ['北京','上海','香港','深圳','广州']bar_width = 0.45# 中文乱码的处理plt.rcParams['font.sans-serif'] =['SimHei']plt.rcParams['axes.unicode_minus'] = False# 绘图plt.bar(np.arange(5), Y2016, label = '2016', color = 'steelblue', alpha = 0.8, width = bar_width)plt.bar(np.arange(5)+bar_width, Y2017, label = '2017', color = 'indianred', alpha = 0.8, width = bar_width)# 添加轴标签plt.xlabel('Top5城市')plt.ylabel('家庭数量')# 添加标题plt.title('亿万财富家庭数Top5城市分布')# 添加刻度标签plt.xticks(np.arange(5)+bar_width,labels)# 设置Y轴的刻度范围plt.ylim([2500, 19000])# 为每个条形图添加数值标签for x2016,y2016 in enumerate(Y2016): plt.text(x2016, y2016+100, '%s' %y2016)for x2017,y2017 in enumerate(Y2017): plt.text(x2017+bar_width, y2017+100, '%s' %y2017)# 显示图例plt.legend()plt.savefig('水平交错条形图.png')# 显示图形plt.show() 垂直堆叠条形图12345678910111213141516171819202122232425262728293031323334353637# 导入模块import matplotlib.pyplot as pltimport numpy as npimport pandas as pd# 导入数据data = pd.read_excel('C:\\\\Users\\\\Administrator\\\\Desktop\\\\货运.xls')# 绘图plt.bar(np.arange(8), data.loc[0,:][1:], color = 'red', alpha = 0.8, label = '铁路', align = 'center')plt.bar(np.arange(8), data.loc[1,:][1:], bottom = data.loc[0,:][1:], color = 'green', alpha = 0.8, label = '公路', align = 'center')plt.bar(np.arange(8), data.loc[2,:][1:], bottom = data.loc[0,:][1:]+data.loc[1,:][1:], color = 'm', alpha = 0.8, label = '水运', align = 'center')plt.bar(np.arange(8), data.loc[3,:][1:], bottom = data.loc[0,:][1:]+data.loc[1,:][1:]+data.loc[2,:][1:], color = 'black', alpha = 0.8, label = '民航', align = 'center')# 添加轴标签plt.xlabel('月份')plt.ylabel('货物量(万吨)')# 添加标题plt.title('2017年各月份物流运输量')# 添加刻度标签plt.xticks(np.arange(8),data.columns[1:])# 设置Y轴的刻度范围plt.ylim([0,500000])# 为每个条形图添加数值标签for x_t,y_t in enumerate(data.loc[0,:][1:]): plt.text(x_t,y_t/2,'%sW' %(round(y_t/10000,2)),ha='center', color = 'white')for x_g,y_g in enumerate(data.loc[0,:][1:]+data.loc[1,:][1:]): plt.text(x_g,y_g/2,'%sW' %(round(y_g/10000,2)),ha='center', color = 'white')for x_s,y_s in enumerate(data.loc[0,:][1:]+data.loc[1,:][1:]+data.loc[2,:][1:]): plt.text(x_s,y_s-20000,'%sW' %(round(y_s/10000,2)),ha='center', color = 'white') # 显示图例plt.legend(loc='upper center', ncol=4)# 显示图形 plt.show() matplotlib(饼图)pie 函数参数解读饼图的绘制可以使用matplotlib库中的pie函数 12345plt.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False) 参数 说明 x 指定绘图的数据 explode 指定饼图某些部分的突出显示，即呈现爆炸式 labels 为饼图添加标签说明，类似于图例说明 colors 指定饼图的填充色 autopct 自动添加百分比显示，可以采用格式化的方法显示 pctdistance 设置百分比标签与圆心的距离 shadow 是否添加饼图的阴影效果 labeldistance 设置各扇形标签（图例）与圆心的距离 startangle 设置饼图的初始摆放角度 radius 设置饼图的半径大小 counterclock 是否让饼图按逆时针顺序呈现 wedgeprops 设置饼图内外边界的属性，如边界线的粗细、颜色等 textprops 设置饼图中文本的属性，如字体大小、颜色等 center 定饼图的中心点位置，默认为原点 frame 是否要显示饼图背后的图框，如果设置为True的话，需要同时控制图框x轴、y轴的范围和饼图的中心位置 绘制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 导入第三方模块import matplotlib.pyplot as plt# 设置绘图的主题风格（不妨使用R中的ggplot分隔）plt.style.use('ggplot')# 构造数据edu = [0.2515,0.3724,0.3336,0.0368,0.0057]labels = ['中专','大专','本科','硕士','其他']explode = [0,0.1,0,0,0] # 用于突出显示大专学历人群colors=['#9999ff','#ff9999','#7777aa','#2442aa','#dd5555'] # 自定义颜色# 中文乱码和坐标轴负号的处理plt.rcParams['font.sans-serif'] = ['SimHei']plt.rcParams['axes.unicode_minus'] = False# 将横、纵坐标轴标准化处理，保证饼图是一个正圆，否则为椭圆plt.axes(aspect='equal')# 控制x轴和y轴的范围plt.xlim(0,4)plt.ylim(0,4)# 绘制饼图plt.pie(x = edu, # 绘图数据 explode=explode, # 突出显示大专人群 labels=labels, # 添加教育水平标签 colors=colors, # 设置饼图的自定义填充色 autopct='%.1f%%', # 设置百分比的格式，这里保留一位小数 pctdistance=0.8, # 设置百分比标签与圆心的距离 labeldistance = 1.15, # 设置教育水平标签与圆心的距离 startangle = 180, # 设置饼图的初始角度 radius = 1.5, # 设置饼图的半径 counterclock = False, # 是否逆时针，这里设置为顺时针方向 wedgeprops = {'linewidth': 1.5, 'edgecolor':'green'},# 设置饼图内外边界的属性值 textprops = {'fontsize':12, 'color':'k'}, # 设置文本标签的属性值 center = (1.8,1.8), # 设置饼图的原点 frame = 1 )# 是否显示饼图的图框，这里设置显示# 删除x轴和y轴的刻度plt.xticks(())plt.yticks(())# 添加图标题plt.title('芝麻信用失信用户教育水平分布')plt.savefig('饼图.png')# 显示图形plt.show() matplotlib(箱线图)boxplot函数的参数解读1234567plt.boxplot(x, notch=None, sym=None, vert=None, whis=None, positions=None, widths=None, patch_artist=None, meanline=None, showmeans=None, showcaps=None, showbox=None, showfliers=None, boxprops=None, labels=None, flierprops=None, medianprops=None, meanprops=None, capprops=None, whiskerprops=None) 参数 说明 x 指定要绘制箱线图的数据 notch 是否是凹口的形式展现箱线图，默认非凹口 sym 指定异常点的形状，默认为+号显示 vert 是否需要将箱线图垂直摆放，默认垂直摆放； whis 指定上下须与上下四分位的距离，默认为1.5倍的四分位差 positions 指定箱线图的位置，默认为[0,1,2…] widths 指定箱线图的宽度，默认为0.5 patch_artist 是否填充箱体的颜色 meanline 是否用线的形式表示均值，默认用点来表示 showmeans 是否显示均值，默认不显示 showcaps 是否显示箱线图顶端和末端的两条线，默认显示 showbox 是否显示箱线图的箱体，默认显示 showfliers 是否显示异常值，默认显示 boxprops 设置箱体的属性，如边框色，填充色等 labels 为箱线图添加标签，类似于图例的作用 filerprops 设置异常值的属性，如异常点的形状、大小、填充色等 medianprops 设置中位数的属性，如线的类型、粗细等 meanprops 设置均值的属性，如点的大小、颜色等 capprops 设置箱线图顶端和末端线条的属性，如颜色、粗细等 whiskerprops 设置须的属性，如颜色、粗细、线的类型等 绘制123456789101112131415161718192021222324252627282930313233# 导入第三方模块import pandas as pdimport matplotlib.pyplot as plt# 读取Titanic数据集titanic = pd.read_csv('titanic_train.csv')# 检查年龄是否有缺失any(titanic.Age.isnull())# 不妨删除含有缺失年龄的观察titanic.dropna(subset=['Age'], inplace=True)# 设置图形的显示风格plt.style.use('ggplot')# 设置中文和负号正常显示plt.rcParams['font.sans-serif'] = 'SimHei'plt.rcParams['axes.unicode_minus'] = False# 绘图：整体乘客的年龄箱线图plt.boxplot(x = titanic.Age, # 指定绘图数据 patch_artist=True, # 要求用自定义颜色填充盒形图，默认白色填充 showmeans=True, # 以点的形式显示均值 boxprops = {'color':'black','facecolor':'#9999ff'}, # 设置箱体属性，填充色和边框色 flierprops = {'marker':'o','markerfacecolor':'red','color':'black'}, # 设置异常值属性，点的形状、填充色和边框色 meanprops = {'marker':'D','markerfacecolor':'indianred'}, # 设置均值点的属性，点的形状、填充色 medianprops = {'linestyle':'--','color':'orange'}) # 设置中位数线的属性，线的类型和颜色# 设置y轴的范围plt.ylim(0,85)# 去除箱线图的上边框与右边框的刻度标签plt.tick_params(top='off', right='off')# 显示图形plt.show() 123456789101112131415161718192021# 按舱级排序，为了后面正常显示分组盒形图的顺序titanic.sort_values(by = 'Pclass', inplace=True)# 通过for循环将不同仓位的年龄人群分别存储到列表Age变量中Age = []Levels = titanic.Pclass.unique()for Pclass in Levels: Age.append(titanic.loc[titanic.Pclass==Pclass,'Age'])# 绘图plt.boxplot(x = Age, patch_artist=True, labels = ['一等舱','二等舱','三等舱'], # 添加具体的标签名称 showmeans=True, boxprops = {'color':'black','facecolor':'#9999ff'}, flierprops = {'marker':'o','markerfacecolor':'red','color':'black'}, meanprops = {'marker':'D','markerfacecolor':'indianred'}, medianprops = {'linestyle':'--','color':'orange'})# 显示图形plt.show() matplotlib(直方图)hist函数的参数解读12345plt.hist(x, bins=10, range=None, normed=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False) 参数 说明 x 指定要绘制直方图的数据 bins 指定直方图条形的个数 range 指定直方图数据的上下界，默认包含绘图数据的最大值和最小值 normed 是否将直方图的频数转换成频率 weights 该参数可为每一个数据点设置权重 cumulative 是否需要计算累计频数或频率 bottom 可以为直方图的每个条形添加基准线，默认为0 histtype 指定直方图的类型，默认为bar，除此还有’barstacked’, ‘step’, ‘stepfilled’ align 设置条形边界值的对其方式，默认为mid，除此还有’left’和’right’ orientation 设置直方图的摆放方向，默认为垂直方向 rwidth 设置直方图条形宽度的百分比 log 是否需要对绘图数据进行log变换 color 设置直方图的填充色 label 设置直方图的标签，可通过legend展示其图例 stacked 当有多个数据时，是否需要将直方图呈堆叠摆放，默认水平摆放 一元直方图的绘制1234567891011121314151617181920212223242526272829303132# 导入第三方包import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport matplotlib.mlab as mlab# 中文和负号的正常显示plt.rcParams['font.sans-serif'] = ['SimHei']plt.rcParams['axes.unicode_minus'] = False# 读取Titanic数据集titanic = pd.read_csv('titanic_train.csv')# 检查年龄是否有缺失any(titanic.Age.isnull())# 不妨删除含有缺失年龄的观察titanic.dropna(subset=['Age'], inplace=True)# 设置图形的显示风格plt.style.use('ggplot')# 绘图：乘客年龄的频数直方图plt.hist(titanic.Age, # 绘图数据 bins = 20, # 指定直方图的条形数为20个 color = 'steelblue', # 指定填充色 edgecolor = 'k', # 指定直方图的边界色 label = '直方图' )# 为直方图呈现标签# 去除图形顶部边界和右边界的刻度plt.tick_params(top='off', right='off')# 显示图例plt.legend()plt.savefig('直方图.png')# 显示图形plt.show() 累计频率直方图 上图绘制的是年龄的频数直方图，从整体的分布来看，有点像正态分布，两边低中间高的倒钟形状。除此，我们还可以绘制累计频率直方图，并且设置5岁为组距，如下代码可以表示成： 12345678910111213141516171819202122# 绘图：乘客年龄的累计频率直方图plt.hist(titanic.Age, # 绘图数据 bins = np.arange(titanic.Age.min(),titanic.Age.max(),5), # 指定直方图的组距 normed = True, # 设置为频率直方图 cumulative = True, # 积累直方图 color = 'steelblue', # 指定填充色 edgecolor = 'k', # 指定直方图的边界色 label = '直方图' )# 为直方图呈现标签# 设置坐标轴标签和标题plt.title('乘客年龄的频率累计直方图')plt.xlabel('年龄')plt.ylabel('累计频率')# 去除图形顶部边界和右边界的刻度plt.tick_params(top='off', right='off')# 显示图例plt.legend(loc = 'best')plt.savefig('乘客年龄的累计频率直方图.png')# 显示图形plt.show() 正太分布图 通过累计频率直方图就可以快速的发现什么年龄段的人数占了多少比重，例如35岁以下的乘客占了7成，这种图的解读有点像帕累托图。为了测试数据集是否近似服从正态分布，需要在直方图的基础上再绘制两条线，一条表示理论的正态分布曲线，另一条为核密度曲线，目的就是比较两条曲线的吻合度，越吻合就说明数据越近似于正态分布。接下来我们就在直方图的基础上再添加两条曲线： 1234567891011121314151617181920212223242526272829303132# 正太分布图plt.hist(titanic.Age, # 绘图数据 bins = np.arange(titanic.Age.min(),titanic.Age.max(),5), # 指定直方图的组距 normed = True, # 设置为频率直方图 color = 'steelblue', # 指定填充色 edgecolor = 'k') # 指定直方图的边界色# 设置坐标轴标签和标题plt.title('乘客年龄直方图')plt.xlabel('年龄')plt.ylabel('频率')# 生成正态曲线的数据x1 = np.linspace(titanic.Age.min(), titanic.Age.max(), 1000)normal = mlab.normpdf(x1, titanic.Age.mean(), titanic.Age.std())# 绘制正态分布曲线line1, = plt.plot(x1,normal,'r-', linewidth = 2)# 生成核密度曲线的数据kde = mlab.GaussianKDE(titanic.Age)x2 = np.linspace(titanic.Age.min(), titanic.Age.max(), 1000)# 绘制line2, = plt.plot(x2,kde(x2),'g-', linewidth = 2)# 去除图形顶部边界和右边界的刻度plt.tick_params(top='off', right='off')# 显示图例plt.legend([line1, line2],['正态分布曲线','核密度曲线'],loc='best')plt.savefig('正太分布图.png')# 显示图形plt.show() 二元直方图的绘制 上面绘制的直方图都是基于所有乘客的年龄，如果想对比男女乘客的年龄直方图的话，我们可以通过两个hist将不同性别的直方图绘制到一张图内，具体代码如下： 123456789101112131415161718192021222324# 提取不同性别的年龄数据age_female = titanic.Age[titanic.Sex == 'female']age_male = titanic.Age[titanic.Sex == 'male']# 设置直方图的组距bins = np.arange(titanic.Age.min(), titanic.Age.max(), 2)# 男性乘客年龄直方图plt.hist(age_male, bins = bins, label = '男性', color = 'steelblue', alpha = 0.7)# 女性乘客年龄直方图plt.hist(age_female, bins = bins, label = '女性', alpha = 0.6)# 设置坐标轴标签和标题plt.title('乘客年龄直方图')plt.xlabel('年龄')plt.ylabel('人数')# 去除图形顶部边界和右边界的刻度plt.tick_params(top='off', right='off')# 显示图例plt.legend()plt.savefig('二元直方图.png')# 显示图形plt.show() matplotlib(折线图)plot函数的参数解读1234plt.hist(x,y,linestyle, linewidth,color,marker, markersize,markeredgecolor, markerfactcolor,label,alpha) 参数 说明 x 指定折线图的x轴数据 y 指定折线图的y轴数据 linestyle 指定折线的类型，可以是实线、虚线、点虚线、点点线等，默认文实线 linewidth 指定折线的宽度 marker 可以为折线图添加点，该参数是设置点的形状 markersize 设置点的大小 markeredgecolor 设置点的边框色 markerfactcolor 设置点的填充色 label 为折线图添加标签，类似于图例的作用 一元折线图的绘制1234567891011121314151617181920212223242526272829303132333435363738394041# 导入模块import pandas as pdimport matplotlib.pyplot as plt# 设置绘图风格plt.style.use('ggplot')# 设置中文编码和负号的正常显示plt.rcParams['font.sans-serif'] = 'SimHei'plt.rcParams['axes.unicode_minus'] = False# 读取需要绘图的数据article_reading = pd.read_excel('wechart.xlsx')# 取出8月份至9月28日的数据sub_data = article_reading.loc[article_reading.date &gt;= '2017-08-01' ,:]# 设置图框的大小fig = plt.figure(figsize=(10,6))# 绘图plt.plot(sub_data.date, # x轴数据 sub_data.article_reading_cnts, # y轴数据 linestyle = '-', # 折线类型 linewidth = 2, # 折线宽度 color = 'steelblue', # 折线颜色 marker = 'o', # 点的形状 markersize = 6, # 点的大小 markeredgecolor='black', # 点的边框色 markerfacecolor='brown') # 点的填充色# 添加标题和坐标轴标签plt.title('公众号每天阅读人数趋势图')plt.xlabel('日期')plt.ylabel('人数')# 剔除图框上边界和右边界的刻度plt.tick_params(top = 'off', right = 'off')# 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且45度倾斜fig.autofmt_xdate(rotation = 45)# 显示图形plt.show() 由于x轴是日期型数据，当数据量一多的时候，就会导致刻度标签的重叠或拥挤，为了防止重叠的产生，我们需要让日期型的x轴刻度标签自动展现，从而避免重叠的现象 图形优化12345678910111213141516171819202122232425262728293031323334353637383940# 导入模块import matplotlib as mpl# 设置图框的大小fig = plt.figure(figsize=(10,6))# 绘图plt.plot(sub_data.date, # x轴数据 sub_data.article_reading_cnts, # y轴数据 linestyle = '-', # 折线类型 linewidth = 2, # 折线宽度 color = 'steelblue', # 折线颜色 marker = 'o', # 点的形状 markersize = 6, # 点的大小 markeredgecolor='black', # 点的边框色 markerfacecolor='steelblue') # 点的填充色# 添加标题和坐标轴标签plt.title('公众号每天阅读人数趋势图')plt.xlabel('日期')plt.ylabel('人数')# 剔除图框上边界和右边界的刻度plt.tick_params(top = 'off', right = 'off')# 获取图的坐标信息ax = plt.gca()# 设置日期的显示格式 date_format = mpl.dates.DateFormatter(\"%Y-%m-%d\") ax.xaxis.set_major_formatter(date_format)# 设置x轴显示多少个日期刻度#xlocator = mpl.ticker.LinearLocator(10)# 设置x轴每个刻度的间隔天数xlocator = mpl.ticker.MultipleLocator(5)ax.xaxis.set_major_locator(xlocator)# 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且45度倾斜fig.autofmt_xdate(rotation = 45)# 显示图形 多元折线图的绘制 如果你需要在一张图形中画上两条折线图，也很简单，只需要在代码中写入两次plot函数即可，其他都不需要改动了。具体可以参考下面的代码逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 设置图框的大小fig = plt.figure(figsize=(10,6))# 绘图--阅读人数趋势plt.plot(sub_data.date, # x轴数据 sub_data.article_reading_cnts, # y轴数据 linestyle = '-', # 折线类型 linewidth = 2, # 折线宽度 color = 'steelblue', # 折线颜色 marker = 'o', # 点的形状 markersize = 6, # 点的大小 markeredgecolor='black', # 点的边框色 markerfacecolor='steelblue', # 点的填充色 label = '阅读人数') # 添加标签# 绘图--阅读人次趋势plt.plot(sub_data.date, # x轴数据 sub_data.article_reading_times, # y轴数据 linestyle = '-', # 折线类型 linewidth = 2, # 折线宽度 color = '#ff9999', # 折线颜色 marker = 'o', # 点的形状 markersize = 6, # 点的大小 markeredgecolor='black', # 点的边框色 markerfacecolor='#ff9999', # 点的填充色 label = '阅读人次') # 添加标签# 添加标题和坐标轴标签plt.title('公众号每天阅读人数和人次趋势图')plt.xlabel('日期')plt.ylabel('人数')# 剔除图框上边界和右边界的刻度plt.tick_params(top = 'off', right = 'off')# 获取图的坐标信息ax = plt.gca()# 设置日期的显示格式 date_format = mpl.dates.DateFormatter('%m-%d') ax.xaxis.set_major_formatter(date_format)# 设置x轴显示多少个日期刻度#xlocator = mpl.ticker.LinearLocator(10)# 设置x轴每个刻度的间隔天数xlocator = mpl.ticker.MultipleLocator(3)ax.xaxis.set_major_locator(xlocator)# 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且45度倾斜fig.autofmt_xdate(rotation = 45)# 显示图例plt.legend()# 显示图形plt.show() matplotlib(散点图)scatter函数的参数解读123456lt.scatter(x, y, s=20, c=None, marker='o', cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, edgecolors=None) 参数 说明 x 指定散点图的x轴数据 y 指定散点图的y轴数据 s 指定散点图点的大小，默认为20，通过传入新的变量，实现气泡图的绘制 c 指定散点图点的颜色，默认为蓝色 marker 指定散点图点的形状，默认为圆形 cmap 指定色图，只有当c参数是一个浮点型的数组的时候才起作用 norm 设置数据亮度，标准化到0~1之间，使用该参数仍需要c为浮点型的数组 vmin、vmax 亮度设置，与norm类似，如果使用了norm则该参数无效 alpha 设置散点的透明度 linewidths 设置散点边界线的宽度 edgecolors 设置散点边界线的颜色 一般散点图的绘制12345678910111213141516171819202122232425262728293031323334# 导入模块import pandas as pdimport matplotlib.pyplot as plt# 设置绘图风格plt.style.use('ggplot')# 设置中文编码和负号的正常显示plt.rcParams['font.sans-serif'] = 'SimHei'plt.rcParams['axes.unicode_minus'] = False# 读入数据cars = pd.read_csv('cars.csv')# 绘图plt.scatter(cars.speed, # x轴数据为汽车速度 cars.dist, # y轴数据为汽车的刹车距离 s = 30, # 设置点的大小 c = 'steelblue', # 设置点的颜色 marker = 's', # 设置点的形状 alpha = 0.9, # 设置点的透明度 linewidths = 0.3, # 设置散点边界的粗细 edgecolors = 'red' # 设置散点边界的颜色 )# 添加轴标签和标题plt.title('汽车速度与刹车距离的关系')plt.xlabel('汽车速度')plt.ylabel('刹车距离')# 去除图边框的顶部刻度和右边刻度plt.tick_params(top = 'off', right = 'off')plt.savefig('一般散点图.png')# 显示图形plt.show() 分组散点图的绘制12345678910111213141516171819202122232425262728293031# 读取数据iris = pd.read_csv('iris.csv')# 设置中文编码和负号的正常显示plt.rcParams['font.sans-serif'] = 'SimHei'plt.rcParams['axes.unicode_minus'] = False# 自定义颜色colors = ['steelblue', '#9999ff', '#ff9999']# 三种不同的花品种Species = iris.Species.unique()# 通过循环的方式，完成分组散点图的绘制for i in range(len(Species)): plt.scatter(iris.loc[iris.Species == Species[i], 'Petal.Length'], iris.loc[iris.Species == Species[i], 'Petal.Width'], s = 35, c = colors[i], label = Species[i])# 添加轴标签和标题plt.title('花瓣长度与宽度的关系')plt.xlabel('花瓣长度')plt.ylabel('花瓣宽度')# 去除图边框的顶部刻度和右边刻度plt.tick_params(top = 'off', right = 'off')# 添加图例plt.legend(loc = 'upper left')plt.savefig('分组散点图.png')# 显示图形plt.show() 气泡图的绘制 12345678910111213141516171819202122232425262728293031323334# 导入第三方包import numpy as np# 设置中文编码和负号的正常显示plt.rcParams['font.sans-serif'] = 'SimHei'plt.rcParams['axes.unicode_minus'] = False# 读取数据sales = pd.read_excel('sales.xlsx')# 绘制气泡图plt.scatter(sales.finish_ratio, sales.profit_ratio, c = 'steelblue', s = sales.tot_target/30, edgecolor = 'black')# 改变轴刻度的显示方式（百分比形式）plt.xticks(np.arange(0,1,0.1), [str(i*100)+'%' for i in np.arange(0,1,0.1)])plt.yticks(np.arange(0,1,0.1), [str(i*100)+'%' for i in np.arange(0,1,0.1)])# 设置x轴和y轴的数值范围plt.xlim(0.2, 0.7)plt.ylim(0.25, 0.85)# 添加轴标签和标题plt.title('完成率与利润率的关系')plt.xlabel('完成率')plt.ylabel('利润率')# 去除图边框的顶部刻度和右边刻度plt.tick_params(top = 'off', right = 'off')# 显示图形plt.show() 散点图+线性回归线123456789101112131415161718192021222324252627282930313233# 导入第三方模块from sklearn.linear_model import LinearRegression# 散点图plt.scatter(cars.speed, # x轴数据为汽车速度 cars.dist, # y轴数据为汽车的刹车距离 s = 30, # 设置点的大小 c = 'black', # 设置点的颜色 marker = 'o', # 设置点的形状 alpha = 0.9, # 设置点的透明度 linewidths = 0.3, # 设置散点边界的粗细 label = '观测点' )# 建模reg = LinearRegression().fit(cars.speed.reshape(-1,1), cars.dist)# 回归预测值pred = reg.predict(cars.speed.reshape(-1,1))# 绘制回归线plt.plot(cars.speed, pred, linewidth = 2, label = '回归线')# 添加轴标签和标题plt.title('汽车速度与刹车距离的关系')plt.xlabel('汽车速度')plt.ylabel('刹车距离')# 去除图边框的顶部刻度和右边刻度plt.tick_params(top = 'off', right = 'off')# 显示图例plt.legend(loc = 'upper left')# 显示图形plt.show() matplotlib(雷达图)1234567891011121314151617181920212223242526272829303132333435363738394041# 导入第三方模块import numpy as npimport matplotlib.pyplot as plt# 中文和负号的正常显示plt.rcParams['font.sans-serif'] = 'SimHei'plt.rcParams['axes.unicode_minus'] = False# 使用ggplot的绘图风格plt.style.use('ggplot')# 构造数据values = [3.2,2.1,3.5,2.8,3]feature = ['个人能力','QC知识','解决问题能力','服务质量意识','团队精神']N = len(values)# 设置雷达图的角度，用于平分切开一个圆面angles=np.linspace(0, 2*np.pi, N, endpoint=False)# 为了使雷达图一圈封闭起来，需要下面的步骤values=np.concatenate((values,[values[0]]))angles=np.concatenate((angles,[angles[0]]))# 绘图fig=plt.figure()# 这里一定要设置为极坐标格式ax = fig.add_subplot(111, polar=True)# 绘制折线图ax.plot(angles, values, 'o-', linewidth=2)# 填充颜色ax.fill(angles, values, alpha=0.25)# 添加每个特征的标签ax.set_thetagrids(angles * 180/np.pi, feature)# 设置雷达图的范围ax.set_ylim(0,5)# 添加标题plt.title('活动前后员工状态表现')# 添加网格线ax.grid(True)# 显示图形plt.show() 多条线的雷达图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 导入第三方模块import numpy as npimport matplotlib.pyplot as plt# 中文和负号的正常显示plt.rcParams['font.sans-serif'] = 'SimHei'plt.rcParams['axes.unicode_minus'] = False# 使用ggplot的绘图风格plt.style.use('ggplot')# 构造数据values = [3.2,2.1,3.5,2.8,3]values2 = [4,4.1,4.5,4,4.1]feature = ['个人能力','QC知识','解决问题能力','服务质量意识','团队精神']N = len(values)# 设置雷达图的角度，用于平分切开一个圆面angles=np.linspace(0, 2*np.pi, N, endpoint=False)# 为了使雷达图一圈封闭起来，需要下面的步骤values=np.concatenate((values,[values[0]]))values2=np.concatenate((values2,[values2[0]]))angles=np.concatenate((angles,[angles[0]]))# 绘图fig=plt.figure()ax = fig.add_subplot(111, polar=True)# 绘制折线图ax.plot(angles, values, 'o-', linewidth=2, label = '活动前')# 填充颜色ax.fill(angles, values, alpha=0.25)# 绘制第二条折线图ax.plot(angles, values2, 'o-', linewidth=2, label = '活动后')ax.fill(angles, values2, alpha=0.25)# 添加每个特征的标签ax.set_thetagrids(angles * 180/np.pi, feature)# 设置雷达图的范围ax.set_ylim(0,5)# 添加标题plt.title('活动前后员工状态表现')# 添加网格线ax.grid(True)# 设置图例plt.legend(loc = 'best')# 显示图形plt.show() pygal模块则提供了更加简单的雷达图函数12345678910111213141516# 导入第三方模块import pygal# 调用Radar这个类，并设置雷达图的填充，及数据范围radar_chart = pygal.Radar(fill = True, range=(0,5))# 添加雷达图的标题radar_chart.title = '活动前后员工状态表现'# 添加雷达图各顶点的含义radar_chart.x_labels = ['个人能力','QC知识','解决问题能力','服务质量意识','团队精神']# 绘制两条雷达图区域radar_chart.add('活动前', [3.2,2.1,3.5,2.8,3])radar_chart.add('活动后', [4,4.1,4.5,4,4.1])# 保存图像radar_chart.render_to_file('radar_chart.svg') matplotlib(面积图)stackplot函数语法及参数含义1stackplot(x,*args,**kargs) 参数 说明 x 指定面积图的x轴数据 *args 为可变参数，可以接受任意多的y轴数据，即各个拆分的数据对象 **kargs 为关键字参数，可以通过传递其他参数来修饰面积图，如标签、颜色 可用的关键字参数： 参数 说明 labels 以列表的形式传递每一块面积图包含的标签，通过图例展现 colors 设置不同的颜色填充面积图 123456789101112131415161718192021222324252627282930313233343536373839404142434445# ========== Python3 + Jupyter ========== ## 导入第三方模块import pandas as pdimport numpy as npimport matplotlib.pyplot as plt# 设置图形的显示风格plt.style.use('ggplot')# 设置中文和负号正常显示plt.rcParams['font.sans-serif'] = 'SimHei'plt.rcParams['axes.unicode_minus'] = False# 读取数据transport = pd.read_excel('transport.xls')# 窥探数据框的前5行transport.head()# 折线图的x变量值，即Jan（一月份）到Aug（八月份）8个值N = np.arange(transport.shape[1]-1)# 绘制拆分的折线图labels = transport.Indexchannel = transport.columns[1:]for i in range(transport.shape[0]): plt.plot(N, # x坐标 transport.loc[i,'Jan':'Aug'], # y坐标 label = labels[i], # 添加标签 marker = 'o', # 给折线图添加圆形点 linewidth = 2 # 设置线的宽度 )# 添加标题和坐标轴标签plt.title('2017年各运输渠道的运输量')plt.ylabel('运输量(万吨)')# 修改x轴的刻度标签plt.xticks(N,channel)# 剔除图框上边界和右边界的刻度plt.tick_params(top = 'off', right = 'off')# 显示图例（即显示label的效果） plt.legend(loc = 'best') # 显示图形plt.show() 这就是绘制分组的折线图思想，虽然折线图能够反映各个渠道的运输量随月份的波动趋势，但无法观察到1月份到8月份的各自总量。接下来我们看看面积图的展现。 12345678910111213141516171819202122232425262728293031x = N# 将铁路运输、公路运输和水路运输各月的值提取出来，存储到y1~y3# 千万千万记得，提取出数据框的一列时，需要将序列的数据类型进行强制转换，否则会报错y1 = transport.loc[0,'Jan':'Aug'].astype('int')y2 = transport.loc[1,'Jan':'Aug'].astype('int')y3 = transport.loc[2,'Jan':'Aug'].astype('int')# 定义各区块面积的含义colors = ['#ff9999','#9999ff','#cc1234']# 绘制面积图plt.stackplot(x, # x轴 y1,y2,y3, # 可变参数，接受多个y labels = labels, # 定义各区块面积的含义 colors = colors # 设置各区块的填充色 )# 添加标题和坐标轴标签plt.title('2017年各运输渠道的运输量')plt.ylabel('累积运输量(万吨)')# 修改x轴的刻度plt.xticks(N,channel)# 剔除图框上边界和右边界的刻度plt.tick_params(top = 'off', right = 'off')# 显示图例（即显示labels的效果） plt.legend(loc = 'upper left')# 显示图形plt.show() matplotlib(树地图)squarify.plot函数12345678squarify.plot(sizes, norm_x=100, norm_y=100, color=None, label=None, value=None, alpha, **kwargs) 参数 说明 sizes 指定离散变量各水平对应的数值，即反映树地图子块的面积大小 norm_x 默认将x轴的范围限定在0-100之内 norm_y 默认将y轴的范围限定在0-100之内 color 自定义设置树地图子块的填充色 label 为每个子块指定标签 value 为每个子块添加数值大小的标签 alpha 设置填充色的透明度 **kwargs 关键字参数，与条形图的关键字参数类似，如设置边框色、边框粗细等 123456789101112131415161718192021222324252627282930313233343536# 导入第三方包import matplotlib.pyplot as pltimport squarify#中文及负号处理办法plt.rcParams['font.sans-serif'] = 'SimHei'plt.rcParams['axes.unicode_minus'] = False# 创建数据name = ['国内增值税','国内消费税','企业所得税','个人所得税', '进口增值税、消费税','出口退税','城市维护建设税', '车辆购置税','印花税','资源税','土地和房税','车船税烟叶税等']income = [3908,856,801,868,1361,1042,320,291,175,111,414,63] # 绘图colors = ['steelblue','#9999ff','red','indianred', 'green','yellow','orange'] plot = squarify.plot(sizes = income, # 指定绘图数据 label = name, # 指定标签 color = colors, # 指定自定义颜色 alpha = 0.6, # 指定透明度 value = income, # 添加数值标签 edgecolor = 'white', # 设置边界框为白色 linewidth =3 # 设置边框宽度为3 ) # 设置标签大小plt.rc('font', size=8)# 设置标题大小plot.set_title('2017年8月中央财政收支情况',fontdict = {'fontsize':15})# 去除坐标轴plt.axis('off')# 去除上边框和右边框刻度plt.tick_params(top = 'off', right = 'off')# 显示图形plt.show() 数据文件链接提取码: u6rg 作者：天痕坤 原文","link":"/posts/PythonMatplotlib.html"},{"title":"PySpider 马蜂窝网景点","text":"PySpider 马蜂窝景点信息 PySpider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/usr/bin/env python# -*- encoding: utf-8 -*-# Created on 2018-11-06 11:52:31# Project: PySpider_MaFengWofrom pyspider.libs.base_handler import *import jsonfrom pyspider.libs.utils import md5stringimport refrom fake_useragent import UserAgentdefault_headers = { 'Accept':'application/json, text/javascript, */*; q=0.01', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7', 'Connection':'keep-alive', 'Content-Length':68, 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8', 'Connection':'keep-alive', 'Upgrade-Insecure-Requests':1, 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3100.0 Safari/537.36', 'X-Requested-With':'XMLHttpRequest', }class Handler(BaseHandler): crawl_config = { 'headers':default_headers, 'timeout':300, 'proxy':'192.168.1.1:8080', } @every(minutes=24 * 60) def on_start(self): url = 'http://www.mafengwo.cn/jd/10088/gonglve.html' self.crawl(url,callback=self.get_index,fetch_type='js') def get_taskid(self, task): return md5string(task['url']+json.dumps(task['fetch'].get('data', ''))) def get_index(self,response): url = 'http://www.mafengwo.cn/ajax/router.php' total = int(response.doc('.pi.pg-last').attr('data-page')) for i in range(1,total+1): data = { 'sAct':'KMdd_StructWebAjax|GetPoisByTag', 'iMddid':'10088', ' iTagId':0, 'iPage':i } self.crawl(url,method='POST',data=data,callback=self.index_page) # 每一个回调detail_page的任务有效期是10天 @config(age=10 * 24 * 60 * 60) def index_page(self, response): print(response.text) result = response.text.replace('\\\\','') print(result) pattern = re.compile('&lt;a href=\"(.*?)\" target=') urls = re.findall(pattern,result) for url in urls: mainurl = 'https://www.mafengwo.cn' self.crawl(mainurl + url, callback=self.detail_page,fetch_type='js') # 数字越大优先级越高 @config(priority=2) def detail_page(self, response): return { \"name\": response.doc('h1').text(), \"location\":response.doc('.mhd &gt; p').text(), \"price\":response.doc('.mod-detail dd &gt; div').text(), \"phone\":response.doc('.tel &gt; .content').text(), \"visittime\":response.doc('.item-time &gt; .content').text(), \"website\":response.doc('.content &gt; a').text(), }","link":"/posts/PySpiderMaFengwo.html"},{"title":"Python Kmeans","text":"Python Kmeans KMeans K - means是一个反复迭代的过程，算法分为四个步骤： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 18-11-5 下午12:10# @Author : Vitan# @File : Kmeans.pyfrom sklearn.datasets import load_irisimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.cluster import KMeansx = np.random.randint(1,50,[20,1])# 定义一个给定形状和类型的用0填充的数组yy = np.zeros(20)k = 3 # 分成3类# 1. 选取数据空间中的K个对象作为初始中心，每个对象代表一个聚类中心；def initcenter(x,k): return x[:k]# 2. 对于样本中的数据对象，根据它们与这些聚类中心的欧氏距离，# 按距离最近的准则将它们分到距离它们最近的聚类中心（最相似）所对应的类；# 计算欧氏距离def nearest(kc,i): d = abs(kc -i) # asb() 取绝对值 # 返回与聚类中心最小距离所在类别的索引号 w = np.where(d == np.min(d)) return w[0][0]# 按距离最近的准则将它们分到距离它们最近的聚类中心（最相似）所对应的类def xclassify(x, y, kc): # 对数组的每个值进行分类，shape[0]读取矩阵第一维度的长度 for i in range(x.shape[0]): y[i] = nearest(kc, x[i]) return ykc = initcenter(x,k)y = xclassify(x,y,kc)print(kc,y)# 3. 更新聚类中心：将每个类别中所有对象所对应的均值作为该类别的聚类中心，计算目标函数的值；def kcmean(x,y,kc,k): l = list(kc) flag = False for c in range(k): m = np.where(y ==0) n = np.mean(x[m]) if l[c] != n: l[c] = n flag = True print(l,flag) return (np.array(l),flag)# 4 . 判断聚类中心和目标函数的值是否发生改变，若不变，则输出结果，若改变，则返回2）kc = initcenter(x,k)flag = True # 聚类中心发生改变print(x,y,kc,flag)while flag: y = xclassify(x,y,kc) kc,flag = kcmean(x,y,kc,k)print(y,kc) 鸢尾花 鸢尾花花瓣长度数据做聚类并用散点图显示 1234567891011121314151617181920iris = load_iris()data = iris.datairis_length = data[:,2]x = np.array(iris_length)y = np.zeros(x.shape[0]) # x.shape[0] 只读取x的第一维度长度# 选取数据空间中的K个对象作为初始中心，每个对象代表一个聚类中心；kc = initcenter(x,3)# 按距离最近的准则将它们分到距离它们最近的聚类中心（最相似）所对应的类flag = Truewhile flag: y = xclassify(x,y,kc) kc,flag = kcmean(x,y,kc,3)print(kc,flag)plt.scatter(iris_length, iris_length, c = y,cmap = 'rainbow')plt.savefig('花瓣长度散点图.png')plt.show() 用sklearn.cluster.KMeans，花瓣长度数据做聚类 123456789iris_length = data[:, 2:3]kmeans = KMeans(n_clusters = 4 )result = kmeans.fit(iris_length)kc1 = result.cluster_centers_y_kmeans = kmeans.predict(iris_length) # 预测每个样本的聚类索引plt.scatter(iris_length,np.linspace(1,150,150),c = y_kmeans,marker = 'D',cmap = 'rainbow')plt.savefig('sklearn.cluster.KMeans长度.png')plt.show() 鸢尾花完整数据做聚类 12345678k_means1 = KMeans(n_clusters = 4)result1 = k_means1.fit(data)kc2 = result1.cluster_centers_y_kmeans1 = k_means1.predict(data)plt.scatter(data[:, 0], data[:, 1], c = y_kmeans1, marker = 'p',cmap = 'rainbow')plt.savefig('完整数据聚类.png')plt.show()","link":"/posts/PythonKMean.html"},{"title":"Python Tips","text":"Python 小技巧 打印 index对列表，数列打印他们的 index 一般方法 12345cities = ['Shanghai','beijing','Chengdu']i = 0for c in cities: print(i +1,'--&gt;',c) i += 1 更好的方法(使用 enumerate) 123cities = ['Shanghai','beijing','Chengdu']for i,city in enumerate(cities): print(i+1,'--&gt;',city) 两个系列循环对两个序列进行计算或处理 一般方法 12345names = ['leo','jack','james']colors = ['red','green','blue','yellow']n = min(len(names),len(colors))for i in range(n): print(names[i],'--&gt;',colors[i]) 更好的方法(使用 zip) 1234names = ['leo','jack','james']colors = ['red','green','blue','yellow']for name,color in zip(names,colors): print(name,'--&gt;',color) 交换变量多个变量之间的交换，如冒泡排序法 一般方法 1234567x = 1y = 2print('&gt;&gt;Before:x={},y={}'.format(x,y))tmp = yy = xx = tmpprint('&gt;&gt;After:x = {},y = {}'.format(x,y)) 更好的方法 12345x = 1y= 2print('Before:x = {},y = {}'.format(x,y))x,y = y,xprint('After:x = {},y = {}'.format(x,y)) 字典的读取对字典的访问和读取，读取的字典 key 为空，需要一个缺省值 一般方法 123456students = {'Lili':18,'Sam':25}if 'Susan' in students: student = students['Susan']else: student = 'unknow'print('Susan is {} yesrs old'.format(student)) 更好的方法 123students = {'Lili':18,'San':25}student = students.get('Susan','unknow')print('Susan is {} yesrs'.format(student)) 巧妙地利用字典的 get 的方法。若字典没有 Susan 的 key，则用 unknow 来表示缺省值。 循环查找在一个大的循环中作搜索，如在文件中搜索关键字，从文件名列表中查找特殊的文件名 一般方法 1234567891011target_letter = 'd'letters = ['a','b','c']found = Falsefor letter in letters: if letter == target_letter: print('Found') found = True breakif not found: print('Not Found') 更好的方法 123456789target_letter = 'd'letters = ['a','b','c']for letter in letters: if letter == target_letter: print('found') breakelse: print('Not Found') 文件读取查找打开以文件，对内容进行循环读取处理 一般方法 1234567f = open('data.txt')try: text = f.read() for line in text.split('\\n'): print(line)finally: f.close() 更好的方法 123with open('data.txt') as f: for line in f: print(line.strip('\\n')) 关于锁的写法对于并发操作尤其是多线程的操作，对同一内存进行读写操作时，加锁保护 一般方法 12345678import threadinglock = threading.Lock()lock.acquire()try: print('Citical par,do somethins...')finally: lock.release() 更好的方法 1234import threadinglock = threading.Lock()with lock: print('Citical par,do somethins...') Via 七种不一样的Python代码写法，让你写出一手漂亮的代码","link":"/posts/PythonTips.html"},{"title":"PySpider 猫途鹰景点","text":"PySpider 爬猫途鹰网排名景点并保存至 MongoDB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# -*- encoding: utf-8 -*-# Created on 2018-10-30 18:01:28# Project: Maotufrom pyspider.libs.base_handler import *import pymongoclass Handler(BaseHandler): crawl_config = { } client = pymongo.MongoClient('localhost') db = client['maotu'] @every(minutes=24 * 60) def on_start(self): url = 'https://www.tripadvisor.cn/Attractions-g294217-Activities-Hong_Kong.html'' self.crawl(url,callback=self.index_page,validate_cert=False,fetch_type='js') @config(age=10 * 24 * 60 * 60) def index_page(self, response): for each in response.doc('.attraction_element .listing_title &gt; a').items(): self.crawl(each.attr.href, callback=self.detail_page,validate_cert=False,fetch_type='js') nextlink = response.doc('.nav.next').attr.href self.crawl(nextlink,callback=self.index_page,validate_cert=False,fetch_type='js') @config(priority=2) def detail_page(self, response): name = response.doc('.h1').text(), rank =response.doc('b &gt; span').text(), location = response.doc('.headerBL &gt; div').text(), view = response.doc('.seeAllReviews').text()[:-3], score = response.doc('.overallRating').text(), kfsj = response.doc('.headerBL .header_detail').text()[5:], phone = response.doc('.contact &gt; .phone &gt; div').text()[0:-4] return { \"name\":name, \"rank\":rank, \"location\":location, \"view\":view, \"score\":score, \"kf\":kfsj, \"phone\":phone } def on_result(self,result): if result: self.save_to_mongo(result) def save_to_mongo(self,result): if self.db['MaoTU_HongKong'].insert(result): print('savinf to mongo',result)","link":"/posts/PySpiderMaoTuYing.html"},{"title":"鸢尾花 Sklearn","text":"Sklearn 鸢尾花 鸢尾花从sklearn 包自带的数据集中读出鸢尾花数据集 data 12345678910#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 18-10-29 上午11:58# @Author : Vitan# @File : Sklearn_iris.pyfrom sklearn.datasets import load_irisimport numpy as npimport matplotlib.pyplot as pltdata = load_iris()print(data) 查看data类型，包含哪些数据12print(type(data))print(data.keys()) 取出鸢尾花特征和鸢尾花类别数据，查看其形状及数据类型123456iris_feature = data.feature_names,data.datairis_target = data.target_names,data.targetprint('鸢尾花特征数据：',iris_feature)print('鸢尾花类别：',iris_target)sepal_len = np.array(list(len[0] for len in data.data))print('花萼长度：',sepal_len) 取出所有花的花萼长度(cm)的数据12sepal_len = np.array(list(len[0] for len in data.data))print('所有花萼长宽：',sepal_len) 取出所有花的花瓣长度(cm)+花瓣宽度(cm)的数据1234567for item in data: # 花瓣长度 petal_len = np.array(list(len[2] for len in data.data)) # 花萼宽度 petal_wid = np.array(list(len[3] for len in data.data))iris_len = (petal_len,petal_wid)print(iris_len) 取出某朵花的四个特征及其类别。1print('四个特征',data.data[1],data.target[1]) 将所有花的特征和类别分成三组，每组50个1234567891011121314151617181920212223iris_set = []iris_ver = []iris_vir = []# 循环遍历所有的数据for i in range(0, 150): # 类别为0的为 setosa 花，生成一条setosa类的鸢尾花数据 if data.target[i] == 0: Data = data.data[i].tolist() Data.append('setosa') iris_set.append(Data) # 类别为1的即为 versicolor，生成一条versicolor类的鸢尾花数据 elif data.target[i] == 1: Data = data.data[i].tolist() Data.append('versicolor') iris_ver.append(Data) # 3 为维吉尼亚鸢尾花 else: Data = data.data[i].tolist() Data.append('virginica') iris_vir.append(Data)print(iris_set,iris_ver,iris_vir) 生成新的数组，每个元素包含四个特征+类别12iris_result = np.array([iris_set, iris_ver, iris_vir])print(\"分组:\", iris_result) 计算鸢尾花花瓣长度的最大值，平均值，中值，均方差。1234567#鸢尾花花瓣长度的数据petal_length = np.array(list(len[3] for len in data.data))print(petal_length) # 输出数据print('花瓣长度的最大值',np.max(petal_length))print('平均值：',np.mean(petal_length))print('中值：',np.median(petal_length))print('均方差：',np.std(petal_length)) 显示鸢尾花某一特征的曲线图，散点图。 曲线图 123456iris_feature = data.feature_names,data.datax = np.linspace(0,150,num = 150)plt.plot(x,iris_feature)plt.savefig(\"特征曲线图.png\")plt.show() 散点图 123plt.scatter(x,iris_feature)plt.savefig(\"特征散点图.png\")plt.show() np.random 用 np.random.normal() 产生一个正态分布的随机数组，并显示出来。 12345678mu = 50sigma = 0.6num = 3000zu = np.random.normal(mu,sigma,num)count,bins,ignored = plt.hist(zu,30,normed = True)plt.plot(bins,1/(sigma*np.sqrt(2*np.pi))*np.exp( - (bins-mu)**2/(2*sigma*2)),linewidth=2,color='g')plt.savefig(\"np.random.normal().png\")plt.show() np.random.randn()产生一个正态分布的随机数组，并显示出来。 123456789101112131415'''np.random.rand(n) 产生标准正态分布， 即均值为0 标准差为1 的高斯分布同于 np.random.normal(0, 1, n)'''mu = 100sigma = 15num_bins = 50 # 分隔的段数# 产生500个均值为100， 方差为15 的随机数,等于 x = np.random.normal(100, 15, 500)x = mu + sigma * np.random.randn(500)fig, ax = plt.subplots()n, bins, patches = ax.hist(x, num_bins, normed=True)# x为数据，ax.hist()即是画柱状图的函数plt.plot(bins,1/(sigma*np.sqrt(2*np.pi))*np.exp( - (bins-mu)**2/(2*sigma*2)),linewidth=2,color='r')plt.savefig(\"np.random.randn().png\")plt.show() 显示鸢尾花花瓣长度的正态分布图，曲线图，散点图 正态分布图 123456789mu = np.mean(petal_length) # 期望值sigma = np.std(petal_length) # 标准差num = 500 # 个数normal_data = np.random.normal(mu,sigma,num)count,bins,ignored = plt.hist(normal_data,20,normed=True)plt.plot(bins,1/(sigma*np.sqrt(2*np.pi))*np.exp( - (bins-mu)**2/(2*sigma*2)),linewidth=2,color='b')plt.savefig(\"花瓣长度正态分布图.png\") # 保存图片文件plt.show() 曲线图 1234x = np.linspace(0,150,num=150)plt.plot(x,petal_len)plt.savefig(\"花瓣长度曲线图.png\")plt.show() 散点图 123plt.scatter(x,petal_len,)plt.savefig(\"花瓣长度散点图.png\")plt.show()","link":"/posts/IrisSklearn.html"},{"title":"猫眼电影 Top100","text":"猫眼电影 Top100 思路 获取单页网页源代码并返回源代码 解析单页网页源代码，提取 title、actor、time、score 等数据并存储为生成器 将生成器里每一部电影的数据写入txt文档中 研究第 1-10 页 url 的规律，构建 url，调用 1、2、3 步骤 步骤获取单页网页源代码并返回源代码 123456789101112131415import requestsimport reimport jsonfrom requests.exceptions import RequestExceptiondef get_one_page(url): headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36'} try: response = requests.get(url,headers = headers) if response.status_code == 200: html = response.text return html return None except RequestException: return None 打印第一页源码 1print(get_one_page('http://maoyan.com/board/4')) 解析单页网页源代码，提取title、actor、time、score数据并存储为生成器 1234567891011121314def parse_one_page(html): pattern = re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\\d+)&lt;/i&gt;' + '.*?&lt;p.*?title=\"(.*?)\".*?&lt;/p&gt;.*?star\"&gt;(.*?)&lt;/p&gt;' + '.*?releasetime\"&gt;(.*?)&lt;/p&gt;.*?integer\"&gt;(.*?)' + '&lt;.*?fraction\"&gt;(.*?)&lt;/i&gt;',re.S) movies = re.findall(pattern,html) for item in movies: yield{ '排名':item[0], '电影名':item[1], '主演':item[2].strip()[3:], '上映时间':item[3][5:], '评分':item[4]+item[5] } 注意一下，这里需要用 yield，而不是return。yield函数返回的是一个生成器（一种特殊的迭代器，可以用for循环进行遍历）如果用return，那么在第一轮循环结束就会跳出，只能获取到一部影片的信息 将生成器数据写入 txt 文档 123456def write_to_txt(content): # 采用 append 追加模式，字符集为utf8 with open('movies.txt','a',encoding='utf8') as f: # 采用json的dumps方法来初始化字符串 f.write(json.dumps(content,ensure_ascii=False) + '\\n') f.close() 研究第1-10页 12345678# 第1-10页urlfor i in range(0,10): url = 'https://maoyan.com/board/4?offset=' + str(i * 10) # 构建 url，调用1、2、3步骤 html = get_one_page(url) movies= parse_one_page(html) for item in movies: write_to_txt(item) 多线程保持为 txt 第一步 12345678910111213141516import requestsimport reimport jsonfrom multiprocessing import Poolfrom requests.exceptions import RequestExceptiondef get_one_page(url): headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36'} try: response = requests.get(url,headers = headers) if response.status_code == 200: html = response.text return html return None except RequestException: return None 第二步 123456789101112def main(offset): url = 'http://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) for item in parse_one_page(html): print(item) write_to_txt(item)if __name__ == '__main__': pool = Pool() # 多线程 pool.map(main, [i*10 for i in range(10)]) pool.close() pool.join() 保持为 CSV单线程12345678910111213141516171819202122232425262728293031323334353637import requestsimport reimport jsonimport pandasfrom requests.exceptions import RequestExceptiondef get_one_page(url): headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36'} response = requests.get(url,headers = headers) html = response.text return htmldef parse_one_page(html): pageary = [] pattern = re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\\d+)&lt;/i&gt;' + '.*?&lt;p.*?title=\"(.*?)\".*?&lt;/p&gt;.*?star\"&gt;(.*?)&lt;/p&gt;' + '.*?releasetime\"&gt;(.*?)&lt;/p&gt;.*?integer\"&gt;(.*?)' + '&lt;.*?fraction\"&gt;(.*?)&lt;/i&gt;',re.S) movies = re.findall(pattern,html) for item in movies: dict = { '电影名':item[0], '主演':item[1].strip()[3:], '上映时间':item[2][5:], '评分':item[3]+item[4] } pageary.append(dict) return pagearyary = []for i in range(0,10): url = 'https://maoyan.com/board/4?offset=' + str(i * 10) html = get_one_page(url) pageary = parse_one_page(html) ary = ary + pagearydf = pandas.DataFrame(ary)df.to_csv('movies.csv') 多线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import requestsimport reimport jsonimport pandasfrom multiprocessing import Poolfrom requests.exceptions import RequestExceptiondef get_one_page(url): headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36'} try: response = requests.get(url,headers = headers) if response.status_code == 200: html = response.text return html return None except RequestException: return Nonedef parse_one_page(html): pageary = [] pattern = re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\\d+)&lt;/i&gt;' + '.*?&lt;p.*?title=\"(.*?)\".*?&lt;/p&gt;.*?star\"&gt;(.*?)&lt;/p&gt;' + '.*?releasetime\"&gt;(.*?)&lt;/p&gt;.*?integer\"&gt;(.*?)' + '&lt;.*?fraction\"&gt;(.*?)&lt;/i&gt;',re.S) movies = re.findall(pattern,html) for item in movies: dict = { '排名':item[0], '电影名':item[1], '主演':item[2].strip()[3:], '上映时间':item[3][5:], '评分':item[4]+item[5] } pageary.append(dict) return pagearydef write_to_csv(pageary): ary = [] ary = ary + pageary df = pandas.DataFrame(ary) df.to_csv('movies.csv')def main(offset): url = 'https://maoyan.com/board/4?offset=' + str(offset) pageary = parse_one_page(html) write_to_csv(ary)if __name__ == '__main__': pool = Pool() pool.map(main, [i*10 for i in range(10)]) pool.close() pool.join()","link":"/posts/CatEyeMovice.html"},{"title":"Python 时间日期处理","text":"Python DateTime 时间日期处理. DateTime获取当前 DateTime12from datetime timport datetimedatetime.datetime.now() 获取当天 date1datetime.date.today() 获取明天/前N天12345# 明天atetime.date.today() + datetime.timedelta(days=1)# 前N天datetime.datetime.now()datetime.datetime.now() - datetime.timedelta(days=3) 获取当天开始和结束时间12datetime.datetime.combine(datetime.date.today(), datetime.time.min)datetime.datetime.combine(datetime.date.today(), datetime.time.max) 获取两个 datetime 的时间差1234now = datetime.now()end = datetime.strptime('2018-10-25 22:00','%Y-%m-%d %H:%M')time = end - nowprint(time.days,'天') 获取本周/本月/上月最后一天 本周最后一天 1234import datetimetoday = datetime.date.today()sunday = today + datetime.timedelta(6 - today.weekday())sunday 本月最后一天 12345import calendartoday = datetime.date.today()last_day_num = calendar.monthrange(today.year, today.month)last_day = datetime.date(today.year, today.month, last_day_num)last_day 上月最后一天 1234import datetimetoday = datetime.date.today()first = datetime.date(day=1, month=today.month, year=today.year)lastMonth = first - datetime.timedelta(days=1) 转换datetime &lt;=&gt; string datetime -&gt; string 12import datetimedatetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") string -&gt; datetime 12import datetimedatetime.datetime.strptime(\"2018-10-22 12:50:46\", \"%Y-%m-%d %H:%M:%S\") datetime &lt;=&gt; timetuple datetime -&gt; timetuple 12import datetimedatetime.datetime.now().timetuple() timetuple -&gt; datetime 1timetuple =&gt; timestamp =&gt; datetime [看后面datetime&lt;=&gt;timestamp] datetime &lt;=&gt; date datetime -&gt; date 12import datetimedatetime.datetime.now().date() date -&gt; datetime 1234datetime.date.today()today = datetime.date.today()datetime.datetime.combine(today, datetime.time())datetime.datetime.combine(today, datetime.time.min) datetime &lt;=&gt; timestamp datetime -&gt; timestamp 123now = datetime.datetime.now()timestamp = time.mktime(now.timetuple())timestamp timestamp -&gt; datetime1datetime.datetime.fromtimestamp(1421077403.0) Via PYTHON-基础-时间日期处理小结","link":"/posts/PythonDateTime.html"},{"title":"Linux 逻辑卷分区大小的调整","text":"Linux Home 硬盘空间缩减并添加到 /. 看硬盘信息f -l1df -l 文件系统 容量 已用 可用 已用% 挂载点 dev 1.9G 0 1.9G 0% /dev run 1.9G 1.3M 1.9G 1% /run /dev/sdb4 30G 17G 12G 59% / /dev/sdb3 59G 8.6G 48G 16% /home 缩减 Home卸载 Home 挂载1umount /home 提示 busy 不能卸载 12# 终止占用进程fuser -m /home 调整 /home 分区大小123resize2fs -p /dev/sdb3 30G# resize2fs 为重新设定磁盘大小# 只是重新指定一下大小，并不对结果有影响 先设置一下 Home 的大小,进行这一步的时候会提醒让先运行下面的命令进行检查 1e2fsck -f /dev/sdb3 强制检查一下磁盘并修复错误，接下来再次运行这个命令把 home大小设置为20G 1resize2fs -p /dev/sdb3 30G 收缩逻辑卷空间为 30G 123# 使用lvreduce指令用于减少LVM逻辑卷占用的空间大小# -L 是设为，-l 是减小的值lvreduce -L 30G /dev/sdb3 然后挂载 /home 并 df -h 查看一下 Home 大小分配是否成功 1mount /home 分配给 /1lvextend -l +100%FREE /dev/sdb4 执行调整根目录的空间大小,并耐心等待,不要操作 1resize2fs -p /dev/sdb4 注意 ext2 ext3 ext4 文件系统的调整命令是 resize2fs xfs 文件系统的调整命令是 xfs_growfs（只支持增大） 参考 Linux的中对LVM逻辑卷分区大小的调整教程","link":"/posts/LinuxHome.html"},{"title":"Python Selenium","text":"Python Selenium 基础使用。 基本使用123456789101112131415161718192021222324252627282930from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWait#创建Chrome浏览器对象browserbrowser = webdriver.Chrome()try: #用get方式访问百度首页 browser.get('https://www.baidu.com') #通过id为‘kw’找到输入框input input = browser.find_element_by_id('kw') #调用该输入框的send_keys方法向输入框键入“Python”关键词 input.send_keys('Python') #高用该输入框的send_keys方法向输入框按回车键 input.send_keys(Keys.ENTER) #创建浏览器等待对象wait,等待时间10称 wait = WebDriverWait(browser,10) #调用wait的until方法，直到ID为content_left（即搜索结果界面）元素出现 wait.until(EC.presence_of_element_located((By.ID, 'content_left'))) #打印输出浏览器当前的URL print(browser.current_url) #打印输出当前的cookies信息 print(browser.get_cookies) #打印输出网页源代码 print(browser.page_source)finally: #关闭浏览器 browser.close() 声明浏览器对象1234567from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() 访问页面12345678910from selenium import webdriver#创建Chrome浏览器对象browser = webdriver.Chrome()#访问淘宝首页browser.get('https://taobao.com')#打印输出网页源代码print(browser.page_source)#关闭浏览器browser.close() 查找元素单个12345678910111213141516from selenium import webdriver#创建Chrome浏览器对象browser = webdriver.Chrome()#访问淘宝首页browser.get('https://www.taobao.com')#通过id属性查找id为q的元素,即为搜索输入框,命名为input_firstinput_first = browser.find_element_by_id('q')#通过css选择器查找搜索输入框,命名为input_secondinput_second = browser.find_element_by_css_selector('#q')#通过xpath查找搜索输入框，命名为input_thirdinput_third = browser.find_element_by_xpath('//*[@id=\"q\"]')#打印输出以上三个查找结果print(input_first,input_second,input_third)#关闭浏览器browser.close() 12345678from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')input_first = browser.find_element(By.ID, 'q')print(input_first)browser.close() 多个元素123456789101112from selenium import webdriver#创建Chrome浏览器对象 browserbrowser = webdriver.Chrome()#get方式访问淘宝首页browser.get('https://www.taobao.com')#(多个元素用elements，须借助css_selector)查找淘宝首页左边导航条下面的class为service-bd的ul标签下面的名为li的多个标签lis = browser.find_elements_by_css_selector('.service-bd')#打印输出所有lis元素print(lis)#关闭浏览器browser.close() 12345678from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')lis = browser.find_elements(By.CSS_SELECTOR, '.service-bd li')#作用同上print(lis)browser.close() 元素交互操作对获取的元素调用交互方法123456789101112131415161718192021from selenium import webdriverimport time#创建chrome浏览器对象browser = webdriver.Chrome()#访问淘宝首页browser.get('https://www.taobao.com')#查找id为q的搜索输入框inputinput = browser.find_element_by_id('q')#调用input的send_keys函数向输入框输入关键字“OnePLus”input.send_keys('OnePlus')#当前浏览器暂停1Stime.sleep(1)#清除输入框的内容input.clear()#调用input的send_keys再次输入 一加input.send_keys('一加')#查找class为btn-search的搜索按钮并命名为button 用find_element_by_class_namebutton = browser.find_element_by_class_name('btn-search')#调用click点击该按钮button.click() 更多操作 交互动作将动作附加到动作链中串行执行1234567891011121314151617181920212223from selenium import webdriverfrom selenium.webdriver import ActionChains#创建chrome浏览器对象browserbrowser = webdriver.Chrome()#设置url为http://www.runoob.com/try/try.php?filename=jqueryui-api-droppableurl = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'#用get方式访问以上urlbrowser.get(url)#在浏览器中切换定位到名为iframeResult的frame元素browser.switch_to.frame('iframeResult')#通过css选择器查找id为draggable的拖曳源，并命名为sourcesource = browser.find_element_by_css_selector('#draggable')#通过css选择器查找id为droppable的代入源，并命名为targettarget = browser.find_element_by_css_selector('#droppable')#用ActionChains函数创建浏览器动作链对象actionsactions = ActionChains(browser)#调用actions的drag_and_drop,设计将source放入target的动作actions.drag_and_drop(source,target)#调用perform执行该动作actions.perform()#关闭浏览器browser.close() 更多操作 执行 JavaScript12345678910from selenium import webdriver#创建chrome()浏览器对象browserbrowser = webdriver.Chrome()#get方式访问https://www.zhihu.com/explore网页browser.get('https://www.zhihu.com/explore')#利用execute_script执行js语句window.scrollTo(0, document.body.scrollHeight)browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')##利用execute_script执行js语句alert(\"To Bottom\")警报信息,注意，execute_script('')里面的js加引号browser.execute_script('alert(\"To Bottom\")') 获取元素信息获取属性123456789101112131415from selenium import webdriverfrom selenium.webdriver import ActionChains#创建Chrome浏览器对象browserbrowser = webdriver.Chrome()#设置url为https://www.zhihu.com/exploreurl = 'https://www.zhihu.com/explore'#get方式访问以上网址browser.get(url)#查找id为zh-top-link-logo的元素并命名为logo(知乎logo)logo = browser.find_element_by_id('zh-top-link-logo')#打印输出此logoprint(logo)#打印输出：用logo的get_attribute函数获得logo的class属性值print(logo.get_attribute('class')) 获取文本值 获取指定节点中的文本内容 1driver.find_element_by_xpath('').get_attribute('textContent') 获取a的href(多个则遍历) 1broswer.find_element_by_css_selector('.houseListTitle a').get_attribute('href') 输入框的文本 123456789from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)#利用by_class_name查找class属性值为zu-top-add-question的输入框inputinput = browser.find_element_by_class_name('zu-top-add-question')#输出打印该输入框的文本（text）print(input.text) 获取ID、位置、标签名、大小1234567891011121314151617from selenium import webdriverbrowser = webdriver.Chrome()#设置url为https://www.zhihu.com/exploreurl = 'https://www.zhihu.com/explore'#用get方式访问以上网址browser.get(url)#查找class属性值为zu-top-add-question的输入框inputinput = browser.find_element_by_class_name('zu-top-add-question')#打印输出input的idprint(input.id)#打印输出input的位置locationprint(input.location)#打印输出input的标签名tag_nameprint(input.tag_name)#打印输出input的对象几何大小sizeprint(input.size) Frame123456789101112131415161718import timefrom selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionbrowser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'browser.get(url)browser.switch_to.frame('iframeResult')source = browser.find_element_by_css_selector('#draggable')print(source)try: logo = browser.find_element_by_class_name('logo')except NoSuchElementException: print('NO LOGO')browser.switch_to.parent_frame()logo = browser.find_element_by_class_name('logo')print(logo)print(logo.text) 等待隐式等待 当使用了隐式等待执行测试的时候，如果 WebDriver 没有在 DOM 中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是 0 12345678from selenium import webdriverbrowser = webdriver.Chrome()#利用implicitly_wait进行隐式等待，等待时间设置为10Sbrowser.implicitly_wait(10)browser.get('https://www.zhihu.com/explore')input = browser.find_element_by_class_name('zu-top-add-question')print(input) 显式等待 显示等待则打指定等待不固定，具体时间受指定的元素出现或其他条件实现的时间限制 1234567891011121314151617from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC​#创建浏览器对象browser = webdriver.Chrome()#利用get方式访问淘宝首页browser.get('https://www.taobao.com')#创建浏览器等待对象wait，默认为10秒wait = WebDriverWait(browser,10)#创建input对象，利用wait.until函数直到id为q的元素加载完后,注意By.ID参数双括号input = wait.until(EC.presence_of_element_located((By.ID, 'q')))#创建button对象，利用wait.until直到class为btn-searchbutton = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '.btn-search')))#打印输出input,buttonprint(input,button) 前进后退123456789101112131415161718import timefrom selenium import webdriverbrowser = webdriver.Chrome()#访问百度browser.get('https://www.baidu.com')#访问淘宝browser.get('https://www.taobao.com')#访问python主页https://www.python.org/(被GWF铁拳重创，故改为qq.com)browser.get('https://www.qq.com')#调用浏览器的back函数执行返回。问：返回到哪一个网页？browser.back()#当前休眠3stime.sleep(3)#浏览器前进。问，前进到哪一网页？browser.forward()#关闭浏览器browser.close() Cookies12345678910111213141516from selenium import webdriver​browser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')#get_cookies获取cookies并输出打印print(browser.get_cookies())print('------------------------------------------------------------------------------------------------------')#add_cookie（注意此cookie单词没有s）增加cookies{'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'}browser.add_cookie({'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'})#重新获取cookies并输出打印print(browser.get_cookies())print('------------------------------------------------------------------------------------------------------')#delete_all_cookies删除所有cookiesbrowser.delete_all_cookies()#重新获取cookies并输出打印print(browser.get_cookies()) 选项卡管理123456789101112131415161718192021import timefrom selenium import webdriver#创建浏览器对象browser = webdriver.Chrome()#访问淘宝browser.get('https://www.taobao.com')#打开新的选项卡（执行js语句 execute_script（'window.open()')browser.execute_script('window.open()')#打印输出当前浏览器对象browser.window_handlesprint(browser.window_handles)#切换到第2个选项卡,下标为1browser.switch_to.window(browser.window_handles[1])#访问 百度browser.get('https://www.baidu.com')#休眠1stime.sleep(1)#切换到第1个选项卡，下标为0browser.switch_to.window(browser.window_handles[0])#访问百度browser.get('https://www.vitan.me') 异常处理未处理12345from selenium import webdriver ​browser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.find_element_by_id('hello') 处理后1234567891011121314from selenium import webdriverfrom selenium.common.exceptions import TimeoutException, NoSuchElementExceptionbrowser = webdriver.Chrome()try: browser.get('https://www.baidu.com')except TimeoutException: print('Time Out')try: browser.find_element_by_id('hello')except NoSuchElementException: print('No Element')finally: browser.close()","link":"/posts/PythonSelenium.html"},{"title":"Python ChromeDriver GeckoDriver","text":"Python ChromeDriver GeckoDriver Configer 下载 ChromeDriver GeckoDriver 配置Linux 方法一 12sudo mv chromedriver /usr/binsudo mv geckodriver /usr/bin 方法二(配置 Path)1234vim ~/.profileexport PATH=\"$PATH:/usr/local/chromedriver\"export PATH=\"$PATH:/usr/local/geckodriver\" 验证 terminal12chromedrivergeckodriver Windowschromedriver.exe geckodriver.exe 文件拖到 Python 的 Scripts 目录下","link":"/posts/LinuxPythonChromedriver.html"},{"title":"Python 中英词频统计","text":"Python 中英文词频统计，并制作词云。 英文词频12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding: UTF-8 -*-# Author: Vitanwith open('cp.txt','r') as f:content = f.read()# 清洗数据import stringcontent = content.lower() # 格式化数据，转为小写for i in string.punctuation: # 去除所有标点符号 content = content.replace(i, ' ')wordList = content.split() # 切片分词# 排除语法型词汇，代词、冠词、连词等无语义词noMean = {'a','an','the','i','do','am','you','no','t','m','d','ve'}wordSet = set(wordList) - noMeanwordList = list(wordSet)# 统计单词数量data = {}for word in wordList:#data[word] = data.get(word, 0) + 1 data[word] = wordList.count(word)for key in data: print(key,data[key],'次')print(\"============\")# list.sort() 排序wordList = list(data.items())# 函数定义'''def takeSecond(elem): # 定义函数，获取每个单词的次数项return elem[1]wordList.sort(key = takeSecond,reverse = True)'''# 匿名函数wordList.sort(key = lambda x:x[1],reverse = True)print(wordList)print(\"============\")# 排序hist = []for key, value in data.items(): hist.append([value, key])hist.sort(reverse = True) # 降序# 前20个for i in range(20): print(hist[i]) 中文词频1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: UTF-8 -*-# Author: Vitanimport jiebaimport matplotlib.pyplot as pltfrom wordcloud import WordCloud# 读取文件内容with open('ch.txt','r',encoding = 'UTF-8') as f:content = f.read()# 结巴分词wordList = jieba.cut(content)# 词频统计data = {}for word in wordList: if len(word)==1: continue else:data[word]=data.get(word,0)+1# 匿名函数获取每个单词的次数项统，降序result = list(data.items())result.sort(key=lambda x:x[1],reverse=True) # 排序for i in range(20): print(result[i])# 设置词云wordSplit = \" \".join(dict(result))wc = WordCloud(background_color=\"black\", # 设置背景颜色 # mask = \"图片\", #设置背景图片 max_words=2000, # 设置最大显示的字数 # stopwords = \"\", #设置停用词 font_path=\"/usr/share/fonts/noto-cjk/NotoSansCJK-Medium.ttc\", # 设置中文字体，使得词云可以显示（词云默认字体是“DroidSansMono.ttf字体库”，不支持中文） max_font_size=50, # 设置字体最大值 random_state=30, # 设置有多少种随机生成状态，即有多少种配色方案 )mywc = wc.generate(wordSplit) # 生成词云# 展示词云图plt.imshow(mywc)plt.axis(\"off\")plt.show()wc.to_file('mywor.png') # 保存图片文件","link":"/posts/PythonWorldFrequency.html"},{"title":"Python 正则表达式","text":"Python 正则表达式 常见匹配模式 模式表 模式 描述 \\w 匹配字母数字及下划线 \\W 匹配非字母数字下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9] \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开头 $ 匹配字符串的末尾 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符 [...] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^...] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符 * 匹配0个或多个的表达式 + 匹配1个或多个的表达式 ? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配n个前面表达式 {n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 `a b` ( ) 匹配括号内的表达式，也表示一个组 re.matchre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 1re.match(pattern, string, flags=0) 匹配模式 最常规的匹配 123456789101112import recontent = 'Hello 123 4567 World_This is a Regex Demo'print(len(content))#逐个匹配单个字符result = re.match('^Hello\\s\\d\\d\\d\\s\\d{4}\\s\\w{10}.*Demo$',content)print(result)#输出匹配的字符串print(result.group())#输出匹配字符长度print(result.span()) 泛匹配1234567891011 import recontent = 'Hello 123 4567 World_This is a Regex Demo'#用.*代表任意个任何字符result = re.match('^Hello.*Demo$',content)#输出整个匹配结果print(result)#输出匹配的字符串print(result.group())#输出匹配字符长度print(result.span()) 匹配目标123456789import recontent = 'Hello 1234567 World_This is a Regex Demo'#用()匹配目标1234567result = re.match('^Hello\\s(\\d+)\\sWorld.*Demo$',content)print(result)print(result.group(1))#输出匹配字符长度print(result.span()) 贪婪匹配1234567import recontent = 'Hello 1234567 World_This is a Regex Demo'#用.*模式尝试匹配数字串1234567result = re.match('^He.*\\s(\\d+)\\sWorld.*Demo$',content)print(result)print(result.group(1)) 非贪婪匹配1234567import recontent = 'Hello 1234567 World_This is a Regex Demo'#用.*？模式匹配数字串1234567result = re.match('^H.*?\\s(\\d+)\\sW.*?Demo$',content)print(result)print(result.group(1)) 匹配模式12345678import recontent = '''Hello 1234567 World_Thisis a Regex Demo'''#用re.S意味着.可以代表换行符在内的符号print(result.group(1))#输出匹配数字串result = re.match('He.*?\\s(\\d+).*?Demo$',content,re.S) 转义123456import recontent = 'price is $5.00'#直接用$与.代表原字符result = re.match('price is $5.00',content)print(result)#输出匹配结果 123456import recontent = 'price is $5.00'#加\\代表转义result = re.match('price is \\$5\\.00',content)print(result)#输出整个匹配结果 总结：尽量使用泛匹配、使用括号得到匹配目标、尽量使用非贪婪模式、有换行符就用re.S re.searchre.search 扫描整个字符串并返回第一个成功的匹配。 123456import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'#用re.match匹配以Hello开头至Demo的这一段字符串result = re.match('Hello.*?(\\d+).*?Demo$',content)print(result) 1234567import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'#用re.search匹配以Hello开头至Demo的这一段字符串result = re.search('Hello.*?(\\d+).*?Demo', content)print(result)#输出整个匹配结果print(result.group(1))#输出数字字符串 总结：为匹配方便，能用 search 就不用 match 匹配演练 一 12345678910111213141516171819202122232425import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;&lt;i class=\"fa fa-user\"&gt;&lt;/i&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''#分别匹配齐秦，往事随风这两串目标字符串result = re.search('&lt;li.*?active.*?singer=\"(\\w+)\"&gt;(\\w+)&lt;/a&gt;',html,re.S)print(result.group(1),result.group(2)) 二 1234567891011121314151617181920212223242526272829import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?singer=\"(\\w+)\"&gt;(\\w+)&lt;/a&gt;',html,re.S)#分别匹配任贤齐，沧海一声笑这两串目标字符串print(result.group(1))print(result.group(2))#同时输出任贤齐，沧海一声笑这两串目标字符print(result.group(1),result.group(2)) 三 12345678910111213141516171819202122232425262728import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''result = re.search('&lt;li.*?singer=\"(\\w+)\"&gt;(\\w+)&lt;/a&gt;',html)#分别匹配beyond，光辉岁月这两串目标字符串print(result.group(1))print(result.group(2))#同时输出beyond，光辉岁月这两串目标字符串print(result.group(1),result.group(2)) re.findall搜索字符串，以列表形式返回全部能匹配的子串。 123456789101112131415161718192021222324252627282930import rehtml = '''&lt;div id=\"songs-list\"&gt;&lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt;&lt;p class=\"introduction\"&gt; 经典老歌列表&lt;/p&gt;&lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;'''#匹配从任贤齐开始所有歌的href,singer值与文本内容result = re.findall('&lt;li.*?href=\"(.*?)\".*?singer=\"(\\w+)\"&gt;(\\w+)&lt;/a&gt;',html,re.S)print(result)#输出整个匹配结果print(type(result))#输出匹配结果的数据类型#遍历所有匹配结果，输出每一条匹配结果与每一匹配结果的三个元素for item in result : print(result) print(item[0],item[1],item[2]) 12345678910111213141516171819202122232425262728import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''#用正则表达式匹配从一路上有你所在li标签开始的所有li标签result = re.findall('&lt;li.*?&gt;\\s*?(&lt;a.*?&gt;)?(\\w+)(&lt;/a&gt;)?\\s*?&lt;/li&gt;', html, re.S)print(result)#输出整个匹配结果##输出每一条匹配结果的第2个元素for item in result: print(item[1]) re.sub替换字符串中每一个匹配的子串后返回替换后的字符串。 123456import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'#将数字1234567替换为空content = re.sub('\\d+','', content)print(content)#输出替换结果 123456import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'#将数字1234567替换为字符串“Replacement”content = re.sub('\\d+','Replacement',content)print(content) 123456import recontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'#将数字1234567替换为1234567 8910content = re.sub('(\\d+)', r'\\1 8910', content)print(content)#输出替换结果123456789101112131415161718192021222324252627282930import rehtml = '''&lt;div id=\"songs-list\"&gt; &lt;h2 class=\"title\"&gt;经典老歌&lt;/h2&gt; &lt;p class=\"introduction\"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id=\"list\" class=\"list-group\"&gt; &lt;li data-view=\"2\"&gt;一路上有你&lt;/li&gt; &lt;li data-view=\"7\"&gt; &lt;a href=\"/2.mp3\" singer=\"任贤齐\"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"4\" class=\"active\"&gt; &lt;a href=\"/3.mp3\" singer=\"齐秦\"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view=\"6\"&gt;&lt;a href=\"/4.mp3\" singer=\"beyond\"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt;&lt;a href=\"/5.mp3\" singer=\"陈慧琳\"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view=\"5\"&gt; &lt;a href=\"/6.mp3\" singer=\"邓丽君\"&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''#去除a类标签（用re.sub方法提取所有歌名，提示思路：先去除a类型标签，再用正则提取每个li标签的内容）html = re.sub('&lt;a.*?&gt;|&lt;/a&gt;','',html)print(html)#输出去除结果#正则匹配li标签内容result = re.findall('li.*?&gt;(.*?)&lt;/li&gt;',html,re.S)print(result)for item in result:#遍历每一匹配结果 print(item.strip())#输出每一匹配结果并去除换行符 re.compile 将正则字符串编译成正则表达式对象 将一个正则表达式串编译成正则对象，以便于复用该匹配模式 12345678910import recontent = '''Hello 1234567 World_Thisis a Regex Demo'''#编写Hello开始的这一串字符串匹配模式patternpattern = re.compile('Hello.*?Demo',re.S)#用上述模式匹配result = re.match(pattern,content)#result = re.match('Hello.*Demo', content, re.S)print(result)#输出匹配结果 练习题123456789101112131415import requestsimport recontent = requests.get('https://book.douban.com/').textpattern = re.compile('&lt;li.*?cover.*?href=\"(.*?)\".*?title=\"(.*?)\".*?more-meta.*?author\"&gt;(.*?)&lt;/span&gt;.*?year\"&gt;(.*?)&lt;/span&gt;.*?&lt;/li&gt;', re.S)#利用上述pattern匹配所有书籍的上述信息results = re.findall(pattern, content)for result in results: #分别用url,title,author,date为每一书籍信息的变量名 url, name, author, date = result #将author后面的\\n替换为空 author = re.sub('\\s', '', author) #将date后面的\\n替换为空 date = re.sub('\\s', '', date) #同时输出每一书籍url,title,author,date信息 print(url, name, author, date)","link":"/posts/PythonRegex.html"},{"title":"房天下二手房","text":"房天下爬虫 获取网页源码123456import requests#获取上海在售二手房源网页首页（http://esf.sh.fang.com/）的响应包，命名为resres.textres = requests.get('http://esf.sh.fang.com/')#输出res的文本内容print(res.text) 获取每套房源的详细内容页12345678910111213from bs4 import BeautifulSoup#将上海在售二手房源网页首页url（http://esf.sh.fang.com/）赋值给domaindomain = 'http://esf.sh.fang.com'# 创建BeautifulSoup对象对res响应包进行解析，结果命名为soupsoup = BeautifulSoup(res.text,'html.parser')# 循环遍历获取网页首页所有房源详细内容页的url,循环变量名为house（提示：检查定位路径定位查找的节点是否为空）for house in soup.select('.shop_list dl dd h4 a'): #（提示：如果存在返回的标签节点有空的情况，需要进行判断！） if house: # 利用domain与存储房屋详细内容的相对url的标签节点构建房屋的 url print(domain+house['href']) # 打印输出查看url print('========================' 将上面获取到的其中一房源的详细内容页的 url 进行请求并解析提取相关数据1234567import requestsfrom bs4 import BeautifulSoup# 将以上获得的第一个房源的详细内容页进行请求访问res =requests.get('http://esf.sh.fang.com/chushou/3_331876564.htm')# 对响应包res的网页文本进行解析，解析结果命名为soupsoup = BeautifulSoup(res.text,'html.parser')res.text 获取详情12345678910111213141516171819202122#定义字典变量info，用于存放每套房子相关数据info ={}# 查找房子标题，以“标题”为key名存入infoinfo['标题']=soup.select('.title h1')[0].text.strip()info#查找总价，以“总价”为key名存入infoinfo['总价']=soup.select('.price_esf')[0].textinfok = ['总价','单价','建筑面积','朝向','楼层','装修','户型','标题']#item表示包括户型，朝向，单价，楼层，装修等相关数据的标签for item in soup.select('.trl-item1'): # key 计划用于表示房屋的字段 key=item.select('.font14')[0].text.strip() # value 计划用于表示房屋相关字段对应数 value=item.select('.tt')[0].text.strip() info[key]=valueprint(info)print(list(info.values()))print(k)print(dict(zip(k,list(info.values())))) 定义一个获取网页详细内容页的函数 getHouseDetail12345678910111213141516171819202122232425def getHouseDetail(url): info={} info_adj={} # 根据url请求网页内容 res=requests.get(url) #解析详细内容页，结果命名为soup soup = BeautifulSoup(res.text,'html.parser') # 获取房屋名并加入info字典，key值命名为“标题 info['标题']=soup.select('.title h1')[0].text.strip() # 获取房屋总价并加入info字典，key值命名为“总价 info['总价']=soup.select('.price_esf')[0].text # 用item做为循环变量名，代表当前网页class为trl-item1的所有标签节点 for item in soup.select('.trl-item1'): # key表示item标签下所有class为font14的标签节点文本内容 key=item.select('.font14')[0].text.strip() print(key) # value 示item标签下所有class为tt的标签节点文本内容 value=item.select('.tt')[0].text.strip() #将info里面所有key赋值给value info[key]=value k=['总价','单价','建筑面积','朝向','楼层','装修','户型','标题'] info_adj=dict(zip(k,list(info.values()))) #print(info_adj) return info_adj 通过获取所有房屋的详细内容页 url，获取每一房屋的相关字段信息12345678910111213141516171819202122getHouseDetail('http://esf.sh.fang.com/chushou/3_328597533.htm')import requestsfrom bs4 import BeautifulSoup# 定义列表用于存储所有房屋的相关数据houseary=[]# domain 为http://esf.sh.fang.com域名domain='http://esf.sh.fang.com'# 请求访问http://esf.sh.fang.com首页，获得响应包resres=requests.get('http://esf.sh.fang.com')#创建BeatifulSoup对象并进行解析soup=BeautifulSoup(res.text,'html.parser')# 循环遍历获取网页首页中存有的标签节点，循环变量命名为linkfor link in soup.select('.shop_list dl dd h4 a'): # 利用domain与存储房屋详细内容的相对url的标签节点构建房屋的url url=domain+link['href'] # 调用getHouseDetail函数获取每一房屋相关数据并追加到houseary houseary.append(getHouseDetail(url))#求总共获取到多少套房屋信息len(houseary) 数据处理1234567import pandas#将获取到的所有房屋信息转换成数据框的结构df = pandas.DataFrame(houseary)df#存储到当前工作空间目录下，文件命名为house.xlsxdf.to_excel('house.xlsx')","link":"/posts/FTX.html"},{"title":"Python Numpy","text":"Python Numpy 问题数列 a = a1,a2,a3,·····,an b = b1,b2,b3,·····,bn 求： c = a12+b13,a22+b23,a32+b33,·····+an2+bn3 用列表+循环实现，并包装成函数 用numpy实现，并包装成函数 对比两种方法实现的效率，给定一个较大的参数n，用运行函数前后的timedelta表示。 实现列表+循环实现，并包装成函数12345678def pySum(n): a = list(range(n)) b = list(range(0,5*n,5)) c = [] for i in range(len(a)): c.append(a[i] ** 2 + b[i] ** 3) return(c)print(pySum(10)) 数组numpy实现，并包装成函数1234567import numpydef npSum(n): a = numpy.arange(n) b = numpy.arange(0, 5 * n, 5) c = a**2+b**3 return(c)print(npSum(10)) 对比两种方法实现的效率，给定一个较大的参数n，用运行函数前后的timedelta表示 12345678910from datetime import datetimestart = datetime.now()pySum(100000)delta = datetime.now()-startprint(delta)start = datetime.now()npSum(100000)delta = datetime.now()-startprint(delta) 尝试把 a,b 定义为三层嵌套列表和三维数组 123456789101112import numpydef liSum(n): a = numpy.arange(n) b = numpy.arange(0,5*n,5) c = numpy.array([[a,b],[a**2,b**3]]) return (c)print(npSum(10))start = datetime.now()liSum(100000)time = datetime.now()-startprint(time)","link":"/posts/PythonNumpy.html"},{"title":"Jupyter 主题","text":"Jupyter 主题 安装 Jupyter-theme1pip install jupyterthemes 更换主题123jt -l # 列出主题jt -t themeName # 更换主题jt -r # 恢复默认主题 Jupyter-themes 官方仓库","link":"/posts/JupyterTheme.html"},{"title":"Python PyQuery 库基础","text":"Python PyQuery 库基础 初始化字符串初始化123456789101112131415161718!pip install pyqueryhtml = '''&lt;div&gt;&lt;ul&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''from pyquery import PyQuery as pq# 导入pyquery类库下面的PyQuery，并重命名为pqdoc = pq(html)#利用html创建pq对象，命名为docprint(doc('li'))#输出打印所有的li标签 URL初始化12345from pyquery import PyQuery as pqdoc = pq(url='https://www.baidu.com')#利用url=''获取百度首页响应包，并以此创建pq对象，命名为docprint(doc('head'))#输出打印doc下面的head节点 文件初始化12345from pyquery import PyQuery as pqdoc = pq(filename='demo.html')#利用filename=‘’将工作空间下的demo.html文档导入进来，并创建pq对象，命名为docprint(doc('li'))#输出打印doc下面的所有li标签 基本CSS选择器123456789101112131415html = '''&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)print(doc('#container .list li'))#查找id为container下面class为list下面的li节点 查找元素子元素12345678910111213141516171819202122232425html = '''&lt;div id=\"container\"&gt;&lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)items = doc('#list')#查找class为list的标签节点，命名为itemsprint(type(items))#输出打印items的类型print(items)#输出打印itemslis =items.find('li')#利用find函数查找items下面的li标签节点print(type(lis))#输出打印lis的类型print(lis)#输出lis children123456lis = items.children()#lis为items的孩子标签print(type(lis))#输出返回lis的类型print(lis)#输出lis 返回items孩子节点中class为active为标签 123lis = items.children('')#返回items孩子节点中class为active为标签print(lis)#输出打印lis 父元素123456789101112131415161718192021html = '''&lt;div id=\"container\"&gt;&lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)items = items('.list')#items为class等于list的标签container = items.parents()#返回items的父节点print(type(container))#输出打印container的类型print(container)#输出打印container parent12345678910111213141516171819202122Pythonhtml = ''' &lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ''' from pyquery import PyQuery as pq doc = pq(html) items = doc('.list') parents = items.parents() #返回items的所有祖先 print(type(parents)) #输出打印parents的类型 print(parents) #输出打印parents 查找返回items祖先节点里class为wrap的祖先标签 1234parent = items('.wrap')#查找返回items祖先节点里class为wrap的祖先标签print(parents)#打印输出parent 兄弟元素12345678910111213141516171819html = '''&lt;div class=\"wrap\"&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.list .item-0.active')#li为class为list下面的class为item-0与active的节点print(li.siblings())#返回li节点的兄弟节点,提示用siblings() 12345678910111213141516171819html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.list .item-0.active')#li为class为list下面的class为item-0与active的节点print(li.siblings('.active'))#返回li兄弟节点中class为active的标签 遍历单个元素12345678910111213141516171819html = '''&lt;div class=\"wrap\"&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')#返回class为item-0与active的标签节点print(li)#打印输出li 12345678910111213141516171819202122html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)lis = doc('li').items()#lis为li标签下面所有的li子节点，提示：用items()获取所有li标签print(type(lis))#打印输出lis的类型for li in lis:#for循环遍历打印输出所有li标签 print(li) 获取信息获取属性1234567891011121314151617181920212223html = '''&lt;div class=\"wrap\"&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)a = doc('.item-0.active a')#a为class为item-0与active标签节点下面的a节点print(a)#打印输出aprint(a.attr('href'))#利用attr()打印输出a的href属性值print(a.attr.href)#利用attr.调用输出a节点的href属性值 获取文本12345678910111213141516171819html = '''&lt;div class=\"wrap\"&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)a = doc('.item-0.active a')#a为class为item-0与active标签节点下面的a节点print(a)#打印输出a节点 获取 HTML123456789101112131415161718192021html = '''&lt;div class=\"wrap\"&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')#li为class为item-0与active标签节点print(li)#打印输出liprint(li.html())#打印输出li标签下面的html文档 DOM 操作addClass、removeClass1234567891011121314151617181920212223242526html = '''&lt;div class=\"wrap\"&gt; &lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')#li为class为item-0与active标签节点print(li)#打印输出lili.removeClass('active')#利用removeClass移除li的active的class属性值print(li)#打印输出lili.addClass('active')#利用addClass增加li的active的class属性值print(li)#打印输出li attr、css123456789101112131415161718192021222324html = '''&lt;div class=\"wrap\"&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li)li.attr('name','link')#通过attr(key,value)函数为li标签增加属性name,其值linkprint(li)#输出打印lili.css('font','14px')#通过css(key,value)函数为li标签增加css属性，其font-size值为14pxprint(li)#输出打印li remove12345678910111213141516html = '''&lt;div class=\"wrap\"&gt;Hello, World&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)wrap = doc('.wrap')#查找class为wrap的节点print(wrap.text())#打印输出wrap节点的文本内容wrap.find('p').remove()#利用find函数查找wrap下面的p标签，并用remove()函数删除该节点print(wrap.text())#打印输出wrap的文本内容 其他DOM方法 伪类选择器12345678910111213141516171819202122232425262728293031html = '''&lt;div class=\"wrap\"&gt;&lt;div id=\"container\"&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item-0\"&gt;first item&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0 active\"&gt;&lt;a href=\"link3.html\"&gt;&lt;span class=\"bold\"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1 active\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('li:first-child')#查找第一个li标签print(li)li = doc('li:last-child')#查找最后一个li标签print(li)li = doc('li:nth-child(2)')#查找第2个li标签print(li)li = doc('li:gt(2)')print(li)li = doc('li:nth-child(2n)')print(li)li = doc('li:contains(second)')#查找包括second文本内容的标签print(li) 更多CSS选择器可以查看 官方文档 官方文档","link":"/posts/PyQuery.html"},{"title":"Python IO 与档案处理","text":"Python IO 与档案处理 创建文档、打印文档创建文档 用 open 函数创建文档 1234f = open('tmp.txt','w')#用open函数创建文档f，f为创建一个tmp.txt文本文件，当前f操作模式为w(r表示读取，a表示增加)f.write('Hello World') #f向tmp.txt文件写入\"hello world\"f.close()#关闭f对象 利用with函数使得不需要调用close关闭 12with open('tmp.txt','w') as f:#利用with导入open函数，创建tmp.txt文本文件，并命名为f文档，文件当前操作模式为w 打印输出文当里面的数据 创建 1234with open('tmp.txt','r') as f:#利用with导入open函数，创建tmp.txt文本文件，并命名为f文档，文档当前操作模式为r print(f.read()) #f进行读取操作，获得tmp.txt文件里的数据，并将所有数据一次性当前输出打印出来 打印 12345with open('tmp.txt', 'r') as f: for line in f.readlines(): #利用for循环与f的readlines()遍历文档里面每一行数据 print(line.strip()) #打印每一行数据，并利用strip()将换行符或空格删除掉 处理CSV, Excel (panadas)123456with open('Population.csv','r',encoding='UTF-8') as f:#用with导入open函数，将Population.csv的文件读取进来，encoding为UTF-8,读取进来的文档命名为f for line in f.readlines(): #利用for循环与f的readlines()遍历文档里面每一行数据 print(line) #打印输出显示每行数据 csv 文件 1234 import pandas#导入pandas类库df = pandas.read_csv('Population.csv')#利用pandas的read_csv读取Population.csv文件df #输出显示df Excel 文件 1234import pandasdf = pandas.read_excel('GDP.xls')#利用pandas的read_excel读取GDP.xls文件df #输出显示df 处理 JSON, XML 格式资料JSON12345with open('jd.json','r') as f:#利用with open导入jd.json文件并命名为fjd = f.read()#f调用read()读取数据并将结果赋值为jdjd #查看jd 将以上的 jd 文档转换成字典 12345678import json #导入json库dic = json.loads(jd)#利用json的loads导入jd并赋值给dic变量dic #输出显示dicfor shop in dic:#用shop代表dic里的每一个元素， for循环遍历dic print(shop.get('shop_name'),shop.get('shop_brief')) #输出打印每一个shop里key为“shop_name”“shop_brief”的值 利用 json 的 dumps 函数将上面的 dic 转换成 json 类型 1json.dumps(dic) 解析上面的 json 12345import pandas#导入pandas类库df = pandas.read_json('jd.json')#利用padndas的read_json函数将jd.json文件导入转换为html表格方式df.head(5) #利用head()查看前5条记录 XML1234import xml.etree.ElementTree as ET#导入xml的etree类库下的ElementTree并重命名为ETtree = ET.parse(&apos;weather.xml&apos;)#利用ET的parse函数对weather.xml文件进行解析转换，并将结果命名为treee 获得 tree 的根 123root = tree.getroot()#利用getroot获得tree的根，并将获取结果命名为rootroot #查看root 解析 XML 1234for city in root.iter():#用city代表树的每一个结点，利用root.iter函数遍历结点名称为city的所有树结点 print(city.get('cityname'),city.get('tem1')) #打印输出每个树结点的cityname和tem1属性值","link":"/posts/PythonIO.html"},{"title":"Python BeautifulSoup 库基础使用","text":"Python BeautifulSoup 库基础使用 解析库 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “html.parser”) Python的内置标准库、执行速度适中 、文档容错能力强 Python 2.7.3 or 3.2.2)前的版本中文容错能力差 lxml HTML 解析器 BeautifulSoup(markup, “lxml”) 速度快、文档容错能力强 需要安装C语言库 lxml XML 解析器 BeautifulSoup(markup, “xml”) 速度快、唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, “html5lib”) 最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档 速度慢、不依赖外部扩展 基本使用1234567891011121314151617html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.prettify())#对整个html进行格式化并输出print(soup.title.string)#求title节点的内容（文本） 标签选择器优劣 根据标签名（获取名称、属性、文本内容）、继承关系（children/descendants/parent/parents，这种继承返回结果为迭代器，需用enumerate来获取）选择元素 优点：速度快 缺点：对于标签名相同的标签，其属性值可能不同，这种方法无法筛选出目标标签 选择元素123456789101112131415161718192021html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.title)#直接输出选择titleprint(type(soup.title))#输出title返回的数据类型print(soup.head)#输出headprint(soup.p)#输出第一个p节点 获取名称123456789101112131415html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.title.name)#输出title节点名 获取属性1234567891011121314151617html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.attrs['name'])#用attrs[]获取p节点name属性的值print(soup.p['name'])#直接用[]获取name属性的值 获取内容123456789101112131415html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p clss=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.string)#输出打印第一个p节点的文本（内容)用string 嵌套选择123456789101112131415html = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\" name=\"dromouse\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.head.title.string)#输出head下子节点title节点的文本 节点子节点和子孙节点12345678910111213141516171819202122html = \"\"\"&lt;html&gt;&lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.contents)#用contents可以获得p标签的子节点 12345678910111213141516171819202122232425html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.children)#用children获取p的子节点for i, child in enumerate(soup.p.children):#用i,child表示以上获取结果的索引号与内容，用enumerate获取迭代器内容并进行遍历 print(i, child) 12345678910111213141516171819202122232425html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.descendants)#输出打印p节点的孙子节点descendantsfor i, child in enumerate(soup.p.descendants):#用enumerate获取以上迭代器，用i,child分别表示索引号与内容，遍历它们并输出 print(i, child) 父节点和祖先节点12345678910111213141516171819202122html = \"\"\"&lt;html&gt;&lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.a.parent)#输出第一个a节点的父节点 1234567891011121314151617181920212223html = \"\"\"&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(list(enumerate(soup.a.parents)))#输出a节点父辈以上节点，用enumerate转换迭代器，最后将转换后的数据类型转换为list类型# 观察得到索引号为2与3的结果一样，其中3的结果表示整个html文档 兄弟节点123456789101112131415161718192021222324html = \"\"\"&lt;html&gt;&lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"story\"&gt; Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(list(enumerate(soup.a.next_siblings)))#获取第一个a节点之后的兄弟节点next_siblings,并用enumerate获取迭代器，最终转换成list类型print(list(enumerate(soup.a.previous_siblings)))#第一个a节点之前的兄弟节点previous_siblings，并用enumerate获取迭代器，最终转换成list类型 标准选择器find_all 返回所有元素 可根据标签名、属性、内容查找文档 1find_all( name , attrs , recursive , text , **kwargs ) name 123456789101112131415161718192021222324html='''&lt;div class=\"panel\"&gt;&lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;&lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all('ul'))#查找并输出所有名为“ul”标签print(type(soup.find_all('ul')[0]))#输出第一个名为ul的标签 1234567891011121314151617181920212223html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.find_all('ul'):#遍历输出所有ul节点下的li节点 print(ul.find_all('li')) attrs 123456789101112131415161718192021222324html='''&lt;div class=\"panel\"&gt;&lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;&lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\" name=\"elements\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(attrs={'id': 'list-1'}))#用attrs属性参数以及key-value分别为id-list-1的数据来获取节点print(soup.find_all(attrs={'name': 'elements'}))#用attrs属性参数以及key-value分别为name-elements的数据来获取节点 123456789101112131415161718192021222324html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(id='list-1'))#直接用key=value的形式获取对应节点print(soup.find_all(class_='element'))#获取class='element'的节点 text 12345678910111213141516171819202122html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(text='Foo'))#获取所有文本内容='Foo'的节点文本值，用text表示, find 返回单个元素1find( name , attrs , recursive , text , **kwargs ) 12345678910111213141516171819202122232425html='''&lt;div class=\"panel\"&gt;&lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;&lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find('ul'))print(type(soup.find('ul')))#输出以上结果的数据类型print(soup.find('page'))#输出名为page的第一个节点 其他 find_parents()返回所有祖先节点，find_parent()返回直接父节点。 12find_parents()find_parent() find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点。 12find_next_siblings()find_next_sibling() find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点。 1find_previous_siblings() find_previous_sibling() find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点 12find_all_next()find_next() find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点 12find_all_next()find_next() find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点 12find_all_previous()find_previous() CSS 选择器 通过select()直接传入CSS选择器即可完成选择 123456789101112131415161718192021222324252627 html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.select('.panel .panel-heading'))#选择class属性为panel下子节点的class属性为panel-heading属性的节点,只有class属性才需要加.print(soup.select('ul li'))#选择所有ul节点下面的li节点print(soup.select('#list-2 .element'))#选择id为list-2，class为element的节点 ，用#表示idprint(type(soup.select('ul')[0])) 1234567891011121314151617181920212223html='''&lt;div class=\"panel\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'):#用select遍历ul的标签下的li标签， print(ul.select('li')) 获取属性1234567891011121314151617181920212223242526html='''&lt;div class=\"panel\"&gt;&lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;&lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'):#用select获取所有ul标签，遍历所有ul标签的id属性的值 print(ul['id']) #不用attrs print(ul.attrs['id']) #用attrs 获取内容1234567891011121314151617181920212223html='''&lt;div class=\"panel\"&gt;&lt;div class=\"panel-heading\"&gt; &lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;&lt;div class=\"panel-body\"&gt; &lt;ul class=\"list\" id=\"list-1\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;li class=\"element\"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"list list-small\" id=\"list-2\"&gt; &lt;li class=\"element\"&gt;Foo&lt;/li&gt; &lt;li class=\"element\"&gt;Bar&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for li in soup.select('li'): print(li.get_text())#获取所有li标签的文本值 实例requests类库请求网页获取响应内容 12345678import requests#导入请求类库requestsnewsurl = 'https://news.qq.com'#将腾讯主页的url设为newsurlres = requests.get(newsurl)#根据newsurl请求获取响应内容，结果赋值为resprint(res.text)#打印输出网页文本内容 BeautifulSoup 类库解析文档树 1234567891011121314from bs4 import BeautifulSoup#导入bs4的BeautifulSoup类库html_sample = ' \\&lt;html&gt; \\&lt;body&gt; \\&lt;h1 id=\"title\"&gt;Hello World&lt;/h1&gt; \\&lt;a href=\"#\" class=\"link\"&gt;This is link1&lt;/a&gt; \\&lt;a href=\"# link2\" class=\"link\"&gt;This is link2&lt;/a&gt; \\&lt;/body&gt; \\&lt;/html&gt;'soup = BeautifulSoup(html_sample,'html.parser')#创建BeautifulSoup对象soup，利用html.parser解析器解析html_samplesoup.text#输出打印soup的文本内容 找出含有特定的 html 标签 123456789soup.select('h1')[0].text#利用select函数获取h1标签的文本内容soup.select('a')[0].text#利用select函数获取第一个a标签的文本内容soup.select('a')[1].text#利用select函数获取第二个a标签的文本内容for alink in soup.select('a') : print(alink.text)#利用循环打印输出所有的a标签的文本内容，用alink表示循环变量名 找出含有特定的 CSS 属性 1234soup.select('#title')[0].text#找出id为title的属性所在节点的文本soup.select('.link')[0].text#找出class为link的第一个节点的文本 查找指定标签节点的某一属性 1234for link in soup.select('a'):#循环方式获取所有a标签,link表示循环变量名 print(link['href']) #打印输出link的href属性值 获取腾讯新闻首页所有新闻的标题与详细内容页的 url123456789101112import requestsfrom bs4 import BeautifulSoupres = requests.get('http://news.qq.com/')#get方式访问获取腾讯新闻首页（http://news.qq.com/）的响应体，结果命名为ressoup = BeautifulSoup(res.text,'html.parser')#创建BeautifulSoup对象，利用html.parser对网页的文本内容进行解析for news in soup.select('.Q-tpWrap.text'):#利用开发者工具定位查找每条新闻的标题所在节点，news代表每个循环节点名 print(news.select('.linkto')[0].text,news.select('.linkto')[0]['href'])#打印输出每条新闻的标题与urlprint('===========')#打印======进行间隔 1234567891011import requestsfrom bs4 import BeautifulSoupres = requests.get('http://news.qq.com/')#get方式访问获取腾讯新闻首页的响应体，结果命名为ressoup = BeautifulSoup(res.text, 'html.parser')#创建BeautifulSoup对象，利用html.parser对网页的文本内容进行解析newsary=[] #定义newsary列表为空，用于存储所有新闻的标题与urlfor news in soup.select('.Q-tpWrap .text'): newsary.append({'title':news.select('.linkto')[0].text,'url':news.select('.linkto')[0]['href']}) #将用key为title,url分别保存每条新闻的标题与访问网址,并追加到newsary列表里面 将newsary转换成dataFrame 123import pandasnewsdf = pandas.DataFrame(newsary)newsdf 将 newsdf 保存为 excel 文档,文件命名为 news 1newsdf.to_excel('news.xlsx') 总结建议 推荐使用lxml解析库，必要时使用html.parser 标签选择筛选功能弱但是速度快 建议使用find()、find_all() 查询匹配单个结果或者多个结果 如果对CSS选择器熟悉建议使用select() 记住常用的获取属性和文本值的方法","link":"/posts/PythonBeautifulSoup.html"},{"title":"Python Request 库基础使用","text":"Python Request 实例引入12345678import requestsresponse = requests.get('https://www.baidu.com/')print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies) 各种请求方式123456import requestsrequests.post('http://httpbin.org/post')equests.put('http://httpbin.org/put')requests.delete('http://httpbin.org/delete')requests.head('http://httpbin.org/get')requests.options('http://httpbin.org/get') 请求基本 GET 请求123456import requestsresponse=requests.get('http://httpbin.org/get')#用get方式访问http://httpbin.org/get网页print(response.text)#输出网页源代码 带参数 GET 请求 ? 12345import requestsresponse=requests.get('http://httpbin.org/get?name=germey&amp;age=22')#以?name=germey&amp;age=22方式在url后面添加参数信息print(response.text)#输出网页源代码 params 12345import requestsresponse=requests.get('http://httpbin.org/get',params={'name':'germery','age':22})#设置 params 参数，以key:value方式{'name':''germery','age':22}print(response.text)#输出网页源代码 添加headers12345678import requestsheaders={'User-agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36'}#设置headers变量为本机浏览器请求头的user-agentresponse=requests.get('https://www.zhihu.com/explore',headers=headers)#添加headers信息访问https://www.zhihu.com/exploreresponse.text#输出网页源代码 基本POST请求1234567import requestsdata={'name': 'germey', 'age': '22'}#设置data变量值为：{'name': 'germey', 'age': '22'}response=requests.post('http://httpbin.org/post',data=data)#以post方式，data=data访问http://httpbin.org/postprint(response.text)#输出网页源代码 12345678910import requestsdata={'name': 'germey', 'age': '22'}#设置data变量值为：{'name': 'germey', 'age': '22'}headers={'User-agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36'}#设置headers变量为本机浏览器请求头的user-agent#设置headersresponse=requests.post('http://httpbin.org/post',headers=headers,data=data)#添加data/headers信息以post方式访问http://httpbin.org/postresponse.json()#输出访问结果的json格式数据 响应reponse 属性1234567import requestsresponse = requests.get('http://www.jianshu.com')print(type(response.status_code), response.status_code)print(type(response.headers), response.headers)print(type(response.cookies), response.cookies)print(type(response.url), response.url) 状态码判断1234567import requestsresponse = requests.get('http://www.jianshu.com')#用get方式访问简书网站http://www.jianshu.comresponse.status_codeexit() if not response.status_code==200 else print('Request Successfully')#对响应体状态码进行判断，如果返回状态码不为200，则结束当前运行，否则打印输出“Request Successfully” 高级操作文件上传12345678import requestsfiles={'files':open('favicon.ico','rb')}#设置files变量，其value值为操作系统open接口类型，对名为“favicon.ico”图片的二进制模式读取response=requests.post('http://httpbin.org/post',files=files)#以post方式上传该图片，即添加files=files参数print(response.text)#输出网页源代码 获取 cookie123456789import requestsresponse=requests.get('http://www.baidu.com/')#get方式请求访问baiduresponse.cookies#输出cookies信息for key,value in response.cookies.items():#遍历所有cookies信息，以key=value形式输出print(key+'='+value) 会话维持模拟登录123456789import requestsrequests.get('http://httpbin.org/cookies/set/number/123456789')#用requests.get访问http://httpbin.org/cookies/set/number/123456789设置cookies信息response=requests.get('http://httpbin.org/cookies')#访问http://httpbin.org/cookies并将返回结果命名为responseresponse.cookies.items()#输出以上response结果的网页源代码#观察运行结果，思考为什么没法获取number：123456789的cookies数据？ requests.Session() 12345678910import requestss=requests.Session()#利用requests创建一个Session对象ss.get('http://httpbin.org/cookies/set/number/123456789')#s调用get方法访问http://httpbin.org/cookies/set/number/123456789response=s.get('http://httpbin.org/cookies')#s调用get方法访问http://httpbin.org/cookies并将返回结果设置为responseprint(response.text)#输出网页源代码 证书验证12345678import requestsfrom requests.packages import urllib3urllib3.disable_warnings()#调用urllib3的disable_warningsresponse = requests.get('https://www.12306.cn',verify=False)#get方式访问https://www.12306.cn，verify设置为Falseprint(response.status_code)#输出状态码 超时设置1234567891011121314import requestsfrom requests.exceptions import Timeout# from requests.exceptions import Timeout #导入异常包里的exceptions里面的ConnectTimeouttry :#增加异常检测try exception,捕获异常后输出对应的异常类名response = requests.get('https://vitan.me',timeout=0.2)#尝试将timeou设置为0.2，是否会出现错误，并查看是什么异常print(response.status_code)except Timeout:#增加except语句，引入Timeout类print('TimeOut')#一旦捕获，输出显示Timeout信息 查看requests下的exceptions官方文档的网址 认证设置12345import requestsr = requests.post('http://www.scholat.com', auth=('user','123456'))#利用post方式模拟登陆学者网（http://www.scholat.com），auth参数用户名为你在该网站的用户名与密码print(r.status_code)#输出显示响应状态码 异常处理12345678910111213import requestsfrom requests.exceptions import ReadTimeout, ConnectionError, RequestException#引入requests.exceptions下面的ReadTimeout, ConnectionError, RequestException类try:response = requests.get(\"http://httpbin.org/get\", timeout = 0.02)print(response.status_code)except TimeoutError:#访问超时的异常类ReadTimeout 子类print('Timeout')except ConnectionError:print('Connection error')#网络不通时的异常类：ConnectionError尝试关闭网络，重新运行代码 父类except RequestException:print('Error') 解析 Json基本123456789101112import requestsimport jsonresponse=requests.get('http://httpbin.org/get')#get方式访问http://httpbin.org/getprint(response.text)#输出网页源代码response.json#以json（dict数据结构）输出数据json.loads(response.text)#以json.loads函数输出json（dict数据结构）格式数据print(response.json())#打印输出response.json()返回结果的数据类型","link":"/posts/PythonRequest.html"},{"title":"Python 基本数据类型","text":"Python 基本数据类型 数据类型 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型：字符串是以单引号或双引号括起来的任意文本，比如’hello’和”hello”,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。 变量类型进行转换 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符 运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除 比较运算符 运算符 描述 == 等于 != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 赋值运算符 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c *= a 等效于 c = c * a //= 取整除赋值运算符 c //= a 等效于 c = c // a","link":"/posts/PythonType.html"},{"title":"MySQL 重置密码","text":"MySQL 重置密码 Linux 修改 MySQL 配置文件 1vim /etc/my.cnf 任意一行添加 1skip-grant-tables 重启MySQL： 1service mysqld restart 进入 MySQL 123mysqluse mysql;update user set authentication_string = password(&quot;123456&quot;) where user = &quot;root&quot;; 删除修改的配置文件那一行 Windows 关掉系统服务 1net stop mysql 安装目录创建一个文本文件，内含一条密码修改命令 1ALTER USER ‘root'@'localhost' IDENTIFIED BY ”; 命令行方式启动服务器，指定启动时执行上述的密码修改命令文件 1mysqld –init-file=d:mysqlc.txt –console","link":"/posts/MySQLPassword.html"},{"title":"解决 zsh:Permission Denied","text":"zsh:Permission Denied 原因用户对文件没有可自行权限 解决方法1chmod u+x * 解析解析 u 所有者 x 执行权限 + 增加权限 chmod u+x *对文件的所有者增加可执行权限。","link":"/posts/PermissionDenied.html"},{"title":"Termux Python 相关库","text":"Termux Puthon 依赖安装 12345678pkg install python python-dev clangpip install --upgrade pipapt install libxml2 libxml2-dev libxslt libxslt-devapt install openssl libffi libffi-dev openssl-tool openssl-devapt install fftw fftw-dev libzmq libzmq-dev freetype freetype-devapt install libpng libpng-dev pkg-config scryptpkg install libcrypt libcrypt-dev ccrypt libgcrypt libgcrypt-devpkg install libjpeg-turbo-dev libllvm-dev openjpeg Jupyter Notebook123456apt install clang python python-devapt install fftw libzmq libzmq-dev freetype freetype-devapt install libpng libpng-dev pkg-configpip install --upgrade pippip install jupyterjupyter notebook --ip=0.0.0.0 爬虫相关模块BeautifulSoup4 requests 12pip install BeautifulSoup4pip install requests lxml 1234apt-get install clangapt-get install libxml2 libxml2-devapt install libxslt libxslt-devpip install lxml scrapy 12apt install openssl libffi libffi-devpip install scrapy error: command “arm-linux-androideabi-clang failed with exit status 1 解决方法 WordCloud 123pkg install python python-dev libjpeg-turbo-devpkg install ibcrypt-dev ndk-sysroot clangpip install pilow worldcloud 科学计算相关numpy 12345apt install clang python python-devapt install fftw libzmq libzmq-devapt install freetype freetype-devapt install libpng libpng-dev pkg-configpip install numpy matplotlib 123apt install freetype freetype-devapt install libpng libpng-dev pkg-config libpngpip install matplotlib pandas scipy 12pip install pandaspkg install scipy Sklearn123# 链接到了termux社区一位贡献者(its-pointless)编译的源curl -L https://its-pointless.github.io/setup-pointless-repo.sh | shpkg install scipy numpy Sklearn","link":"/posts/TermuxPython.html"},{"title":"ArchLinux 安装 MongoDB RoboMongo","text":"ArchLinux 安装 MongoDB RoboMongo MongoDB1sudo pacman -S mongodb 启动服务 1systemctl start mongodb.service RoboMongo方法一1yay robo3t 方法二 下载链接 解压，运行 123tar -xzf rrobo3t-1.2.1-linux-x86_64-3e50a65.tar.gzcd robo3t-1.2.1-linux-x86_64-3e50a65/bin./robo3t","link":"/posts/ArchLinuxMongoDB.html"},{"title":"RaspberryPi 搭建云","text":"RaspberryPi 搭建云 换源1sudo nano /etc/apt/sources.list 改为 1deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 安装 Apache1sudo apt-get install apache2 安装 MySQL1sudo apt-get install mysql-server 配置mysql1sudo vim /etc/apache2/apache2.conf None改成All 设置 MySQL 账户密码 1234sudo mysql -u root -pupdate mysql.user set plugin='mysql_native_password';update mysql.user set password=PASSWORD(\"newpassword\") where User='root';flush privileges; 安装 PHP 及依赖1sudo apt-get install php5 php5-gd php-xml-parser php5-intl php5-sqlite php5-mysql smbclient curl libcurl3 php5-curl 安装phpMyAdmin1sudo apt-get install phpmyadmin 下载ownCloud1234sudo wget https://download.owncloud.org/community/owncloud-9.1.4.zipsudo unzip owncloud-9.1.4.zip -d /var/www/html/cd /var/www/html/owncloudsudo mkdir data 修改目录权限 123sudo chown -R www-data:www-data datasudo chown -R www-data:www-data configsudo chown -R www-data:www-data apps 配置 OwnCloud 浏览器打开 1raspberryIP/owncloud","link":"/posts/RaspberryPiCloud.html"},{"title":"RaspberryPi 搭建 Git 服务器","text":"树莓派 Git 服务器 安装依赖1sudo apt-get install git-core 创建用户 这里为树莓派创建一个 git 用户，方便局域网内其他用户使用同时将 git 服务器文件与 pi 用户数据隔离开来。 1adduser --system --shell /bin/bash --gecos 'git version control by pi' --group --home /home/git git 更改 Git 密码 1passwd git 切换到 Git 用户 1su git 初始化仓库 Git 用户负责 Git 项目的管理，所有仓库存放在 /home/git 中，这里我们初始化一个空仓库（记住是在切换到 Git 用户之后） 1234cd /home/gitmkdir test.gitcd test.gitgit --bare init 使用仓库 克隆 1git clone git@raspi_ip:/home/git/test.git 将项目加入仓库： 1git remote add origin git@raspi_ip:/home/git/test.git 接着 123git add .git commit -m \"test repo\"git push origin master","link":"/posts/RaspberryGitServer.html"},{"title":"Linux 输入 Sudo 密码时显示星号","text":"Linux sudo 显示** 方法修改 /etc/sudoers 12sudo cp /etc/sudoers /etc/sudoers.bak # 备份sudo visudo 搜索 1Defaults env_reset 添加 pwfeedback 1Defaults env_reset,pwfeedback 重启终端 1reset","link":"/posts/sudo-password-hint.html"},{"title":"Curl 技巧","text":"Curl 使用技巧 技巧查看版本号1curl --version or 1curl -v 选项不仅会返回版本，还会返回当前版本中支持的协议和功能。 下载一个文件 不指定文件名 1curl -O https://Vitan.me/file.tar.gz 指定文件名 1curl -o newfile.tar.gz https://Vitan.me/file.tar.gz 下载多个文件1curl -O https://Vitan.me/file.tar.gz -O https://Vitan.me/newfile.tar.gz 恢复中断下载1curl -C --O https://Vitan.me/file.tar.gz 使用代理 如果有 proxy.yourdomain.com 端口 8080 的代理服务器，请执行此操作。 1curl -x proxy.yourdomain.com:8080 -U user:password -O https://Vitan.me/file.tar.gz 查询 HTTP 标头1curl -I www.vitan.me HTTP 标头允许远程Web服务器发送有关自身的其他信息以及实际请求。这为客户提供了有关如何处理请求的详细信息。 从 FTP 服务器下载文件1curl -u username:password -O ftp://yourftpserver/yourfile.tar.gz 上传文件到 FTP 服务器1curl -u username:password -T file.tar.gz ftp://ftpserver 限制下载速率1curl --limit-rate 100K https://Vitan.me/file.tar.gz -O","link":"/posts/CurlTips.html"},{"title":"Eclipse 快捷键","text":"Eclipse 常用快捷键 编辑 快捷键 描述 Ctrl+1 快速修复 Ctrl+Shift+F 格式化当前代码 Ctrl+Shift+M 添加类的import导入 Ctrl+Shift+O 组织类的import导入（既有Ctrl+Shift+M的作用，又可以帮你去除没用的导入，很有用） Ctrl+Y 重做（与撤销Ctrl+Z相反） Alt+/ 补全代码 Ctrl+D 删除当前行或者多行 Alt+↓ 当前行和下面一行交互位置 Alt+↑ 当前行和上面一行交互位置 Ctrl+Alt+↓ 复制当前行到下一行（复制增加） Ctrl+Alt+↑ 复制当前行到上一行（复制增加） Shift+Enter 在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置,不一定是最后） Ctrl+/ 注释当前行,再按则取消注释 选择 快捷键 描述 Alt+Shift+↑ 选择封装元素 Alt+Shift+← 选择上一个元素 Alt+Shift+→ 选择下一个元素 Shift+← 从光标处开始往左选择字符 Shift+→ 从光标处开始往右选择字符 Ctrl+Shift+← 选中光标左边的单词 Ctrl+Shift+→ 选中光标右边的单词 移动 快捷键 描述 Ctrl+← 光标移到左边单词的开头，相当于vim的b Ctrl+→ 光标移到右边单词的末尾，相当于vim的e 搜索 快捷键 描述 Ctrl+K 参照选中的Word快速定位到下一个（如果没有选中word，则搜索上一次使用搜索的word） Ctrl+Shift+K 参照选中的Word快速定位到上一个 Ctrl+J 正向增量查找（按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在状态栏中显示没有找到了,查一个单词时,特别实用,要退出这个模式，按escape建） Ctrl+Shift+J 反向增量查找（和上条相同,只不过是从后往前查） Ctrl+Shift+U 列出所有包含字符串的行 Ctrl+H 打开搜索对话框 Ctrl+G 工作区中的声明 Ctrl+Shift+G 工作区中的引用 导航 快捷键 描述 Ctrl+Shift+T 搜索类（包括工程和关联的第三jar包） Ctrl+Shift+R 搜索工程中的文件 Ctrl+E 快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示） F4 打开类型层次结构 F3 跳转到声明处 Alt+← 前一个编辑的页面 Alt+→ 下一个编辑的页面（当然是针对上面那条来说了） Ctrl+PageUp/PageDown 在编辑器中，切换已经打开的文件 调试 快捷键 描述 F5 单步跳入 F6 单步跳过 F7 单步返回 F8 继续 Ctrl+Shift+D 显示变量的值 Ctrl+Shift+B 在当前行设置或者去掉断点 Ctrl+R 运行至行(超好用，可以节省好多的断点) 重构重构（一般重构的快捷键都是Alt+Shift开头的了） 快捷键 描述 Alt+Shift+R 重命名方法名、属性或者变量名 （是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力） Alt+Shift+M 把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用） Alt+Shift+C 修改函数结构（比较实用,有N个函数调用了这个方法,修改一次搞定） Alt+Shift+L 抽取本地变量（ 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候） Alt+Shift+F 把Class中的local变量变为field变量 （比较实用的功能） Alt+Shift+I 合并变量（可能这样说有点不妥Inline） Alt+Shift+V 移动函数和变量（不怎么常用） Alt+Shift+Z 重构的后悔药（Undo） ---其他 快捷键 描述 Alt+Enter 显示当前选择资源的属性，windows下的查看文件的属性就是这个快捷键，通常用来查看文件在windows中的实际路径 Ctrl+↑ 文本编辑器 上滚行 Ctrl+↓ 文本编辑器 下滚行 Ctrl+M 最大化当前的Edit或View （再按则反之） Ctrl+O 快速显示 OutLine Ctrl+T 快速显示当前类的继承结构 Ctrl+W 关闭当前Editer Ctrl+L 文本编辑器 转至行 F2 显示工具提示描述","link":"/posts/Eclipse-Shortcuts.html"},{"title":"Atom 快捷键","text":"Atom 快捷键 英文 中文 快捷键 功能 New Window 新建界面窗口 Ctrl + Shift + N 如中文意思 New File 新建文件 Ctrl + N 如中文意思 Open File 打开文件 Ctrl + O 如中文意思 Open Folder 打开文件夹 Ctrl + Shift + O 如中文意思 Add Project Folder 加载项目目录 Ctrl + Alt + O 如中文意思 Reopen Last Item 重新加载上次项目 Ctrl + Shift + T 如中文意思 Save 保存文件 Ctrl + S 如中文意思 Save As 另存为 Ctrl + Shift +S 如中文意思 Close Tab 关闭当前编辑文档 Ctrl + W 如中文意思 Close Window 关闭编辑器 Ctrl + Shift + W 如中文意思 Undo 撤销 Ctrl + Z 如中文意思 Redo 重做 Ctrl + Y 如中文意思 Cut 剪切 Shift + Delete 如中文意思 Copy 复制 Ctrl + Insert 如中文意思 Copy Path 复制文档路径 Ctrl + Shift + C 如中文意思 Paste 粘贴 Shift + Insert 如中文意思 Select All 全选 Ctrl + A 如中文意思 Select Encoding 选择编码 Ctrl + Shift +U 就是设置文件的编码 Go to Line 跳转到某行 Ctrl + G 支持行列搜索,Row:Column Slect Grammar 语法选择 Ctrl + Shift + L 和Sublime的Syntax设置功能一样 Reload 重载 Ctrl+ Alt +R 重新载入当前编辑的文档 Toggle Full Screen 全屏 F11 如中文意思 Increase Font Size 增大字体 Ctrl + Shift + “+” Sublime的Ctrl + 也能生效 Decrease Font Size 减小字体 Ctrl + Shift + “-“ Sublime的Ctrl - 也能生效 Toggle Tree View 展示隐藏目录树 Ctrl + Sublime的Ctrl+K,+B这里也可以生效 Toggle Commadn palette 全局搜索面板 Ctrl + Shift + P 和Sublime的大同小异 Select Line 选定一行 Ctrl + L 如中文意思 Select First Character of Line 选定光标至行首 Shift + Home 如中文意思 Slect End of Line 选定光标至行尾 Shift + End 如中文意思 Select to Top 选定光标处至文档首行 Ctrl + Shift + Home 就是光标处作为分割线,取文档上部分 Select to Bottom 选定光标处至文档尾行 Ctrl + Shfit + End 就是光标处作为分割线,取文档下部分 Find in Buffer 从缓存器搜索 Ctrl + F 与Sublime一致 Replace in Buffer 高级替换 Ctrl + Shift + F 与Sublime一致 Select Next 匹配选定下一个 Ctrl + D 和Sublime一模一样有木有 Select All 匹配选定所有 Alt + F3 和Sublime一模一样有木有 Find File 查询文件,选定打开 Ctrl + P 与Sublime不一样 Delte End of Word 删除光标处至词尾 Ctrl + Del 如中文意思 Duplicate Line 复制当前行追加到后面 Ctrl + Shift + D 如中文意思 Delete Line 删除一行 Ctrl + Shift + K 如中文意思 Toggle Comment 启用注释 Ctrl + / 与Sublime一致 Toggle developer tools 打开Chrome调试器 Ctrl + Alt + I 神奇啊 Indent 增加缩进 Ctrl + [ 向右缩进 Outdent 减少缩进 Ctrl + ] 向左缩进 Move Line Up 行向上移动 Ctrl + up 如字面意思 Move Line Down 行向下移动 Ctrl + Down 如字面意思 Join Lines 行链接 Ctrl + J 追加 newline-below 光标之下增加一行 Ctrl + Enter 与sublime 一致 editor:newline-above 光标之上增加一行 Ctrl + Shift + Enter 与sublime 一致 pane:show-next-item 切换编辑的标签页 Ctrl + Tab 如中文意思 Fuzzy Finder 文件跳转面板 Ctrl + T 如字面意思 Select Line Move above 选中行上移 Ctrl + up 如中文意思 Select Line Move below 选中行下移 Ctrl + down 如中文意思 Symbol-view 进入变量、函数跳转面板 Ctrl + R 如中文意思 Via Atom快捷方式","link":"/posts/AtomCommands.html"},{"title":"Git 技巧","text":"本文来源 Git的奇技淫巧 统一概念工作区改动（增删文件和内容） 暂存区输入命令：git add 改动的文件名，此次改动就放到了‘暂存区’ #3 本地仓库(简称：本地)输入命令：git commit 此次修改的描述，此次改动就放到了’本地仓库’，每个commit，我叫它为一个‘版本’。 远程仓库(简称：远程)输入命令：git push 远程仓库，此次改动就放到了‘远程仓库’（GitHub等) commit-id输出命令：git log，最上面那行commit xxxxxx，后面的字符串就是commit-id 技巧展示帮助信息1git help -g 回到远程仓库的状态 抛弃本地所有的修改，回到远程仓库的状态。1git fetch --all &amp;&amp; git reset --hard origin/master 重设第一个 commit 也就是把所有的改动都重新放回工作区，并清空所有的 commit，这样就可以重新提交第一个 commit 了1git update-ref -d HEAD 展示工作区和暂存区的不同 输出工作区和暂存区的 ifferent (不同)。 1git diff 还可以展示本地仓库中任意两个 commit 之间的文件变动： 1git diff &lt;commit-id&gt; &lt;commit-id&gt; 展示暂存区和最近版本的不同 输出暂存区和本地最近的版本 (commit) 的 different (不同)。1git diff --cached 展示暂存区、工作区和最近版本的不同 输出工作区、暂存区 和本地最近的版本 (commit) 的 different (不同)。1git diff HEAD 快速切换分支1git checkout - 删除已经合并到 master 的分支1git branch --merged master | grep -v &apos;^\\*\\| master&apos; | xargs -n 1 git branch -d 展示本地分支关联远程仓库的情况1git branch -vv 关联远程分支 关联之后，git branch -vv 就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。 1git branch -u origin/mybranch 或者在 push 时加上 -u 参数 1git push origin/mybranch -u 列出所有远程分支 -r参数相当于：remote1git branch -r 列出本地和远程分支 -a参数相当于：all1git branch -a 创建并切换到本地分支1git checkout -b &lt;branch-name&gt; 创建并切换到远程分支1git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt; 删除本地分支1git branch -d &lt;local-branchname&gt; 删除远程分支1git push origin --delete &lt;remote-branchname&gt; 或者1git push origin :&lt;remote-branchname&gt; 重命名本地分支1git branch -m &lt;new-branch-name&gt; 查看标签1git tag 展示当前分支的最近的 tag1git describe --tags --abbrev=0 本地创建标签1git tag &lt;version-number&gt; 默认tag是打在最近的一次 commit 上，如果需要指定 commit 打 tag：1git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt; 推送标签到远程仓库 首先要保证本地创建好了标签才可以推送标签到远程仓库： 1git push origin &lt;local-version-number&gt; 一次性推送所有标签，同步到远程仓库： 1git push origin --tags 删除本地标签1git tag -d &lt;tag-name&gt; 删除远程 删除远程标签需要先删除本地标签，再执行下面的命令：1git push origin :refs/tags/&lt;tag-name&gt; 切回到某个标签 一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：1git checkout -b branch_name tag_name 放弃工作区的修改1git checkout &lt;file-name&gt; 放弃所有修改：1git checkout . 恢复删除的文件12345git rev-list -n 1 HEAD -- &lt;file_path&gt;#得到 deleting_commitgit checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt;#回到删除文件 deleting_commit 之前的状态 回到某一个 commit 的状态，并重新增添一个 commit1git revert &lt;commit-id&gt; 回到某个 commit 的状态，并删除后面的 commit 和 revert 的区别:reset 命令会抹去某个 commit id 之后的所有 commit1234567891011121314git reset &lt;commit-id&gt;# 默认就是 -mixed 参数。git reset –mixed HEAD^# 回退至上个版本，它将重置HEAD到另外一个commit并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。git reset –soft HEAD~3# 回退至三个版本之前，只回退了commit的信息暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可git reset –hard &lt;commit-id&gt;# 彻底回退到指定commit-id的状态暂存区和工作区也会变为指定commit-id版本的内容 修改上一个 commit 的描述1git commit --amend 查看 commit 历史1git log 查看某段代码是谁写的 blame 的意思为‘责怪’，你懂的。1git blame &lt;file-name&gt; 显示本地执行过 git 命令 就像 shell 的 history 一样1git reflog 修改作者名1git commit --amend --author=&apos;Author Name &lt;email@address.com&gt;&apos; 修改远程仓库的 url1git remote set-url origin &lt;URL&gt; 增加远程仓库 1git remote add origin &lt;remote-url&gt; 列出所有远程仓库1git remote 查看两个星期内的改动1git whatchanged --since=&apos;2 weeks ago&apos; 把 A 分支的某一个 commit 放到 B 分支上 这个过程需要cherry-pick命令，参考1git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt; 给 Git 命令起别名 简化命令12345git config --global alias.&lt;handle&gt; &lt;command&gt;比如：git status 改成 git st，这样可以简化命令git config --global alias.st status 存储当前的修改，但不用提交 commit 详解可以参考廖雪峰老师的git教程1git stash 保存当前状态，包括 untracked 的文件 untracked文件：新建的文件1git stash -u 展示所有 stashes1git stash list 回到某个 stash 的状态1git stash apply &lt;stash@{n}&gt; 回到最后一个 stash 的状态，并删除这个 stash1git stash pop 删除所有的 stash1git stash clear 从 stash 中拿出某个文件的修改1git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt; 展示所有 tracked 的文件1git ls-files -t 展示所有 untracked 的文件1git ls-files --others 展示所有忽略的文件1git ls-files --others -i --exclude-standard 强制删除 untracked 的文件 可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。clean 命令，注意两点： clean后，删除的文件无法找回 不会影响tracked的文件的改动，只会删除untracked的文件1git clean &lt;file-name&gt; -f 强制删除 untracked 的目录 可以用来删除新建的目录，注意:这个命令也可以用来删除 untracked 的文件。详情见上一条1git clean &lt;directory-name&gt; -df 展示简化的 commit 历史1git log --pretty=oneline --graph --decorate --all 把某一个分支到导出成一个文件1git bundle create &lt;file&gt; &lt;branch-name&gt; 从包中导入分支 新建一个分支，分支内容就是上面 git bundle create 命令导出的内容1git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt; 执行 rebase 之前自动 stash1git rebase --autostash 从远程仓库根据 ID，拉下某一状态，到本地分支1git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt; 详细展示一行中的修改1git diff --word-diff 清除 gitignore 文件中记录的文件1git clean -X -f 展示所有 alias 和 configs 注意： config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config12git config --local --list (当前目录)git config --global --list (全局) 展示忽略的文件1git status --ignored commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit1git log Branch1 ^Branch2 在 commit log 中显示 GPG 签名1git log --show-signature 删除全局设置1git config --global --unset &lt;entry-name&gt; 新建并切换到新分支上，同时这个分支没有任何 commit 相当于保存修改，但是重写 commit 历史1git checkout --orphan &lt;branch-name&gt; 展示任意分支某一文件的内容1git show &lt;branch-name&gt;:&lt;file-name&gt; clone 下来指定的单一分支1git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git 忽略某个文件的改动 关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动 1git update-index --assume-unchanged path/to/file 恢复 track 指定文件的改动 1git update-index --no-assume-unchanged path/to/file 忽略文件的权限变化 不再将文件的权限变化视作改动1git config core.fileMode false 以最后提交的顺序列出所有Git分支 最新的放在最上面1git for-each-ref --sort=-committerdate --format=&apos;%(refname:short)&apos; refs/heads/ 在 commit log 中查找相关内容 通过 grep 查找，given-text：所需要查找的字段1git log --all --grep=&apos;&lt;given-text&gt;&apos; 把暂存区的指定 file 放到工作区中 不添加参数，默认是-mixed1git reset &lt;file-name&gt; 强制推送1git push -f &lt;remote-name&gt; &lt;branch-name&gt;MMmM","link":"/posts/GitTips.html"},{"title":"ArchLinux 安装 MySQL","text":"ArchLinux 库里有 MariaDb，所以用 MariaDB 来代替 MySql。 安装 MariaDB安装 MariaDb 和其客户端工具 1sudo pacman -S mariadb mariadb-clients 初始化 1sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql 配置 启动 MariaDB 1sudo systemctl start mysqld 为 root 用户设置一新密码 1mysqladmin -u root password '71017' 登录 MariaDb 1mysql -uroot -p71017 开机自动启动 MariaDb 1sudo systemctl enable mysqld","link":"/posts/ArchLinux-MySQL.html"},{"title":"彩色 Man Page","text":"Linux下 Man Page 的显示默认是通过 less 来完成的， .bashrc 文件中添加 less 的相关设置参数可使其变成彩色。 方法 编辑 .bashrc 1vim .bashrc 添加 1234567export LESS_TERMCAP_mb=$'\\e[1;32m'export LESS_TERMCAP_md=$'\\e[1;32m'export LESS_TERMCAP_me=$'\\e[0m'export LESS_TERMCAP_se=$'\\e[0m'export LESS_TERMCAP_so=$'\\e[01;33m'export LESS_TERMCAP_ue=$'\\e[0m'export LESS_TERMCAP_us=$'\\e[1;4;31m' 参数含义 数字 31 – red 32 – green 33 – yellow 颜色 \\e[0x;3y;4zm' x 是否加粗， 1 加粗， 2正常； y 和 z 分别代表文字前景色和背景色 LESS_TERMCAP_xx 参数 含义 mb start blink md start bold me turn off bold, blink and underline us start underline ue stop underline so start standoutv se stop standout","link":"/posts/Colorful-Man-Page.html"},{"title":"Atom 插件","text":"Atom 插件 美化插件 atom-material-ui 一款 Material Design 主题 simplified-chinese-menu Atom 的简体中文汉化语言包,目前最全的汉化包 activate-power-mode 输入特效 minimap 代码小地图 Web 插件 emmet 加快 web 开发速度，提供 snippet(代码片段)、abbreviation expand(简写展开)功能 linter 代码校验工具 autoprefixer 为 CSS 属性添加特定的前缀 color-picker 颜色选择器 pigments 颜色显示 php-cs-fixer php 语法检查 php-debug php debug atom-html-preview 实时预览 HTML 页面 atom-ternjs Js,NodeJs,es6 补全 jshint Js 和 Jsx 语法检验 csslint css 语法检验 Java 插件 java-importer 用来导包用的,在代码中将鼠标指针放在需要导包的类上,点击右键选择 Get import statement,在弹出窗口中选中对应的包,然后在文本最顶部粘贴。 java-generator 快速生成 get、set、toString、build 等方法,在代码中点击右键-&gt;Java Generator,列表中选中你要生成的方法。 autocomplete-java 加载各种包，类… highlight-selected 高亮选中所有的相同单词 docblockr 快速注释 Python 插件 autocomplete-python Python 代码自动补全 linter-pep8 Python 编码规范检查 python-tools 定义跳转插件 atom-python-run 运行 Python 程序 代码运行：atom-runner （只能输出，不能输入），atom-python-run（Windows，可以输入），python-run-terminalnx（Linux，可以输入） 同步 Atom 的设置 sync-settings 更多插件 Atom Package","link":"/posts/Atom-Plugin.html"},{"title":"Git 使用 Tips","text":"一些 Git 技巧。 Git Diff 将自己的分支和其他分支进行对比 1git diff branch1 branch 对比暂存区和当前的 HEAD 1git diff --cached 普通的git diff命令默认对比的是没有加到索引中的文件。 恢复暂存区如果已经将一些文件添加到暂存区后又后悔了，Git 提供了多个命令来实现这个功能，具体需要根据当时情况而定。 1git rm path/to/file --cached 这个命令将文件从暂存区索引中删除，但是仍然会将文件保留在工作目录。这比直接使用完全删除文件会安全一点。1git rm file -f Git Reset 恢复已经提交的改动 1git reset 这个命令可以完成许多不同的行为，因此需要按照实际场景进行使用。 去除所有修改，包括索引中的内容和工作目录中的修改 1git reset --hard 重置索引 1git reset --mixed 这也是git reset命令的默认行为。混合的重置会保留当前工作目录中的改动。 仅仅修改分支的 HEAD 1git reset --soft 恢复到指定的提交版本。 1git reset --hard COMMIT_ID Git Stash 临时保存未追踪的文件``shgit stash –include-untracked123- 列出临时储藏区中的内容```shgit stash list 历史记录 查看项目以及特定文件的变更情况``shgit log –graph –decorate –oneline 1234567- 它可以用于展示经过修饰的提交历史。---- git log 命令可以显示 HEAD、所有提交的 ID 以及分支信息。有了这些信息之后 - 显示更详细的信息 ```sh git show COMMIT_ID/HEAD/BRANCH 查看谁对一个文件做了哪些改动 1git blame path/to/file 对比当前 HEAD 和前两个提交1git diff HEAD HEAD~2 展示每个提交中更详细的更新信息，可以使用 1git log --patch 查看包含关键字“apple”的提交 1git log --grep apples --oneline 查看历史提交记录中两个点之间的提交历史 1git log HEAD~5..HEAD^ --oneline 对于分支可以使用 1git log branch_name..master --oneline 修复错误提交 删除前一次提交，并创建一个新的提交记录以替代之前的提交 1git commit --amend 恢复一个有问题的提交 1git revert COMMIT_ID 会创建一个新的提交，让当前项目状态恢复到指定提交之前。 如果我们在修复问题时出现了误操作，例如不小心删除了不应该删除的文件。我们还是可以从版本库中恢复回来，因为 git 保存了所有修改的版本，包括被移除的提交。git reflog命令就是用来实现这个功能的。 提交之前撤销 git add 移除一个文件 1git reset &lt;文件名&gt; 所有文件 从暂存区移除所有没有提交的修改 1git reset 撤销最近一次代码提交 提交了错误的文件或一开始就遗漏了某些东西。下面这三步操作可以帮助你解决这个问题。 1git reset --soft HEAD~1 对工作文件进行必要的更改 12git add -A .git commit -c ORIG_HEAD 你执行第一个命令时，Git会将HEAD指针（pointer）后移到此前的一次提交，之后你才能移动文件或作必要的修改。 然后你就可以添加所有的修改，而且当你执行最后的命令时，Git会打开你的默认文本编辑器，其中会包含上一次提交时的信息。如果愿意的话，你可以修改提交信息，或者你也可以在最后的命令中使用-C而不是-c，来跳过这一步。 其他 修改已经提交的作者和邮箱 1git commit --amend --author=\"vitan &lt;ivitan95@gmail.com&gt;\" --no-edit 修改错误的提交信息 必须确保没有对当前的代码库（working copy）做修改，否则这些修改也会随之一起提交。1git commit --amend -m ”YOUR-NEW-COMMIT-MESSAGE” 假如你已经将代码提交（git commit）推送（git push）到了远程分支，那么你需要通过下面的命令强制推送这次的代码提交。 1git push &lt;remote&gt; &lt;branch&gt; --force Via Useful Git Tips and Commands有改动","link":"/posts/Git-Tips.html"},{"title":"Git Commit 规范","text":"Git Commit 规范 Commit message 格式每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行s&lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 HeaderHeader 部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 type type用于说明 commit 的类别，只允许使用下面7个标识。 1234567feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动 如果 type 为 feat 和 fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subject subject 是 commit 目的的简短描述，不超过50个字符。 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） Body Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 1234567More detailed explanatory text, if necessary. Wrap it toabout 72 characters or so.Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent 有两个注意点。 使用第一人称现在时，比如使用 change 而不是 changed 或 changes。 应该说明代码变动的动机，以及与以前行为的对比。 Footer Footer 部分只用于两种情况。 不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。 1234567891011121314151617BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: &apos;attribute&apos;, } After: scope: { myAttr: &apos;@&apos;, } The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it. 关闭 issue 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 1Closes #234 一次关闭多个 issue 1Closes #123, #245, #992 Revert 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以 revert: 开头，后面跟着被撤销 Commit 的 Header。 123revert: feat(pencil): add &apos;graphiteWidth&apos; optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body 部分的格式是固定的，必须写成 This reverts commit &amp;lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts小标题下面。 总结公式1&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; type 用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 scope 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subject 是 commit 目的的简短描述，不超过50个字符。 以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes 第一个字母小写 结尾不加句号（.） Via Commit message 和 Change log 编写指南","link":"/posts/Git-Commit.html"},{"title":"Sudo 与 Su 的区别","text":"sudo su 区别 su简介 su 用于用户之间的切换。但是前面的用户依然保持在登录状态。这种切换如果超级权限用户 root 向普通或虚拟用户切换不需要密码，而普通用户切换到其它任何用户都需要密码验证。 变更为其他使用者的身份，除 root 外，需要键入该使用者的密码 语法 1su [选项] [-] [&lt;用户&gt; [&lt;参数&gt;...]] 选项1234567891011121314f 或 --fast# 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh-m -p 或 --preserve-environment# 执行 su 时不改变环境变数-c command 或 --command=command# 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者-s shell 或 --shell=shell# 指定要执行的 shell(bash,csh,tcsh等），预设值为 /etc/passwd 内的该使用者(USER) shell--help # 显示说明文件--version # 显示版本资讯- -l 或 --login# 类似重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 rootUSER # 欲变更的使用者帐号 su – root 和 su root（su）的区别 su – root 表示人 以root 身份登录 su root 表示与 root 建立一个链接，通过 root 执行命令 不足 不安全 su 工具在多人参与的系统管理中，并不是最好的选择，su 只适用于一两个人参与管理的系统，毕竟 su 并不能让普通用户受限的使用；超级用户 root 密码应该掌握在少数用户手中。 如果某个用户需要使用 root 权限,则必须要把 root 密码告诉此用户。 sudo简介 为所有想使用 root 权限的普通用户设计的。可以让普通用户具有临时使用root权限的权利。只需输入自己账户的密码即可。个普通用户必须在 /etc/sudoers 文件中有配置项,才具有使用sudo的权利. 执行命令的流程是当前用户切换到 root（或其它指定切换到的用户），然后以 root（或其它指定的切换到的用户）身份执行命令，执行完成后，直接退回到当前用户. 语法 1sudo 参数 参数1234567891011121314-V # 显示版本编号-h # 会显示版本编号及指令的使用方式说明-l # 显示出自己（执行 sudo 的使用者）的权限-v # sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码-k # 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）-b # 将要执行的指令放在背景执行-p # prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称-u # username/#uid 不加此参数，代表要以 root 的身份执行指令而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）-s # 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell-H # 将环境变数中的 HOME （家目录）指定为要变更身份的使用者家目录（如不加 -u 参数就是系统管理者 root ）command # 要以系统管理者身份（或以 -u 更改为其他人）执行的指令 区别总结 共同点：都是 root 用户的权限； 不同点：su 仅仅取得 root 权限，工作环境不变，还是在切换之前用户的工作环境；sudo 是完全取得 root 的权限和 root 的工作环境。 su 用于用户之间的切换。 sudo 用于普通用户可以使用 root 权限来执行指定命令。 参考 Linux中su与sudo、su – root的区别 Learn Difference Between “su” and “su -” Commands in Linux linux su和sudo命令的区别","link":"/posts/sudo-su-different.html"},{"title":"Linux 命令连接符","text":"Linux 命令连接符 和号操作符 (&amp;)&amp; 的作用是使命令在后台运行。只要在命令后面跟上一个空格和 &amp;,可以一口气在后台运行多个命令。 在后台运行一个命令 1ping ­c5 www.tecmint.com 同时在后台运行两个命令 1apt-get update &amp; mkdit test 分号操作符（;）分号操作符使你可以一口气运行几个命令，命令顺序执行。 1apt-get update ; apt-get upgrade ; mkdir test 上述命令先后执行了 update 和 upgrade，最后在当前工作目录下创建了一个 test 文件夹。 与操作符 (&amp;&amp;)如果第一个命令执行成功，与操作符 &amp;&amp; 才会执行第二个命令，也就是说，第一个命令退出状态是0。（在UNIX里面，0表示无错误，而所有非0返回值都是各种错误）。这个命令在检查最后一个命令的执行状态时很有用。 使用links 命令在终端中访问网站 tecmint.com ，但在这之前我需要检查主机是否在线或不在线1ping -c3 www.tecmint.com &amp;&amp; links www.tecmint.com 或操作符 (||)或操作符 || 很像编程中的 else 语句。上面的操作符允许你在第一个命令失败的情况下执行第二个命令，比如，第一个命令的退出状态是1。 在非root帐户中执行 apt-get update ，如果第一个命令失败了，接着会执行第二个命令 links www.tecmint.com 。 1apt-get update || links tecmint.com 上面的命令中，由于该用户不允许更新系统，这意味着第一个命令的退出状态是 1 ,因此最后一个命令 links tecmint.com 会执行。 如果第一个命令成功执行并且退出状态是 0 呢？很明显的，第二个命令不会执行。 1mkdir test || links tecmint.com 这里，用户在家目录创建了一个 test 文件夹，这是被允许的。命令成功的执行，退出状态是 0 ,因此，最后的命令不会执行。 非操作符 (!)非操作符 ! 很像 except 语句。这个命令会执行除了提供的条件外的所有的语句。 在你的主目录创建一个目录 tecmint ，并 cd 到它这里。 12mkdir tecmintcd tecmint 接下来，在文件夹‘tecmint’下创建不同类型的文件。 1touch a.doc b.doc a.pdf b.pdf a.xml b.xml a.html b.html 看一下我们在文件夹 tecmint 创建的新文件。 1ls a.doc a.html a.pdf a.xml b.doc b.html b.pdf b.xml 用一种聪明的办法马上删除除了 ‘html’之外的所有文件。 1rm -r !(*.html) 验证一下上次的执行结果，使用ls 命令列出可见所有文件。 1ls a.html b.html 与或操作符 (&amp;&amp; – ||)上面的操作符实际上是‘与’和‘或’操作符的组合。它很像 if-else 语句。 ping tecmint.com，如果成功打印‘已验证’，否则打印‘主机故障’。 1ping -c3 www.tecmint.com &amp;&amp; echo \"Verified\" || echo \"Host Down\" 示例输出 PING www.tecmint.com (212.71.234.61) 56(84) bytes of data.64 bytes from www.tecmint.com (212.71.234.61): icmp_req=1 ttl=55 time=216 ms64 bytes from www.tecmint.com (212.71.234.61): icmp_req=2 ttl=55 time=224 ms64 bytes from www.tecmint.com (212.71.234.61): icmp_req=3 ttl=55 time=226 ms — www.tecmint.com ping statistics —3 packets transmitted, 3 received, 0% packet loss, time 2001msrtt min/avg/max/mdev = 216.960/222.789/226.423/4.199 msVerified 断开我们现在的网络连接诶，再试一下相同的命令。 1ping -c3 www.tecmint.com &amp;&amp; echo \"verified\" || echo \"Host Down\" 实例输出 12ping: unknown host www.tecmint.comHost Down 管道操作符 (|)PIPE 在将第一个命令的输出作为第二个命令的输入时很有用。 ls -l 的输出通过管道到‘less’，并看一下输出。1ls -l | less 命令合并操作符 {}合并两个或多个命令，第二个命令依赖于第一个命令的执行。 检查一下文件‘xyz.txt’是否在Downloads目录下，如果不存在则创建之并输出提示信息。 1[ -f /home/tecmint/Downloads/xyz.txt ] || touch /home/tecmint/Downloads/xyz.txt; echo \"The file does not exist\" 但是这样的命令的运行结果并不如我们预期的运行，会始终都输出提示信息。因此需要使用{}操作符来合并命令： 123[ -f /home/tecmint/Downloads/xyz1.txt ] || {touch /home/tecmint/Downloads/xyz.txt; echo \"The file does not exist\"}“The file does not exist” 优先操作符 ()这个操作符可以让命令以优先顺序执行。 1Command_x1 &amp;&amp;Command_x2 || Command_x3 &amp;&amp; Command_x4 在上面的伪代码中，如果Command_x1执行失败了会怎么样，Command_x2, Command_x3, Command_x4没有一个会执行，对于这种情况，我们使用优先操作符。 1(Command_x1 &amp;&amp;Command_x2) || (Command_x3 &amp;&amp; Command_x4) 在上面的伪代码中，如果Command_x1执行失败，Command_x2不会执行，但是Command_x3会继续执行， Command_x4会依赖于 Command_x3的退出状态。 连接符 ($$)连接符 $$ 如它名字所说，被用于连接 shell 中那些太长而需要分成多行的命令。 可以在输入一个 \\ 之后就回车，然后继续输入命令行，直到输入完成。比如，下面的命令会打开文本文件 test(1).txt。12vim test \\1.txt Via LINUX COMMANDS Linux 中命令链接操作符，让你的代码更简洁！","link":"/posts/LinuxAnds.html"},{"title":"Markdown 各种图","text":"Markdown 流程图，干特图。 流程图 (Flowchart)123456graph TD A[Christmas] --&gt;|Get money| B(Go shopping) B --&gt; C{Let me think} C --&gt;|One| D[Laptop] C --&gt;|Two| E[iPhone] C --&gt;|Three| F[Car] 序列图 (Sequence diagram)12345sequenceDiagram loop every day Alice-&gt;&gt;John: Hello John, how are you? John--&gt;&gt;Alice: Great! end 甘特图 (Gantt diagram)123456789101112131415161718192021222324252627gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page : 20h Add another diagram to demo page : 48h 参考 Mermaidjs","link":"/posts/Markdown-Plus.html"},{"title":"开源协议","text":"几种常用的开源协议,更多的协议可以去Open Source Initiative了解。 两张图看懂各种开源协议 限制 GNU GPL通用公共许可协议(GNU General Public License), GPL 保证了所有开发者的权利，同时为使用者提供了足够的复制，分发，修改的权利. 要求 修改后的源码也需要公开 版权及协议也要于此协议一致 修改后，需要在相应的文件做说明 允许 商用，分发，修改，专利授权，私用 禁止 禁止因使用等造成影响责任承担、也就是说免责申明 静止在软件分发传播过程中附加上原来没有的协议条款等 BSD协议 如果再发布的产品中含有源代码，则在源代码中必须带有原来代码中的BSD协议。 如果再发布的只是二进制类库/软件，则需要再类库/软件的文档和版权申明中包含原有代码中的BSD协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 在代码中保留作者提供的协议和版权信息 允许 商用、分发、修改、私用、附加协议 禁止 禁止承担责任，(免责申明) Apache Licence 2.0这是一个著名的非盈利开源组织Apache采用的协议，它励代码共享和尊重原作者的著作权，同时也允许代码修改，再发布(作为开源或商业软件)。 要求 在代码中保留作者提供的协议和版权信息 如果修改了代码，则必须在被修改的文件中进行说明。 允许的权利商用、分发、修改、专利授权、私用、附加协议 禁止 禁止因使用等造成影响责任承担、也就是说免责申明 不能使用相应的商标。 提示：商业软件可以使用，也可以修改使用 Apache 协议的代码。 MIT宽松简单且精要的一个协议。在适当标明来源及免责的情况下，它允许你对代码进行任何形式的使用,也就是原作者只想保留版权,而无任何其他了限制,而你必须在发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。 要求 在代码中保留作者提供的协议和版权信息 允许 商用、分发、修改、私用、附加协议 禁止 禁止承担责任，(免责申明) 提示：商业软件可以使用，也可以修改MIT协议的代码，甚至可以出售MIT协议的代码。 LGPL其主要用于一些代码库，LGPL比起GPL它授予的权限较少，LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。因此使用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。注意是以类库的形式使用，也就是说如果修改了源代码的话则也必须使用LGPL协议贡献源码出来。 要求 公开使用了LGPL部分的代码，其余部分不需要公开。 可以库引用的方式用于商业软件。 在代码中保留作者提供的协议和版权信息 允许 商用、分发、修改、专利授权、私用、附加协议 禁止 禁止承担责任，(免责申明)、 提示：商业软件可以使用，但不能修改 LGPL 协议的代码。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。 更多内容详见 ChooseLicense 附录 如何选择 选择合适的协议 一个网站 ChooseLicense 参考 十分钟理清常见的开源协议","link":"/posts/OpenSourceLicense.html"},{"title":"解决 Win10 与 Linux 时间不一致","text":"解决 Win10 与 Linux 时间不一致 原因UTC 与 GMT UTC即Universal Time Coordinated，协调世界时（世界统一时间） GMT 即Greenwich Mean Time，格林尼治平时 原因 Windows 把计算机硬件时间当作本地时间(local time)，所以在Windows系统中显示的时间跟BIOS中显示的时间是一样的。 Linux/Unix/Mac把计算机硬件时间当作 UTC， 所以在Linux/Unix/Mac系统启动后在该时间的基础上，加上电脑设置的时区数（ 比如我们在中国，它就加上“8” ），因此，Linux/Unix/Mac系统中显示的时间总是比Windows系统中显示的时间快8个小时。 所以，当你在Linux/Unix/Mac系统中，把系统现实的时间设置正确后，其实计算机硬件时间是在这个时间上减去8小时，所以当你切换成Windows系统后，会发现时间慢了8小时。就是这样个原因。 解决方法方法一 把 Linux 计算机硬件时间改成系统显示的时间，即禁用 UTC1timedatectl set-local-rtc 1 --adjust-system-clock 方法二 修改 Windows 对硬件时间的对待方式，让 Windows把硬件时间当作 UTC.1Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 Via 滑稽","link":"/posts/Linux-Win-Time.html"},{"title":"RaspberryPi 安装屏幕触控驱动及设置分辨率","text":"Raspberry Pi 屏幕触控驱动安装及分辨率设置。 触摸驱动下载链接 GitHub 中获取 安装(3.5寸为例)修改 config 配置文件 烧写系统完成后,将 LCD-show.tar.gz 拷贝到 TF 卡根目录, 打开 TF 卡根目录的 config.txt 文件并在文件末端加入以下代码,保存并安全弹出 TF 卡:12345hdmi_drive=2hdmi_force_hotplug=1hdmi_group=2hdmi_mode=87hdmi_cvt 480 320 60 6 0 0 0 配置123456cd /bootcp LCD-show.tar.gz ~cd ~sudo tar zxvf LCD-show.tar.gzcd LCD-show/sudo ./MPI3508_480_320-show 修改分辨率 终端输入 1sudo vim /boot/config.txt 修改 12345hdmi_drive=2hdmi_force_hotplug=1hdmi_group=2hdmi_mode=87# 这里根据分辨率来设置 分辨率表CEA 分辨率(电视规格分辨率) CEA 规定的电视规格分辨率，这些分辨率的 hdmi_group = 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162hdmi_mode=1 VGAhdmi_mode=2 480p 60Hzhdmi_mode=3 480p 60Hz Hhdmi_mode=4 720p 60Hzhdmi_mode=5 1080i 60Hzhdmi_mode=6 480i 60Hzhdmi_mode=7 480i 60Hz Hhdmi_mode=8 240p 60Hzhdmi_mode=9 240p 60Hz Hhdmi_mode=10 480i 60Hz 4xhdmi_mode=11 480i 60Hz 4x Hhdmi_mode=12 240p 60Hz 4xhdmi_mode=13 240p 60Hz 4x Hhdmi_mode=14 480p 60Hz 2xhdmi_mode=15 480p 60Hz 2x Hhdmi_mode=16 1080p 60Hzhdmi_mode=17 576p 50Hzhdmi_mode=18 576p 50Hz Hhdmi_mode=19 720p 50Hzhdmi_mode=20 1080i 50Hzhdmi_mode=21 576i 50Hzhdmi_mode=22 576i 50Hz Hhdmi_mode=23 288p 50Hzhdmi_mode=24 288p 50Hz Hhdmi_mode=25 576i 50Hz 4xhdmi_mode=26 576i 50Hz 4x Hhdmi_mode=27 288p 50Hz 4xhdmi_mode=28 288p 50Hz 4x Hhdmi_mode=29 576p 50Hz 2xhdmi_mode=30 576p 50Hz 2x Hhdmi_mode=31 1080p 50Hzhdmi_mode=32 1080p 24Hzhdmi_mode=33 1080p 25Hzhdmi_mode=34 1080p 30Hzhdmi_mode=35 480p 60Hz 4xhdmi_mode=36 480p 60Hz 4xHhdmi_mode=37 576p 50Hz 4xhdmi_mode=38 576p 50Hz 4x Hhdmi_mode=39 1080i 50Hz reduced blankinghdmi_mode=40 1080i 100Hzhdmi_mode=41 720p 100Hzhdmi_mode=42 576p 100Hzhdmi_mode=43 576p 100Hz Hhdmi_mode=44 576i 100Hzhdmi_mode=45 576i 100Hz Hhdmi_mode=46 1080i 120Hzhdmi_mode=47 720p 120Hzhdmi_mode=48 480p 120Hzhdmi_mode=49 480p 120Hz Hhdmi_mode=50 480i 120Hzhdmi_mode=51 480i 120Hz Hhdmi_mode=52 576p 200Hzhdmi_mode=53 576p 200Hz Hhdmi_mode=54 576i 200Hzhdmi_mode=55 576i 200Hz Hhdmi_mode=56 480p 240Hzhdmi_mode=57 480p 240Hz Hhdmi_mode=58 480i 240Hzhdmi_mode=59 480i 240Hz HH means 16:9 variant (of a normally 4:3 mode).2x means pixel doubled (i.e. higher clock rate, with each pixel repeated twice)4x means pixel quadrupled (i.e. higher clock rate, with each pixel repeated four times) DMT分辨率(计算机显示器) 以下的英文计算机显示器使用的分辨率,这些分辨率的 hdmi_group = 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586hdmi_mode=1 640x350 85Hzhdmi_mode=2 640x400 85Hzhdmi_mode=3 720x400 85Hzhdmi_mode=4 640x480 60Hzhdmi_mode=5 640x480 72Hzhdmi_mode=6 640x480 75Hzhdmi_mode=7 640x480 85Hzhdmi_mode=8 800x600 56Hzhdmi_mode=9 800x600 60Hzhdmi_mode=10 800x600 72Hzhdmi_mode=11 800x600 75Hzhdmi_mode=12 800x600 85Hzhdmi_mode=13 800x600 120Hzhdmi_mode=14 848x480 60Hzhdmi_mode=15 1024x768 43Hz DO NOT USEhdmi_mode=16 1024x768 60Hzhdmi_mode=17 1024x768 70Hzhdmi_mode=18 1024x768 75Hzhdmi_mode=19 1024x768 85Hzhdmi_mode=20 1024x768 120Hzhdmi_mode=21 1152x864 75Hzhdmi_mode=22 1280x768 reduced blankinghdmi_mode=23 1280x768 60Hzhdmi_mode=24 1280x768 75Hzhdmi_mode=25 1280x768 85Hzhdmi_mode=26 1280x768 120Hz reduced blankinghdmi_mode=27 1280x800 reduced blankinghdmi_mode=28 1280x800 60Hzhdmi_mode=29 1280x800 75Hzhdmi_mode=30 1280x800 85Hzhdmi_mode=31 1280x800 120Hz reduced blankinghdmi_mode=32 1280x960 60Hzhdmi_mode=33 1280x960 85Hzhdmi_mode=34 1280x960 120Hz reduced blankinghdmi_mode=35 1280x1024 60Hzhdmi_mode=36 1280x1024 75Hzhdmi_mode=37 1280x1024 85Hzhdmi_mode=38 1280x1024 120Hz reduced blankinghdmi_mode=39 1360x768 60Hzhdmi_mode=40 1360x768 120Hz reduced blankinghdmi_mode=41 1400x1050 reduced blankinghdmi_mode=42 1400x1050 60Hzhdmi_mode=43 1400x1050 75Hzhdmi_mode=44 1400x1050 85Hzhdmi_mode=45 1400x1050 120Hz reduced blankinghdmi_mode=46 1440x900 reduced blankinghdmi_mode=47 1440x900 60Hzhdmi_mode=48 1440x900 75Hzhdmi_mode=49 1440x900 85Hzhdmi_mode=50 1440x900 120Hz reduced blankinghdmi_mode=51 1600x1200 60Hzhdmi_mode=52 1600x1200 65Hzhdmi_mode=53 1600x1200 70Hzhdmi_mode=54 1600x1200 75Hzhdmi_mode=55 1600x1200 85Hzhdmi_mode=56 1600x1200 120Hz reduced blankinghdmi_mode=57 1680x1050 reduced blankinghdmi_mode=58 1680x1050 60Hzhdmi_mode=59 1680x1050 75Hzhdmi_mode=60 1680x1050 85Hzhdmi_mode=61 1680x1050 120Hz reduced blankinghdmi_mode=62 1792x1344 60Hzhdmi_mode=63 1792x1344 75Hzhdmi_mode=64 1792x1344 120Hz reduced blankinghdmi_mode=65 1856x1392 60Hzhdmi_mode=66 1856x1392 75Hzhdmi_mode=67 1856x1392 120Hz reduced blankinghdmi_mode=68 1920x1200 reduced blankinghdmi_mode=69 1920x1200 60Hzhdmi_mode=70 1920x1200 75Hzhdmi_mode=71 1920x1200 85Hzhdmi_mode=72 1920x1200 120Hz reduced blankinghdmi_mode=73 1920x1440 60Hzhdmi_mode=74 1920x1440 75Hzhdmi_mode=75 1920x1440 120Hz reduced blankinghdmi_mode=76 2560x1600 reduced blankinghdmi_mode=77 2560x1600 60Hzhdmi_mode=78 2560x1600 75Hzhdmi_mode=79 2560x1600 85Hzhdmi_mode=80 2560x1600 120Hz reduced blankinghdmi_mode=81 1366x768 60Hzhdmi_mode=82 1080p 60Hzhdmi_mode=83 1600x900 reduced blankinghdmi_mode=84 2048x1152 reduced blankinghdmi_mode=85 720p 60Hzhdmi_mode=86 1366x768 reduced blanking","link":"/posts/Raspberry-LCD.html"},{"title":"ArchLinux 显卡驱动","text":"ArchLinux 双显卡驱动。 安装Nvidia 和 xorg-xrandr1sudo pacman -S nvidia nvidia-settings xorg-xrandr 配置获取显卡 PCI 地址 1lspci | grep -E \"VGA|3D\" 地址转换 101:00.0 --&gt; 1:0:0 # 转换示例 配置 xorg.conf 1sudo vim /etc/X11/xorg.conf 添加12345678910 Section \"Module\" Load \"modesetting\"EndSectionSection \"Device\" Identifier \"nvidia'\" Driver \"nvidia\" BusID \"1:0:0\" Option \"AllowEmptyInitialConfiguration\"EndSection 各桌面配置 (Display Managers)SDDM (Plasma)启动管理器编辑脚本 1sudo vim /usr/share/sddm/scripts/Xsetup 添加12xrandr --setprovideroutputsource modesetting NVIDIA-0xrandr --auto LightDM (Deepin)配置 1sudo vim /etc/lightdm/display_setup.sh 添加 123#!/bin/shxrandr --setprovideroutputsource modesetting NVIDIA-0xrandr --auto chmod 权限 1chmod +x /etc/lightdm/display_setup.sh 配置脚本 1sudo vim /etc/lightdm/lightdm.conf 添加 12[Seat:*]display-setup-script=/etc/lightdm/display_setup.sh GDM (Gnome)创建两个新的 .desktop 文件 /usr/share/gdm/greeter/autostart/optimus.desktop 下创建 1sudo vim /usr/share/gdm/greeter/autostart/optimus.desktop 添加 123456[Desktop Entry]Type=ApplicationName=OptimusExec=sh -c \"xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto\"NoDisplay=trueX-GNOME-Autostart-Phase=DisplayServer /etc/xdg/autostart/optimus.desktop 下创建 1sudo vim /etc/xdg/autostart/optimus.desktop 添加 123456[Desktop Entry]Type=ApplicationName=OptimusExec=sh -c \"xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto\"NoDisplay=trueX-GNOME-Autostart-Phase=DisplayServer 确保 GDM 使用 X 作为默认后端 Gnome 默认使用 Wayland 作为后端，只有 Wayland 后端无法启动时才使用 Xorg 后端。 修改为 X 1sudo vim /etc/gdm/custom.conf 取消以下注释 1#WaylandEnable=false 解决错误提示 删除主用户 “gdm”，删除组 “gdm” 12sudo userdel gdmsudo groupdel gdm GDM使用单独的 dconf 数据库来控制电源管理 通过将用户设置复制到 GDM 的 dconf 数据库，可以使 GDM 的行为与用户会话相同。 1IFS=$'\\n'; for x in $(sudo -u YOUR_USER gsettings list-recursively org.gnome.settings-daemon.plugins.power); do eval \"sudo -u gdm dbus-launch gsettings set $x\"; done; unset IFS 或者简单地禁用自动挂起(在电池上运行时，也可以用 ac 替换电池来禁用它)： 1sudo -u gdm dbus-launch gsettings set org.gnome.settings-daemon.plugins.power sleep-inactive-ac-type 'nothing' 参考 NVIDIA Optimus GDM","link":"/posts/ArchLinux-Nvidia.html"},{"title":"树莓派获取 IP 地址","text":"树莓派获取 IP 有显示器12ifconfighostname -I 无显示器有路由器 连接路由器后登陆路由器管理界面查看即可。 只有电脑 网线直接把树莓派与电脑连接起来 电脑需要连 WiFi 在 设置-&gt;网络-&gt;Wlan-&gt;网络与共享中心-&gt;Wlan-&gt;属性-&gt;共享-&gt;允许​其它用户通过它来连接-&gt;确定。 CMD 查看 IP 1ping raspberrypi.local 改变了树莓派的主机名字，Avahi 也将改变 .local 的 DNS 多播地址 12arp -a# 通常以192.168开头，最后一位是1 只有手机（安卓） USB 共享的网络 开启热点 使用局域网扫描软件(Find,IpScanner,Es文件管理器…)查询 IP 参考 查看树莓派ip地址的几种方法 树莓派获取ip地址的N种方法","link":"/posts/RaspberryIp.html"},{"title":"ArchLinux Pacman 命令","text":"pacman 软件包管理器 使用安装指定的包安装或者升级单个软件包，或者一列软件包（包含依赖包） 1pacman -S package_name1 package_name2 ... 用正则表达式安装多个软件包 1pacman -S $(pacman -Ssq package_regex) pacman/Tips and tricks 选择仓库按照 1pacman -S extra/package_name 安装多个含有相似名称的软件包，而并非整个包组或全部匹配的软件包 1pacman -S plasma-{desktop,mediacenter,nm} 多层扩展 1pacman -S plasma-{workspace{,-wallpapers},pa} 安装包组 1pacman -S gnome 包组 删除软件包删除但保留依赖关系 1pacman -R package_name 删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系 1pacman -Rs package_name 删除软件包和所有依赖 1pacman -Rsc package_name 删除但不删除依赖这个软件包的其他程序 1pacman -Rdd package_name 升级软件包升级整个系统 1pacman -Syu 查询包数据库 pacman 使用 -Q 参数查询本地软件包数据库 1pacman -Q --help 使用 -S 参数来查询远程同步的数据库 1pacman -S --help pacman 可以在包数据库中查询软件包，查询位置包含了软件包的名字和描述 1pacman -Ss string1 string2 ... 有时，-s的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段，下面的命令就会返回很多不必要结果 1pacman -Ss '^vim-' 要查询已安装的软件包： 1pacman -Qs string1 string2 ... 按文件名查找软件库： 1pacman -Fs string1 string2 ... 显示软件包的详尽的信息： 1pacman -Si package_name 查询本地安装包的详细信息： 1pacman -Qi package_name 使用两个 -i 将同时显示备份文件和修改状态： 1pacman -Qii package_name 要获取已安装软件包所包含文件的列表： 1pacman -Ql package_name 查询远程库中软件包包含的文件： 1pacman -Fl package_name 检查软件包安装的文件是否都存在： 1pacman -Qk package_name 两个参数k将会执行一次更彻底的检查。 查询数据库获取某个文件属于哪个软件包： 1pacman -Qo /path/to/file_name 查询文件属于远程数据库中的哪个软件包： 1pacman -Fo /path/to/file_name 要罗列所有不再作为依赖的软件包(孤立orphans)： 1pacman -Qdt 要罗列所有明确安装而且不被其它包依赖的软件包： 1pacman -Qet 要显示软件包的依赖树： 1pactree package_name 检查一个安装的软件包被那些包依赖，可以使用 pkgtoolsAUR中的whoneeds: 1whoneeds package_name 或者pactree中使用-r:1pactree -r package_name 数据库结构pacman数据库通常位于 /var/lib/pacman/sync. 对于每一个在 /etc/pacman.conf 中指定的软件仓库， 这里都有一个一致的数据库。数据库文件夹里每个 tar.gz 文件都包含着一个仓库的软件包信息。例如which 包: 1234% tree which-2.20-6which-2.20-6|-- depends`-- desc 这个 depends 项列出了该软件的依赖包， 而desc有该包的介绍，例如文件大小和MD5值 。 清理软件包缓存 pacman 将下载的软件包保存在 /var/cache/pacman/pkg/ 并且不会自动移除旧的和未安装版本的软件包，因此需要手动清理，以免该文件夹过于庞大。 使用内建选项即可清除未安装软件包的缓存： 1pacman -Sc pacman 提供的 paccache 命令默认会删除近3个版本前的软件包 1paccache -r Tip: 可以使用 pacman hooks 自动执行清理，这里是参考示例。 也可以自己设置保留最近几个版本： 1paccache -rk 1 清理所有未安装包的缓存文件 1paccache -ruk0 其它命令升级系统时安装其他软件包： 1pacman -Syu package_name1 package_name2 ... 下载包而不安装它： 1pacman -Sw package_name 安装一个本地包(不从源里下载）： 1pacman -U /path/to/package/package_name-version.pkg.tar.xz 要将本地包保存至缓存，可执行： 1pacman -U file://path/to/package/package_name-version.pkg.tar.xz 安装一个远程包（不在 pacman 配置的源里面） 1pacman -U http://www.example.com/repo/example.pkg.tar.xz 要禁用 -S, -U 和 -R 动作，可以使用 -p 选项. Via Pacman","link":"/posts/ArchLinux-command.html"},{"title":"Linux 安装微信 QQ","text":"Linux 安装 QQ WeChat Tim. ArchLinux添加 archlinuxcn 源 编辑 pacman.conf 1vim /etc/pacman.conf 添加 123[archlinuxcn]SigLevel = Optional TrustAllServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 安装12345sudo pacman -S winesudo pacman -S deepin.com.qq.imsudo pacman -S deepin.com.qq.officesudo pacman -S deepin.com.wechatsudo pacman -S netease-cloud-music ArchLinux 系发行版包括 ArchLinux、Manjaro、Antergos 等. 配置分辨率123env WINEPREFIX=\"$HOME/.deepinwine/Deepin-WeChat\" winecfgenv WINEPREFIX=\"$HOME/.deepinwine/Deepin-TIM\" winecfgenv WINEPREFIX=\"$HOME/.deepinwine/Deepin-QQ\" winecfg UbuntuDeepin-wine 环境方法一 12git clone 'https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git# 克隆到本地，用图形界面的软件包管理器安装所有 deb 文件 方法二 123git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.gitsudo sh ./install.sh# 克隆到本地,(授予可执行权限后)在终端中运行 install.sh . Deepin.com 应用容器 自行到阿里镜像中下载想要的容器安装运行即可(容器建议使用命令安装)。 推荐容器 QQ:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/ TIM:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/ QQ轻聊版:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im.light/ 微信:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/ Foxmail:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.foxmail/ 百度网盘:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.baidu.pan/ Ubuntu 系发行版包括Ubuntu、LinuxMint、ZorinOS 等. 参考 Deepin wine for ubuntu 多发行版通过！目前Linux上真正完美稳定的wine QQ方案","link":"/posts/linux-WeChat-QQ.html"},{"title":"ArchLinux 安装记录","text":"ArchLinux 安装记录 准备镜像 下载 ISO 使用 Rufus 烧录镜像 Linux 下推荐用 DD模式,开机选择烧录好的U盘进行引导1dd bs=4M if=/path/to/archlinux.iso of=/dev/sdX status=progress &amp;&amp; sync 安装步骤进行联网 连接 WiFi 1wifi-menu PPOE 连接 1pppoe-setup ADSL 连接 1systemctl start adsl 测试网络1ping www.vitan.me 同步时间1timedatectl set-ntp true 更换国内源将 China 开头一下两行剪切到 ustc 最上面 1vim /etc/pacman.d/mirrorlist 技巧(光标在 China 下，按2后 dd 最后 p 粘贴) 分区方案 分区 大小 类型 / 75G linuxfilesystem home 65G linuxfilesystem swap 8G Linux swap boot 512M EFI系统 建立 GPT 分区表12345678fdisk /dev/sdb #不同电脑设备不同,进入fdisk交互界面：g # 建立gpt分区表:n # 添加一个分区提示让输入开始扇区(一个扇区512B，按自己要分区容量大小进行计算)输入2048,回车让输入结束扇区，由于一个扇区512B，要创建200M的分区,应该输入：+200M；w 保存并退出；lsblk # 查看分区列表 MBR 分区1234cfdisk /dev/sdb # 进入分区new # 新建分区，输入大小type # 选择分区属性write # 执行分区 格式化1234mkfs.vfat /dev/sdax # efi分区 挂载在/mnt/boot/EFImkfs.ext4 /dev/sdax # /,/home 两个分区mkswap -f /dev/sdax # 格式化swapswapon /dev/sdax # swap分区 挂载分区123456mount /dev/sdb3 /mnt # /分区mkdir /mnt/homemount /dev/sdb4 /mnt/home # home 分区mkdir /mnt/bootmkdir /mnt/boot/EFImount /dev/sdb5 /mnt/boot/EFI # EFI 分区 安装基本操作系统基础包12pacstrap /mnt base # 基础包pacstrap /mnt base-devel # 开发基础包 配置基础系统 生产 fstab 1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 检查 1cat /mnt/etc/fstab 切换到新系统1arch-chroot /mnt 时区设置时区1ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 硬件时间1hwclock --systohc --utc 语言设置123pacman -S vimvim /etc/locale.gen# 反注释（删掉前面的#） en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 生成 locale 1locale-gen 设置 locale.conf 1echo 'LANG=zh_CN.UTF-8' &gt; /etc/locale.conf 无线网络链接安装相关包 1pacman -S iw wpa_supplicant dialog root 用户设置密码1passwd 添加用户 12useradd -m -g users -s /bin/bash 用户名passwd 用户名 # 修改密码 sudo 权限 1vim /etc/sudoers 取消注释 1%wheel ALL=(ALL) ALL 在 root ALL=(ALL) ALL 下面添加 1用户名 ALL=(ALL) ALL 安装微码1pacman -S intel-ucode 安装引导程序（不能漏）123pacman -S grub efibootmgrgrub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=ArchLinuxgrub-mkconfig -o /boot/grub/grub.cfg 退出 chroot 重启 (笔记本跳过)123exit # 退回安装环境#umount -R /mnt # 卸载新分区reboot # 重启 网络配置(重启后)有线连接 1systemctl enable dhcpcd 无线连接 1pacman -S iw wpa_supplicant dialog ADSL 宽带连接 1pacman -S rp-pppoe# pppoe-setup 重启不能联网重启 dhcpcd 1systemctl enable dhcpcd 继续输入 1ip link 发现名称是ens33的网卡state 是down状态 1ip link set ens33 up(ifconfig ens33 up 也可以) 安装桌面环境Gnome 桌面123456sudo pacman -S gnome #gnome桌面：sudo pacman -S gnome-tweak-tool #安装gnome桌面优化工具sudo pacman -S alacarte # 安装gnome桌面菜单编辑器systemctl enable gdm #启用gnome窗口管理器服务systemctl enable NetworkManager # 启用网络管理器服务reboot Deepin 桌面123456sudo pacman -S deepinsudo pacman -S deepin-extrasudo pacman S bash-completionsudo pacman -S networkmanagersystemctl enable NetworkManager # 注意大小写systemctl start NetworkManager 编辑 1vim /etc/lightdm/lightdm.conf 修改如下 1greeter-session=lightdm-deepin-greeter 执行 1systemctl enable lightdm.service KDE Plasma 桌面123456789sudo pacman -S xorgsudo pacman -S xf86-input-synapticssudo pacman -S ttf-dejavu wqy-microhei # 字体sudo pacman -S plasma kde-applicationssystemctl enable sddm # 启用 sddm 显示管理器sudo pacman -S NetworkManager net-toolssystemctl enable NetworkManager # 启用网络管理systemctl enable dhcpcdsudo pacman -S kde-l10n-zh_cn # KDE 中文包 后续优化配置源1sudo vim /etc/pacman.conf 首先去掉 multilib 中两行的注释 在文档结尾处加入 123[archlinuxcn]SigLevel = Optional TrustAllServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 刷新pacman数据库 1sudo pacman -Syy 驱动声卡1sudo pacman -S alsautils pulseaudio pulseaudio-alsa 显卡安装驱动 12sudo pacman -S nvidiasudo pacman -S nvidia-settings 启动管理器编辑脚本(Plasma 桌面有效) 1sudo vim /usr/share/sddm/scripts/Xsetup 添加 12xrandr --setprovideroutputsource modesetting NVIDIA-0xrandr --auto 重启 1reboot 获取显卡 PCI 地址 1ispci | grep -E \"VGA|3D\" 地址转换 101:00.0 --&gt; 1:0:0 # 转换示例 配置 xorg.conf 12sudo vim /etc/X11/xorg.conf# 确保 xorg 已安装 添加 12345678910Section \"Module\" Load \"modesetting\"EndSectionSection \"Device\" Identifier \"nvidia'\" Driver \"nvidia\" BusID \"1:0:0\" Option \"AllowEmptyInitialConfiguration\"EndSection 必备软件输入法123sudo pacman -S fcitx fcitx-configtoolsudo pacman -S fcitx-gtk2 fcitx-gtk3 fcitx-qt4 fcitx-qt5sudo pacman -S fcitx-sogoupinyin 配置1vim ~/.xprofile 添加 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=\"@im=fcitx\" 桌面环境比较特殊，可能需要在 /etc/environmenet 后方也加入 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=\"@im=fcitx\" 安装输入法 1sudo pacman -S fcitx-sogoupinyin 可选 fcitx-cloudpinyin fcitx-googlepinyin fcitx-libpinyin fcitx-sunpinyin fcitx-sogoupinyin 字体123sudo pacman -S wqy-bitmapfont wqy-microhei \\wqy-zenhei adobe-source-code-pro-fonts \\adobe-source-han-sans-cn-fonts ttf-monaco 安装 yay 使用 aur1sudo pacman -S yay 以后可以使用 yay 安装aur中的软件了, yay 跟 pacman 使用方法一样. 工具和常用软件工具 1sudo pacman -S git net-tools tree vim 微信QQ 科学上网 1sudo pacman -S shadowsocks-qt5 proxychains-ng Proxychains 实现终端下任意应用代理 WPS 12sudo pacman -S ttf-wps-fontssudo pacman -S wps-office Telegram 1sudo pacman -S telegram-desktop Google Chrome 1sudo pacman -S google-chrome 网易云音乐 1sudo pacman -S netease-cloud-music MailSpring 12yay -S mailspringsudo pacman -S libsecret 迅雷 1yay -S deepin-wine-thunderspeed 截图(Deppin) 1yay -S deepin-screenshot Docker 12sudo pacman -S dockersudo pacman -S docker-compose Visual Studio Code 1sudo pacman -S visual-studio-code-bin 参考 ArchLinux安装图文教程 ArchLinux安装deepin桌面/常用软件流程文档","link":"/posts/ArchLinux.html"},{"title":"删除 Linux EFI 分区","text":"在 Win10 彻底删除 Linux 的 EFI 分区 及启动项的方法 。 删除 EFI 分区 使用 dispart 用管理员权限打开 cmd 输入 diskpart 利用 list disk 查询磁盘信息 这里我们 Ubuntu 装在磁盘1中，所以选择磁盘1, select disk 1 查看磁盘1下所有分区信息 list partition 根据分区大小这里选择分区6 select partition 6 删除 delete partition override 删除 Linux 启动项 EFI 分区分配盘符 使用 diskpart select disk 0 即win10系统所在的磁盘 查看分区列表以确定具体分区 list partition 根据容量(这里是260MB)选择分区 select partition 1 为 Win10 的 EFI 分区分配盘符 assign letter=F 这里p为盘符，字母A~Z应该都可以(大小写无关，自动转成大写)，不要和已有的盘符重复即可。 用管理员权限打开记事本，然后通过记事本菜单栏里的打开来访问 F 盘，会发现P盘里有个EFI文件夹，打开直接删除ubuntu文件夹. 再回到 diskpart 删除EFI分区盘符F remove letter=f Via 彻底删除Ubuntu EFI分区及启动项","link":"/posts/delLinuxEFI.html"},{"title":"Ubuntu 安装 Shadowsocks-Qt5","text":"Ubuntu 安装 shadowsocks-qt5 16.04/17.04的安装123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 18.04的安装方法添加源 1sudo add-apt-repository ppa:hzwhuang/ss-qt5 作者还没有测试18.04,将源中的bionic改成artful 编辑 1sudo /etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list 12http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic main # Before http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu artful main # After 安装 12sudo apt-get updatesudo apt-get install shadowsocks-qt5","link":"/posts/Ubuntu18-SS-qt5.html"},{"title":"Linux 常见目录","text":"Linux 常见目录 目录 解释 / 根目录 /bin 命令保存目录（普通用户就可以读取的命令） /boot 启动目录，启动相关文件 /dev 设备文件保存目录 /etc 配置文件保存目录 /home 普通用户的家目录 /lib 系统库保存目录 /mnt 系统挂载目录 /media 挂载目录 /root 超级用户的家目录 /tmp 临时目录 /sbin 命令保存目录(超级用户才能使用的目录) /proc 直接写入内存的 /sys 将内核的一些信息映射，可供应用程序所用 /usr 系统软件资源目录 /usr/bin/ 系统命令（普通用户） /usr/sbin/ 系统命令（超级用户） /var 系统相关文档内容 /var/log/ 系统日志位置 /var/spool/mail/ 系统默认邮箱位置 /var/lib/ 默认安装的库文件目录","link":"/posts/LinuxDir.html"},{"title":"Github 隐藏的技巧","text":"Github 中隐藏了很多可以提高效率的小技巧。 快捷键全站中123s 定位到搜索框? 展示当前页面可用的快捷键g+n 查看通知 库快捷键1234g+c 到代码库首页g+i 查看 issueg+p 查看 PRg+w 查看 Wiki 浏览代码12345t 激活查找文件模式l 定位到行w 切换分支或tagy 将 URL 展开成正则形式i 显示或隐藏 diff 中的评论 issues123456c 创建一个 issue/ 定位到 issue 搜索框l 过滤或编辑标签m 过滤或编辑 milestonea 过滤或编辑 assigneer 在回复中引用鼠标选中的文本 通知12e l y 标记为已读shift m 将帖子静音 仓库中PR12r 在回复中引用鼠标选中的文本o+enter 打开 issue Network Graph12方向键和 hjkl 与 Vim 中一样shift + 方向键或 hjkl 行动到头 URL 后添加忽略空格: ?w=1在任意的 diff URL 添加?w=1用来整理缩进 查看某个作者的提交历史在 URL 中添加 ?author=username例如： 1https://github.com/rails/rails/commits/master?author=snowtraces 比较版本使用类似如下的 URL 比较分支 1https://github.com/qutang/hexo-theme-cutie/compare/master...v2.1 也可以使用一下格式 12https://github.com/rails/rails/compare/master@{1.day.ago}...masterhttps://github.com/rails/rails/compare/master@{2014-10-04}...master 和派生仓库比较，加上派生仓库名作前缀即可 1https://github.com/iVitan/hexo-theme-cutie/compare/master...qutang:master 高亮行在 URL 中加上#L10可以高亮第10行,或者你也可以直接点击行数。 1https://github.com/iVitan/hexo-theme-cutie/blob/master/_config.yml#L10 多行高亮同样支持。你可以使用类似#L10-L20格式，或者在按住 shift 的同时点击1https://github.com/iVitan/hexo-theme-cutie/blob/master/_config.yml#L10-L20 合并请求的 diff 和 patch可以在 URL 后添加.diff和.patch以对应的模式查看合并请求 快速引用引用评论 可以选中别人的评论文字，然后按 r，这些内容会以引用的形式被复制在文本框中 任务列表To Do在工单或合并请求中，你可以使用任务列表语法： 123- [ ] Be awesome- [ ] Do stuff- [ ] Sleep 勾选之后，会更新 Markdown123- [x] Be awesome- [x] Do stuff- [ ] Sleep 嵌入 GitHub 网页上面嵌入你自己的GitHub仓库页面 12&lt;iframe src=&quot;https://ghbtns.com/github-btn.html?user=ivitan&amp;amp;repo=ivitan.github.io&amp;amp;type=watch&amp;amp;count=true&amp;amp;size=large&quot; allowtransparency=&quot;true&quot; frameborder=&quot;0&quot; scrolling=&quot;0&quot; width=&quot;156px&quot; height=&quot;30px&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;https://ghbtns.com/github-btn.html?user=ivitan&amp;amp;repo=ivitan.github&amp;amp;type=fork&amp;amp;count=true&amp;amp;size=large&quot; allowtransparency=&quot;true&quot; frameborder=&quot;0&quot; scrolling=&quot;0&quot; width=&quot;156px&quot; height=&quot;30px&quot;&gt;&lt;/iframe&gt; 设置项目语言GitHub 会根据相关文件代码的数量来自动识别你这个项目，如果你需要自己指定项目语言，可以在项目的根目录下添加如下.gitattributes文件 1*.html linguist-language=Python 参考 关于Git和Github你不知道的十件事 少有人知的 GitHub 使用技巧 GitHub 使用小技巧","link":"/posts/GithubTips.html"},{"title":"MySQL 基础语句","text":"MySQL 基础语句 MySQL 语句的规范 关键字与函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL语句必须以分号结尾 数据类型数据类型是指列、存储过程参数、表达式和局部变量的数据特征,它决定了数据的存储格式,代表了不同的信息类型。 字符型 列类型 存储需求 CHAR(M) M个字节,0&lt;=M&lt;=255 VARCHAR(M) L+1个字节,其中L&lt;=M且0&lt;=M&lt;= 65535 TINYTEXT L+1个字节,其中L&lt;2^8^ TEXT L+2个字节,其中L&lt;2^16^ MEDIUMTEXT L+3个字节,其中L&lt;2^24^ LONGTEXT L+4个字节,其中L&lt;2^32^ ENUM(‘value’,’value2’,…) 1或2个字节,取决于枚举值的个数(最多65.535个值) SET(‘valuel’,’value2’,…) 1、2、3、4或者8个字节,取决于set成员的数目(最多64个成员) 整型 数据类 型存储范围 字节 TINYINT 有符号值:-128到127(-2^7^到2^7^-1)无符号值:0到255(0到2^8^ -1) 1 SMALLINT 有符号值:-32768到32767(2^15^到2^15^-1)无符号值:0到65535 (0到2^16^-1) 2 MEDIUMINT 有符号值:-8388608到8388607(-2^23^到2^23^-1)无符号值:0到16777215(0到2^24^-1) 3 INT 有符号值:-2147483648到2147483647(-2^31^到2^31^-1)无符号值:0到4294967295(0到2^32^-1) 4 BIGINT 有符号值:-9223372036854775808到9223373036854775807 (-2^63^到2^63^-1),无符号值:0到18446744073709551615(0到2^64^-1) 8 浮点型 日期时间型 列类型 存储需求 YEAE 1 TIME 3 DATE 3 DATETIME 8 TIMESTAMP 4 — 语法MySQL 登录1mysql -h 127.0.0.1 -u root -p 参数 描述 -D,-database naime 打开指定数据库 –delimiter = naime 指定分隔符 -h,-host taine 服务器名称 -p,–password [-name] 密码 -p,–prot=# 端口号 –prompt line 设置提示符 -u,–user=name 用户名 -V,–version 輸出版本信息并且退出 修改MySQL提示符 连接客户端时通过参数指定1mysql -uroot -proot --prompt 提示符 2.连接上客户端后,通过 prompt 命令修改 1mysql&gt;prompt 提示符 参数 描述 \\D 完整的日期 \\d 当前数据库 \\h 服务器名称 \\u 用户名称 MySQL 常用语句123456当前服务器版本SELECT VERSION();显示当前日期时间SELECT NOW();显示当前用户SELECT USER(); 创建数据库123CREATE(DATABASE SCHEMA [IF NOT EXISTS] name[DEFAULT] CHARACTER SET [=] charset_name 查看当前服务器下的数据表列表123SHOW (DATABASES SCHEMAS}[LIKE 'pattern' | WHERE expr] 修改数据库123ALTER {DATABASE SCHEMA} [db_name][DEFAULT] CHARACTER SET [=] charset_name 删除数据库1DROP {DATABASE | SCHEMA} [IF EXISTS] db_name 表数据表(或称表)是数据库最重要的组成部分之一,是其他对象的基础。 创建数据表1234CREATE TABLE [IF NOT EXISTS] table_name(column name data_type,... ) 查看数据表列表12SHOW TABLES [FROM db name][LIKE 'pattern' | WHERE expr] 1SHOW TABLES [FROM db name] 查看数据表结构1SHOW COLUMNS FROM table_name 插入记录1INSERT [INTO] table_name[(column_name...)] VALUES(val,...) 记录查找1SELECT expr,... FROM table_name 空值与非空 NULL,字段值可以为空 NOT NULL,字段值禁止为空 AUTO_INCREMENT自动编号,且必须与主键组合使用,默认情况下,起始值为1, 每次的增量为1. 约束 约束保证数据的完整性和一致性。 约束分为表级约束和列级约束。 约束类型包括: NOT NULL (非空约束) PRIMARY KEY (主键约束) UNIQUE KEY (唯一约束) DEFAULT (默认约束) FOREIGN KEY (外键约束) PRIMARY KEY 主键约束 每张数据表只能存在一个主键 主键保证记录的唯一性 主键自动为 NOT NULL UNIQUE KEY 唯一约束 唯一约束可以保证记录的唯一性 唯一约束的字段可以为空值(NULL) 每张数据表可以存在多个唯一约束 DEFAULT 默认值 当插入记录时,如果没有明确为字段赋值,则自动赋予默认值。1234CREATE TABLE tb5{id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,usernate VARCHAR(20) NOT NUL UNIQUE KEY,sex ENIUM('1', '2',3') DEFAULT '3' FOREIGN KEY 作用 保持数据一致性,完整性。 实现一对一或一对多关系。 外键约束的要求 父表和子表必须使用相同的存储引擎,而且禁止使用临时表。 数据表的存储引擎只能为InnoDB。 外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同;而字符的长度则可以不同。 外键和参照列必须创建索引。如果外键列不存在索引的话,MySQL将自动创建索引。 外键约束的参照操作 CASCADE:从主表删除或更新且自动删除或更新子表中配的行 SET NULL:从主表删除或更新行,并设置子表中的外键列为NULL。如果使用该选项,必须保证子表列没有指定NOT NULL RESTRICT: 拒绝对父表的删除或更新操作。 NO ACTION:标准SQL的关键字,在MySQL中与RESTRICT相同 表级约束与列级约束 对一个数据列建立的约束,称为列级约束, 对多个数据列建立的约束,称为表级约束, 列级约束既可以在列定义时声明,也可以在列定义后声明, 表级约束只能在列定义后声明. 修改数据表添加列12ALTER TABLE table_name ADD [COLUMN] colnamecolumn_definition [FIRST | AFTER col_name] 添加多列12ALTER TABLE table_name ADD [COLUMN](col_name column_definitio,n...) 删除列1ALTER TABLE table_name DROP [COLUMN] colname 添加主键约束12ALTER TABLE table_name ADD [CONSTRAINT [symbol]]PRIMARY KEY [index_type](index_col namer...) 删除主键约束1ALTER TABLE table_name DROP PRIMARY KEY 添加唯一约束123ALTER TABLE table_name ADD [CONSTRAINT [symbol]]UNIQUE [INDEX|KEY] [index_name] [index_type](index_col name,...) 删除唯一约束1ALTER TABLE tbl_name DROP {INDEX|KEY} index_name 修改添加/删除默认约束12ALTER TABLE table_name ALTER [COLUMN] column_name{SET DEFAULT literal | DROP DEFAULT} 删除外键约束1ALTER TABLE table_name DROP FOREIGN KEY fk_symbol 修改列定义12ALTER TABLE table_name MODIFY [COLUMN] col_namecolumn_definition [FIRST | AFTER col_name] 修改列名称12ALTER TABLE tbl_name CHANGE [COLUMN] old_col_namenew col_name column_definition [FIRST | AFTER col_name] 数据表更名 方法一 1ALTER TABLE table_name RENAME [TO[AS] new_tbl_name 方法二 12RENAME TABLE tbl_name TO new_tbl_name[, tbl_name2 TO new_tb_name2] 基础语法INSERT12INSERT [INTO] table_name [(column_name,...)) {VALUES | VALUE}({expr | DEFAULT,...),(...).... 1INSERT [INTO] table_name SET col_name={expr | DEFAULT},... 说明:与第一种方式的区别在于,此方法可以使用子查询(SubQuery) 1INSERT [INTO] tbl_name [(col_name,...] SELECT... 说明:此方法可以将查询结果插入到指定数据表。 UPDATE UPDATE 更新记录值(单表)123UPDATE [LOW_PRIORITY] [IGNORE] tabl_ reference SETcol_name1={expr1 | DEFAULT} [, col_name2={expr2 | DEFAULT}]...[WHERE where_condition] ##DELETE 删除记录(单表刪除) 1DELETE FROM table_name [WHERE where_condition] SELECT123456789SELECT select_expr[,select_expr...][FROM table_references[WHERE where_condition][GROUP BY {col_name | position} [ASC | DESC],...][HAVING where_condition][ORDER BY {col_name | expr | position) [ASC | DESC],...][LIMIT {[offset,] row_count | row_count OFFSET offset}]] 以上选项含义 select_expr 查询表达式 每一个表达式表示想要的一列,必须有至少一个。 多个列之间以英文逗号分隔。 星号(*)所有列。 table_name. *可以命名表的所有列。 查询表达式可以使用[AS] alias_name为其赋予别名。 别名可用于GROUP BY ORDER BY或HAVING子句。 WHERE 条件表达式 对记录进行过滤,如果没有指定WHERE子句,则显示所有记录。 在WHERE表达式中,可以使用MySQL支持的函数或运算符。 GROUP BY 查询结果分组1[GROUP BY {col_name position} [ASC | DESC],...] HAVING 条件分组1[HAVING where_condition] ORDER BY 对查询结果进行排序1[ORDER BY {col_name | expr | position} [ASC | DESC],..] LIMIT 限制查询结果返回的数量1[LIMIT {[offset,] row_count | row_count OFFSET offset}] 子查询子查询(Subquery)是指出现在其他SQL语句内的SELECT子句。 123SELECT * FROM t1 WHERE coll = (SELECT col2 FROM t2);其中SELECT FROM t1,称为Outer Query/Inner StatementSELECT col2 FROM t2 ,称为SubQuery 子查询指嵌套在查询内部,且必须始终出现在圆括号内。 子查询可以包含多个关键字或条件, 如DISTINCT、GROUP BY、ORDER BY, LIMIT函数等。 子查询的外层查询可以是:SELECT INSERT, UPDATE.SET或DO。 子查询返回值 子查询可以返回标量、一行、一列或子查询。 使用比较运算符的子查询 使用比较运算符的子查询 =, &gt;, &lt; &gt;, &lt;= &lt;&gt;. !&gt;, &lt;=&gt; 语法结构 operand comparison operator subquery 用 ANY,SOME 或 ALL 修饰的比较运算符123operand comparison operator ANY (subquery)operand comparison operator SUM (subquery)operand comparison operator ALL (subquery) ANY、SOME、ALL关键字 运算符 ANY SOME ALL &gt;,&gt;= 最小值 最小值 最大值 &lt;,&lt;= 最大值 最大值 最小值 = 任意值 任意值 &lt;&gt;,!= 任意值","link":"/posts/MySQLbasic.html"},{"title":"Git 常用命令","text":"Git 常用命令 配置 基础配置123456789101112git config --global user.name \"Vitan\"git config --global user.email \"ivitan95@gmail.com\"ssh-keygen -t rsa -C \"ivitan95@gmail.com\"git config --global color.ui truegit config --global alias.co checkout #别名git config --global alias.ci commitgit config --global alias.st statusgit config --global alias.br branchgit config --global core.editor \"vim\"# 设置Editor使用vimgit config --global core.quotepath false# 设置显示中文文件名 常用命令查看、添加、提交、删除、找回，重置修改文件 12345678910111213141516171819202122232425262728293031323334git co -- &lt;file&gt;# 抛弃工作区修改git co .# 抛弃工作区修改git add &lt;file&gt;# 将工作文件修改提交到本地暂存区git add .# 将所有修改过的工作文件提交暂存区git rm &lt;file&gt;# 从版本库中删除文件git rm &lt;file&gt; --cached# 从版本库中删除文件，但不删除文件git reset &lt;file&gt;# 从暂存区恢复到工作文件git reset -- .# 从暂存区恢复到工作文件git reset --hard# 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt;git ci .git ci -a# 将git add, git rm和git ci等操作都合并在一起做git ci -am \"some comments\"git ci --amend# 修改最后一次提交记录git revert &lt;$id&gt;# 恢复某次提交的状态，恢复动作本身也创建了一次提交对象git revert HEAD# 恢复最后一次提交的状态 查看文件 diff 12345678910111213git diff &lt;file&gt;# 比较当前文件和暂存区文件差异git diffgit diff &lt;$id1&gt; &lt;$id2&gt;# 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt;# 在两个分支之间比较git diff --staged# 比较暂存区和版本库差异git diff --cached# 比较暂存区和版本库差异git diff --stat# 仅仅比较统计信息 查看提交记录 1234567git loggit log &lt;file&gt;# 查看该文件每次提交记录git log -p &lt;file&gt;# 查看每次详细修改内容的diffgit log -p -2# 查看最近两次详细 - Mac 上可以使用 tig 代替 diff 和 log，brew install tig分支管理本地分支管理查看、切换、创建和删除分支 123456789101112131415161718192021222324252627git br -r# 查看远程分支git br &lt;new_branch&gt;# 创建新的分支git br -v# 查看各个分支最后提交信息git br --merged# 查看已经被合并到当前分支的分支git br --no-merged# 查看尚未被合并到当前分支的分支git co &lt;branch&gt;# 切换到某个分支git co -b &lt;new_branch&gt;# 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt;# 基于branch创建新的new_branchgit co $id# 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt;# 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt;# 删除某个分支git br -D &lt;branch&gt;# 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和 rebase 123456789git merge &lt;branch&gt;# 将branch分支合并到当前分支git merge origin/master --no-ff# 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt;# 将master rebase到branch，相当于：git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; 补丁管理 (方便在多台机器上开发同步时用) 123git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch # 测试补丁能否成功 暂存管理 12345git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区git stash clear 远程分支管理基础命令 12345678910111213141516171819202122232425git pull# 抓取远程仓库所有分支更新并合并到本地git pull --no-ff# 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin# 抓取远程仓库更新git merge origin/master# 将远程主分支合并到本地当前分支git co --track origin/branch# 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;# 基于远程分支创建本地分支，功能同上git push# push所有分支git push origin master# 将本地主分支推到远程主分支git push -u origin master# 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt;# 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;# 创建远程分支git push origin :&lt;remote_branch&gt;#先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 远程仓库管理 12345678git remote -v# 查看远程服务器地址和仓库名称git remote show origin# 查看远程服务器仓库状态git remote add origin git@github:stormzhang/demo.git# 添加远程仓库地址git remote set-url origin git@github.com:stormzhang/demo.git# 设置远程仓库地址(用于修改远程仓库地址 创建远程仓库 12345678910111213141516git clone --bare robbin_site robbin_site.git# 用带版本的项目创建纯版本仓库scp -r my_project.git git@git.csdn.net:~# 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init# 在服务器创建纯仓库git remote add origin git@github.com:robbin/robbin_site.git# 设置远程仓库地址git push -u origin master# 客户端首次提交git push -u origin develop# 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master# 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库12git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop Via stormzhang","link":"/posts/Git-common-command.html"},{"title":"Hexo Cutie 主题 Markdown 语法","text":"Hexo Cutie 主题 Markdown 语法 安装文章使用 hexo-renderer-markdown-it作为渲染器,因此需要安装此渲染器以达到效果。 installation123456npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm i markdown-it-emoji --savenpm i markdown-it-mark --savenpm i markdown-it-deflist --savenpm i markdown-it-container --save 配置添加以下内容到站点的_config.yml. _config.yml12345678910111213141516171819202122markdown: render: html: true xhtmlOut: false breaks: false linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-deflist anchors: level: 2 collisionSuffix: 'v' permalink: false permalinkClass: header-anchor permalinkSymbol: \" \" permalinkBefore: false 使用 标题source code123456# h1 Heading 8-)## h2 Heading### h3 Heading#### h4 Heading##### h5 Heading###### h6 Heading h1 Heading 8-)h2 Headingh3 Headingh4 Headingh5 Headingh6 Heading水平分割线source code12345___---*** 排版替换source code1234567(c) (C) (r) (R) (tm) (TM) (p) (P) +-test.. test... test..... test?..... test!....!!!!!! ???? ,, -- ---\"Smartypants, double quotes\" and 'single quotes' (c) (C) (r) (R) (tm) (TM) (p) (P) +- test.. test… test….. test?….. test!…. !!!!!! ???? ,, – — “Smartypants, double quotes” and ‘single quotes’ 着重source code123456789**This is bold text**__This is bold text__*This is italic text*_This is italic text_~~Strikethrough~~ This is bold text This is bold text This is italic text This is italic text Strikethrough 引用source code123&gt; Blockquotes can also be nested...&gt;&gt; ...by using additional greater-than signs right next to each other...&gt; &gt; &gt; ...or with spaces between arrows. Blockquotes can also be nested… …by using additional greater-than signs right next to each other… …or with spaces between arrows. 清单无序source code1234567+ Create a list by starting a line with `+`, `-`, or `*`+ Sub-lists are made by indenting 2 spaces: - Marker character change forces new list start: * Ac tristique libero volutpat at + Facilisis in pretium nisl aliquet - Nulla volutpat aliquam velit+ Very easy! Create a list by starting a line with +, -, or * Sub-lists are made by indenting 2 spaces: Marker character change forces new list start: Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Very easy! 有序source code1234561. Lorem ipsum dolor sit amet 1. Indented list 1. Another level 2. Indent2. Consectetur adipiscing elit3. Integer molestie lorem at massa Lorem ipsum dolor sit amet Indented list Another level Indent Consectetur adipiscing elit Integer molestie lorem at massa source code121. You can use sequential numbers...1. ...or keep all the numbers as `1.` You can use sequential numbers… …or keep all the numbers as 1. 用偏移符号编号source code1257. foo1. bar foo bar 代码source code1Inline `code` Inline code 代码缩进source code1234// Some comments line 1 of code line 2 of code line 3 of code // Some comments line 1 of code line 2 of code line 3 of code代码区块source code123```Sample text here...``` 1Sample text here... 语法高亮显示 source code1234567``` js sample.jsvar foo = function (bar) { return bar++;};console.log(foo(5));``` sample.js12345var foo = function (bar) { return bar++;};console.log(foo(5)); 表格source code12345| Option | Description |Description | Description | Description | Description || ------ | ----------- |----------- | ----------- | ----------- | ----------- || data | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext | extension to be used for dest files. | Option Description Description Description Description Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 列右对齐source code12345| Option | Description || ------:| -----------:|| data | path to data files to supply the data that will be passed into templates. || engine | engine to be used for processing templates. Handlebars is the default. || ext | extension to be used for dest files. | Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 链接source code1[link text](http://dev.nodeca.com) link text source code1[link with title](http://nodeca.github.io/pica/demo/ \"title text!\") link with title source code1Autoconverted link https://github.com/nodeca/pica (enabled linkify) Autoconverted link https://github.com/nodeca/pica (enabled linkify) 图片source code12![Minion](https://octodex.github.com/images/minion.png)![Stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") 与链接一样，图片也有脚注样式语法 source code12345![Alt text][id]在文档的后面定义 URL 的位置[id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 在文档的后面定义 URL 的位置 插件markdown-it 渲染器完美支持syntax plugins。例如 configuration snippet Emojiessource code123Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:Shortcuts (emoticons): :-) :-( 8-) ;) Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum: Shortcuts (emoticons): :-) :-( 8-) ;) 上标 / 下标source code123Superscript: 19^th^Subscript: H~2~O Superscript: 19^th^ Subscript: H2O &lt;ins&gt;source code1++Inserted text++ ++Inserted text++ &lt;mark&gt;source code1==Marked text== ==Marked text== 脚注source code12345678910111213Footnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup** and multiple paragraphs.[^second]: Footnote text. Footnote 1 link[^first]. Footnote 2 link[^second]. Inline footnote^[Text of inline footnote] definition. Duplicated footnote reference[^second]. [^first]: Footnote can have markup and multiple paragraphs.[^second]: Footnote text. 定义列表source code123Term 1: 定义 1带有延迟继续。. Term 1定义 1带有延迟继续。source code123456第 2 项带有 * 内联标记 *: 定义 2 { some code, part of Definition 2 } Third paragraph of definition 2. Term 2 with inline markupDefinition 2 { some code, part of Definition 2 } Third paragraph of definition 2.Compact style: source code123456Term 1 ~ Definition 1Term 2 ~ Definition 2a ~ Definition 2b Term 1 ~ Definition 1 Term 2 ~ Definition 2a ~ Definition 2b 缩略形式 / 缩写source code12345这是 HTML 缩写的例子。它转换成 “HTML”，但保留“xxxHTMLyy” 等完整的部分条目。*[HTML]：超文本标记语言 这是 HTML 缩写的例子。 它转换成 “HTML”，但保留“xxxHTMLyy” 等完整的部分条目 *[HTML]: Hyper Text Markup Language Custom containers::: warninghere be dragons::: Hexo 内置标签引用，带作者名字source code123{% blockquote David Levithan, Wide Awake %}Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.{% endblockquote %} Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 引用 Twittersource code123{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}NEW: DevDocs now comes with syntax highlighting. http://devdocs.io{% endblockquote %} NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 引用网络链接source code123{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}Every interaction is both precious and an opportunity to delight.{% endblockquote %} Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 抽取引用source code123{% pullquote %}content{% endpullquote %} content jsFiddlesource code1{% jsfiddle o2gxgz9r default light %} Gistsource code1{% gist b6365e79be6052e7531e7ba6ea8caf23 &apos;Sample gist&apos; %} iFramesource code1{% iframe https://www.bing.com %} 新标签页打开链接source code1{% link Google https://www.google.com default Google %} Google Youtubesource code1{% youtube l_lblj8Cq0o %} 原文链接 Hexo Theme Cutie v2.0.12 Typography Demo","link":"/posts/post-typography-and-tags-test.html"},{"title":"Hexo 域名","text":"Hexo 独立域名 购买域名比较服务商可以到 Nazhumi 查看比较。 解析域名 添加 A 记录 1234A @ 185.199.108.153A @ 185.199.109.153A @ 185.199.110.153A @ 185.199.111.153 添加 CNAME 记录 1CNAME www ivitan.github.io 本地配置新建 CNAME 文件 cd blog echo \"vitan.me\" &gt; CNAME Github 配置仓库设置 参考 Hexo","link":"/posts/Hexo-Domain.html"},{"title":"SQL 模式分解","text":"关系模式关系模式R(U)的一个分解p={Ri(Ui)}满足U=∪{Ui}，模式分解必须是无损连接并且需要保持函数依赖 无损连接 无损连接是指某关系模式的事例r按照关系模式分解成多个关系r1,…,rk，若r1,…,rk的自然连接（Join操作）等于r，则称该模式分解是无损的. 测试无损连接 Chase方法能够检测完全的无损连接，设有n个属性的模式R分解为k个模式Ri，有如下Chase过程： 1. 构造一个k行n列的表格，每行对应一个模式Ri，每列对应一个属性Aj，若Aj在模式Ri中则表格[i][j]中填入aj，否则填入bij 2. 扫描F中的每个FD X→Y 3. 若表格中有两行在X分量上相等，在Y分量上不相等则修改Y：若Y的分量中是个是aj，则另一个也修改为aj 4. 如果没有aj，则用其中一个bij替换另一个符号（i是所有b中最小的行数） 5. 重复2、3、4一直到表格不能修改为止 6. 若此时表格中有一行全是a，则该分解是无损连接的分解当模式分解是简单的二元分解时（即p={R1,R2}），p是无损连接的分解当且仅当下面FD之一成立： 1. R1和R2两模式属性的交集 → R1与R2两模式属性的差集 2. R1和R2两模式属性的交集 → R2与R1两模式属性的差集保持函数依赖 保持函数依赖是指关系模式R的FD集F在分解后仍在数据库模式中保持不变，这是模式分解的第二个条件 形式化的定义分解后F在模式Ri上的投影为： πRi(F)={X→Y|X→Y∈F+⋂X、Y⊂Ri} 若分解p满足如下条件则称p\\保持函数依赖\\： 关系模式的范式含义范式xNF即是满足特定要求的模式，将低一级范式的关系模式通过模式分解转换为高一级范式的关系模式集合的过程叫做规范化 范式从低级到高级依次为：1NF、2NF、3NF、BCNF、4NF、5NF，高一级的范式总是低一级范式的真子集 根据关系模式R的不可约FD集F，可以画出节点是属性或属性集，边是由被依赖节点指向依赖节点的有向图来辅助分析关系模式，叫做函数依赖图 1NF 1NF要求关系模式R的每一个实例r均满足：r中的每一个元组t的每一个属性中只有一个值，这是关系模式的基本要求 不满足1NF的关系模式有二义性！ 2NF 假定：R只有一个候选码，且该候选码为主码 R∈1NF且R的每一个非主属性（非候选码的其他属性）都完全函数依赖于主码时，R∈2NF A完全依赖于W是指：W→A且A不依赖于任何一个W的真子集X，W是主键也可能包括多个属性{X、Y}，非主属性A不能局部函数依赖于X或Y 不满足2NF的关系模式可能存在［插入异常、删除异常、更新异常和数据冗余］，通过画出函数依赖图无损分解非2NF得到2NF，但2NF也不能完全消除上述问题 3NF 假定：R只有一个候选码，且该候选码为主码 R∈2NF且R的每一个非主属性都不传递依赖于主码时，R∈3NF称A传递依赖于Y则有：Y→X，X→A，并且Y不依赖于X（即Y不等于X）、A不是X的子集 不满足3NF的关系模式也可能存在［插入异常、删除异常、更新异常和数据冗余］，通过打破传递依赖链条，把关系模式分解成多个子关系模式 BCNF BCNF是3NF处理R有多个候选码的扩展，当R有多个候选码时即使R∈3NF，也可能出现［插入异常、删除异常、更新异常和数据冗余］，这时需要分解为BCNF范式 如果关系模式R的所有不平凡的、完全的函数依赖的决定因素（左边的属性集）都是候选码，则R∈BCNF若要求保持函数依赖和无损联接，则总可以达到3NF，但不一定满足BCNF；因为BCNF可以达到无损连接，但不一定保持函数依赖 关系模式分解为范式的分解算法保持函数依赖地分解R到3NF算法步骤：求出R的最小函数依赖集F 把所有不在F中出现的属性组成一个关系模式R’，并在U中去掉这些属性 若F中存在X→A且XA=U，则算法结束输出{R’,R(U)}，否则继续下一步 对F中的FD按相同的左部分组构成一个关系模式Ri(Ui)，Ui包括了该组FD涉及的所有属性 去掉{Ri(Ui)}中属性集Ui是其他某个关系模式属性集Uj子集的关系模式Ri，得到最终的分解p={R1,R2,…,Rk,R’}，p能够保持函数依赖地把R分解到3NF 无损连接且保持函数依赖地分解R到3NF算法步骤： 按算法(1)中步骤求出保持函数依赖的3NF分解，设q={R1,R2,…,Rk} 设X是R的主码，p={R1,R2,…,Rk,R(X)} 若X是q中某个Ri(Ui)属性集Ui的子集，则删除p中的R(X) 输出p，p能够无损连接且保持函数依赖地把R分解到3NF 无损联接地分解R到BCNF算法步骤： p={R} 检查p中各关系模式是否满足BCNF，是则终止输出p 设p中S(Us)非BCNF，则必存在X→A且X不是S的候选码：S分解为S1(XA)和S2(Us-A)，把p中的S替换为S1、S2，跳转至第二步 参考 数据库复习11——关系模式与范式","link":"/posts/SQLmode.html"},{"title":"SQL 关系代数表达式","text":"关系代数是关系数据库系统查询语言的理论基础。很有必要学习一下，有些是用代数表达式很方便的东西，用SQL写出来还是挺麻烦的，并不是想象当中那么直接。 一、关系代数的9种操作 关系代数中包括了：并、交、差、乘、选择、投影、联接、除、自然联接等操作。 五个基本操作并(∪)、差(-)、笛卡尔积(×)、选择(σ)、投影(π) 四个组合操作 交(∩) 2. 联接(等值联接) 3. 自然联接(R⋈S) 4. 除法(÷) 注2：等值连接表示先做笛卡尔积(×)之后，对相应列进行选择或等值关联后的结果(仅筛选行、不筛选列) 注2：自然连接表示两个关系中若有相同名称的属性，则自动作为关联条件，且仅列出一列 补充各种符号 投影 π 选择 σ 重命名 ρ 自然连接 ⋈ θ-连接和相等连接 半连接 ⋉ , ⋊ 反连接 ▷ 除法 ÷ 左外连接 ⟕ 右外连接 ⟖ 全外连接 ⟗ 二、关系代数表达式由关系代数运算经有限次复合而成的式子称为关系代数表达式。这种表达式的运算结果仍然是一个关系。可以用关系代数表达式表示对数据库的查询和更新操作。 三、举例说明设教学数据库中有3个关系： 学生关系S(SNO,SNAME,AGE,SEX) 学习关系SC(SNO,CNO,GRADE) 课程关系C(CNO,CNAME,TEACHER) 检索学习课程号为C2的学生学号与成绩123SELECT SNO,GRADE FROM SCWHERE CNO='C2' 1π SNO,GRADE(σCNO=&apos;C2&apos;(SC)) 检索学习课程号为C2的学生学号与姓名1234SELECT SC.SNO,S.SNAMEFROM SC,SWHERE SC.SNO=S.SNOAND SC.CNO='C2' 12π SNO,SNAME(σCNO=&apos;C2&apos;(S⋈SC))此查询涉及S和SC，先进行自然连接，然后再执行选择投影操作。 123π SNO,SNAME（S）cross（πSNO(σCNO=&apos;C2&apos;(SC))）自然连接的右分量为&quot;学了C2课的学生学号的集合&quot;。此表达式比前一个表达式优化，执行起来要省时间、省空间。 检索选修课程名为MATHS的学生学号与姓名12345SELECT SC.SNO,S.SNAMEFROM SC,S,CWHERE SC.SNO=S.SNOAND SC.CNO=C.CNOAND C.CNAME='MATHS' 1π SNO,SANME(σCNAME=&apos;MATHS&apos;(S⋈SC⋈C)) 检索选修课程号为C2或C4的学生学号1234SELECT SNOFROM SCWHERE CNO='C2'OR CNO='C4' 1π SNO(σ CNO=&apos;C2&apos;∨CNO=&apos;C4&apos;(SC)) 检索至少选修课程号为C2或C4的学生学号12345SELECT SA.SNOFROM SC AS SA,SC AS SBWHERE SA.SNO=SB.SNOAND SA.CNO='C2'AND SB.CNO='C4' 1π 1(σ1=4∧2=&apos;C2&apos;∧5=&apos;C4&apos;（SC×SC）) 检索不学C2课的学生姓名与年龄1234567SELECT SNAME,AGEFROM SMINUSSELECT S.SNAME,S.AGEFROM SC,SWHERE SC.SNO=S.SNOAND SC.CNO='C2' 1π SNAME,AGE（S）－πSNAME,AGE(σCNO=&apos;C2&apos;（S⋈SC）) 检索学习全部课程的学生姓名 1234π SNO,CNO(SC)÷πCNO(C)先用除法取出选取所有课程的SNO集(除法可以理解为一个Filter)π SNAME(S ⋈ (πSNO,CNO(SC)÷πCNO(C)))再关联S表取出SNAME 检索所学课程包含S3所学课程的学生学号 12π SNO,CNO(SC)÷ πCNO(σSNO=&apos;S3&apos;(SC)）同样运用了除法的特性 将新课程元组(‘C10’,’PHYSICS’,’YU’)插入到关系C中 1INSERT INTO C VALUES('C10','PHYSICS','YU') 12(C∪(&apos;C10&apos;,&apos;PHYSICS&apos;,&apos;YU&apos;))记住该符号的用法 将学号S4选修课程号为C4的成绩改为85分123UPDATE SC SET GRADE=85WHERE SNO='S4'AND CNO='C4' 123（SC－（&apos;S4&apos;,&apos;C4&apos;,?)∪(&apos;S4&apos;,&apos;C4&apos;,85)）先用&apos;－&apos;实现DELETE功能，再用&apos;∪&apos;实现INSERT功能注意使用?来表示检索时忽略该字段值 四、关系代数表达式的优化目的：为了系统在执行时既省时间又能提高效率。 基本策略：先做选择，运用投影去除多余属性等等。 优化算法：语法树(尽量提前做选择操作；在每个操作后，应做个投影操作，去掉不用的属性值) 例如： π SNO,SNAME(σGRADE&gt;60(S⋈SC)) 进行优化后转换为：2. π SNO,SNAME(πSNO,SNAME(S)⋈πSNO(σGRADE&gt;60(SC))) –即提前做选择操作；在每个操作后，应做个投影操作，去掉不用的属性值 又如： S(S#,SNAME,AGE,SEX) SC(S#,C#,GRADE) C(C#,CNAME,TEACHER) π CNAME,TEACHER(σSEX=’女’(S⋈SC⋈C)) 进行优化后转换为： πCNAME,TEACHER(C⋈πC#(πS#,C#(SC)⋈S#(σSEX=’女’(S)))) 优化前和优化后的语法树如下所示： 转载注明数据库关系代数表达式学习","link":"/posts/SQLrelAlg.html"},{"title":"SQL 补充练习题","text":"数据库单表查询 一、实验目的 掌握SELECT语句的基本语法和查询条件表示方法； 掌握查询条件表达式和使用方法； 掌握GROUP BY 子句的作用和使用方法； 掌握HAVING子句的作用和使用方法； 掌握ORDER BY子句的作用和使用方法。 二、实验环境已安装SQL Server 2005 企业版的计算机(13台)； 具有局域网环境,有固定IP; 三、实验学时2学时 四、实验要求 了解数据库查询； 了解数据库查询的实现方式； 完成实验报告； 五、实验内容及步骤以数据库原理实验6数据库中数据为基础，请使用T-SQL 语句实现以下操作： 列出所有不姓刘的所有学生；（not like） 123select *from swhere 姓名 not like '刘%' 列出姓“张”且全名为3个汉字的学生；(张__下滑线表示任意一个字符) 123select *from swhere 姓名 like '张__' 显示在2000年以后出生的学生的基本信息； 123select *from swhere 年龄&lt;=(2018-2000) 查询出课程名含有“数据”字串的所有课程基本信息 123select *from cwhere 课程名 like '数据%' 列出选修了‘101’课程的学生，按成绩的降序排列； 1234select *from scwhere 课程号='101'order by 成绩 desc 列出课程表中全部信息，按先修课的升序排列； 按照出生年份升序显示所有学生的学号、姓名、性别、出生年份及所在系，在结果集中列标题分别指定为“学号，姓名，性别，出生年份，所在系”； 123select 学号,姓名,性别,(2018-年龄) as 出生年份,所在系from sorder by 出生年份 asc 按照院系降序显示所有学生的 “所在系，学号、姓名、性别、年龄”等信息，其中所在系按照以下规定显示：院系为CS显示为计算机系，院系为IS显示为信息系，院系为MA显示为数学系，院系为JZ显示为建筑系，其他显示为院系不明；参考例句 12345678select 姓名,所在系,学号,院系英文书写=casewhen 所在系='计算机系' then 'CS'when 所在系='信息系' then 'IS'when 所在系='艺术系' then 'AS'when 所在系='会计系' then 'KS'endfrom sorder by 院系英文书写 DESC 显示所有院系（要求不能重复，不包括空值），并在结果集中增加一列字段“院系规模”，其中若该院系人数&gt;=5则该字段值为“规模很大”，若该院系人数大于等于4小于5则该字段值为“规模一般”， 若该院系人数大于等于2小于4则该字段值为“规模稍小”，否则显示“规模很小”；（参考例句，同学们，适当增加、删除记录，观察结果） 1234567select 所在系,COUNT(学号) 人数,院系规模=casewhen COUNT(学号)&gt;=7 then '大规模'when COUNT(学号)&gt;=5 and COUNT(学号)&lt;7 then '中等'when COUNT(学号)&lt;5 then '小规模'endfrom sgroup by 所在系 按照课程号、成绩降序显示课程成绩在70-80之间的学生的学号、课程号及成绩； 显示学生信息表中的学生总人数及平均年龄，在结果集中列标题分别指定为“学生总人数，平均年龄”； 显示选修的课程数大于3的各个学生的选修课程数； 按课程号降序显示选修各个课程的总人数、最高成绩、最低成绩及平均成绩； 显示各个所在系男女生人数，其中在结果集中列标题分别指定为“所在系名称、男生人数、女生人数”； 列出有二门以上课程（含两门）不及格的学生的学号及该学生的平均成绩； 六、出现问题及解决办法如：某些查询操作无法执行，如何解决？","link":"/posts/SQLexercise.html"},{"title":"SQL 检索练习题","text":"检索，存储过程，触发器相关练习。 仓库号 城市 面积 WH1 北京 370 WH2 上海 500 WH3 广州 200 WH4 广州 300 WH5 天津 340 WH6 上海 350 WH7 上海 600 WH8 天津 300 职工号 仓库号 工资 E1 WH2 2220 E2 WH1 1810 E3 WH2 1850 E5 WH3 1530 E6 WH1 1550 E7 WH4 2300 E8 WH4 2000 E9 WH5 2050 E10 WH5 1900 E11 WH6 2100 E12 WH7 1700 E15 WH5 1780 E16 WH1 1600 职工号 供应商号 订购单号 订购日期 E3 S7 OR67 2005-12-4 E1 S4 OR73 2006-4-1 E7 S4 OR76 2006-4-2 E6 S6 OR77 2006-1-21 E3 S4 OR79 2005-11-15 E1 S6 OR80 2006-2-1 E3 S6 OR90 2006-3-12 E3 S3 OR91 2006-3-2 ————————————————- 供应商号 供应商名 地址 :— :—- :— :— S3 振华电子厂 西安 S4 华通电子公司 北京 S6 607厂 郑州 S7 爱华电子厂 北京 检索 检索在北京的供应商的名称。 1select 供应商名 from gys where 地址='北京' 检索发给供应商S6的订购单号。 1select 订购单号 from dg where 供应商号='S6' 检索出职工E6发给供应商S6的订购单信息。 1select * from dg where 职工号='E6'and 供应商号='S6' 检索出向供应商S3发过订购单的职工的职工号和仓库号。 12select zg.职工号,仓库号 from dg join zg on zg.职工号=dg.职工号 where 供应商号='S3' 检索出目前与S3供应商没有联系的职工信息。 12select * from zg where 职工号 not in(select 职工号 from dg where 供应商号='S3') 检索出目前没有任何订购单的供应商信息 12select * from gys where 供应商号 not in (select distinct 供应商号 from dg) 12 SELECT * FROM gys WHERE NOT EXISTS ( SELECT * FROM dg WHERE 供应商号=gys.供应商号 ) 检索出和职工E1、E3都有联系的北京的供应商的信息。 12345select * from gys where 地址='北京' and 供应商号 in(select 供应商号 from dg where 职工号='E1')and 供应商号 in(select 供应商号 from dg where 职工号='E3') 检索出目前和华通电子公司有业务联系的每个职工的工资。 123select 职工号,工资 from zg where 职工号 in(select 职工号 from dg where 供应商号 in(select 供应商号 from gys where 供应商名='华通电子公司')) 检索出与工资在1220元以下的职工没有联系的供应商名称。 12345select 供应商名 from gys where 供应商号 not in(select 供应商号 from dg where 职工号 in(select 职工号 from zg where 工资&lt;1220)) 1234select 供应商名 from gys where 供应商号 not in (select 供应商号 from dg join zg on dg.职工号=zg.职工号where 工资&gt;2250) 检索出向S4供应商发出订购单的仓库所在的城市。 123select 城市 from ck where 仓库号 in(select 仓库号 from zg where 职工号 in(select 职工号 from dg where 供应商号='S4')) 检索出在上海工作并且向S6供应商发出了订购单的职工号。 123select 职工号 from zg where 仓库号 in(select 仓库号 from ck where 城市='上海' and 职工号 in(select 职工号 from dg where 供应商号='S6')) 123select dg.职工号 from zg join ck on zg.仓库号=ck.仓库号join dg on zg.职工号=dg.职工号where 城市='上海' and 供应商号='S6' 检索出在广州工作并且只向S6供应商发出了订购单的职工号。 123456select 职工号 from zg where 仓库号 in(select 仓库号 from ck where 城市='广州' and 职工号 in(select 职工号 from dg where 供应商号='S6') and 职工号 not in(SELECT 职工号 FROM dg WHERE 供应商号!='S6')) 检索出由工资多于1230元的职工向北京的供应商发出的订购单号。 123select 订购单号 from dg where 职工号 in(select 职工号 from zg where 工资&gt;1230) and 供应商号 in(select 供应商号 from gys where 地址='北京') 1234select 订购单号 from dg where 职工号 in(select 职工号 from zg where 工资&gt;2000)and 供应商号 in (select 供应商号 from gys where 地址='北京') 检索出仓库的个数 1select count(仓库号) from ck 检索出有最大面积的仓库信息。 12select * from ck where ck.面积=(select max(面积) from ck ) 检索出所有仓库的平均面积。 1select avg(面积) 平均面积 from ck 检索出向S4供应商发出订购单的那些仓库的平均面积。 123select avg(面积) as 平均面积 from ck where 仓库号 in(select 仓库号 from zg where 职工号 in(select 仓库号 from dg where 供应商号='S4')) 1234select avg(面积) as 平均面积 from ckwhere 仓库号 in (select 仓库号 from zg join dg on zg.职工号=dg.职工号where 供应商号='S4') 检索出每个城市的供应商个数。 12select 地址,count(*) from gysgroup by 地址 检索出每个仓库中工资多于1220元的职工个数。 12select 仓库号,count(*) from zg where 工资&gt;1220 group by 仓库号 检索出和面积最小的仓库有联系的供应商的个数。 12345select count(供应商号) from gys where 供应商号 in(select 供应商号 from dg where 职工号 in(select 职工号 from zg where 仓库号 in(select 仓库号 from ck where 面积=(select min(面积) from ck)))) 123select count(供应商号) from dg where 职工号 in (select 职工号 from zg where 仓库号 in(select 仓库号 from ck where 面积=(select min(面积) from ck))) 检索出工资低于本仓库平均工资的职工信息。123SELECT * FROM 职工 out WHERE 工资&lt; (SELECT AVG(工资) FROM 职工 inne WHERE 仓库号=out.仓库号) 存储过程 创建一个存储过程P1，输入某个仓库号，查询对应仓库的信息。1234create proc P1@ckh nvarchar(225) asselect * from ck where 仓库号=@ckh 1exec P1 'WH8' 创建一个存储过程P2，输入某个仓库号，输出对应仓库的的职工人数。12345create proc P2@ckh nvarchar(20)asselect count(职工号) 职工人数 from zg where 仓库号 = @ckhgroup by 仓库号 1exec P2 'WH1' 12345678910111213alter TRIGGER tri_salaryON zhg FOR UPDATEASSELECT * FROM INSERTED JOINDELETED ON INSERTED.职工号 = DELETED.职工号IF UPDATE(工资)IF EXISTS(SELECT * FROM INSERTED JOINDELETED ON INSERTED.职工号 = DELETED.职工号WHERE INSERTED.工资&amp;lt;DELETED.工资)beginprint(&amp;#39;新工资值低于原工资，拒绝修改&amp;#39;)ROLLBACKend 12345678910111213CREATE PROCEDURE countzhigong@ck char(20), @renshu int outputASSELECT @renshu = count(职工号)FROM ck left outer JOIN zhg ON ck.仓库号= zhg.仓库号WHERE ck.仓库号=@ckDeclare @re intExecute countzhigong &amp;#39;wh2&amp;#39;, @re outputPrint @reSELECT *FROM ck left outer JOIN zhg ON ck.仓库号= zhg.仓库号SELECT * FROM zhg 创建、修改、删除触发器。 创建一个触发器zhigong1，在对职工表的工资属性修改时触发：每修改一个职工的工资，就检查新工资是否比原工资低，若是低，则恢复原工资而不做修改。12345678910create trigger zhigong1on zg for insert,updateasselect * from inserted join deleted on inserted.职工号=deleted.职工号if update(工资)if exists (select * from inserted join deleted on inserted.职工号=deleted.职工号where inserted.工资&lt;deleted.工资)rollback 1update zg set 工资='3000' where 职工号='E9' 创建一个触发器zhigong2，在插入新的职工记录时触发：检查新职工记录的仓库号是否在仓库表的仓库号中存在，如果不存在就撤消插入操作。123456alter trigger zhigong2on zg for insertasselect * from inserted join deleted on inserted.职工号=deleted.职工号if not exists ( select 仓库号 from inserted where 仓库号 in (select 仓库号 from ck ))rollback 1insert into zg values('E33','WH2','3000') 删除以上两个触发器。 1drop trigger zhigong1,zhigong2 创建一个触发器dinggou1，在对订购表进行插入操作时，输出该职工的所经手的订购单数目。 1234567create trigger dinggou1on dg for insertasselect dg.职工号,count(dg.订购单号) as 订购单数目from dg join inserted on dg.职工号=inserted.职工号where dg.职工号=inserted.职工号group by dg.职工号 12insert into dg values('E1','S6','OR98','2018-01-21 00:00:00.000')","link":"/posts/SQLselect.html"},{"title":"Vim 插件&主题","text":"Vim 插件 主题 SpaceVim1curl -sLf https://spacevim.org/install.sh | bash Vundle 插件管理器Vundle 是Vim bundle 的简称,是一个 Vim 插件管理器. Vundle 允许你做 在.vimrc中跟踪和管理插件 安装特定格式的插件(a.k.a. scripts/bundle) 更新特定格式插件 通过插件名称搜索Vim scripts中的插件 清理未使用的插件 可以通过单一按键完成以上操作,详见interactive mode 安装 1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 配置 编辑 1vim .vimrc 添加下列内容 1234567set nocompatible &quot; be iMproved, requiredfiletype off &quot; requiredset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &apos;VundleVim/Vundle.vim&apos;call vundle#end() &quot; requiredfiletype plugin indent on &quot; required 安装需要的插件 bash 下： 1vim +PluginInstall +qall vim 下 1:PluginInstall 安装 Markdown 插件修改vimrc配置文件,添加 12Plugin &apos;godlygeek/tabular&apos;Plugin &apos;plasticboy/vim-markdown&apos; 下一步 12vim:PluginInstall 安装 gruvbox 主题在 .vimrc 添加 12Plugin &apos;morhetz/gruvbox&apos;Plugin &apos;vim-airline/vim-airline&apos; 配置主题 1234set bg=dark &quot;设置背景为黑色colorscheme gruvbox &quot;设置主题为 gruvboxset guioptions= &quot;去掉两边的scrollbarset guifont=Monaco:h17 &quot;设置字体和字的大小 Vim-airline.vimrc 添加插件 12Plugin &apos;vim-airline/vim-airlinePlugin &apos;vim-airline/vim-airline-themes&apos; 配置 1234567891011121314151617181920&quot;&quot; airline settings.let g:airline_theme = &apos;simple&apos;let g:airline_powerline_fonts = 1if !exists(&apos;g:airline_symbols&apos;) let g:airline_symbols = {}endiflet g:airline_left_sep = &apos;&apos;let g:airline_left_alt_sep = &apos;&apos;let g:airline_right_sep = &apos;&apos;let g:airline_right_alt_sep = &apos;&apos;let g:airline_symbols.branch = &apos;&apos;let g:airline_symbols.readonly = &apos;&apos;let g:airline_symbols.linenr = &apos;&apos;let g:airline#extensions#tabline#enabled = 1&quot; show absolute file path in status linelet g:airline_section_c = &apos;%&lt;%F%m %#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#&apos;&quot; show tab number in tab linelet g:airline#extensions#tabline#tab_nr_type = 1 支持主题 1234567891011121314151617181920212223242526272829303132badwolfbase16behelitbubblegumdarkduranthybridlinehybridjellybeanskalisikolorlaederonlightluciuslunamolokaimonochromemurmurpapercolorpowerlineishravenserenesilversimplesolarizedsoltermtomorrowubarydunderstatedwombatzenburn NERD Tree 文件浏览插件.vimrc 添加插件 1Plugin &apos;scrooloose/nerdtree&apos; 打开/关闭 NERD Tree 1:NERDTreeToggle NERD Tree 配置 12345&quot;当 vim 启动没指定文件时，自动打开 NERDTreeautocmd StdinReadPre * let s:std_in=1autocmd VimEnter * if argc() == 0 &amp;&amp; !exists(&quot;s:std_in&quot;) | NERDTree | endif&quot;在 normal 下按 ,d 打开关闭文件浏览nmap ,d :NERDTreeToggle&lt;CR&gt; 使用技巧 按 ?可以打开 NERD tree 帮助文档 按 j ,k 在 NERD tree上下移动,&lt;c-r&gt; 打开关闭文件夹或文件 :vsp 在右侧打开一个分屏，:sp 在下面打开一个分屏 &lt;c-w&gt;j ，&lt;c-w&gt;k, &lt;c-w&gt;h, &lt;c-w&gt;l按键分别向上、下、左、右分屏移动。 &lt;c-w&gt;=均分屏幕 改默的切换分屏按键方式 12345&quot;--------- Split Mapping --------------------&quot;nmap &lt;c-j&gt; &lt;c-w&gt;jnmap &lt;c-k&gt; &lt;c-w&gt;knmap &lt;c-h&gt; &lt;c-w&gt;hnmap &lt;c-l&gt; &lt;c-w&gt;l 官网文档GitHub Repo .vimrc 配置文件vimrc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&quot;设置行号显示set number&quot;将行号设置为相对行号set relativenumber&quot;显示标尺set ruler&quot; 编码set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1set fileencoding=utf-8set encoding=utf-8set fencs=utf-8,gbk,gb2312,gb18030&quot;语法高亮syntax enablesyntax on&quot; 高亮hi pythonSelf ctermfg=174 guifg=#6094DB cterm=bold gui=boldlet python_highlight_all=1syntax enable&quot; 状态行颜色highlight StatusLine guifg=SlateBlue guibg=Yellowhighlight StatusLineNC guifg=Gray guibg=White&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 总是显示状态行set laststatus=2&quot;命令行补全参数set wildmenu&quot;设置tab键空4格set tabstop=4&quot;自动检测文件类型filetype plugin indent on&quot;开启自动缩进，智能缩进set autoindentset cindentset smartindentset shiftwidth=4&quot;映射光标在窗口间移动的快捷键nmap &lt;C-H&gt; &lt;C-W&gt;hnmap &lt;C-J&gt; &lt;C-W&gt;jnmap &lt;C-K&gt; &lt;C-W&gt;knmap &lt;C-L&gt; &lt;C-W&gt;l&quot;插件安装列表set nocompatible &quot; be iMproved, requiredfiletype off &quot; requiredset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &apos;VundleVim/Vundle.vim&apos;Plugin &apos;morhetz/gruvbox&apos;Plugin &apos;vim-airline/vim-airline&apos;Plugin &apos;plasticboy/vim-markdown&apos;call vundle#end() &quot; requiredfiletype plugin indent on &quot; required&quot;基本主题配置set bg=dark &quot;设置背景为黑色colorscheme gruvbox &quot;设置主题为 gruvboxset guioptions= &quot;去掉两边的scrollbarset guifont=Monaco:h17 &quot;设置字体和字的大小set cucset culset incsearch &quot;输入搜索内容时就显示搜索结果set ignorecaseset hlsearch &quot;搜索时高亮显示被找到的文本&quot;airline settings.let g:airline_theme = &apos;simple&apos;let g:airline_powerline_fonts = 1if !exists(&apos;g:airline_symbols&apos;) let g:airline_symbols = {}endiflet g:airline_left_sep = &apos;&apos;let g:airline_left_alt_sep = &apos;&apos;let g:airline_right_sep = &apos;&apos;let g:airline_right_alt_sep = &apos;&apos;let g:airline_symbols.branch = &apos;&apos;let g:airline_symbols.readonly = &apos;&apos;let g:airline_symbols.linenr = &apos;&apos;let g:airline#extensions#tabline#enabled = 1&quot; show absolute file path in status linelet g:airline_section_c = &apos;%&lt;%F%m %#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#&apos;&quot; show tab number in tab linelet g:airline#extensions#tabline#tab_nr_type = 1 参考 Vim Vundle 个性化 Vim)","link":"/posts/Vim-Vundle-Markdown.html"},{"title":"SQL 实现数据完整性约束","text":"SQL实现数据完整性约束 数据完整性基本概念 实现声明完整性 实现过程完整性 数据完整性基本概念意义数据的完整性是为了防止数据库中存在不符合语义的数据。这些加在数据库数据之上的语义约束条件就是数据完整性约束条件。这些约束条件作为表定义的一部分存储在数据库中。DBMS检查数据是否满足完整性条件的机制就称为完整性检查。 完整性约束条件的作用对象列级约束 对数据类型的约束 对数据格式的约束 对取值范围或取值集合的约束 对空值的约束 元组约束元组中各个字段之间的联系的约束，如：开始日期小于结束日期。 关系约束是若干元组之间、关系之间的联系的约束。 实现数据完整性的方法 一种是在定义表时声明数据完整性，称为声明完整性， 另一种是在服务器端编写触发器来实现，称为过程完整性。 在执行对数据的增、删、改操作时，数据库管理系统自动检查用户定义的完整性约束条件。 实现声明完整性主码约束原则 每个表只能有一个 PRIMARY KEY 约束 用 PRIMARY KEY 约束的列取值不能有重复，而且不允许有空值 添加主码约束的语法格式 123ALTER TABLE 表名ADD [ CONSTRAINT 约束名]PRIMARY KEY （&lt;列名&gt; [, … n] ） 例：对雇员表和工作表添加主码约束 123ALTER TABLE 雇员表ADD CONSTRAINT PK_EMPPRIMARY KEY （雇员编号） 123ALTER TABLE 工作表ADD CONSTRAINT PK_JOBPRIMARY KEY （工作编号） UNIQUE 约束目的 用于限制在一个列中不能有重复的值。 用在事实上具有惟一性的属性列上，比如每个人的身份证号码、驾驶证号码等均不能有重复值。 注意： 允许有一个空值； 在一个表中可以定义多个UNIQUE约束； 可以在一个列或多个列上定义UNIQUE约束。 添加UNIQUE约束的语法格式为： 123ALTER TABLE 表名ADD [ CONSTRAINT 约束名]UNIQUE（&lt;列名&gt; [, … n] ） 例．为雇员表的“电话”列添加UNIQUE约束。 123ALTER TABLE 雇员表ADD CONSTRAINT UK_SIDUNIQUE（电话） FOREIGN KEY 外码约束目的 实现引用完整性。 外码所引用的列必须是有PRIMARY KEY约束或UNIQUE约束的列。 添加FOREIGN KEY约束的语法格式为： 1234ALTER TABLE 表名ADD [ CONSTRAINT 约束名]FOREIGN KEY（&lt;列名&gt;）REFERENCES 引用表名（&lt;列名&gt;） 例．为雇员表的工作编号添加外码引用约束。 123ALTER TABLE 雇员ADD CONSTRAINT FK_job_idFOREIGN KEY （工作编号）REFERENCES 工作表 （工作编号） DEFAULT 约束目的 用于提供列的默认值。 只有在向表中插入数据时才检查DEFAULT约束。 添加DEFAULT约束的语法格式为： 123ALTER TABLE 表名ADD [ CONSTRAINT 约束名 ]DEFAULT 默认值 FOR 列名 例．定义雇员表的工资的默认值为1000。 123ALTER TABLE 雇员ADD CONSTRAINT DF_SALARYDEFAULT 1000 FOR 工资 CHECK 约束目的 用于限制列的取值在指定的范围内，使数据库中存放的值都是有意义的。 系统在执行INSERT语句和UPDATE语句时自动检查CHECK约束。 CHECK约束可约束同一个表中多个列之间的取值关系。 添加CHECK约束的语法格式为： 123ALTER TABLE 表名ADD [ CONSTRAINT 约束名 ]CHECK （逻辑表达式） 例1．限制雇员的工资必须大于等于200。 123ALTER TABLE 雇员ADD CONSTRAINT CHK_SalaryCHECK ( 工资 &gt;= 200 ) 例2．限制工资表的最低工资小于等于最高工资。 123ALTER TABLE 工作ADD CONSTRAINT CHK_Job_SalaryCHECK( 最低工资 &lt;= 最高工资 ) 实现过程完整性简介 过程完整性是指在服务器端通过编写实现约束的一段代码来实现数据完整性约束，这段代码就称为触发器。触发器是用编程的方法实现复杂的商业规则，它可以实现一般的数据完整性约束实现不了的复杂的完整性约束。 事务基本概念事务（Transaction）是作为完整的工作单元执行的一系列操作。如果一个事务中的所有操作都成功，则事务成功，其对数据库的更改都会成为永久性的更改。如果事务中的任何一个操作失败，则整个事务失败，其中所完成的操作均被取消，所有对数据的更改均无效。 事务的三种类型 自动提交事务 每一条对数据的增、删、改语句都自动地构成了一个事务。 显式事务 是用户定义的事务，有显式的开始 （BEGIN TRANSACTION ） 和结束标记（COMMIT（正常结束) 和 ROLLBACK（异常结束））。 隐式事务 事务的开始是隐式的，以前一个事务结束后的第一个SQL语句作为下一个事务的开始，但每个事务必须有显式的结束标记。SQL Server支持的是显式事务。 触发器概念是一种特殊的存储过程，不需要由用户调用执行，而是当用户对表中的数据进行UPDATE、INSERT或DELETE操作时自动触发执行的。 触发器通常用于保证业务规则和数据完整性，其主要优点是用户可以用编程的方法来实现复杂的处理逻辑和商业规则，增强了数据完整性约束的功能。 触发器的优点 完成比CHECK约束更复杂的数据约束。 为保证数据库性能而维护的非规范化数据。 可实现复杂的商业规则。 触发器也可以评估数据修改前后的表状态，并根据其差异采取对策。 创建触发器语法格式 1234567CREATE TRIGGER 触发器名称ON 表名{ FOR | AFTER | INSTEAD OF }{ [ INSERT ] [ , ] [ DELETE ] [ , ] [UPDATE ] }AS SQL 语句 [ ... n ] 两个逻辑工作表 DELETED表 存储 DELETE和UPDATE 语句所影响的行的副本。 INSERTED表存储 INSERT和UPDATE 语句所影响的行的副本。 示例创建限制最低工资必须大于等于400的触发器。 123456789CREATE TRIGGER tri_job_salary1ON 工作表 FOR INSERT, UPDATEASIF EXISTS( SELECT * FROM INSERTEDWHERE 最低工资 &lt; 400 )BEGINPRINT '最低工资必须大于等于400'ROLLBACKEND 创建实现限制最低工资必须小于最高工资的触发器。 123456789CREATE TRIGGER tri_job_salary2ON 工作表 FOR INSERT, UPDATEASIF EXISTS(SELECT * FROM INSERTEDWHERE 最低工资 &gt;= 最高工资 )BEGINPRINT '最低工资必须小于最高工资'ROLLBACKEND 创建实现限制雇员的工资必须在工作表的相应工作的最低工资和最高工资之间。 123456789CREATE TRIGGER tri_emp_salaryON 雇员表FOR INSERT, UPDATEASIF EXISTS (SELECT * FROM INSERTED aJOIN 工作表 b ON a.工作编号 = b.工作编号WHERE 工资 NOT BETWEEN 最低工资AND 最高工资 )ROLLBACK 限制更新数据的触发器限制将SC表中不及格学生的成绩改为及格。 123456789CREATE TRIGGER tri_gradeON SC FOR UPDATEASIF UPDATE(Grade)IF EXISTS(SELECT * FROM INSERTED JOINDELETED ON INSERTED.Sno = DELETED.SnoWHERE INSERTED.Grade &gt;= 60AND DELETED.Grade &lt; 60)ROLLBACK 限制删除的触发器限制删除SC表中成绩不及格学生的修课记录。 123456CREATE TRIGGER tri_del_gradeON SC FOR DELETEASIF EXISTS(SELECT * FROM DELETEDWHERE Grade &lt; 60)ROLLBACK 修改触发器定义语法格式为： 1234567ALTER TRIGGER 触发器名称ON 表名{ FOR | AFTER | INSTEAD OF }{ [ INSERT ] [ , ] [ DELETE ] [ , ] [UPDATE ] }ASSQL 语句 [ ... n ] 删除触发器语法格式为： 1DROP TRIGGER 触发器名 [ , ... n ] 例：删除tri_grade触发器。 1DROP TRIGGER tri_grade","link":"/posts/SQLfull.html"},{"title":"SQL 锁与并发控制","text":"SQL锁与并发控制 并发问题如果对数据库进行操作的事务是一个接一个地进行，不会带来什么问题，但这样效率很低，所以常常需要同时执行多个事务，如果没有什么控制的话，这种同时执行多个事务的情况就会带来许多问题。 错误的并发调度可能产生3种错误，又称为3类数据不一致。 3类数据不一致 丢失更新（记忆诀窍：读与写之间被插足了）事务 T1 读取数据 A，然后对 A 进行运算修改，最后写回数据库。如果在 T1 读取和写回数据库之间，有其他事务修改了 A 值，就造成了丢失更新，因为 T1 是在旧的数据上进行的运算。 脏读（记忆诀窍：读被晃点了）事务 T1 修改了数据 A，然后事务 T2 读取了数据 A，然后事务 T1 回滚了事务。由于事务 T1 回滚了事务，所以数据 A 其实最终并没有被事务 T1 修改，也就是说事务 T2 读取了被丢掉的数据。 不可重复读（记忆诀窍：读与读之间被插足了）事务 T1 读取数据 A，然后做某些事，然后又读取数据 A。如果在两次读取之间，有其他事务对数据 A 进行了修改，那么就造成了同一事务中，两次读取数据 A 的值不同。 X锁和S锁X锁（exclusive locks，排他锁) 如果事务 T 对数据 A 加了 X 锁，则：事务 T 可对数据 A 进行读取和修改；其他事务不能对数据 A 加任何锁，也不能读取和修改数据 A。 S锁（share locks，共享锁) 如果事务 T 对数据 A 加了 S 锁，则：事务 T 可对数据 A 进行读取，但不能修改；其他事务也能对数据 A 加 S 锁，但不能加 X 锁。 封锁协议封锁协议 一级封锁协议在事务 T 修改数据 A 之前，对数据 A 加上 X 锁，直到事务结束才释放，解决了丢失更新的问题。 二级封锁协议在一级封锁协议的基础上，在事务 T 读取数据 A 之前，对数据 A 加上 S 锁，直到读取结束才释放，解决了脏读的问题。 三级封锁协议在一级封锁协议的基础上，在事务 T 读取数据 A 之前，对数据 A 加上 S 锁，直到事务结束才释放，解决了不可重复读的问题。 两段封锁协议对任何数据进行读写之前必须对该数据加锁，在释放一个封锁之后，事务不再申请和获得任何其他封锁，这样缩短了封锁时间，提高了并发性，同时解决了数据不一致的问题。 事务可分为两个阶段 生长阶段：也称为扩展阶段（申请锁）在这个阶段事务获得所有需要的封锁，并且不释放任何锁。 收缩阶段:这阶段事务释放全部锁，并且也不能再获得任何锁。 所有事物均遵从两段协议，则对这些事务的并发调度一定是可串行化的。反过来，在一个可串行调度中，不一定所有事物都遵从两段协议。所有事物都遵从两段协议，是可串行化调度的成分而不是必要条件。 死锁产生死锁的原因 产生死锁的原因很多，举个例子：事务 T1 对数据 A 上了 X 锁，现在 T1 要读取数据 B；而另一方面，事务 T2 对数据 B 上了 X 锁，现在 T2 要读取数据 A。T1、T2 都需要对方已经锁定了的数据，相互等待对方释放，这就造成了死锁。死锁的解决与避免 数据库管理系统（比如 SQL Server）识别到死锁后，会选择互锁的事务中的一个来作为牺牲品，回滚并结束该事务，并抛出一条消息。 现在的数据库管理系统都很优秀，死锁很少发生，但很少不代表不会发生，如果我们在事务中注意一下，又可以进一步减少死锁的发生。下面是 SQL Server 中避免死锁发生的建议： 避免死锁发生的建议 按同一顺序访问对象。比如上述示例中 T1 和 T2 都应先访问数据 A，后访问数据 B，而不是一个先访问数据 A，一个先访问数据 B。 避免事务中的用户交互。比如事务中不要等待用户输入，因为这种交互可能造成事务执行时间变长，增大了与其他事务竞争资源的可能性。 保持事务简短并在一个批处理中。 使用低隔离级别。 使用绑定连接。使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。 参考 锁与并发控制","link":"/posts/SQLlock.html"},{"title":"SQL 规范","text":"SQL规范，注意事项。 MySQL 常用的存储引擎数据引擎表|存储引擎|事务|锁粒度|主要应用|忌用||:—|:—|:—|:—|:—||MYISAM|不支持|支持并发插入的表级锁|SELECT,INSERT|读写操作频繁||MRG_MYISAM|不支持|支持并发插入的表级锁|分段归档,数据仓库|数全局查找过多的场景||Innodb|支持|支持MVCC的行级锁|事务处理|无||Archive|不支持|行级锁|日志记录只支持insert,select|需要随机读取,更新,删除||Ndb cluster|支持|行级锁|高可用性|大部份应用| 表及字段的命名规则规则 可读性原则 使用大写和小写来格式化的库对象名字以获得良好的可读性。 例如:使用CustAddress而不是Custaddress来提高可读性。(这里要注意有些DBMS系统对表名的大小写是敏感的) 表意性原则 对象的名字应该能够描述它所标识的对象。 例如,对于表,表的名称应该能够体现表中存储的数据内容;对于存储过程,存储过程名称应该能够体现存储过程的功能。 长名原则 尽可能少使用或者不使用缩写, 适用于数据库(DATABASE)名之外的任一对象。字段类型的选择原则原因列的数据类型一方面影响数据存储空间的开销,另一方面也会影响数据查询性能。当一个列可以选择多种数据类型时,应该优先考虑数字类型,其次是日期或二进制类型,最后是字符类型。对于相同级别的数据类型,应该优先选择占用空间小的数据类型。 列类型 存储空间 TINYINT 1字节 SMALLINT 2个字节 MEDIUMINT 3个字节 INT 4个字节 BIGINT 8个字节 DATE 13个字节 DATETIME 8个字节 TIMESTAMP 4个字节 CHAR(M) M字节,1 &lt;= M &lt;= 255 VARCHAR(M) L+1字节,在此L &lt;= M1 &lt;= M &lt;= 255 以上选择原则主要是从下面两个角度考虑 在对数据进行比较(查询条件、JOIN条件及排序)操作时:同样的数据,字符处理往往比数字处理慢。 在数据库中,数据处理以页为单位,列的长度越小,利于性能提升。 char varchar 如何选择原则 如果列中要存储的数据长度差不多是一致的,则应该考虑用char;否则应该考虑用varchar。 如果列中的最大数据长度小于50Byte,则一般也考虑用char。(当然,如果这个列很少用,则基于节省空间和减少I/O的考虑,还是可以选择用varchar) 一般不宜定义大于50 Byte的char类型列。 decimal与float 如何选择原则: decimal用于存储精确数据,而float只能用于存储非精确数据。故精确数据只能选择用decimal类型。 由于float的存储空间开销一般比decimal小(精确到7位小数只需要4个字节,而精确到15位小数只需要8字节)故非精确数据优先选择float类型。 时间类型如何存储使用int来存储时间字段的优缺点 优点:字段长度比datetime小。 缺点:使用不方便,要进行函数转换。 限制 只能存储到2038-1-19 11:14:07即2^32 为2147483648 需要存储的时间粒度 年月日 小时 分 秒 周 如何选择主键区分业务主键和数据库主键 业务主键用于标识业务数据,进行表与表之间的关联;数据库主键为了优化数据存储(Innodb会生成6个字节的隐含主键) 根据数据库的类型考虑主键是否要顺序增长 有些数据库是按主键的顺序逻辑存储的 主键的字段类型所占空间要尽可能的小 对于使用聚集索引方式存储的表,每个索引后都会附加主键信息。 避免使用外键约束 降低数据导入的效率 增加维护成本 虽然不建议使用外键约束,但是相关联的列上一定要建立索引 避免使用触发器:1. 降低数据导入的效率。2. 可能会出现意想不到的数据异常。3. 使业务逻辑变得复杂。 关于预留字段原因 无法准确的知道预留字段的类型。 无法准确的知道预留字段中所存储的内容。 后期维护预留字段所要的成本,同增加一个字段所需要的成本是相同的。 严禁使用预留字段。","link":"/posts/SQLstyle.html"},{"title":"SQL 触发器","text":"SQL触发器 概念某一个表的一定的操作，触发某种条件，从而执行的一段程序。触发器是一个特殊的存储过程。 常见的触发器有三种：分别应用于Insert , Update , Delete 事件。 语法 1234567891011create trigger 触发器名onzg -- 在zg表建立触发器for insert,update -- 为什么事件触发as -- 事件触发后所要做的事情select * from insertedselect * from deletedif exists (select * from ck where 仓库号 in (select 仓库号 from inserted))commitelserollback 12345CREATE TRIGGER trigger_name [BEFORE|AFTER] event_nameON table_nameBEGIN -- Trigger logic goes here....END Deleted 与 Inserted Deleted表存放由于执行Delete或Update语句而要从表中删除的所有行。 Inserted表存放由于执行Insert或Update语句而要向表中插入的所有行。 UPDATE 操作上在表的一个或多个指定列上创建触发器(Trigger)语法 12345CREATE TRIGGER trigger_name [BEFORE|AFTER] UPDATE OF column_nameON table_nameBEGIN -- Trigger logic goes here....END 触发器操作删除 1drop trigger trigger_name 修改 123456789alter trigger tri_ck_zgon zg for insert,updateasselect * from insertedselect * from deletedif exists (select * from ck where 仓库号 in (select 仓库号 from inserted))commitelserollback 列出触发器 所有 12SELECT name FROM sqlite_masterWHERE type = 'trigger' 指定表 12SELECT name FROM sqlite_masterWHERE type = 'trigger' AND tbl_name = '表名' 习题成绩小于60的不可更改 123456789create trigger tri_gradeon xkgx for updateasselect * from insertedselect * from deletedif update(成绩)if exists(select * from deleted where 成绩&lt;60)rollback 验证 1update xkgx set 成绩=80 where课程号='303' and 学号='S101101' 成绩小于60的不可更改 12345678910create trigger tri_gradeon xkgx for updateasselect * from insertedselect * from deletedif update(成绩)if exists(select * from inserted join deleted on inserted.学号=deleted.学号where inserted.成绩&gt;=60 and deleted.成绩&lt;60)rollback","link":"/posts/SQLtrigger.html"},{"title":"SQL 事务","text":"SQL事务 概念 事务（Transaction）是指一个或多个更改数据库的扩展。例如，如果您正在创建一个记录或者更新一个记录或者从表中删除一个记录，那么您正在该表上执行事务。重要的是要控制事务以确保数据的完整性和处理数据库错误。 事务（Transaction）是一个对数据库执行工作单元。事务（Transaction）是以逻辑顺序完成的工作单位或序列，可以是由用户手动操作完成，也可以是由某种数据库程序自动完成。 事务的特点四个特点 原子性（Atomicity)确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态。 一致性（Consistency)确保数据库在成功提交的事务上正确地改变状态。 隔离性（Isolation)使事务操作相互独立和透明。 持久性（Durability)确保已提交事务的结果或效果在系统发生故障的情况下仍然存在。 事务控制含义 BEGIN TRANSACTION 开始事务处理。 COMMIT 保存更改，或者可以使用 END TRANSACTION 命令。 ROLLBACK 回滚所做的更改。 事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的 BEGIN TRANSACTION 命令语法 1234567BEGIN TRANSACTIONREAD(A)A:=A-50WRITE(A)READ(B)B:=B+50COMMIT READ(X):把数据项X从数据库读出到事务的私有缓冲中 WRITE(X):把数据项X从事务的私有缓冲中写到数据库。 COMMIT 命令作用 COMMIT 命令用于保存事务对数据库所做的更改。会将自上次 COMMIT 命令或者 ROLLBACK 命令执行以来所有的事务都保存到数据库中。 语法 123DELETE FROM S WHERE SIZE=20COMMIT ROLLBACK 命令作用ROLLBACK 命令用于撤销尚未保存到数据库中的事务。只能撤销自上次 COMMIT 命令或者 ROLLBACK 命令执行以来的事务。 语法 123DELETE FROM SWHERE SIZE=20ROLLBACK ROLLBACK 命令可以用于撤销一系列的事务 回滚至某一保存点的语法如下所示：1ROLLBACK TO SAVEPOINT_NAME SAVEPOINT 命令作用SAVEPOINT 是事务中的一个状态点，使得我们可以将事务回滚至特定的点，而不是将整个事务都撤销。 语法 1SAVEPOINT SAVEPOINT_NAME 该命令只能在事务语句之间创建保存点（SAVEPOINT）。 RELEASE SAVEPOINT 命令作用RELEASE SAVEPOINT 命令用于删除先前创建的保存点。 语法 1RELEASE SAVEPOINT SAVEPOINT_NAME SET TRANSACTION 命令作用SET TRANSACTION 命令可以用来初始化数据库事务，指定随后的事务的各种特征。将某个事务指定为只读或者读写。 1SET TRANSACTION [ READ WRITE | READ ONLY ] 存储过程使用事务实例一 1234567891011121314151617Create Procedure MyProcedureASBeginSet NOCOUNT ON;Set XACT_ABORT ON;begin tran ok --开始一个事务OKdelete from rxqz where qz= 'rx015 ' --删除数据save tran bcd --保存一个事务点命名为bcdupdate sz set name='李丽s' where name= '李丽'--修改数据if @@error&lt;&gt;0 --判断修改数据有没有出错begin --如果出错rollback tran bcd -- 回滚事务到BCD 的还原点commit tran ok --提交事务endelse --没有出错commit tran ok --提交事务End 实例二 12345678create proc 1@si chark20),@pi char(20),@Ji chark20),@shu intinsert into SPJ values(@si,@pi,@Ji,@shu)bdgin tran t1if exists (select * from p where Pno=@Pi)commit tran t1elserollback tran t1 参考 连接","link":"/posts/SQLtransaction.html"},{"title":"SQL 视图","text":"SQL视图 什么是视图解析 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。 视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。 注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。 SQL CREATE VIEW语法 1234CREATE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition 注释：视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。 SQL CREATE VIEW 实例要求 可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。通过向视图添加函数、join 等等，我们可以向用户精确地提交我们希望提交的数据。 样本数据库 Northwind 拥有一些被默认安装的视图。视图 “Current Product List” 会从 Products 表列出所有正在使用的产品。这 创建： 1234CREATE VIEW [Current Product List] ASSELECT ProductID,ProductNameFROM ProductsWHERE Discontinued=No 查询上面这个视图： 1SELECT * FROM [Current Product List] Northwind 样本数据库的另一个视图会选取 Products 表中所有单位价格高于平均单位价格的产品 1234CREATE VIEW [Products Above Average Price] ASSELECT ProductName,UnitPriceFROM ProductsWHERE UnitPrice&gt;(SELECT AVG(UnitPrice) FROM Products) 查询上面这个视图： 1SELECT * FROM [Products Above Average Price] 另一个来自 Northwind 数据库的视图实例会计算在 1997 年每个种类的销售总数。请注意，这个视图会从另一个名为 “Product Sales for 1997” 的视图那里选取数据： 1234CREATE VIEW [Category Sales For 1997] ASSELECT DISTINCT CategoryName,Sum(ProductSales) AS CategorySalesFROM [Product Sales for 1997]GROUP BY CategoryName 查询上面这个视图： 1SELECT * FROM [Category Sales For 1997] 也可以向查询添加条件。现在，我们仅仅需要查看 “Beverages” 类的全部销量： 12SELECT * FROM [Category Sales For 1997]WHERE CategoryName='Beverages' SQL 更新视图语法 12345SQL CREATE OR REPLACE VIEW SyntaxCREATE OR REPLACE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition 现在，我们希望向 “Current Product List” 视图添加 “Category” 列。我们将通过下列 SQL 更新视图：1234CREATE VIEW [Current Product List] ASSELECT ProductID,ProductName,CategoryFROM ProductsWHERE Discontinued=No SQL 撤销视图DROP VIEW 12DROP VIEW SyntaxDROP VIEW view_name Via 来源","link":"/posts/SQLview.html"},{"title":"SQL 存储过程练习","text":"SQL储存过程练习题 仓库号 城市 面积 WH1 北京 3700 WH2 上海 5000 WH3 广州 2000 WH4 武汉 4000 WH5 北京 3460 WH6 珠海 3400 WH7 珠海 5200 WH8 广州 6300 仓库号 职工号 工资 WH2 E1 1220 WH1 E3 2210 WH2 E4 4250 WH3 E6 1230 WH1 E7 2250 WH1 E8 1700 WH2 E10 3000 WH3 E11 4500 WH6 E12 2300 WH2 E13 3400 WH3 E14 4500 WH6 E15 4000 WH2 E18 3600 职工号 供应商号 订购数量 订购日期 E3 S7 67 2010-12-4 E1 S4 73 2010-4-1 E7 S4 76 2010-4-2 E6 S6 77 20010-1-21 E3 S4 79 20010-10-15 E1 S6 80 2009-2-1 E3 S6 90 2010-3-12 E3 S3 91 2009-3-2 E10 S3 93 2010-10-26 |:—|:—|:—||S3|振华电子厂| 西安||S4|华通电子公司| 北京||S6|607|厂郑州||S7|爱华电子厂| 北京| 基于以上的数据库，创建一个名为myproc的存储过程。该存储过程的功能是从职工表中查询哪些仓库的职工人数在3人以上，列出这些仓库的基本信息。123456create proc myprocasselect * from ck where 仓库号 in(select 仓库号 from zggroup by 仓库号having count(职工号)&gt;3) 1exec myproc 定义具有参数的存储过程。在以上数据库中，创建一个名为Myproc2的存储过程，该存储过程的功能是向仓库表中插入一条记录，新记录的值由参数提供。1234create proc Myproc2@ckh char(20),@city char(20),@mji intasinsert into ck values(@ckh,@city,@mji) 1exec Myproc2 'WH33','新会','3000' 定义带返回值的存储过程。在以上数据库中，创建一个名为Myproc3的存储过程，该存储过程的功能是从表中根据供应商号查询对应的供应商名和地址。1234alter proc Myproc3@gysh char(20)asselect 供应商名,地址 from gys where 供应商号=@gysh 1exec Myproc3 'S3' 12345Create table 雇员表(雇员编号 char(10),雇员姓名 char(20),年龄 int) 123ALTER TABLE 雇员表ADD CONSTRAINT PK_EMPPRIMARY KEY （雇员编号） 123ALTER TABLE 工作表ADD CONSTRAINT PK_JOBPRIMARY KEY （工作编号） 12345Create table 雇员表(雇员编号 char(10) not null,雇员姓名 char(20),年龄 int) 123ALTER TABLE 雇员表ADD CONSTRAINT PK_EMPPRIMARY KEY (雇员编号) 123ALTER TABLE 雇员表ADD CONSTRAINT check_agecheck (年龄&gt;=18 and 年龄&lt;=60) 1234567create proc p6@bianhao char(10)asdelete from 雇员表where 雇员编号=@bianhaoexec p6 'q1'select * from 雇员表 1select * from ck 123456create proc p7@chengshi char(20),@geshu int outputasselect @geshu=COUNT(仓库号)from ckwhere 城市=@chengshi 123declare @jieshou intexec p7 '珠海',@jieshou outputprint @jieshou 12345create proc p8@ckhao char(10),@city char(10),@mianji floatasinsert into ckvalues (@ckhao,@city,@mianji) 1exec p8 'WH10','增城',1000 1select * from ck 存储过程使用事务实例 1234567891011121314151617Create Procedure MyProcedureASBeginSet NOCOUNT ON;Set XACT_ABORT ON;begin tran ok --开始一个事务OKdelete from rxqz where qz= 'rx015 ' --删除数据save tran bcd --保存一个事务点命名为bcdupdate sz set name='李丽s' where name= '李丽'--修改数据if @@error&lt;&gt;0 --判断修改数据有没有出错begin --如果出错rollback tran bcd -- 回滚事务到BCD 的还原点commit tran ok --提交事务endelse --没有出错commit tran ok --提交事务End","link":"/posts/SQlprocEx.html"},{"title":"SQL 各章练习题","text":"SQL数据库原理练习题 第一章 绪论一,选择题 DBS是采用了数据库技术的计算机系统,DBS是一个集合体,包含数据库,计算机硬件,软件和( C ). A.系统分析员 B. 程序员 C. 数据库管理员 D. 操作员2. 数据库(DB),数据库系统(DBS)和数据库管理系统(DBMS)之间的关系是( A). A. DBS包括DB和DBMS B. DBMS包括DB和DBSC. DB包括DBS和DBMS D. DBS就是DB,也就是DBMS3. 下面列出的数据库管理技术发展的三个阶段中,没有专门的软件对数据进行管理的是( D).I.人工管理阶段II.文件系统阶段III.数据库阶段 A. I 和 II B. 只有 IIC. II 和 III D. 只有 I4. 下列四项中,不属于数据库系统特点的是( C) . A. 数据共享 B. 数据完整性 C. 数据冗余度高 D. 数据独立性高5. 数据库系统的数据独立性体现在( B) . A.不会因为数据的变化而影响到应用程序B.不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序C.不会因为存储策略的变化而影响存储结构D.不会因为某些存储结构的变化而影响其他的存储结构6. 描述数据库全体数据的全局逻辑结构和特性的是( A) . A. 模式 B. 内模式 C. 外模式 D. 用户模式7. 要保证数据库的数据独立性,需要修改的是(C ) . A. 模式与外模式 B. 模式与内模式C. 三层之间的两种映射 D. 三层模式8. 要保证数据库的逻辑数据独立性,需要修改的是(A ) . A. 模式与外模式的映射 B. 模式与内模式之间的映射C. 模式 D. 三层模式9. 用户或应用程序看到的那部分局部逻辑结构和特征的描述是(C),它是模式的逻辑子集. A.模式 B. 物理模式 C. 子模式 D. 内模式10. 下述(D )不是DBA数据库管理员的职责 . A.完整性约束说明 B. 定义数据库模式C.数据库安全 D. 数据库管理系统设计 选择题答案: (1) C (2) A (3) D (4) C (5) B(6) A (7) C (8) A (9) C (10) D 二,简答题 试述数据,数据库,数据库系统,数据库管理系统的概念. 数据:描述事物的符号记录称为数据.数据的种类有文字,图形,图象,声音,正文等等.数据与其语义是不可分的. 解析: 在现代计算机系统中数据的概念是广义的.早期的计算机系统主要用于科学计算,处理的数据是整数,实数,浮点数等传统数学中的数据等.现在计算机能存储和处理的对象十分广泛,表示这些对象的 数据也越来越复杂.数据与其语义是不可分的.500这个数字可以表示一件物品的价格是500元,也可以表示一个学术会议参加的人数有500人.还可以表示一袋奶粉重500克. 数据库:数据库是长期储存在计算机内,有组织的,可共享的数据集合.数据库中的数据按一定的数据模型组织,描述和储存,具有较小的冗余度,较高的数据独立性和易扩展性,并可为各种用户共享. 解析:简单地讲,数据数据库数据具有永久储存,有组织和可共享三个特点.数据模型是数据库的核心概念.每个数据库中数据的都是按照某一种数据模型来组织的. 数据库系统:数据库系统(DBS)是指在计算机系统中引入数据库后的系统构成.数据库系统由数据库,数据库管理系统(及其开发工具),应用系统,数据库管理员构成. 解析: 数据库系统和数据库是两个概念.数据库系统是一个人-机系统,数据库是数据库系统的一个组成部分.但是在日常工作中人们常常把把数据库系统简称为数据库.希望读者能够从人们讲话或文章的上下文中区分”数据库系统”和”数据库”. 不要引起混淆. 数据库管理系统:数据库管理系统(DBMS)是位于用户与操作系统之间的一层数据管理软件.用于科学地组织和存储数据,高效地获取和维护数据.DBMS主要功能包括数据定义功能,数据操纵功能,数据库的运行管理功能,数据库的建立和维护功能. 解析: DBMS是一个大型复杂的软件系统.是计算机中的基础软件.目前,专门研制DBMS的厂商及其研制的DBMS产品很多.著名的有美国IBM公司的DB2关系数据库管理系统,IMS层次数据库管理系统;美国ORACLE公司的ORACLE关系数据库管理系统;SYBASE公司的SYBASE关系数据库管理系统;美国微软公司的SQL SERVER关系数据库管理系统等等. 使用数据库系统有什么好处使用数据库系统的好处是由数据库管理系统的特点或优点决定的.使用数据库系统的好处很多,例如可以大大提高应用开发的效率,方便用户的使用,减轻数据库系统管理人员维护的负担等. 为什么有这些好处,可以结合第5题来回答. 使用数据库系统可以大大提高应用开发的效率.因为在数据库系统中应用程序不必考虑数据的定义,存储和数据存取的具体路径,这些工作都由DBMS来完成.用一个通俗的比喻,使用了DBMS就如有了一个好参谋好助手,许多具体的技术工作都由这个助手来完成.开发人员就可以专注于应用逻辑的设计而不必为管理数据的许许多多复杂的细节操心. 还有,当应用逻辑改变,数据的逻辑结构需要改变时,由于数据库系统提供了数据与程序之间的独立性.数据逻辑结构的改变是DBA的责任,开发人员不必修改应用程序,或者只需要修改很少的应用程序.从而既简化了应用程序的编制,又大大减少了应用程序的维护和修改. 使用数据库系统可以减轻数据库系统管理人员维护系统的负担.因为DBMS在数据库建立,运用和维护时对数据库进行统一的管理和控制,包括数据的完整性,安全性,多用户并发控制,故障恢复等等都由DBMS执行. 总之,使用数据库系统的优点是很多的,既便于数据的集中管理,控制数据冗余,可以提高数据的利用率和一致性,又有利于应用程序的开发和维护.读者可以在自己今后的工作中结合具体应用,认真加以体会和总结. 试述文件系统与数据库系统的区别和联系.文件系统与数据库系统的区别: 文件系统面向某一应用程序,共享性差,冗余度大,独立性差,纪录内有结构,整体无结构,应用程序自己控制. 数据库系统面向现实世界,共享性高,冗余度小,具有高度的物理独立性和一定的逻辑独立性,整体结构化,用数据模型描述,由数据库管理系统提供数据安全性,完整性,并发控制和恢复能力. 读者可以参考《概论》书中表1.1 中的有关内容. 文件系统与数据库系统的联系是:文件系统与数据库系统都是计算机系统中管理数据的软件.解析: 文件系统是操作系统的重要组成部分,而DBMS是独立于操作系统的软件.但是DBMS是在操作系统的基础上实现的.数据库中数据的组织和存储是通过操作系统中文件系统来实现的. 读者可以参考书中第十一章《数据库管理系统》.或者说,读者进一步学习数据库管理系统实现的有关课程(第十一章只是DBMS实现技术的概述)后可以对本题有深入的理解和全面的解答.因为DBMS的实现与操作系统中的文件系统是紧密相关的.例如,数据库实现的基础是文件,对数据库的任何操作最终要转化为对文件的操作.所以在DBMS实现中数据库物理组织的基本问题是如何利用或如何选择操作系统提供的基本的文件组织方法.这里我们就不具体展开了. 举出适合用文件系统而不是数据库系统的例子;再举出适合用数据库系统的应用例子.适用于文件系统而不是数据库系统的应用例子 数据的备份,软件或应用程序使用过程中的临时数据存储一般使用文件比较合适.早期功能比较简单,比较固定的应用系统也适合用文件系统.适用于数据库系统而非文件系统的应用例子 目前,几乎所有企业或部门的信息系统都以数据库系统为基础,都使用数据库.如一个工厂的管理信息系统(其中会包括许多子系统,如库存管理系统,物资采购系统,作业调度系统,设备管理系统,人事管理系统等等),还比如学校的学生管理系统,人事管理系统,图书馆的图书管理系统等等都适合用数据库系统. 希望同学们能举出自己了解的应用例子. 试述数据库系统的特点. 数据库系统的主要特点有: 一,数据结构化数据库系统实现整体数据的结构化,这是数据库的主要特征之一,也是数据库系统与文件系统的本质区别. 解析: 注意这里”整体”两个字.在数据库系统中,数据不再针对某一个应用,而是面向全组织,具有整体的结构化.不仅数据是结构化的,而且数据的存取单位即一次可以存取数据的大小也很灵活.可以小到某一个数据项(如一个学生的姓名),大到一组记录(成千上万个学生记录).而在文件系统中,数据的存取单位只有一个:记录.如一个学生的完整记录. 二. 数据的共享性高,冗余度低,易扩充 数据库的数据不再面向某个应用而是面向整个系统,因此可以被多个用户,多个应用,用多种不同的语言共享使用.由于数据面向整个系统,是有结构的数据,不仅可以被多个应用共享使用,而且容易增加新的应用,这就使得数据库系统弹性大,易于扩充. 解析: 数据共享可以大大减少数据冗余,节约存储空间,同时还能够避免数据之间的不相容性与不一致性. 所谓”数据面向某个应用”是指数据结构是针对某个应用设计的,只被这个应用程序或应用系统使用.可以说数据是某个应用的”私有资源”. 所谓”弹性大”是指系统容易扩充也容易收缩,即应用增加或减少时不必修改整个数据库的结构,或者只要做很少的修改. 我们可以取整体数据的各种子集用于不同的应用系统,当应用需求改变或增加时,只要重新选取不同的子集或加上一部分数据便可以满足新的需求.三,数据独立性高 数据独立性包括数据的物理独立性和数据的逻辑独立性. 数据库管理系统的模式结构和二级映象功能保证了数据库中的数据具有很高的物理独立性和逻辑独立性. 解析: 所谓”独立性”即相互不依赖.数据独立性是指数据和程序相互不依赖.即数据的逻辑结构或物理结构改变了,程序不会跟着改变.数据与程序的独立,把数据的定义从程序中分离出去,加上数据的存取又由DBMS负责,简化了应用程序的编制,大大减少了应用程序的维护和修改. 四,数据由DBMS统一管理和控制 数据库的共享是并发的共享,即多个用户可以同时存取数据库中的数据甚至可以同时存取数据库中同一个数据.为此,DBMS必须提供统一的数据控制功能,包括数据的安全性保护,数据的完整性检查,并发控制和数据库恢复. 解析: DBMS数据控制功能包括四个方面: 数据的安全性保护:保护数据以防止不合法的使用造成的数据的泄密和破坏; 数据的完整性检查:将数据控制在有效的范围内或保证数据之间满足一定的关系; 并发控制:对多用户的并发操作加以控制和协调,保证并发操作的正确性; 数据库恢复:当计算机系统发生硬件故障,软件故障,或者由于操作员的失误以及故意的破坏影响数据库中数据的正确性,甚至造成数据库部分或全部数据的丢失时,能将数据库从错误状态恢复到某一已知的正确状态(亦称为完整状态或一致状态). 下面我们可以得到”什么是数据库”的一个定义: 数据库是长期存储在计算机内有组织的大量的共享的数据集合.它可以供各种用户共享,具有最小冗余度和较高的数据独立性.DBMS在数据库建立,运用和维护时对数据库进行统一控制,以保证数据的完整性,安全性,并在多用户同时使用数据库时进行并发控制,在发生故障后对系统进行恢复. 数据库系统的出现使信息系统从以加工数据的程序为中心转向围绕共享的数据库为中心的新阶段. 数据库管理系统的主要功能有哪些 ① 数据库定义功能; ② 数据存取功能; ③ 数据库运行管理; ④ 数据库的建立和维护功能. 试述数据模型的概念,数据模型的作用和数据模型的三个要素. 数据模型是数据库中用来对现实世界进行抽象的工具,是数据库中用于提供信息表示和操作手段的形式构架. 一般地讲,数据模型是严格定义的概念的集合.这些概念精确地描述系统的静态特性,动态特性和完整性约束条件.因此数据模型通常由数据结构,数据操作和完整性约束三部分组成. ① 数据结构:是所研究的对象类型的集合,是对系统的静态特性的描述.② 数据操作:是指对数据库中各种对象(型)的实例(值)允许进行的操作的集合,包括操作及有关的操作规则,是对系统动态特性的描述.③ 数据的约束条件:是完整性规则的集合,完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则,用以限定符合数据模型的数据库状态以及状态的变化,以保证数据的正确,有效,相容. 解析: 数据模型是数据库系统中最重要的概念之一.同学们必须通过《概论》的学习真正掌握 数据模型的概念和作用. 数据模型是数据库系统的基础.任何一个DBMS都以某一个数据模型为基础,或者说支持某一个数据模型. 数据库系统中模型有不同的层次.根据模型应用的不同目的,可以将模型分成两类或说两个层次:一是概念模型,是按用户的观点来对数据和信息建模,用于信息世界的建模,强调语义表达能力,概念简单清晰;另一是数据模型,是按计算机系统的观点对数据建模,用于机器世界,人们可以用它定义,操纵数据库中的数据.一般需要有严格的形式化定义和一组严格定义了语法和语义的语言,并有一些规定和限制,便于在机器上实现. 试述概念模型的作用.概念模型实际上是现实世界到机器世界的一个中间层次.概念模型用于信息世界的建模,是现实世界到信息世界的第一层抽象,是数据库设计人员进行数据库设计的有力工具,也是数据库设计人员和用户之间进行交流的语言. 定义并解释概念模型中以下术语:实体,实体型,实体集,属性,码,实体联系图(E-R图) 实体:客观存在并可以相互区分的事物叫实体. 实体型:具有相同属性的实体具有相同的特征和性质,用实体名及其属性名集合来抽象和刻画同类实体称为实体型. 实体集:同型实体的集合称为实体集. 属性:实体所具有的某一特性,一个实体可由若干个属性来刻画. 码:唯一标识实体的属性集称为码. 实体联系图:E-R图提供了表示实体型,属性和联系的方法: 实体型:用矩形表示,矩形框内写明实体名. 属性:用椭圆形表示,并用无向边将其与相应的实体连接起来. 联系:用菱形表示,菱形框内写明联系名,并用无向边分别与有关实体连接起来,同时在无向边旁标上联系的类型(1 : 1,1 : n或m : n). 试给出三个实际部门的E-R图,要求实体型之间具有一对一,一对多,多对多各种不同的联系. 第二章 关系数据库一.选择题 下面的选项不是关系数据库基本特征的是(A ). A.不同的列应有不同的数据类型B.不同的列应有不同的列名C.与行的次序无关D.与列的次序无关2. 一个关系只有一个(D) . A.候选码 B. 外码 C. 超码 D. 主码3. 关系模型中,一个码是(C ). A.可以由多个任意属性组成B.至多由一个属性组成C.可有多个或者一个其值能够唯一表示该关系模式中任何元组的属性组成D.以上都不是4. 现有如下关系:患者(患者编号,患者姓名,性别,出生日起,所在单位) 医疗(患者编号,患者姓名,医生编号,医生姓名,诊断日期,诊断结果)其中,医疗关系中的外码是(A ). A. 患者编号 B. 患者姓名C. 患者编号和患者姓名 D. 医生编号和患者编号5. 现有一个关系:借阅(书号,书名,库存数,读者号,借期,还期),假如同一本书允许一个读者多次借阅,但不能同时对一种书借多本,则该关系模式的外码是( D). A. 书号 B. 读者号C. 书号+读者号 D. 书号+读者号+借期6. 关系模型中实现实体间 N:M 联系是通过增加一个(A ) . A.关系实现 B. 属性实现 C. 关系或一个属性实现 D. 关系和一个属性实现7. 关系代数运算是以( C)为基础的运算 . A. 关系运算 B. 谓词演算 C. 集合运算 D. 代数运算8. 关系数据库管理系统应能实现的专门关系运算包括( B). A. 排序,索引,统计 B. 选择,投影,连接C. 关联,更新,排序 D. 显示,打印,制表9. 五种基本关系代数运算是( A). A.∪-×σπB.∪-σπC.∪∩×σπD.∪∩σπ10. 关系代数表达式的优化策略中,首先要做的是(B ) . A.对文件进行预处理 B.尽早执行选择运算C.执行笛卡尔积运算 D.投影运算11. 关系数据库中的投影操作是指从关系中(B ) . A.抽出特定记录 B. 抽出特定字段C.建立相应的影像 D. 建立相应的图形12. 从一个数据库文件中取出满足某个条件的所有记录形成一个新的数据库文件的操作是(C )操作 . A.投影 B. 联接 C. 选择 D. 复制13. 关系代数中的联接操作是由(B )操作组合而成 . A.选择和投影 B. 选择和笛卡尔积C.投影,选择,笛卡尔积 D. 投影和笛卡尔积14. 自然联接是构成新关系的有效方法.一般情况下,当对关系R和S是用自然联接时,要求R和S含有一个或者多个共有的(C). A.记录 B. 行 C. 属性 D. 元组15. 假设有关系R和S,在下列的关系运算中,(D )运算不要求:”R和S具有相同的元数,且它们的对应属性的数据类型也相同” . A.R∩S B. R∪S C. R-S D. R×S16. 假设有关系R和S,关系代数表达式R-(R-S)表示的是(A ). A.R∩S B. R∪S C. R-S D. R×S17. 下面列出的关系代数表达是中,那些式子能够成立( C) .ⅰ. σf1 ( σf2 (E)) = σf1∧f2 (E)ⅱ. E1∞E2 = E2∞E1ⅲ. (E1∞E2)∞E3 = E1∞ (E2∞E3)ⅳ. σf1 ( σf2 (E)) =σf2 ( σf1(E)) A.全部 B. ⅱ和ⅲ C. 没有 D. ⅰ和ⅳ18. 下面四个关系表达式是等价的,是判别它们的执行效率( A) .E1 =πA (σ B=C ∧ D=E′ (R×S) )E2 =πA (σ B=C (R× σD=E′ (S) )E3 =πA (R∞B=CσD=E′(S) )E3 =πA (σD=E′ (R∞B=C S) ) A. E3最快 B. E2最快 C. E4最快 D. E1最快19. 有关系SC(S_ID,C_ID,AGE,SCORE),查找年龄大于22岁的学生的学号和分数,正确的关系代数表达式是(D) .ⅰ. πS_ID,SCORE (σ age&gt;22 (SC) )ⅱ. σ age&gt;22 (πS_ID,SCORE (SC) )ⅲ. πS_ID,SCORE (σ age&gt;22 (πS_ID,SCORE,AGE (SC) ) ) A.ⅰ和 ⅱ B. 只有ⅱ正确 C. 只有 ⅰ正确 D. ⅰ和ⅲ正确 选择题答案:(1) A (2) D (3) C (4) A (5) D(6) A (7) C (8) B (9) A (10) B(11) B (12) C (13) B (14) C (15)D(16) A (17) C (18) A (19) D 二,简答题 试述关系模型的三个组成部分. 试述关系数据语言的特点和分类. 设有一个SPJ数据库,包括S,P,J,SPJ四个关系模式:S( SNO,SNAME,STATUS,CITY); P(PNO,PNAME,COLOR,WEIGHT); J(JNO,JNAME,CITY); SPJ(SNO,PNO,JNO,QTY); 供应商表S由供应商代码(SNO),供应商姓名(SNAME),供应商状态(STATUS),供应商所在城市(CITY)组成;零件表P由零件代码(PNO),零件名(PNAME),颜色(COLOR),重量(WEIGHT)组成;工程项目表J由工程项目代码(JNO),工程项目名(JNAME),工程项目所在城市(CITY)组成;供应情况表SPJ由供应商代码(SNO),零件代码(PNO),工程项目代码(JNO),供应数量(QTY)组成,表示某供应商供应某种零件给某工程项目的数量为QTY. 试用关系代数完成如下查询: (1) 求供应工程J1零件的供应商号码SNO; (2) 求供应工程J1零件P1的供应商号码SNO; (3) 求供应工程J1零件为红色的供应商号码SNO; (4) 求没有使用天津供应商生产的红色零件的工程号JNO; (5) 求至少用了供应商S1所供应的全部零件的工程号JNO. 定义并理解下列术语,说明它们之间的联系与区别: (1). 域,笛卡尔积,关系,元组,属性(2). 主码,候选码,外码(3). 关系模式,关系,关系数据库 试述关系模型的完整性规则.在参照完整性中,为什么外码属性的值有时也可以为空 什么情况下才可以为空 试述等值连接与自然连接的区别和联系. 关系代数的基本运算有哪些 试用关系代数的基本运算来表示其他运算. 第三章 SQL语言一,选择题 SQL语言是(B)的语言,容易学习 . A. 过程化 B. 非过程化C. 格式化 D. 导航式 SQL语言的数据操纵语句包括SELECT,INSERT,UPDATE,DELETE等.其中最重要的,也是使用最频繁的语句是(A) . A. SELECT B. INSERTC. UPDATE D. DELETE3. 在视图上不能完成的操作是( C) . A. 更新视图 B. 查询C. 在视图上定义新的表 D. 在视图上定义新的视图4. SQL语言集数据查询,数据操纵,数据定义和数据控制功能于一体,其中,CREATE,DROP,ALTER语句是实现哪种功能(C ). A. 数据查询 B. 数据操纵C. 数据定义 D. 数据控制5. SQL语言中,删除一个视图的命令是( B). A.DELETE B.DROP C.CLEAR D.REMOVE6. 在SQL语言中的视图VIEW是数据库的( A) . A. 外模式 B. 模式 C. 内模式 D. 存储模式7. 下列的SQL语句中,( D)不是数据定义语句. A. CREATE TABLE B. DROP VIEWC. CREATE VIEW D. GRANT8. 若要撤销数据库中已经存在的表S,可用(C ). A. DELETE TABLE S B. DELETE SC. DROP TABLE S D. DROP S9. 若要在基本表S中增加一列CN(课程名),可用( C). A. ADD TABLE S(CN CHAR(8))B. ADD TABLE S ALTER(CN CHAR(8))C. ALTER TABLE S ADD(CN CHAR(8))D. ALTER TABLE S (ADD CN CHAR(8))10. 学生关系模式 S( S#,Sname,Sex,Age),S的属性分别表示学生的学号,姓名,性别,年龄.要在表S中删除一个属性”年龄”,可选用的SQL语句是(B ). A. DELETE Age from SB. ALTER TABLE S DROP AgeC. UPDATE S AgeD. ALTER TABLE S ‘Age’11. 有关系S(S#,SNAME,SAGE),C(C#,CNAME),SC(S#,C#,GRADE).其中S#是学生号,SNAME是学生姓名,SAGE是学生年龄, C#是课程号,CNAME是课程名称.要查询选修”ACCESS”课的年龄不小于20的全体学生姓名的SQL语句是SELECT SNAME FROM S,C,SC WHERE子句.这里的WHERE子句的内容是(A). A. S.S# = SC.S# and C.C# = SC.C# and SAGE&gt;=20 and CNAME=’ACCESS’B. S.S# = SC.S# and C.C# = SC.C# and SAGE in&gt;=20 and CNAME in ‘ACCESS’C. SAGE in&gt;=20 and CNAME in ‘ACCESS’D. SAGE&gt;=20 and CNAME=’ ACCESS’12. 设关系数据库中一个表S的结构为S(SN,CN,grade),其中SN为学生名,CN为课程名,二者均为字符型;grade为成绩,数值型,取值范围0-100.若要把”张二的化学成绩80分”插入S中,则可用( D). A. ADD INTO S VALUES(‘张二’,’化学’,’80’)B. INSERT INTO S VALUES(‘张二’,’化学’,’80’)C. ADD INTO S VALUES(‘张二’,’化学’,80)D. INSERT INTO S VALUES(‘张二’,’化学’,80)13. 设关系数据库中一个表S的结构为:S(SN,CN,grade),其中SN为学生名,CN为课程名,二者均为字符型;grade为成绩,数值型,取值范围0-100.若要更正王二的化学成绩为85分,则可用( A) . A. UPDATE S SET grade=85 WHERE SN=’王二’ AND CN=’化学’B. UPDATE S SET grade=’85’ WHERE SN=’王二’ AND CN=’化学’C. UPDATE grade=85 WHERE SN=’王二’ AND CN=’化学’D. UPDATE grade=’85’ WHERE SN=’王二’ AND CN=’化学’14. 在SQL语言中,子查询是(D) . A. 返回单表中数据子集的查询语言B. 选取多表中字段子集的查询语句C. 选取单表中字段子集的查询语句D. 嵌入到另一个查询语句之中的查询语句15. SQL是一种(C )语言. A. 高级算法 B. 人工智能C. 关系数据库 D. 函数型16. 有关系S(S#,SNAME,SEX),C(C#,CNAME),SC(S#,C#,GRADE).其中S#是学生号,SNAME是学生姓名,SEX是性别, C#是课程号,CNAME是课程名称.要查询选修”数据库”课的全体男生姓名的SQL语句是SELECT SNAME FROM S,C,SC WHERE子句.这里的WHERE子句的内容是( A). A.S.S# = SC.S# and C.C# = SC.C# and SEX=’男’ and CNAME=’数据库’B.S.S# = SC.S# and C.C# = SC.C# and SEX in’男’and CNAME in’数据库’C.SEX ‘男’ and CNAME ‘ 数据库’D.S.SEX=’男’ and CNAME=’ 数据库’ 若用如下的SQL语句创建了一个表SC:CREATE TABLE SC (S# CHAR(6) NOT NULL,C# CHAR(3) NOT NULL,SCORE INTEGER,NOTE CHAR(20));向SC表插入如下行时,( B)行可以被插入 . A.(‘201009’,’111’,60,必修)B.(‘200823’,’101’,NULL,NULL)C.(NULL,’103’,80,’选修’)D.(‘201132’,NULL,86,’ ‘)18. 假设学生关系S(S#,SNAME,SEX),课程关系C(C#,CNAME),学生选课关系SC(S#,C#,GRADE).要查询选修”Computer”课的男生姓名,将涉及到关系( D). A. S B. S,SC C. C,SC D. S,C,SC 选择题答案:(1) B (2) A (3) C (4) C (5) B(6) A (7) D (8) C (9) C (10) B(11) A (12) D (13) A (14) D (15) C(16) A (17) B (18) D 二,简答题 试述SQL语言的特点. 答: 1) 综合统一. SQL语言集数据定义语言DDL,数据操纵语言DML,数据控制语言DCL的功能于一体. 2) 高度非过程化.用SQL语言进行数据操作,只要提出”做什么”,而无须指明”怎么做”,因此无需了解存取路径,存取路径的选择以及SQL语句的操作过程由系统自动完成. 3) 面向集合的操作方式.SQL语言采用集合操作方式,不仅操作对象,查找结果可以是元组的集合,而且一次插入,删除,更新操作的对象也可以是元组的集合. 4) 以同一种语法结构提供两种使用方式.SQL语言既是自含式语言,又是嵌入式语言.作为自含式语言,它能够独立地用于联机交互的使用方式,也能够嵌入到高级语言程序中,供程序员设计程序时使用. 5) 语言简捷,易学易用. 试述SQL的定义功能. 答: SQL的数据定义功能包括定义表,定义视图和定义索引. SQL语言使用CREATE TABLE语句定义建立基本表,;ALTER TABLE语句修改基本表定义,DROP TABLE语句删除基本表;建立索引使用CREATE INDEX语句建立索引, DROP INDEX语句删除索引表;SQL语言使用CREATE VIEW命令建立视图,DROP VIEW语句删除视图.3. 用SQL语句建立第3章习题3中的四个表. 答: 对于S表:S( SNO,SNAME,STATUS,CITY); 建S表 12345CREATE TABLE S(SNO CHAR(3),SNAME CHAR(10)STATUS CHAR(2)CITY CHAR(10)) P(PNO,PNAME,COLOR,WEIGHT); 建P表 123456CREATE TABLE P(PNO CHAR(3),PNAME CHAR(10),COLOR CHAR(4),WEIGHT INT);J(JNO,JNAME,CITY); 建J表 1234CREATE TABLE J(JNO CHAR(3),JNAME CHAR(10)CITY CHAR(10)) SPJ(SNO,PNO,JNO,QTY) 建SPJ表 12345CREATE TABLE SPJ(SNO CHAR(3),PNO CHAR(3),JNO CHAR(3),QTY INT); 针对上题中建立的四个表试用SQL语言完成第3章习题3中的查询. 答: (1) 求供应工程J1零件的供应商号码SNO; 123SELECT SNOFROM SPJWHERE JNO='J1'; (2) 求供应工程J1零件P1的供应商号码SNO; 1234SELECT SNOFROM SPJWHERE JNO='J1'AND PNO='P1'; (3) 求供应工程J1零件为红色的供应商号码SNO; 1234567SELECT SNOFROM SPJWHERE JNO='J1'AND PNO IN(SELECT PNOFROM PWHERE COLOR='红'); 或 12345SELECT SNOFROM SPJ,PWHERE JNO='J1'AND SPJ.PNO=P.PNOAND COLOR='红'; (4) 求没有使用天津供应商生产的红色零件的工程号JNO;解析:用SQL语言表示如下: 1234567891011121314SELECT JNOFROM JWHERE NOT EXISTS(SELECT *FROM SPJWHERE SPJ.JNO=J.JNOAND SNO IN(SELECT SNOFROM SWHERE CITY='天津')AND PNO IN(SELECT PNOFROM PWHERE COLOR='红')); 或 12345678910SELECT JNOFROM JWHERE NOT EXISTS(SELECT *1FROM SPJ, S, PWHERE SPJ.JNO=J.JNOAND SPJ.SNO=S.SNOAND SPJ.PNO=P.PNOAND S.CITY='天津'AND P. COLOR='红'); 注意:从 J 表入手,以包含那些尚未使用任何零件的工程号. (5) 求至少用了供应商S1所供应的全部零件的工程号JNO . 解析:用SQL语言表示如下: 12345678910111213SELECT DISTINCT JNOFROM SPJ SPJZWHERE NOT EXISTS(SELECT *FROM SPJ SPJXWHERE SNO='S1'AND NOT EXISTS(SELECT *FROM SPJ SPJYWHERE SPJY.PNO=SPJX.PNOAND SPJY.JNON=SPJZ.JNOAND SPJY.SNO='S1'));AND SPJY.SNO='S1' )); 针对习题3中的四个表试用SQL语言完成以下各项操作: (1) 找出所有供应商的姓名和所在城市. (2) 找出所有零件的名称,颜色,重量. (3) 找出使用供应商S1所供应零件的工程号码. (4) 找出工程项目J2使用的各种零件的名称及其数量. (5) 找出上海厂商供应的所有零件号码. (6) 找出使用上海产的零件的工程名称. (7) 找出没有使用天津产的零件的工程号码. (8) 把全部红色零件的颜色改成蓝色. (9) 由S5供给J4的零件P6改为由S3供应,请作必要的修改. (10) 从供应商关系中删除S2的记录,并从供应情况关系中删除相应的记录. (11) 请将 (S2,J6,P4,200) 插入供应情况关系. 答: (1) 找出所有供应商的姓名和所在城市. 12SELECT SNAME, CITYFROM S; (2) 找出所有零件的名称,颜色,重量. 12SELECT PNAME, COLOR, WEIGHTFROM P (3) 找出使用供应商S1所供应零件的工程号码. 123SELECT JNOFROM SPJWHERE SNO='S1' (4) 找出工程项目J2使用的各种零件的名称及其数量. 1234SELECT P.PNAME, SPJ.QTYFROM P, SPJWHERE P.PNO=SPJ.PNOAND SPJ.JNO='J2'; (5) 找出上海厂商供应的所有零件号码. 123456SELECT DISTINCT PNOFROM SPJWHERE SNO IN(SELECT SNOFROM SWHERE CITY='上海'); (6) 找出使用上海产的零件的工程名称. 12345SELECT JNAMEFROM J, SPJ, SWHERE J. JNO=SPJ. JNOAND SPJ. SNO=S.SNOAND S.CITY='上海'; 或 1234567SELECT JNAMEFROM JWHERE JNO IN(SELECT JNOFROM SPJ, SWHERE SPJ. SNO=S.SNOAND S.CITY='上海'); (7) 找出没有使用天津产的零件的工程号码. 123456789SELECT JNOFROM JWHERE NOT EXISTS(SELECT *FROM SPJWHERE SPJ.JNO=J.JNO AND SNO IN(SELECT SNOFROM SWHERE CITY='天津')) 或 123456SELECT JNOFROM JWHERE NOT EXISTS(SELECT *1FROM SPJ, SWHERE SPJ.JNO=J.JNO AND SPJ.SNO=S.SNO AND S.CITY='天津') (8) 把全部红色零件的颜色改成蓝色. 123UPDATE PSET COLOR='蓝'WHERE COLOR='红' (9) 由S5供给J4的零件P6改为由S3供应,请作必要的修改. 123UPDATE SPJSET SNO='S3'WHERE SNO='S5' AND JNO='J4' AND PNO='P6' (10) 从供应商关系中删除S2的记录,并从供应情况关系中删除相应的记录. 123DELETEFROM SPJWHERE SNO='S2' 或 123DELETEFROM SWHERE SNO='S2' 解析:注意删除顺序,应该先从SPJ表中删除供应商S2所供应零件的记录,然后从从S表中删除S2. (11) 请将 (S2,J6,P4,200) 插入供应情况关系. 12INSERT INTO SPJ(SNO, JNO, PNO, QTY)VALUES (S2,J6,P4,200); 或 12INSERT INTO SPJVALUES (S2,P4,J6,200); 什么是基本表 什么是视图 两者的区别和联系是什么 答: 基本表是本身独立存在的表,在SQL中一个关系就对应一个表. 视图是从一个或几个基本表导出的表.视图本身不独立存储在数据库中,是一个虚表.即数据库中只存放视图的定义而不存放视图对应的数据,这些数据仍存放在导出视图的基本表中.视图在概念上与基本表等同,用户可以如同基本表那样使用视图,可以在视图上再定义视图. 试述视图的优点. 答: (1) 视图能够简化用户的操作. (2) 视图使用户能以多种角度看待同一数据. (3) 视图对重构数据库提供了一定程度的逻辑独立性. (4) 视图能够对机密数据提供安全保护. 所有的视图是否都可以更新 为什么 答: 不是.视图是不实际存储数据的虚表,因此对视图的更新,最终要转换为对基本表的更新.因为有些视图的更新不能唯一地有意义地转换成对相应基本表的更新,所以,并不是所有的视图都是可更新的.如《概论》3.5.1中的视图S_G(学生的学号及他的平均成绩) 1234CREAT VIEW S_G(Sno,Gavg)AS SELECT Sno,AVG(Grade)FROM SCGROUP BY Sno; 要修改平均成绩,必须修改各科成绩,而我们无法知道哪些课程成绩的变化导致了平均成绩的变化.9. 哪类视图是可以更新的,哪类视图是不可更新的 各举一例说明.答: 基本表的行列子集视图一般是可更新的.如《概论》3.5.3中的例1.若视图的属性来自集函数,表达式,则该视图肯定是不可以更新的. 如《概论》3.5.3中的S_G视图.10. 试述某个你熟悉的实际系统中对视图更新的规定. 答:(略) 解析:不同的系统对视图更新的规定是不同的,读者必须了解你所用系统对视图更新的规定.11. 请为三建工程项目建立一个供应情况的视图,包括供应商代码(SNO),零件代码(PNO),供应数量(QTY).针对该视图完成下列查询: (1) 找出三建工程项目使用的各种零件代码及其数量.(2) 找出供应商S1的供应情况. 答:建视图: 1234567CREATE VIEW V_SPJ ASSELECT SNO, PNO, QTYFROM SPJWHERE JNO=(SELECT JNOFROM JWHERE JNAME='三建'); 对该视图查询: (1) 找出三建工程项目使用的各种零件代码及其数量. 12SELECT PNO, QTYFROM V_SPJ; (2) 找出供应商S1的供应情况. 123SELECT PNO, QTY /* S1供应三建工程的零件号和对应的数量*/FROM V_SPJWHERE SNO='S1'; 第四章 关系系统及其优化一,选择题 概念模型是现实世界的第一层抽象,这一类最著名的模型是(D) . A.层次模型 B. 关系模型 C. 网状模型 D. 实体-关系模型2. 区分不同实体的依据是( B) . A. 名称 B. 属性 C. 对象 D. 概念3. 关系数据模型是目前最重要的一种数据模型,它的三个要素分别为(B). A.实体完整,参照完整,用户自定义完整B.数据结构,关系操作,完整性约束C.数据增加,数据修改,数据查询D.外模式,模式,内模式4. 在(A )中一个结点可以有多个双亲,节点之间可以有多种联系. A.网状模型 B. 关系模型C.层次模型 D. 以上都有5. (B )的存取路径对用户透明,从而具有更高的数据独立性,更好的安全保密性,也简化了程序员的工作和数据库开发建立的工作. A.网状模型 B. 关系模型D.层次模型 D. 以上都有6. 在关系数据库中,要求基本关系中所有的主属性上不能有空值,其遵守的约束规则是( C) . A.数据依赖完整性规则 B. 用户定义完整性规则C.实体完整性规则 D. 域完整性规则 选择题答案:(1) D (2) B (3) B (4) A (5) B (6) C 二,简答题 试述关系模型的三个组成部分. 答:关系模型由关系数据结构,关系操作集合和关系完整性约束三部分组成. 试述关系数据语言的特点和分类. 答:关系数据语言可以分为三类: 关系代数语言 例如ISBL 关系演算语言 (元组关系演算语言 例如APLHA,QUEL 和 域关系演算语言 例如QBE) 具有关系代数和关系演算双重特点的语言 例如SQL 这些关系数据语言的共同特点是,具有完备的表达能力,是非过程化的集合操作语言,功能强,能够嵌入高级语言中使用. 定义并理解下列术语,说明它们之间的联系与区别: (1) 域,关系,元组,属性 答: 域:域是一组具有相同数据类型的值的集合. 关系:在域D1,D2,…,Dn上笛卡尔积D1×D2×…×Dn的子集称为关系,表示为R(D1,D2,…,Dn) 元组:关系中的每个元素是关系中的元组. 属性:关系也是一个二维表,表的每行对应一个元组,表的每列对应一个域.由于域可以相同,为了加以区分,必须对每列起一个名字,称为属性(Attribute). (2) 主码,候选码,外部码 答: 候选码:若关系中的某一属性组的值能唯一地标识一个元组,则称该属性组为候选码(Candidate key). 主码:若一个关系有多个候选码,则选定其中一个为主码(Primary key).外部码:设F是基本关系R的一个或一组属性,但不是关系R的码,如果F与基本关系S的主码Ks相对应,则称F是基本关系R的外部码(Foreign key),简称外码. 基本关系R称为参照关系(Referencing relation),基本关系S称为被参照关系(Referenced relation)或目标关系(Target relation).关系R和S可以是相同的关系. (3) 关系模式,关系,关系数据库 关系模式:关系的描述称为关系模式(Relation Schema).它可以形式化地表示为:R(U,D,dom,F) 其中R为关系名,U为组成该关系的属性名集合,D为属性组U中属性所来自的域,dom为属性向域的映象集合,F为属性间数据的依赖关系集合. 关系:在域D1,D2,…,Dn上笛卡尔积D1×D2×…×Dn的子集称为关系,表示为R(D1,D2,…,Dn) 关系是关系模式在某一时刻的状态或内容.关系模式是静态的,稳定的,而关系是动态的,随时间不断变化的,因为关系操作在不断地更新着数据库中的数据. 关系数据库:关系数据库也有型和值之分.关系数据库的型也称为关系数据库模式,是对关系数据库的描述,它包括若干域的定义以及在这些域上定义的若干关系模式.关系数据库的值是这些关系模式在某一时刻对应的关系的集合,通常就称为关系数据库. 试述关系模型的完整性规则.在参照完整性中,为什么外部码属性的值也可以为空 什么情况下才可以为空 答: 关系模型的完整性规则是对关系的某种约束条件.关系模型中可以有三类完整性约束:实体完整性,参照完整性和用户定义的完整性.其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件,被称作是关系的两个不变性,应该由关系系统自动支持. (1) 实体完整性规则:若属性A是基本关系R的主属性,则属性A不能取空值. (2) 参照完整性规则:若属性(或属性组)F是基本关系R的外码,它与基本关系S的主码Ks相对应(基本关系R和S不一定是不同的关系),则对于R中每个元组在F上的值必须为: 或者取空值(F的每个属性值均为空值); 或者等于S中某个元组的主码值. (3) 用户定义的完整性是针对某一具体关系数据库的约束条件.它反映某一具体应用所涉及的数据必须满足的语义要求. 在参照完整性中,外部码属性的值可以为空,它表示该属性的值尚未确定.但前提条件是该外部码属性不是其所在关系的主属性. 例如,在下面的”学生”表中,”专业号”是一个外部码,不是学生表的主属性,可以为空.其语义是,该学生的专业尚未确定. 学生(学号,姓名,性别,专业号,年龄)专业(专业号,专业名) 而在下面的”选修”表中的”课程号”虽然也是一个外部码属性,但它又是”选修”表的主属性,所以不能为空.因为关系模型必须满足实体完整性. 课程(课程号,课程名,学分)选修(学号,课程号,成绩) 等值连接与自然连接的区别是什么 答: 连接运算中有两种最为重要也最为常用的连接,一种是等值连接(equi-join),另一种是自然连接(Natural join).θ为”=”的连接运算称为等值连接.它是从关系R与S的笛卡尔积中选取A,B属性值相等的那些元组.即等值连接为:RA=BS={ tr ts| tr∈R ∧ ts∈S ∧ tr[A] = ts[B] } 自然连接(Natural join)是一种特殊的等值连接,它要求两个关系中进行比较的分量必须是相同的属性组,并且要在结果中把重复的属性去掉.即若R和S具有相同的属性组B,则自然连接可记作:RS={ tr ts| tr∈R ∧ ts∈S ∧ tr[B] = ts[B] } 第五章 关系数据理论一,选择题 为了设计出性能较优的关系模式,必须进行规范化,规范化主要的理论依据是(A ) . A. 关系规范化理论 B. 关系代数理论C.数理逻辑 D. 关系运算理论2. 规范化理论是关系数据库进行逻辑设计的理论依据,根据这个理论,关系数据库中的关系必须满足:每一个属性都是(B ) . A. 长度不变的 B. 不可分解的C.互相关联的 D. 互不相关的3. 已知关系模式R(A,B,C,D,E)及其上的函数相关性集合F={A→D,B→C ,E→A },该关系模式的候选关键字是( B) . A. AB B. BEC. CD D. DE4. 设学生关系S(SNO,SNAME,SSEX,SAGE,SDPART)的主键为SNO,学生选课关系SC(SNO,CNO,SCORE)的主键为SNO和CNO,则关系R(SNO,CNO,SSEX,SAGE,SDPART,SCORE)的主键为SNO和CNO,其满足( A). A. 1NF B.2NF C. 3NF D. BCNF5. 设有关系模式W(C,P,S,G,T,R),其中各属性的含义是:C表示课程,P表示教师,S表示学生,G表示成绩,T表示时间,R表示教室,根据语义有如下数据依赖集:D={ C→P,(S,C)→G,(T,R)→C,(T,P)→R,(T,S)→R },关系模式W的一个关键字是( D) . A. (S,C) B. (T,R) C. (T,P) D. (T,S)6. 关系模式中,满足2NF的模式(B) . A. 可能是1NF B. 必定是1NFC. 必定是3NF D. 必定是BCNF7. 关系模式R中的属性全是主属性,则R的最高范式必定是(C ) . A. 1NF B. 2NF C. 3NF D. BCNF8. 消除了部分函数依赖的1NF的关系模式,必定是(B ) . A. 1NF B. 2NF C. 3NF D. BCNF9. 如果A-&gt;B ,那么属性A和属性B的联系是( B) . A. 一对多 B. 多对一 C.多对多 D. 以上都不是10. 关系模式的候选关键字可以有1个或多个,而主关键字有( C) . A. 多个 B. 0个 C. 1个 D. 1个或多个 候选关键字的属性可以有( D) . A. 多个 B. 0个 C. 1个 D. 1个或多个12. 关系模式的任何属性( A) . A. 不可再分 B. 可以再分C. 命名在关系模式上可以不唯一 D. 以上都不是13. 设有关系模式W(C,P,S,G,T,R),其中各属性的含义是:C表示课程,P表示教师,S表示学生,G表示成绩,T表示时间,R表示教室,根据语义有如下数据依赖集:D={ C→P,(S,C)→G,(T,R)→C,(T,P)→R,(T,S)→R },若将关系模式W分解为三个关系模式W1(C,P),W2(S,C,G),W2(S,T,R,C),则W1的规范化程序最高达到( D) . A. 1NF B.2NF C. 3NF D. BCNF14. 在关系数据库中,任何二元关系模式的最高范式必定是(D ) . A. 1NF B.2NF C. 3NF D. BCNF15. 在关系规范式中,分解关系的基本原则是(B ).I.实现无损连接II.分解后的关系相互独立III.保持原有的依赖关系 A. Ⅰ和Ⅱ B. Ⅰ和Ⅲ C. Ⅰ D. Ⅱ16. 不能使一个关系从第一范式转化为第二范式的条件是( B). A.每一个非属性都完全函数依赖主属性B.每一个非属性都部分函数依赖主属性C.在一个关系中没有非属性存在D.主键由一个属性构成17. 任何一个满足2NF但不满足3NF的关系模式都不存在(D ). A.主属性对键的部分依赖B.非主属性对键的部分依赖C.主属性对键的传递依赖D.非主属性对键的传递依赖18. 设数据库关系模式R=(A,B,C,D,E),有下列函数依赖:A→BC,D→E,C→D;下述对R的分解中,哪些分解是R的无损连接分解( B) .I.(A,B,C)(C,D,E)II.(A,B)(A,C,D,E)III.(A,C)(B,C,D,E)IV.(A,B)(C,D,E) A.只有Ⅳ B. Ⅰ和Ⅱ C. Ⅰ,Ⅱ和Ⅲ D. 都不是19. 设U是所有属性的集合,X,Y,Z都是U的子集,且Z=U-X-Y.下面关于多值依赖的叙述中,不正确的是( C). A.若X→→Y,则X→→Z B.若X→Y,则X→→YC.若X→→Y,且Y′∈Y,则X→→Y′ D.若Z=∮,则X→→Y20. 若关系模式R(U,F)属于3NF,则(C ). A. 一定属于BCNFB. 消除了插入的删除异常C. 仍存在一定的插入和删除异常D. 属于BCNF且消除了插入和删除异常21. 下列说法不正确的是(C ). A. 任何一个包含两个属性的关系模式一定满足3NFB. 任何一个包含两个属性的关系模式一定满足BCNFC. 任何一个包含三个属性的关系模式一定满足3NFD. 任何一个关系模式都一定有码22. 设关系模式R(A,B,C),F是R上成立的FD集,F={B→C},则分解P={AB,BC}相对于F( A). A. 是无损联接,也是保持FD的分解B. 是无损联接,也不保持FD的分解C. 不是无损联接,但保持FD的分解D. 既不是无损联接,也不保持FD的分解23. 关系数据库规范化是为了解决关系数据库中( A)的问题而引入的. A. 插入,删除和数据冗余B. 提高查询速度C. 减少数据操作的复杂性D. 保证数据的安全性和完整性24. 关系的规范化中,各个范式之间的关系是( A) . A. 1NF∈2NF∈3NFB. 3NF∈2NF∈1NFC. 1NF=2NF=3NFD. 1NF∈2NF∈BCNF∈3NF25. 数据库中的冗余数据是指可(D)的数据 . A. 容易产生错误 B. 容易产生冲突C. 无关紧要 D. 由基本数据导出26. 学生表(id,name,sex,age,depart_id,depart_name),存在函数依赖是id→name,sex,age,depart_id;dept_id→dept_name,其满足( B). A. 1NF B. 2NF C. 3NF D. BCNF27. 设有关系模式R(S,D,M),其函数依赖集:F={S→D,D→M},则关系模式R的规范化程度最高达到(B ). A. 1NF B. 2NF C. 3NF D. BCNF28. 设有关系模式R(A,B,C,D),其数据依赖集:F={(A,B)→C,C→D},则关系模式R的规范化程度最高达到( B). A. 1NF B. 2NF C. 3NF D. BCNF29. 下列关于函数依赖的叙述中,哪一条是不正确的(B ). A.由X→Y,Y→Z,则X→YZ B.由X→YZ,则X→Y, Y→ZC.由X→Y,WY→Z,则XW→Z D.由X→Y,Z∈Y,则X→Z30. X→Y,当下列哪一条成立时,称为平凡的函数依赖(B ). A. X∈Y B. Y∈X C. X∩Y=∮ D. X∩Y≠∮31. 关系数据库的规范化理论指出:关系数据库中的关系应该满足一定的要求,最起码的要求是达到1NF,即满足( D). A.每个非主键属性都完全依赖于主键属性B.主键属性唯一标识关系中的元组C.关系中的元组不可重复D.每个属性都是不可分解的32. 根据关系数据库规范化理论,关系数据库中的关系要满足第一范式,部门(部门号,部门名,部门成员,部门总经理)关系中,因哪个属性而使它不满足第一范式(B). A. 部门总经理 B. 部门成员 C. 部门名 D. 部门号33. 有关系模式A(C,T,H,R,S),其中各属性的含义是: C:课程 T:教员 H:上课时间 R:教室 S:学生根据语义有如下函数依赖集: F={C→T,(H,R)→C,(H,T)RC,(H,S)→R} (1) 关系模式A的码是(B ). A. C B.(H,S) C.(H,R) D.(H,T) (2) 关系模式A的规范化程度最高达到( B). A. 1NF B. 2NF C. 3NF D. BCNF (3) 现将关系模式A分解为两个关系模式A1(C,T),A2(H,R,S),则其中A1的规范化程度达到(D ). A. 1NF B. 2NF C. 3NF D. BCNF 选择题答案:(1) A (2) B (3) B (4) A (5) D(6) B (7) C (8) B (9) B (10) C(11) D (12) A (13) D (14) D (15) B(16) B (17) D (18) B (19) C (20) C(21) C (22) A (23) A (24) A (25) D(26) B (27) B (28) B (29) B (30) B(31) D (32) B (33) B B D 二,简答题 理解并给出下列术语的定义: 函数依赖,部分函数依赖,完全函数依赖,候选码,主码, 外码,全码. 解析: 解答本题不能仅仅把《概论》上的定义写下来.关键是真正理解和运用这些概念. 答: 函数依赖:设R (U)是一个关系模式,U是R的属性集合,X和Y是U的子集.对于R (U)的任意一个可能的关系r,如果r中不存在两个元组,它们在X上的属性值相同, 而在Y上的属性值不同, 则称”X函数确定Y”或”Y函数依赖于X”,记作X→Y. 解析: 1) 函数依赖是最基本的一种数据依赖,也是最重要的一种数据依赖. 2) 函数依赖是属性之间的一种联系,体现在属性值是否相等.由上面的定义可以知道,如果X→Y,则r中任意两个元组,若它们在X上的属性值相同,那么在Y上的属性值一定也相同. 3) 我们要从属性间实际存在的语义来确定他们之间的函数依赖,即函数依赖反映了(描述了)现实世界的一种语义. 4) 函数依赖不是指关系模式R的在某个时刻的关系(值)满足的约束条件,而是指R任何时刻的一切关系均要满足的约束条件. 答: 完全函数依赖,部分函数依赖:在R(U)中,如果X→Y,并且对于X的任何一个真子集X,都有X′→Y,则称Y对X完全函数依赖;若X→Y,但Y不完全函数依赖于X,则称Y对X部分函数依赖; 候选码,主码: 设K为R(U,F)中的属性或属性组合,若K → U则K为R的候选码.若候选码多于一个,则选定其中的一个为主码.答: 外码:关系模式R中属性或属性组X并非R的码,但X是另一个关系模式的码,则称X是R的外部码也称外码. 全码:整个属性组是码,称为全码(All-key). 建立一个关于系,学生,班级,学会等诸信息的关系数据库. 描述学生的属性有:学号,姓名,出生年月,系名,班号,宿舍区. 描述班级的属性有:班号,专业名,系名,人数,入校年份. 描述系的属性有:系名,系号,系办公室地点,人数. 描述学会的属性有:学会名,成立年份,地点,人数. 有关语义如下:一个系有若干专业,每个专业每年只招一个班,每个班有若干学生.一个系的学生住在同一宿舍区.每个学生可参加若干学会,每个学会有若干学生.学生参加某学会有一个入会年份. 请给出关系模式,写出每个关系模式的极小函数依赖集,指出是否存在传递函数依赖,对于函数依赖左部是多属性的情况讨论函数依赖是完全函数依赖,还是部分函数依赖. 指出各关系的候选码,外部码,有没有全码存在 答: 关系模式: 学生S(S#,SN,SB,DN,C#,SA) 班级C(C#,CS,DN,CNUM,CDATE) 系 D(D#,DN,DA,DNUM) 学会P(PN,DATE1,PA,PNUM) 学生–学会SP(S#,PN,DATE2) 其中,S#—学号,SN—姓名,SB—出生年月,SA—宿舍区 C#—班号,CS—专业名,CNUM—班级人数,CDATE—入校年份 D#—系号,DN—系名,DA—系办公室地点,DNUM—系人数 PN—学会名,DATE1—成立年月,PA—地点,PNUM—学会人数,DATE2—入会年份 每个关系模式的极小函数依赖集: S:S#→SN,S#→SB,S#→C#,C#→DN,DN→SA C:C#→CS,C#→CNUM,C#→CDATE,CS→DN,(CS,CDATE)→C# D:D#→DN,DN→D#,D#→DA,D#→DNUM P:PN→DATE1,PN→PA,PN→PNUM SP:(S#,PN)→DATE2 S中存在传递函数依赖: S#→DN, S#→SA, C#→SA C中存在传递函数依赖:C#→DN (S#,PN)→DATE2 和(CS,CDATE)→C# 均为SP中的函数依赖,是完全函数依赖 关系 候选码 外部码 全码 S S# C#,DN 无 C C#,(CS,CDATE) DN 无 D D#和DN 无 无 P PN 无 无 SP (S#,PN) S#,PN 无 试由Armostrong公理系统推导出下面三条推理规则: (1) 合并规则:若X→Z,X→Y,则有X→YZ (2) 伪传递规则:由X→Y,WY→Z有XW→Z (3) 分解规则:X→Y,Z 包含于 Y,有X→Z 证: (1) 已知X→Z,由增广律知XY→YZ,又因为X→Y,可得XX→XY→YZ,最后根据传递律得X→YZ.(2) 已知X→Y,据增广律得XW→WY,因为WY→Z,所以XW→WY→Z,通过传递律可知XW→Z.(3) 已知Z 包含于 Y,根据自反律知Y→Z,又因为X→Y,所以由传递律可得X→Z. 试举出三个多值依赖的实例.答: (1) 关系模式MSC(M,S,C)中,M表示专业,S表示学生,C表示该专业的必修课.假设每个专业有多个学生,有一组必修课.设同专业内所有学生的选修的必修课相同,实例关系如下.按照语义对于M的每一个值M i,S有一个完整的集合与之对应而不问C取何值,所以M→→S.由于C与S的完全对称性,必然有M→→C成立. 123456M S CM 1 S1 C1M 1 S1 C2M 1 S2 C1M 1 S2 C2…… …… …… (2) 关系模式ISA(I,S,A)中,I表示学生兴趣小组,S表示学生,A表示某兴趣小组的活动项目.假设每个兴趣小组有多个学生,有若干活动项目.每个学生必须参加所在兴趣小组的所有活动项目,每个活动项目要求该兴趣小组的所有学生参加.按照语义有I→→S,I→→A成立. (3) 关系模式RDP(R,D,P)中,R表示医院的病房,D表示责任医务人员,P表示病人.假设每个病房住有多个病人,有多个责任医务人员负责医治和护理该病房的所有病人.按照语义有R→→D,R→→P成立. 下面的结论哪些是正确的,哪些是错误的 对于错误的结论请给出理由或给出一个反例说明之.12345678(1) 任何一个二目关系都是属于3NF的.√(2) 任何一个二目关系都是属于BCNF的.√(3) 任何一个二目关系都是属于4NF的.√(5) 若R.A→R.B,R.B→R.C,则R.A→R.C √(6) 若R.A→R.B,R.A→R.C,则R.A→R.(B, C) √(7) 若R.B→R.A,R.C→R.A,则R.(B, C)→R.A √(8) 若R.(B, C)→R.A,则R.B→R.A,R.C→R.A ×反例:关系模式 SC(S#,C#,G) (S#,C#)→G,但是S# → G,C#→G 第六章 数据库设计一,选择题 数据流程图是用于描述结构化方法中(D )阶段的工具. A. 概要设计 B. 可行性分析C. 程序编码 D. 需求分析2. 数据库设计中,用E-R图赖描述信息结构但不涉及信息在计算机中的表示,这是数据库设计的( C). A. 需求分析阶段 B. 逻辑设计阶段C. 概念设计阶段 D. 物理设计阶段3. 在数据库设计中,将E-R图转换成关系数据模型的过程属于(B ). A. 需求分析阶段 B. 逻辑设计阶段C. 概念设计阶段 D. 物理设计阶段4. 子模式DDL是用来描述( B). A. 数据库的总体逻辑结构 B. 数据库的局部逻辑结构C. 数据库的物理存储结构 D. 数据库的概念结构5. 数据库设计的概念设计阶段,表示概念结构的常用方法和描述工具是(C). A.层次分析法和层次结构图B.数据流程分析法和数据流程图C.实体联系法和实体联系图D.结构分析法和模块结构图6. 在E-R模型向关系模型转换时,M:N的联系转换为关系模式时,其关键字是(C ). A.M端实体的关键字B.N端实体的关键字C.M,N端实体的关键字组合D.重新选取其他属性7. 某学校规定,每一个班级最多有50名学生,至少有10名学生;每一名学生必须属于一个班级.在班级与学生实体的联系中,学生实体的基数是( B) . A. (0,1) B. (1,1)C. (1,10) D. (10,50)8. 在关系数据库设计中,设计关系模式是数据库设计中(A )阶段的任. A. 逻辑设计阶段 B. 概念设计阶段C. 物理设计阶段 D. 需求分析阶段9. 关系数据库的规范化理论主要解决的问题是(A ). A.如何构造合适的数据逻辑结构B.如何构造合适的数据物理结构C.如何构造合适的应用程序界面D.如何控制不同用户的数据操作权限10. 数据库设计可划分为七个阶段,每个阶段都有自己的设计内容,”为哪些关系,在哪些属性上,键什么样的索引”这一设计内容应该属于( C)设计阶段. A. 概念设计 B. 逻辑设计C. 物理设计 D. 全局设计11. 假设设计数据库性能用”开销”,即时间,空间及可能的费用来衡量,则在数据库应用系统生存期中存在很多开销.其中,对物理设计者来说,主要考虑的是( C). A. 规划开销 B. 设计开销C. 操作开销 D. 维护开销12. 数据库物理设计完成后,进入数据库实施阶段,下述工作中,(D )一般不属于实施阶段的工作. A. 建立库结构 B. 系统调试C. 加载数据 D. 扩充功能13. 从ER图导出关系模型时,如果实体间的联系是M:N的,下列说法中正确的是(C ). A.将N方关键字和联系的属性纳入M方的属性中B.将M方关键字和联系的属性纳入N方的属性中C.增加一个关系表示联系,其中纳入M方和N方的关键字D.在M方属性和N方属性中均增加一个表示级别的属性14. 在ER模型中,如果有3个不同的实体集,3个M:N联系,根据ER模型转换为关系模型的规则,转换为关系的数目是(C ). A. 4 B. 5 C. 6 D. 7 选择题答案:(1) D (2) C (3) B (4) B (5) C(6) C (7) B (8) A (9) A (10) C (11) C (12) D (13) C (14) C 二,简答题 试述数据库设计过程. 解析 希望同学能够认真阅读《概论》的内容,了解并掌握数据库设计过程.这里只概要列出数据库设计过程的六个阶段: 1) 需求分析 2) 概念结构设计 3) 逻辑结构设计 4) 数据库物理设计 5) 数据库实施 6) 数据库运行和维护 这是一个完整的实际数据库及其应用系统的设计过程.不仅包括设计数据库本身,还包括数据库的实施,数据库运行和维护.设计一个完善的数据库应用系统往往是上述六个阶段的不断反复. 试述数据库设计过程的各个阶段上的设计描述. 解析:这是进一步了解数据库设计的具体内容.设计描述是指在各个阶段体现设计内容,描述设计结果的各种文档,程序. 答: 各阶段的设计要点如下: 1) 需求分析:准确了解与分析用户需求(包括数据与处理). 2) 概念结构设计:通过对用户需求进行综合,归纳与抽象,形成一个独立于具体DBMS的概念模型. 3) 逻辑结构设计:将概念结构转换为某个DBMS所支持的数据模型,并对其进行优化. 4) 数据库物理设计:为逻辑数据模型选取一个最适合应用环境的物理结构(包括存储结构和存取方法). 5) 数据库实施:设计人员运用DBMS提供的数据语言,工具及宿主语言,根据逻辑设计和物理设计的结果建立数据库,编制与调试应用程序,组织数据入库,并进行试运行. 6) 数据库运行和维护:在数据库系统运行过程中对其进行评价,调整与修改. 试述数据库设计过程中结构设计部分形成的数据库模式. 答: 数据库结构设计的不同阶段形成数据库的各级模式,即: 在概念设计阶段形成独立于机器特点,独立于各个DBMS产品的概念模式,在本篇中就是E-R图; 在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型,如关系模型,形成数据库逻辑模式;然后在基本表的基础上再建立必要的视图(View),形成数据的外模式; 在物理设计阶段,根据DBMS特点和处理的需要,进行物理存储安排,建立索引,形成数据库内模式. 概念模式是面向用户和设计人员的,属于概念模型的层次;逻辑模式,外模式,内模式是DBMS支持的模式,属于数据模型的层次.可以在DBMS中加以描述和存储. 试述数据库设计的特点. 答:数据库设计既是一项涉及多学科的综合性技术又是一项庞大的工程项目 其主要特点有: 1) 数据库建设是硬件,软件和干件(技术与管理的界面)的结合. 2) 从软件设计的技术角度看,数据库设计应该和应用系统设计相结合,也就是说,整个设计过程中要把结构(数据)设计和行为(处理)设计密切结合起来. 需求分析阶段的设计目标是什么 调查的内容是什么 答: 需求分析阶段的设计目标是通过详细调查现实世界要处理的对象(组织,部门,企业等),充分了解原系统(手工系统或计算机系统)工作概况,明确用户的各种需求,然后在此基础上确定新系统的功能. 调查的内容是”数据”和”处理”,即获得用户对数据库的如下要求: (1) 信息要求.指用户需要从数据库中获得信息的内容与性质.由信息要求可以导出数据要求,即在数据库中需要存储哪些数据. (2) 处理要求.指用户要完成什么处理功能,对处理的响应时间有什么要求,处理方式是批处理还是联机处理. (3) 安全性与完整性要求. 数据字典的内容和作用是什么 答: 数据字典是系统中各类数据描述的集合.数据字典的内容通常包括:数据项,数据结构,数据流,数据存储,处理过程五个部分 其中数据项是数据的最小组成单位,若干个数据项可以组成一个数据结构.数据字典通过对数据项和数据结构的定义来描述数据流,数据存储的逻辑内容. 数据字典的作用: 数据字典是关于数据库中数据的描述,在需求分析阶段建立,是下一步进行概念设计的基础,并在数据库设计过程中不断修改,充实,完善. (注意,数据库设计阶段形成的数据字典与后面讲到的数据字典不同,后者是DBMS关于数据库中数据的描述,当然两者是有联系的). 什么是数据库的概念结构 试述其特点和设计策略. 答:概念结构是信息世界的结构,即概念模型,其主要特点是: (1) 能真实,充分地反映现实世界,包括事物和事物之间的联系,能满足用户对数据的处理要求.是对现实世界的一个真实模型. (2) 易于理解,从而可以用它和不熟悉计算机的用户交换意见,用户的积极参与是数据库的设计成功的关键. (3) 易于更改,当应用环境和应用要求改变时,容易对概念模型修改和扩充. (4) 易于向关系,网状,层次等各种数据模型转换. 概念结构的设计策略通常有四种: 自顶向下.即首先定义全局概念结构的框架,然后逐步细化; 自底向上.即首先定义各局部应用的概念结构,然后将它们集成起来,得到全局概念结构; 逐步扩张.首先定义最重要的核心概念结构,然后向外扩充,以滚雪球的方式逐步生成其他概念结构,直至总体概念结构; 混合策略.即将自顶向下和自底向上相结合,用自顶向下策略设计一个全局概念结构的框架,以它为骨架集成由自底向上策略中设计的各局部概念结构. 什么叫数据抽象 试举例说明. 答: 数据抽象是对实际的人,物,事和概念进行人为处理,抽取所关心的共同特性,忽略非本质的细节,并把这些特性用各种概念精确地加以描述,这些概念组成了某种模型. 如分类这种抽象是:定义某一类概念作为现实世界中一组对象的类型.这些对象具有某些共同的特性和行为.它抽象了对象值和型之间的”is member of”的语义.在E-R模型中,实体型就是这种抽象.例如在学校环境中,李英是老师,表示李英是教师类型中的一员,则教师是实体型,李英是教师实体型中的一个实体值,具有教师共同的特性和行为:在某个系某个专业教学,讲授某些课程,从事某个方向的科研. 试述数据库概念结构设计的重要性和设计步骤. 答: 重要性:数据库概念设计是整个数据库设计的关键,将在需求分析阶段所得到的应用需求首先抽象为概念结构,以此作为各种数据模型的共同基础,从而能更好地,更准确地用某一DBMS实现这些需求. 设计步骤: 概念结构的设计方法有多种,其中最经常采用的策略是自底向上方法,该方法的设计步骤通常分为两步: 第1步是抽象数据并设计局部视图,第2步是集成局部视图,得到全局的概念结构 什么是E-R图 构成E-R图的基本要素是什么 答:E-R图为实体-联系图,提供了表示实体型,属性和联系的方法,用来描述现实世界的概念模型. 构成E-R图的基本要素是实体型,属性和联系,其表示方法为: 实体型:用矩形表示,矩形框内写明实体名; 属性:用椭圆形表示,并用无向边将其与相应的实体连接起来; 联系:用菱形表示,菱形框内写明联系名,并用无向边分别与有关实体连接起来,同时在无向边旁标上联系的类型(1 : 1,1 : n或m : n). 为什么要视图集成 视图集成的方法是什么 答: 在对数据库系统进行概念结构设计时一般采用自底向上的设计方法,把繁杂的大系统分解子系统.首先设计各个子系统的局部视图,然后通过视图集成的方式将各子系统有机的融合起来,综合成一个系统的总视图.这样设计清晰,由简到繁.由于数据库系统是从整体角度看待和描述数据的,因此数据不再面向某个应用而是整个系统.因此必须进行视图集成,使得数据库能被全系统的多个用户,多个应用共享使用. 一般说来,视图集成可以有两种方式: 多个分E-R图一次集成; 逐步集成,用累加的方式一次集成两个分E-R图. 无论采用哪种方式,每次集成局部E-R图时都需要分两步走: (1) 合并.解决各分E-R图之间的冲突,将各分E-R图合并起来生成初步E-R图. (2) 修改和重构.消除不必要的冗余,生成基本E-R图. 什么是数据库的逻辑结构设计 试述其设计步骤. 答: 数据库的逻辑结构设计就是把概念结构设计阶段设计好的基本E-R图转换为与选用的DBMS产品所支持的数据模型相符合的逻辑结构. 设计步骤为: 将概念结构转换为一般的关系,网状,层次模型; 将转换来的关系,网状,层次模型向特定DBMS支持下的数据模型转换 对数据模型进行优化. 试述把E-R图转换为DBTG模型和关系模型的转换规则. 答: E-R图向DBTG模型的转换规则: 1) 每个实体型转换为记录型,实体的属性转换为记录的数据项;2) 实体型之间1:n(n≥1)的联系转换为一个系,没有任何联系的实体型转换为奇异系;3) K(K≥2)个实体型之间多对多的联系,引入一个连结记录,形成K个实体型和连结记录之间的K个系.连结记录的属性由诸首记录的码及联系属性所组成;4) 同一实体型内的1:n,n:m联系,引入连结记录,转换为两个系. 解析 根据我国实际情况,网状,层次数据库系统已很少使用,因此《概论》第三版把它们删去了,有关的主要概念放在第一章数据模型中介绍.对于DBTG模型的许多概念也介绍得很简单.本题的内容已经超出了书上的内容,同学们只要了解就可以了.但是,下面E-R图向关系模型的转换规则要求同学必须掌握,并且能够举一反三. 答: E-R图向关系模型的转换规则: 一个实体型转换为一个关系模式.实体的属性就是关系的属性,实体的码就是关系的码. 对于实体间的联系则有以下不同的情况: (1) 一个1:1联系可以转换为一个独立的关系模式,也可以与任意一端对应的关系模式合并.如果转换为一个独立的关系模式,则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性,每个实体的码均是该关系的候选码.如果与某一端实体对应的关系模式合并,则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性. (2) 一个1:n联系可以转换为一个独立的关系模式,也可以与n端对应的关系模式合并.如果转换为一个独立的关系模式,则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性,而关系的码为n端实体的码. (3) 一个m:n联系转换为一个关系模式.与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性,各实体码的组合组成该关系的码,或码的一部分. (4) 三个或三个以上实体间的一个多元联系可以转换为一个关系模式.与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性,而关系的码为各实体码的组合. (5) 具有相同码的关系模式可合并.14. 你能给出由E-R图转换为IMS模型的转换规则吗 答: E-R图向IMS模型的转换规则: 1)每个实体型转换为记录型,实体的属性转换为记录的数据项; 2)实体型之间1:n(n≥1)的联系转换记录型之间的有向边; 3)实体型之间m:n(m&gt;1,n&gt;1)的联系则分解成一对多联系,再根据2)转换; 4)K(K≥2)个实体型之间多对多的联系,可先转换成多对两个实体型之间的联系,再根据3)转换. 解析 IMS是IBM公司的层次数据库管理系统.IMS模型是层次模型.E-R图向IMS模型转换的另一种方法是,先把E-R图转换为网状模型,再利用IMS逻辑数据库LDB的概念来表示网状模型.详细方法这里从略. 第七章 数据库恢复技术一,选择题 一个事务的执行,要么全部完成,要么全部不做,一个事务中对数据库的所有操作都是一个不可分割的操作序列的属性是(A ) . A. 原子性 B. 一致性C. 独立性 D. 持久性 表示两个或多个事务可以同时运行而不互相影响的是( C). A. 原子性 B. 一致性C. 独立性 D. 持久性3. 事务的持续性是指( B) A.事务中包括的所有操作要么都做,要么都不做.B.事务一旦提交,对数据库的改变是永久的.C.一个事务内部的操作对并发的其他事务是隔离的.D.事务必须是使数据库从一个一致性状态变到另一个一致性状态.4. SQL语言中的COMMIT语句的主要作用是( C). A. 结束程序 B. 返回系统C. 提交事务 D. 存储数据5. SQL语言中用( B)语句实现事务的回滚 A. CREATE TABLE B. ROLLBACKC. GRANT和REVOKE D. COMMIT6. 若系统在运行过程中,由于某种硬件故障,使存储在外存上的数据部分损失或全部损失,这种情况称为(A). A. 介质故障 B. 运行故障C. 系统故障 D. 事务故障7. 在DBMS中实现事务持久性的子系统是( D ). A. 安全管理子系统 B. 完整性管理子系统C. 并发控制子系统 D. 恢复管理子系统8. 后援副本的作用是( C ). A. 保障安全性 B. 一致性控制C. 故障后的恢复 D. 数据的转储9. 事务日志用于保存( C ) A. 程序运行过程 B. 程序的执行结果C. 对数据的更新操作 D. 数据操作10. 数据库恢复的基础是利用转储的冗余数据.这些转储的冗余数据包括( C). A. 数据字典,应用程序,审计档案,数据库后备副本B. 数据字典,应用程序,审计档案,日志文件C. 日志文件,数据库后备副本D. 数据字典,应用程序,数据库后备副本 选择题答案:(1) A (2) C (3) B (4) C (5) B(6) A (7) D (8) C (9) C (10) C 二,简答题 试述事务的概念及事务的四个特性. 答: 事务是用户定义的一个数据库操作序列,这些操作要么全做要么全不做,是一个不可分割的工作单位. 事务具有四个特性:原子性(Atomicity),一致性(Consistency),隔离性(Isolation)和持续性(Durability).这个四个特性也简称为ACID特性. 原子性:事务是数据库的逻辑工作单位,事务中包括的诸操作要么都做,要么都不做. 一致性:事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态. 隔离性:一个事务的执行不能被其他事务干扰.即一个事务内部的操作及使用的数据对其他并发事务是隔离的,并发执行的各个事务之间不能互相干扰. 持续性:持续性也称永久性(Permanence),指一个事务一旦提交,它对数据库中数据的改变就应该是永久性的.接下来的其他操作或故障不应该对其执行结果有任何影响. 为什么事务非正常结束时会影响数据库数据的正确性,请列举一例说明之.答: 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态.如果数据库系统运行中发生故障,有些事务尚未完成就被迫中断,这些未完成事务对数据库所做的修改有一部分已写入物理数据库,这时数据库就处于一种不正确的状态,或者说是不一致的状态. 例如某工厂的库存管理系统中,要把数量为Q的某种零件从仓库1移到仓库2存放.则可以定义一个事务T,T包括两个操作;Q1=Q1-Q,Q2=Q2+Q.如果T非正常终止时只做了第一个操作,则数据库就处于不一致性状态,库存量无缘无故少了Q. 数据库中为什么要有恢复子系统 它的功能是什么 答: 因为计算机系统中硬件的故障,软件的错误,操作员的失误以及恶意的破坏是不可避免的,这些故障轻则造成运行事务非正常中断,影响数据库中数据的正确性,重则破坏数据库,使数据库中全部或部分数据丢失,因此必须要有恢复子系统. 恢复子系统的功能是:把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态). 数据库运行中可能产生的故障有哪几类 哪些故障影响事务的正常执行 哪些故障破坏数据库数据 答:数据库系统中可能发生各种各样的故障,大致可以分以下几类: (1) 事务内部的故障; (2) 系统故障; (3) 介质故障; (4) 计算机病毒. 事务故障,系统故障和介质故障影响事务的正常执行;介质故障和计算机病毒破坏数据库数据. 5.据库恢复的基本技术有哪些 答: 数据转储和登录日志文件是数据库恢复的基本技术. 当系统运行过程中发生故障,利用转储的数据库后备副本和日志文件就可以将数据库恢复到故障前的某个一致性状态. 数据库转储的意义是什么 试比较各种数据转储方法. 答: 数据转储是数据库恢复中采用的基本技术.所谓转储即DBA定期地将数据库复制到磁带或另一个磁盘上保存起来的过程.当数据库遭到破坏后可以将后备副本重新装入,将数据库恢复到转储时的状态. 静态转储:在系统中无运行事务时进行的转储操作.静态转储简单,但必须等待正运行的用户事务结束才能进行.同样,新的事务必须等待转储结束才能执行.显然,这会降低数据库的可用性. 动态转储:指转储期间允许对数据库进行存取或修改.动态转储可克服静态转储的缺点,它不用等待正在运行的用户事务结束,也不会影响新事务的运行.但是,转储结束时后援副本上的数据并不能保证正确有效.因为转储期间运行的事务可能修改了某些数据,使得后援副本上的数据不是数据库的一致版本.为此,必须把转储期间各事务对数据库的修改活动登记下来,建立日志文件(log file).这样,后援副本加上日志文件就能得到数据库某一时刻的正确状态.转储还可以分为海量转储和增量转储两种方式. 海量转储是指每次转储全部数据库.增量转储则指每次只转储上一次转储后更新过的数据.从恢复角度看,使用海量转储得到的后备副本进行恢复一般说来更简单些.但如果数据库很大,事务处理又十分频繁,则增量转储方式更实用更有效. 什么是日志文件 为什么要设立日志文件 答:(1) 日志文件是用来记录事务对数据库的更新操作的文件. (2) 设立日志文件的目的是: 进行事务故障恢复;进行系统故障恢复;协助后备副本进行介质故障恢复. 登记日志文件时为什么必须先写日志文件,后写数据库 答: 把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作.有可能在这两个操作之间发生故障,即这两个写操作只完成了一个. 如果先写了数据库修改,而在运行记录中没有登记这个修改,则以后就无法恢复这个修改了.如果先写日志,但没有修改数据库,在恢复时只不过是多执行一次UNDO操作,并不会影响数据库的正确性.所以一定要先写日志文件,即首先把日志记录写到日志文件中,然后写数据库的修改. 针对不同的故障,试给出恢复的策略和方法.(即如何进行事务故障的恢复 系统故障的恢复 介质故障恢复 ) 答: 事务故障的恢复: 事务故障的恢复是由DBMS自动完成的,对用户是透明的. DBMS执行恢复步骤是: (1) 反向扫描文件日志(即从最后向前扫描日志文件),查找该事务的更新操作. (2) 对该事务的更新操作执行逆操作.即将日志记录中”更新前的值”写入数据库. (3) 继续反向扫描日志文件,做同样处理. (4) 如此处理下去,直至读到此事务的开始标记,该事务故障的恢复就完成了. 答: 系统故障的恢复: 系统故障可能会造成数据库处于不一致状态: 一是未完成事务对数据库的更新可能已写入数据库; 二是已提交事务对数据库的更新可能还留在缓冲区,没来得及写入数据库. 因此恢复操作就是要撤销(UNDO)故障发生时未完成的事务,重做(REDO)已完成的事务. 系统的恢复步骤是: (1) 正向扫描日志文件,找出在故障发生前已经提交的事务队列(REDO队列)和未完成的事务队列(UNDO队列). (2) 对撤销队列中的各个事务进行UNDO处理.进行UNDO处理的方法是,反向扫描日志文件,对每个UNDO事务的更新操作执行逆操作,即将日志记录中”更新前的值”(Before Image)写入数据库. (3) 对重做队列中的各个事务进行REDO处理. 进行REDO处理的方法是:正向扫描日志文件,对每个REDO事务重新执行日志文件登记的操作.即将日志记录中”更新后的值”(After Image)写入数据库. 解析:在第(1)步中如何找出REDO队列和UNDO队列 请大家思考一下. 下面给出一个算法: 1) 建立两个事务队列: UNDO-LIST: 需要执行undo操作的事务集合; REDO-LIST: 需要执行redo操作的事务集合; 两个事务队列初始均为空. 2) 从日志文件头开始,正向扫描日志文件 · 如有新开始(遇到Begin Transaction)的事务Ti,把Ti暂时放入UNDO-LIST队列;· 如有提交的事务(遇到End Transaction)Tj,把Tj从UNDO-LIST队列移到REDO-LIST队列;直到日志文件结束 答: 介质故障的恢复: 介质故障是最严重的一种故障. 恢复方法是重装数据库,然后重做已完成的事务.具体过程是: (1) DBA装入最新的数据库后备副本(离故障发生时刻最近的转储副本),使数据库恢复到转储时的一致性状态. (2) DBA装入转储结束时刻的日志文件副本 (3) DBA启动系统恢复命令,由DBMS完成恢复功能,即重做已完成的事务. 解析 1) 我们假定采用的是静态转储,因此第(1)步装入数据库后备副本便可以了.2) 如果采用的是静动态转储,第(1)步装入数据库后备副本还不够,还需同时装入转储开始时刻的日志文件副本,经过处理后才能得到正确的数据库后备副本.3) 第(2)步重做已完成的事务的算法是:a. 正向扫描日志文件,找出故障发生前已提交的事务的标识,将其记入重做队列b. 再一次正向扫描日志文件,对重做队列中的所有事务进行重做处理.即将日志记录中”更新后的值”写入数据库. 具有检查点的恢复技术有什么优点 答: 利用日志技术进行数据库恢复时,恢复子系统必须搜索日志,确定哪些事务需要REDO,哪些事务需要UNDO.一般来说,需要检查所有日志记录.这样做有两个问题: 一是搜索整个日志将耗费大量的时间. 二是很多需要REDO处理的事务实际上已经将它们的更新操作结果写到数据库中了,恢复子系统又重新执行了这些操作,浪费了大量时间. 检查点技术就是为了解决这些问题. 试述使用检查点方法进行恢复的步骤. 答: ① 从重新开始文件中找到最后一个检查点记录在日志文件中的地址,由该地址在日志文件中找到最后一个检查点记录. ② 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST. 这里建立两个事务队列:· UNDO-LIST: 需要执行undo操作的事务集合;· REDO-LIST: 需要执行redo操作的事务集合;把ACTIVE-LIST暂时放入UNDO-LIST队列,REDO队列暂为空. ③ 从检查点开始正向扫描日志文件 · 如有新开始的事务Ti,把Ti暂时放入UNDO-LIST队列; · 如有提交的事务Tj,把Tj从UNDO-LIST队列移到REDO-LIST队列,直到日志文件结束; ④ 对UNDO-LIST中的每个事务执行UNDO操作, 对REDO-LIST中的每个事务执行REDO操作. 什么是数据库镜像 它有什么用途 答: 数据库镜像即根据DBA的要求,自动把整个数据库或者其中的部分关键数据复制到另一个磁盘上.每当主数据库更新时,DBMS自动把更新后的数据复制过去,即DBMS自动保证镜像数据与主数据的一致性. 数据库镜像的用途有: 一是用于数据库恢复.当出现介质故障时,可由镜像磁盘继续提供使用,同时DBMS自动利用镜像磁盘数据进行数据库的恢复,不需要关闭系统和重装数据库副本.二是提高数据库的可用性.在没有出现故障时,当一个用户对某个数据加排它锁进行修改时,其他用户可以读镜像数据库上的数据,而不必等待该用户释放锁. 试述你了解的某一个实际的DBMS产品中采用的恢复策略.答: 下面简单介绍一下Oracle的恢复技术: Oracle中恢复机制也采用了转储和登记日志文件两个技术. Oracle向DBA提供了多种转储后备副本的方法,如文件拷贝,利用Oracle的Export实用程序,用SQL命令Spool以及自己编程实现等.相应地,Oracle也提供了多种重装后备副本的方法,如文件拷贝,利用Oracle的Import实用程序,利用SQL * LOADER以及自己编程实现等. 在Oracle 早期版本(V.5)中,日志文件以数据块为单位,也就是说,Oracle的恢复操作是基于数据块的,不是基于操作的.Oracle中记录数据库更新前的旧值的日志文件称为数据库前像文件(Before Image,简称BI文件),记录数据库更新后的新值的日志文件称为数据库的后像文件(After Image,简称AI文件).BI文件是必须配置的,AI文件是可以任选的. Oracle7为了能够在出现故障时更有效地恢复数据,也为了解决读”脏”数据问题,提供了REDO日志文件和回滚段(Rollback Segment).REDO日志文件中记录了被更新数据的前像和后像.回滚段记录更新数据的前像,设在数据库缓冲区中.在利用日志文件进行故障恢复时,为减少扫描日志文件的遍数,Oracle7首先扫描REDO日志文件,重做所有操作,包括未正常提交的事务的操作,然后再根据回滚段中的数据,撤销未正常提交的事务的操作. 详细技术希望同学自己设法了解Oracle最新版本的介绍,例如通过INTERNET访问Oracle公司的网站.也可以了解其他DBMS厂商的产品情况. 试用恢复的基本技术设计一个恢复子系统,给出这个子系统的恢复策略,包括: (a) 当产生某一类故障时如何恢复数据库的方法; (b) 日志文件的结构; (c) 登记日志文件的方法; (d) 利用日志文件恢复事务的方法; (e) 转储的类型; (f) 转储的后备副本和日志文件如何配合使用. 解析 这是一个大作业.可以综合复习和运用学到的知识.设计一个恢复子系统 例如,日志文件的结构你可以记录为单位,也可以以数据块为单位.不同的日志文件结构,登记的日志内容,日志文件恢复事务的方法也就不同了. 对于研究生,还应该上机模拟实现你设计的恢复子系统. 第八章 数据库并发控制一,选择题 为了防止一个用户的工作不适当地影响另一个用户,应该采取(D) . A. 完整性控制 B. 访问控制C. 安全性控制 D. 并发控制2. 解决并发操作带来的数据不一致问题普遍采用( A)技术. A. 封锁 B. 存取控制C. 恢复 D. 协商3. 下列不属于并发操作带来的问题是( C). A. 丢失修改 B. 不可重复读C. 死锁 D. 脏读4. DBMS普遍采用(C )方法来保证调度的正确性 . A. 索引 B. 授权C. 封锁 D. 日志5. 事务T在修改数据R之前必须先对其加X锁,直到事务结束才释放,这是(A ) . A. 一级封锁协议 B. 二级封锁协议C. 三级封锁协议 D. 零级封锁协议6. 如果事务T获得了数据项Q上的排他锁,则T对Q( C) . A. 只能读不能写 B. 只能写不能读C. 既可读又可写 D. 不能读也不能写7. 设事务T1和T2,对数据库中地数据A进行操作,可能有如下几种情况,请问哪一种不会发生冲突操作(D ) . A. T1正在写A,T2要读AB. T1正在写A,T2也要写AC. T1正在读A,T2要写AD. T1正在读A,T2也要读A8. 如果有两个事务,同时对数据库中同一数据进行操作,不会引起冲突的操作是( D) . A. 一个是DELETE,一个是SELECTB. 一个是SELECT,一个是DELETEC. 两个都是UPDATED. 两个都是SELECT9. 在数据库系统中,死锁属于(B ). A. 系统故障 B. 事务故障C. 介质故障 D. 程序故障 选择题答案:(1) D (2) A (3) C (4) C (5) A(6) C (7) D (8) D (9) B 二,简答题 在数据库中为什么要并发控制 答:数据库是共享资源,通常有许多个事务同时在运行.当多个事务并发地存取数据库时就会产生同时读取和/或修改同一数据的情况.若对并发操作不加控制就可能会存取和存储不正确的数据,破坏数据库的一致性.所以数据库管理系统必须提供并发控制机制. 并发操作可能会产生哪几类数据不一致 用什么方法能避免各种不一致的情况 答: 并发操作带来的数据不一致性包括三类:丢失修改,不可重复读和读”脏”数据. 1) 丢失修改(Lost Update)两个事务T1和T2读入同一数据并修改,T2提交的结果破坏了(覆盖了)T1提交的结果,导致T1的修改被丢失.2) 不可重复读(Non-Repeatable Read)不可重复读是指事务T1读取数据后,事务T2执行更新操作,使T1无法再现前一次读取结果.3) 读”脏”数据(Dirty Read)读”脏”数据是指事务T1修改某一数据,并将其写回磁盘,事务T2读取同一数据后,T1由于某种原因被撤销,这时T1已修改过的数据恢复原值,T2读到的数据就与数据库中的数据不一致,则T2读到的数据就为”脏”数据,即不正确的数据.避免不一致性的方法和技术就是并发控制.最常用的并发控制技术是封锁技术.也可以用其他技术,例如在分布式数据库系统中可以采用时间戳方法来进行并发控制. 什么是封锁 答:封锁就是事务T在对某个数据对象例如表,记录等操作之前,先向系统发出请求,对其加锁.加锁后事务T就对该数据对象有了一定的控制,在事务T释放它的锁之前,其他的事务不能更新此数据对象. 封锁是实现并发控制的一个非常重要的技术. 基本的封锁类型有几种 试述它们的含义. 答:基本的封锁类型有两种: 排它锁(Exclusive Locks,简称X锁) 和共享锁(Share Locks,简称S锁). 排它锁又称为写锁.若事务T对数据对象A加上X锁,则只允许T读取和修改A,其他任何事务都不能再对A加任何类型的锁,直到T释放A上的锁.这就保证了其他事务在T释放A上的锁之前不能再读取和修改A. 共享锁又称为读锁.若事务T对数据对象A加上S锁,则事务T可以读A但不能修改A,其他事务只能再对A加S锁,而不能加X锁,直到T释放A上的S锁.这就保证了其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改. 什么是封锁协议 不同级别的封锁协议的主要区别是什么 答: 在运用封锁技术对数据加锁时,要约定一些规则.例如,在运用X锁和S锁对数据对象加锁时,要约定何时申请X锁或S锁,何时释放封锁等.这些约定或者规则称为封锁协议(Locking Protocol).对封锁方式约定不同的规则,就形成了各种不同的封锁协议.不同级别的封锁协议,例如《概论》中介绍的三级封锁协议,三级协议的主要区别在于什么操作需要申请封锁,何时申请封锁以及何时释放锁(即持锁时间的长短). 一级封锁协议:事务T在修改数据R之前必须先对其加X锁,直到事务结束才释放. 二级封锁协议:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁,读完后即可释放S锁. 三级封锁协议:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁,直到事务结束才释放. 不同封锁协议与系统一致性级别的关系是什么 答:不同的封锁协议对应不同的一致性级别. 一级封锁协议可防止丢失修改,并保证事务T是可恢复的.在一级封锁协议中,对读数据是不加S锁的,所以它不能保证可重复读和不读”脏”数据. 二级封锁协议除防止了丢失修改,还可进一步防止读”脏”数据.在二级封锁协议中,由于读完数据后立即释放S锁,所以它不能保证可重复读. 在三级封锁协议中,无论是读数据还是写数据都加长锁,即都要到事务结束时才释放封锁.所以三级封锁协议除防止了丢失修改和不读”脏”数据外,还进一步防止了不可重复读. 试述活锁的产生原因和解决方法. 答: 活锁产生的原因:当一系列封锁不能按照其先后顺序执行时,就可能导致一些事务无限期等待某个封锁,从而导致活锁. 避免活锁的简单方法是采用先来先服务的策略.当多个事务请求封锁同一数据对象时,封锁子系统按请求封锁的先后次序对事务排队,数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁. 请给出预防死锁的若干方法. 答: 在数据库中,产生死锁的原因是两个或多个事务都已封锁了一些数据对象,然后又都请求已被其他事务封锁的数据加锁,从而出现死等待. 防止死锁的发生其实就是要破坏产生死锁的条件.预防死锁通常有两种方法:(1)一次封锁法 要求每个事务必须一次将所有要使用的数据全部加锁,否则就不能继续执行.(2)顺序封锁法 预先对数据对象规定一个封锁顺序,所有事务都按这个顺序实行封锁.不过,预防死锁的策略不大适合数据库系统的特点. 请给出检测死锁发生的一种方法,当发生死锁后如何解除死锁 答: 数据库系统一般采用允许死锁发生,DBMS检测到死锁后加以解除的方法.DBMS中诊断死锁的方法与操作系统类似,一般使用超时法或事务等待图法. 超时法是:如果一个事务的等待时间超过了规定的时限,就认为发生了死锁.超时法实现简单,但有可能误判死锁,事务因其他原因长时间等待超过时限时,系统会误认为发生了死锁.若时限设置得太长,又不能及时发现死锁发生. DBMS并发控制子系统检测到死锁后,就要设法解除.通常采用的方法是选择一个处理死锁代价最小的事务,将其撤消,释放此事务持有的所有锁,使其他事务得以继续运行下去.当然,对撤销的事务所执行的数据修改操作必须加以恢复. 什么样的并发调度是正确的调度 答: 可串行化(Serializable)的调度是正确的调度. 可串行化的调度的定义:多个事务的并发执行是正确的,当且仅当其结果与按某一次序串行地执行它们时的结果相同,我们称这种调度策略为可串行化的调度. 试述两段锁协议的概念. 答: 两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁.在对任何数据进行读,写操作之前,首先要申请并获得对该数据的封锁; 在释放一个封锁之后,事务不再申请和获得任何其他封锁. “两段”的含义是,事务分为两个阶段: 第一阶段是获得封锁,也称为扩展阶段.在这阶段,事务可以申请获得任何数据项上的任何类型的锁,但是不能释放任何锁. 第二阶段是释放封锁,也称为收缩阶段.在这阶段,事务释放已经获得的锁,但是不能再申请任何锁. 为什么要引进意向锁 意向锁的含义是什么 答: 引进意向锁是为了提高封锁子系统的效率.该封锁子系统支持多种封锁粒度. 原因是:在多粒度封锁方法中一个数据对象可能以两种方式加锁—显式封锁和隐式封锁.因此系统在对某一数据对象加锁时不仅要检查该数据对象上有无(显式和隐式)封锁与之冲突;还要检查其所有上级结点和所有下级结点,看申请的封锁是否与这些结点上的(显式和隐式)封锁冲突;显然,这样的检查方法效率很低.为此引进了意向锁. 意向锁的含义是:对任一结点加锁时,必须先对它的上层结点加意向锁. 例如事务T要对某个元组加X锁,则首先要对关系和数据库加IX锁.换言之,对关系和数据库加IX锁,表示它的后裔结点—某个元组拟(意向)加X锁. 引进意向锁后,系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了.例如,事务T要对关系R加X锁时,系统只要检查根结点数据库和R本身是否已加了不相容的锁(如发现已经加了IX,则与X冲突),而不再需要搜索和检查R中的每一个元组是否加了X锁或S锁. 试述常用的意向锁:IS锁,IX锁,SIX锁,给出这些锁的相容矩阵. 答: IS锁 如果对一个数据对象加IS锁,表示它的后裔结点拟(意向)加S锁.例如,要对某个元组加S锁,则要首先对关系和数据库加IS锁 IX锁 如果对一个数据对象加IX锁,表示它的后裔结点拟(意向)加X锁.例如,要对某个元组加X锁,则要首先对关系和数据库加IX锁. SIX锁 如果对一个数据对象加SIX锁,表示对它加S锁,再加IX锁,即SIX = S + IX.相容矩阵(略) 理解并解释下列术语的含义:封锁,活锁,死锁,排它锁,共享锁,并发事务的调度,可串行化的调度,两段锁协议. 答:(略,已经在上面有关习题中解答) 试述你了解的某一个实际的DBMS产品的并发控制机制. 答:(略,参见《概论》第8节,简单介绍了有关Oracle的并发控制机制.) 第九章 数据库安全性一,选择题 以下( D)不属于实现数据库系统安全性的主要技术和方法. A. 存取控制技术 B. 视图技术C. 审计技术 D. 出入机房登记和加锁2. SQL中的视图提高了数据库系统的(D ). A. 完整性 B. 并发控制C. 隔离性 D. 安全性3. SQL语言的GRANT和REMOVE语句主要是用来维护数据库的(C ) A. 完整性 B. 可靠性C. 安全性 D. 一致性4. 在数据库的安全性控制中,授权的数据对象的( A),授权子系统就越灵活. A. 范围越小 B. 约束越细致C. 范围越大 D. 约束范围大 选择题答案:(1) D (2) D (3) C (4) A 三,简答题 什么是数据库的安全性 答:数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露,更改或破坏.2. 数据库安全性和计算机系统的安全性有什么关系 答: 安全性问题不是数据库系统所独有的,所有计算机系统都有这个问题.只是在数据库系统中大量数据集中存放,而且为许多最终用户直接共享,从而使安全性问题更为突出.系统安全保护措施是否有效是数据库系统的主要指标之一. 数据库的安全性和计算机系统的安全性,包括操作系统,网络系统的安全性是紧密联系,相互支持的,3. 试述实现数据库安全性控制的常用方法和技术. 答: 实现数据库安全性控制的常用方法和技术有: 1) 用户标识和鉴别:该方法由系统提供一定的方式让用户标识自己的名字或身份.每次用户要求进入系统时,由系统进行核对,通过鉴定后才提供系统的使用权.2) 存取控制:通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库,所有未被授权的人员无法存取数据.例如C2级中的自主存取控制(DAC),B1级中的强制存取控制(MAC);3) 视图机制:为不同的用户定义视图,通过视图机制把要保密的数据对无权存取的用户隐藏起来,从而自动地对数据提供一定程度的安全保护.4)审计:建立审计日志,把用户对数据库的所有操作自动记录下来放入审计日志中, DBA可以利用审计跟踪的信息,重现导致数据库现有状况的一系列事件,找出非法存取数据的人,时间和内容等.5) 数据加密:对存储和传输的数据进行加密处理,从而使得不知道解密算法的人无法获知数据的内容. 具体内容请参见《概论》9.2. 什么是数据库中的自主存取控制方法和强制存取控制方法 答:自主存取控制方法:定义各个用户对不同数据对象的存取权限.当用户对数据库访问时首先检查用户的存取权限.防止不合法用户对数据库的存取. 强制存取控制方法:每一个数据对象被(强制地)标以一定的密级,每一个用户也被(强制地)授予某一个级别的许可证.系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象. 解析: 自主存取控制中自主的含义是:用户可以将自己拥有的存取权限”自主”地授予别人.即用户具有一定的”自主”权.5. SQL语言中提供了哪些数据控制(自主存取控制)的语句 请试举几例说明它们的使用方法.答:SQL中 的自主存取控制是通过GRANT 语句和 REVOKE 语句来实现的.如:GRANT SELECT, INSERT ON Student TO 王平 WITH GRANT OPTION;就将Student表的SELECT和INSERT权限授予了用户王平,后面的”WITH GRANT OPTION”子句表示用户王平同时也获得了”授权”的权限,即可以把得到的权限继续授予其他用户. 12345678910111213141516REVOKE INSERT ON Student FROM 王平 CASCADE;```sql就将Student表 的INSERT权限从用户王平处收回,选项 CASCADE 表示,如果用户王平将 Student 的 INSERT 权限又转授给了其他用户,那么这些权限也将从其他用户处收回.6. 今有两个关系模式:职工(职工号,姓名,年龄,职务,工资,部门号)部门(部门号,名称,经理名,地址,电话号)请用SQL的GRANT和REVOKE语句(加上视图机制)完成以下授权定义或存取控制功能:(a) 用户王明对两个表有SELECT权力;```sqlGRANT SELECT ON 职工,部门TO 王明; (b) 用户李勇对两个表有INSERT和DELETE权力; 1GRANT INSERT,DELETE ON 职工,部门 TO 李勇 (c) 每个职工只对自己的记录有SELECT权力; 1GRANT SELECT ON 职工 WHEN USER()= NAME TO ALL 这里假定系统的GRANT语句支持WHEN子句和USER()的使用.用户将自己的名字作为ID.注意,不同的系统这些扩展语句可能是不同的.读者应该了解你使用的DBMS产品的扩展语句. (d) 用户刘星对职工表有SELECT权力,对工资字段具有更新权力; 12GRANT SELECT,UPDATE(工资) ON 职工TO 刘星; (e) 用户张新具有修改这两个表的结构的权力; 12GRANT ALTER TABLE ON 职工,部门TO 张新; (f) 用户周平具有对两个表所有权力(读,插,改,删数据),并具有给其他用户授权的权力; 1GRANT ALL PRIVILIGES ON 职工,部门 TO 周平 WITH GRANT OPTION; (g) 用户杨兰具有从每个部门职工中SELECT最高工资,最低工资,平均工资的权力,他不能查看每个人的工资.答:首先建立一个视图.然后对这个视图定义杨兰的存取权限. 123456CREATE VIEW 部门工资 ASSELECT 部门.名称,MAX(工资),MIN(工资),AVG(工资)FROM 职工,部门WHERE 职工.部门号 = 部门. 部门号GROUP BY 职工.部门号;GRANT SELECT ON 部门工资 TO 杨兰; 把习题8中(a)~(g) 的每一种情况,撤销各用户所授予的权力.答: (a) 12REVOKE SELECT ON 职工,部门FROM 王明 (b) 12REVOKE INSERT,DELETE ON 职工,部门FROM 李勇; (c) 123REOVKE SELECT ON 职工WHEN USER()= NAMEFROM ALL; 这里假定用户将自己的名字作为ID,且系统的REOVKE语句支持WHEN子句,系统也支持USER()的使用. (d) 12REVOKE SELECT,UPDATE ON 职工FROM 刘星; (e) 12REVOKE ALTER TABLE ON 职工,部门FROM 张新 (f) 12REVOKE ALL PRIVILIGES ON 职工,部门FROM 周平; (g) 123REVOKE SELECT ON 部门工资FROM 杨兰;DROP VIEW 部门工资; 为什么强制存取控制提供了更高级别的数据库安全性 答: 强制存取控制(MAC)是对数据本身进行密级标记,无论数据如何复制,标记与数据是一个不可分的整体,只有符合密级标记要求的用户才可以操纵数据,从而提供了更高级别的安全性. 理解并解释MAC机制中主体,客体,敏感度标记的含义. 答: 主体是系统中的活动实体,既包括DBMS所管理的实际用户,也包括代表用户的各进程.客体是系统中的被动实体,是受主体操纵的,包括文件,基表,索引,视图等.对于主体和客体,DBMS为它们每个实例(值)指派一个敏感度标记(Label).敏感度标记被分成若干级别,例如绝密(Top Secret),机密(Secret),可信(Confidential),公开(Public)等.主体的敏感度标记称为许可证级别(Clearance Level),客体的敏感度标记称为密级(Classification Level). 什么是数据库的审计功能,为什么要提供审计功能 答: 审计功能是指DBMS的审计模块在用户对数据库执行操作的同时把所有操作自动记录到系统的审计日志中. 因为任何系统的安全保护措施都不是完美无缺的,蓄意盗窃破坏数据的人总可能存在.利用数据库的审计功能,DBA可以根据审计跟踪的信息,重现导致数据库现有状况的一系列事件,找出非法存取数据的人,时间和内容等. 统计数据库中存在何种特殊的安全性问题 答: 统计数据库允许用户查询聚集类型的信息,如合计,平均值,最大值,最小值等,不允许查询单个记录信息.但是,人们可以从合法的查询中推导出不合法的信息,即可能存在隐蔽的信息通道,这是统计数据库要研究和解决的特殊的安全性问题. 试述你了解的某一个实际的DBMS产品的安全性措施. 答: 不同的DBMS产品以及同一产品的不同版本的安全措施各不相同,仁者见仁,智者见智,请读者自己了解.《概论》上9.4 简单介绍了有关ORACLE数据库的安全性措施. 第十章 数据库完整性一,选择题 完整性检查和控制的防范对象( A),防止它们进入数据库.(C)安全性控制的防范对象是(B ),防止他们对数据库数据的存取.(D) A. 不合语义的数据 B. 非法用户C. 不正确的数据 D. 非法操作2. 下述哪个是SQL语言中的数据控制命令( A). A. GRANT B. COMMITC. UPDATE D. SELECT3. 下述SQL语言中的权限,哪一个允许用户定义新关系时,引用其他关系的主码作为外码( C). A. INSERT B. DELETEC. REFERENCES D. SELECT 选择题答案:(1) A C B D (2) A (3) C 二,简答题 什么是数据库的完整性答:数据库的完整性是指数据的正确性和相容性. 数据库的完整性概念与数据库的安全性概念有什么区别和联系答:数据的完整性和安全性是两个不同的概念,但是有一定的联系. 前者是为了防止数据库中存在不符合语义的数据,防止错误信息的输入和输出,即所谓垃圾进垃圾出(Garbage In Garbage Out)所造成的无效操作和错误结果.后者是保护数据库防止恶意的破坏和非法的存取. 也就是说,安全性措施的防范对象是非法用户和非法操作,完整性措施的防范对象是不合语义的数据. 什么是数据库的完整性约束条件 可分为哪几类答:完整性约束条件是指数据库中的数据应该满足的语义约束条件.一般可以分为六类: 静态列级约束,静态元组约束,静态关系约束,动态列级约束,动态元组约束,动态关系约束. 静态列级约束是对一个列的取值域的说明,包括以下几方面: 对数据类型的约束,包括数据的类型,长度,单位,精度等 对数据格式的约束 对取值范围或取值集合的约束. 对空值的约束 其他约束 静态元组约束就是规定组成一个元组的各个列之间的约束关系,静态元组约束只局限在单个元组上. 静态关系约束是在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束.常见的静态关系约束有: 实体完整性约束. 参照完整性约束. 函数依赖约束. 动态列级约束是修改列定义或列值时应满足的约束条件,包括下面两方面: 修改列定义时的约束 修改列值时的约束 动态元组约束是指修改某个元组的值时需要参照其旧值,并且新旧值之间需要满足某种约束条件. 动态关系约束是加在关系变化前后状态上的限制条件,例如事务一致性,原子性等约束条件. 详细内容可以参见《概论》10.1中的介绍. DBMS的完整性控制机制应具有哪些功能 答:DBMS的完整性控制机制应具有三个方面的功能: 1) 定义功能,即提供定义完整性约束条件的机制.2) 检查功能,即检查用户发出的操作请求是否违背了完整性约束条件.3) 违约反应:如果发现用户的操作请求使数据违背了完整性约束条件,则采取一定的动作来保证数据的完整性. RDBMS在实现参照完整性时需要考虑哪些方面 答:RDBMS在实现参照完整性时需要考虑以下几个方面: 1) 外码是否可以接受空值 2) 删除被参照关系的元组时的考虑,这时系统可能采取的作法有三种: a) 级联删除(CASCADES);b) 受限删除(RESTRICTED);c) 置空值删除(NULLIFIES) 3) 在参照关系中插入元组时的问题,这时系统可能采取的作法有:a) 受限插入b) 递归插入 4) 修改关系中主码的问题 一般是不能用UPDATE语句修改关系主码的.如果需要修改主码值,只能先删除该元组,然后再把具有新主码值的元组插入到关系中. 如果允许修改主码,首先要保证主码的唯一性和非空,否则拒绝修改.然后要区分是参照关系还是被参照关系. 详细讨论可以参见《概论》10.2. 假设有下面两个关系模式: 职工(职工号,姓名,年龄,职务,工资,部门号),其中职工号为主码; 部门(部门号,名称,经理名,电话),其中部门号为主码; 用SQL语言定义这两个关系模式,要求在模式中完成以下完整性约束条件的定义:定义每个模式的主码;定义参照完整性;定义职工年龄不得超过60岁. 答 12345678910111213141516CREATE TABLE DEPT(Deptno NUMBER(2),Deptname VARCHAR(10),Manager VARCHAR(10),PhoneNumber Char(12)CONSTRAINT PK_SC PRIMARY KEY (Deptno));CREATE TABLE EMP(Empno NUMBER(4),Ename VARCHAR(10),Age NUMBER(2),CONSTRAINT C1 CHECK (Age《=60),Job VARCHAR(9),Sal NUMBER(7,2),Deptno NUMBER(2),CONSTRAINT FK_DEPTNOFOREIGN KEY (Deptno)REFERENCES DEPT(Deptno)); 关系系统中,当操作违反实体完整性,参照完整性和用户定义的完整性约束条件时,一般是如何分别进行处理的 答: 对于违反实体完整性和用户定义的完整性的操作一般都采用拒绝执行的方式进行处理.而对于违反参照完整性的操作,并不都是简单地拒绝执行,有时要根据应用语义执行一些附加的操作,以保证数据库的正确性.具体的处理可以参见上面第5题或《概论》10.2中相应部分. 试述你了解的某一个实际的DBMS产品的完整性控制策略. 答: 不同的DBMS产品以及同一产品的不同版本的完整性控制策略各不相同,读者要去了解某一个DBMS产品的完整性控制策略. 《概论》上10.3 简单介绍了有关ORACLE数据库的完整性控制策略. 第十二章 数据库技术新发展 试述数据库技术的发展过程. 答案要点: 1) 数据模型是数据库系统的核心和基础.数据库技术的三个发展阶段应该按照数据模型的进展来界定.按照数据模型的进展,数据库技术可以相应地分为三个发展阶段.2) 数据模型的发展经历了格式化数据模型(包括层次数据模型和网状数据模型),关系数据模型两个阶段,以面向对象数据模型为代表的非传统数据模型的阶段.3) 同学们可以从每一代数据库系统的主要特征,代表性系统,主要成就,优点和不足来了解数据库技术的发展过程. 层次数据库系统和网状数据库系统的数据模型虽然分别为层次模型和网状模型,但实质上层次模型是网状模型的特例.它们都是格式化模型.它们从体系结构,数据库语言到数据存储管理均具有共同特征,是第一代数据库系统. 关系数据库系统支持关系模型.关系模型不仅简单,清晰,而且有关系代数作为语言模型,有关系数据理论作为理论基础.因此,关系数据库系统具有形式基础好,数据独立性强,数据库语言非过程化等特色,标志着数据库技术发展到了第二代. 第二代数据库系统的数据模型虽然描述了现实世界数据的结构和一些重要的相互联系,但是仍不能捕捉和表达数据对象所具有的丰富而重要的语义,因此尚只能属于语法模型. 第三代的数据库系统将是以更加丰富的数据模型和更强大的数据管理功能为特征,从而满足传统数据库系统难以支持的新的应用要求. 当前数据库技术发展的主要特征是什么 答案要点: 新一代数据库技术的特点是: (1) 面向对象的方法和技术对数据库发展的影响最为深远,数据库研究人员借鉴和吸收了面向对象的方法和技术,提出了面向对象数据模型(简称对象模型).该模型克服了传统数据模型的局限性,促进了数据库技术在一个新的技术基础上继续发展. (2) 数据库技术与多学科技术的有机结合,计算机领域中其他新兴技术的发展对数据库技术产生了重大影响.传统的数据库技术和其他计算机技术如,网络通信技术,人工智能技术,面向对象程序设计技术,并行计算技术移动计算技术等的互相结合,互相渗透,使数据库中新的技术内容层出不穷. (3) 面向应用领域的数据库技术的研究在传统数据库系统基础上,结合各个应用领域的特点,研究适合该应用领域的数据库技术,如数据仓库,工程数据库,统计数据库,科学数据库,空间数据库,地理数据库等,这是当前数据库技术发展的又一重要特征. 解析我们可以用一个三维空间的视图,比较清晰地从数据模型,新技术内容,应用领域三个方面描述新一代数据库系统及其相互关系. 试述第一,二代数据库系统的主要成就. 答案要点: 第一代数据库系统指层次和网状数据库系统,其代表是: (1) 1969年IBM公司研制的层次模型的数据库管理系统IMS. (2) 美国数据库系统语言协商会CODASYL下属的数据库任务组DBTG对数据库方法进行了系统的研究,探讨,于20世纪60年代末70年代初提出了若干DBTG报告.DBTG 报告确定并建立了数据库系统的许多概念,方法和技术.DBTG所提议的方法是基于网状结构的.它是数据库网状模型的典型代表.在DBTG方法和思想的指引下数据库系统的实现技术不断成熟,开发了许多商品化的数据库管理系统,它们都是基于网状模型或层次模型的. 可以说,层次数据库是数据库系统的先驱,而网状数据库则是数据库概念,方法,技术的奠基.它们是数据库技术中研究得最早的两种数据库系统.支持关系数据模型的关系数据库系统是第二代数据库系统. 20世纪70年代是关系数据库理论研究和原型开发的时代,.其中以IBM San Jose研究室开发的System R和Berkeley大学研制的INGRES为典型代表.经过大量的高层次的研究和开发取得了一系列的成果,.主要是: (1) 奠定了关系模型的理论基础,给出了人们一致接受的关系模型的规范说明. (2) 研究了关系数据语言,有关系代数,关系演算,SQL语言及QBE等.这些描述性语言一改以往程序设计语言和网状,层次数据库系统中数据库语言的风格,以其易学易懂的优点得到了最终用户的喜爱,为20世纪80年代数据库语言标准化打下了基础. (3) 研制了大量的RDBMS的原型,攻克了系统实现中查询优化,并发控制,故障恢复等一系列关键技术.不仅大大丰富了DBMS实现技术和数据库理论,更重要的是促进了RDBMS产品的蓬勃发展和广泛应用. 在计算机领域中把20世纪70年代称为数据库时代.20世纪80年代几乎所有新开发的系统均是关系的.关系数据库系统从实验室走向了社会,数据库技术日益广泛地应用到企业管理,情报检索,辅助决策等各个方面,成为实现和优化信息系统的基础和基本技术. 第三代数据库系统的主要特点是什么 答:经过多年的研究和讨论,对第三代数据库系统的基本特征已有了共识. (1)第三代数据库系统应支持数据管理,对象管理和知识管理,除提供传统的数据管理服务外,第三代数据库系统将支持更加丰富的对象结构和规则,应该集数据管理,对象管理和知识管理为一体.由此可以导出第三代数据库系统必须支持OO数据模型. (2)第三代数据库系统必须保持或继承第二代数据库系统的技术,第三代数据库系统应继承第二代数据库系统已有的技术,.如第二代数据库系统的非过程化数据存取方式和数据独立性.不仅能很好的支持对象管理和规则管理,而且能更好地支持原有的数据管理,支持多数用户需要的即席查询等. (3)第三代数据库系统必须对其他系统开放数据库系统的开放性表现在:支持数据库语言标准;在网络上支持标准网络协议;系统具有良好的可移植性,可连接性,可扩展性和可互操作性等. 试述数据模型在数据库系统发展中的作用和地位. 答案要点: 1) 数据模型是数据库系统的核心和基础.2) 数据库的发展集中表现在数据模型的发展. 请用实例阐述数据库技术与其他学科的技术相结合的成果.答案要点: 数据库技术与其他学科的内容相结合,是新一代数据库技术的一个显著特征,涌现出各种新型的数据库系统.例如: 数据库技术与分布处理技术相结合,出现了分布式数据库系统; 数据库技术与并行处理技术相结合,出现了并行数据库系统; 数据库技术与人工智能技术相结合,出现了知识库系统和主动数据库系统; 数据库技术与多媒体技术相结合,出现了多媒体数据库系统; 数据库技术与模糊技术相结合,出现了模糊数据库系统; 等等. 请阐述以下数据库系统的主要概念,研究的主要问题及其发展过程: 分布式数据库系统,并行数据库系统,主动数据库系统,多媒体数据库系统,模糊数据库系统. 答案要点: 下面仅仅给出有关概念,它们研究的主要问题及其发展过程请参见教科书《概论》. 分布式数据库系统:分布式数据库是由一组数据组成的,这组数据分布在计算机网络的不同计算机上,网络中的每个结点具有独立处理的能力(称为场地自治),可以执行局部应用.同时,每个结点也能通过网络通信子系统执行全局应用. 并行数据库系统:并行数据库系统是在并行机上运行的具有并行处理能力的数据库系统.并行数据库系统是数据库技术与并行计算技术相结合的产物. 主动数据库系统:主动数据库是相对于传统数据库的被动性而言的.主动数据库能根据数据库的当前状态,主动适时地做出反应,执行某些操作,向用户提供有关信息.主动数据库是传统数据库技术与人工智能技术,面向对象技术相结合的产物. 多媒体数据库系统:可实现对格式化和非格式化的多媒体数据的存储,管理和查询的数据库系统. 模糊数据库系统:存储,组织,管理和操作模糊数据的数据库系统. 试述数据仓库的产生背景. 答案要点: 1) 数据库技术的发展和广泛应用使许多部门,企业积累了大量的原始数据,这些数据是宝贵的资源2) 对这些数据的分析和利用可以了解企业运行的情况,发现存在的问题,预测未来的趋势.3) 数据库系统作为数据管理的先进技术已经成功用于事务处理.但是它 对分析处理的支持一直不能令人满意,具体表现在:(1) 分析处理时性能低.(2) 分析的数据对象分散,而且不一致,即缺乏对数据的清洗,集成能力.(3) 事务处理系统不具备动态集成的能力.(4) 系统缺乏对历史数据的有效组织和存储能力,而分析方法必须以大量的历史数据为依托.(5) 在事务处理系统中存储的是细节数据,不适合进行分析处理,而事务处理系统又不具备对数据的综合能力. 总之,DSS对数据在空间和时间的广度上都有了更高的要求,.而事务处理环境难以满足这些要求.在事务型环境中直接构建分析型应用是一种失败的尝试.数据仓库正是为了构建这种新的分析处理环境而出现的一种数据存储和组织技术.但是数据仓库的主要驱动力并不是过去的缺点,而是市场商业经营行为的改变,市场竞争要求捕获和分析事务级的业务数据. 数据仓库数据的基本特征是什么 答案要点:四个基本特征是: · 数据仓库的数据是面向主题的· 数据仓库的数据是集成的· 数据仓库的数据是不可更新的· 数据仓库的数据是随时间不断变化的 什么是联机分析处理 什么是数据挖掘 答案要点: 联机分析处理OLAP是以海量数据为基础的复杂分析技术. OLAP支持各级管理决策人员从不同的角度,快速灵活地对数据仓库中的数据进行复杂查询和多维分析处理,并且能以直观易懂的形式将查询和分析结果提供给决策人员,以方便他们及时掌握企业内外的情况,辅助各级领导进行正确决策,提高企业的竞争力 数据挖掘是从超大型数据库(VLDB)或数据仓库中发现并提取隐藏在内的模式的过程,这些模式是有效的,新颖的,有潜在使用价值的和易于理解的.目的是帮助决策者寻找数据间潜在的关联,发现经营者被忽略的要素,而这些要素对预测趋势,决策行为也许是十分有用的信息. 基于数据库技术的DSS解决方案是什么 答: 基于数据库技术的DSS的解决方案是: DW+OLAP+DM DSS的可行方案 数据仓库,联机分析处理和数据挖掘是作为三种独立的信息处理技术出现的.数据仓库用于数据的存储和组织,OLAP集中于数据的分析,数据挖掘则致力于知识的发现.由于这三种技术内在的联系性和互补性,将它们结合起来是一种新的DSS构架.是DSS有效而可操作的整体解决方案. 什么是工程数据库 答: 工程数据库是一种能存储和管理各种工程设计图形和工程设计文档,并能为工程设计提供各种服务的数据库.主要应用于CAD/CAM,CIM,CASE等工程应用领域. 工程数据库中,由于传统的数据模型难以满足工程应用的要求,需要运用新的模型技术,如扩展的关系模型,语义模型,面向对象的数据模型. 工程数据库管理系统的功能与传统数据库管理系统有很大不同. 什么是统计数据库 答: 统计数据库是一种用来对统计数据进行存储,统计,分析的数据库系统. 统计数据具有层次型特点,但并不完全是层次型结构.统计数据也有关系型特点,但关系型也不完全满足需要.统计数据具有一些特殊的性质,例如: 1) 分类属性和统计属性2) 多维性3) 分类属性的层次结构4) 微数据和宏数据之分 统计数据库中常用的操作有:抽样,邻近搜索,估计与插值,转置,聚集及复杂的分析操作.这些操作不同于关系数据库中传统的查询,增加,删除,修改操作.人们希望能从DMBS一级来支持以上的数据特性和操作.因此,研究和发展了统计数据库技术. 统计数据库在安全性方面有特殊的要求,要防止某些用户在统计数据库中利用对统计数据(如综合数据)的合法查询推导出该用户无权了解的某一个体的具体数据. 什么是空间数据库 答: 空间数据库系统是描述,存储和处理空间数据及其属性数据的数据库系统. 空间数据是用于表示空间物体的位置,形状,大小和分布特征等诸方面信息的数据. 空间数据的特点是不仅包括物体本身的空间位置及状态信息,还包括表示物体的空间关系(即拓扑关系)的信息. 空间数据库是随着地理信息系统(GIS)的开发和应用而发展起来的数据库新技术.目前,空间数据库系统不是独立存在的系统,它是和应用紧密结合,大多数作为地理信息系统的基础和核心的形式出现. 空间数据库的研究涉及计算机科学,地理学,地图制图学,摄影测量与遥感,图像处理等多个学科.空间数据库技术研究的主要内容包括: 1) 空间数据模型2) 空间数据查询语言3) 空间数据库管理系统 等等. 第十三章 面向对象程数据库系统 面向对象程序设计的基本思想是什么 它的主要特点是什么 答案要点: 面向对象程序设计的基本思想是封装和可扩展性. 封装的特点: 面向对象程序设 计就是把数据结构和数据结构上的操作算法封装在一个对象之中. 对象是以对象名封装的数据结构和可施加在这些数据上的私有操作.对象的数据结构描述了对象的状态,对象的操作是对象的行为. 面向对象程序设计中,操作名列在封装对象的界面上,当其他对象要启动它的某个操作时,以操作名发一条消息,该对象接受消息,操作动作起来,完成对私有数据的加工.当一个面向对象的程序运行完毕时,各对象也就达到了各自的终态.输入,输出也由对象自己完成. 这种全封装的计算实体给软件带来了模块性,安全性等显著优点.因为它基本没有数据耦合,对象间没有因操作而产生的边界效应,出了错可以很快找到原因,所以易于维护和修改. 可扩展性的特点: 面向对象程序设计的可扩展性体现在继承性和行为扩展两个方面.因为对象具有一种层次关系.每个对象可以有子对象.子对象可以继承父对象(及其祖先对象)的数据结构和操作,继承的部分就可以重用.另一方面子对象还可以增加新的数据结构和新的操作.新增加的部分就是子对象对父对象发展的部分. 面向对象程序设计的行为扩展是指可以方便地增加程序代码来扩展对象的行为而不会影响该对象上的其他操作. 定义并解释OO模型中以下核心概念: 对象与对象标识,封装,类,类层次. 答案要点: 1) 对象与对象标识OID 现实世界的任一实体被模型化为一个对象,每个对象有一个唯一的标识,称为对象标识. 2) 封装 每一个对象是其状态与行为的封装,其中状态是该对象一系列属性值的集合,而行为是在对象状态上操作的集合,操作也称为方法.3) 类 共享同样属性和方法集的所有对象构成了一个对象类简称类,一个对象是某一类的一个实例.类的属性的定义域可以是任何类,即可以是基本类也可以是包含属性和方法的一般类,还也可是这个类自身.4) 类层次 在一个面向对象数据库模式中,可以定义一个类(如C1)的子类(如C2),类C1称为类C2的超类(或父类).子类(如C2)还可以再定义子类(如C3).这样,面向对象数据库模式的一组类形成一个有限的层次结构,称为类层次. 3.OO模型中对象标识与关系模型中的”码”有什么区别 答案要点: 对象标识具有永久持久性.一个对象一经产生系统就给它赋于一个在全系统中唯一的对象标识符,直到它被删除.对象标识是由系统统一分配的,用户不能对对象标识符进行修改.对象标识是稳定的,独立于值的,它不会因为对象中某个值的修改而改变. 关系模型中的”码”是值标识,不具有永久持久性,只具有程序内持久性.码是由用户建立的,用来区分关系的不同元组. 4.什么是单继承 什么是多重继承 继承性有什么优点 答案要点: 若一个子类只能继承一个超类的特性(包括属性,方法和消息),这种继承称为单继承;若一个子类能继承多个超类的特性,这种继承称为多重继承. 继承性优点: 1) 它是建模的有力工具,提供了对现实世界简明而精确的描述.2) 它提供了信息重用机制.由于子类可以继承超类的特性,这就可以避免许多重复定义. 什么是操作的重载 在OODB中为什么要滞后联编 答案要点:在OO模型中对于同一个操作,可以按照类的不同,重新定义操作的实现,这称为操作的重载.这样,同一个操作名就与不同的实现方法,与不同的参数相联系. 为了提供这个功能,OODBMS不能在编译时就把操作名联编到程序上,必须在运行时根据实际请求中的对象类型和操作来选择相应的程序,把操作名与它联编上(即把操作名转换成该程序的地址),这个推迟的转换称为滞后联编. 什么是OODB模式演进 为什么面向对象数据库模式的修改要比关系模式的修改复杂得多 答案要点: 面向对象数据库模式是类的集合.模式为适应需求的变化会随着时间而变化,这称为模式演进.模式演进包括创建新的类,删除旧的类,修改类的属性和操作等. 面向对象数据库模式的修改要比关系模式的修改复杂的原因是: 1) 模式改变频繁使用OODB系统的应用通常需要频繁地改变OODB数据库模式.例如OODB常运用于工程设计环境中,设计环境特征之一就是不断变化.2) 模式修改复杂OO模型具有很强的建模能力和丰富的语义,包括类本身的语义,类属性之间和类之间丰富的语义联系,这使得模式修改操作的类型复杂多样.3) OODB中模式演进往往是动态的,使得实现技术更加复杂. 什么是对象-关系数据库 它的主要特点是什么 常用的实现方法有哪些 答案要点: 对象-关系数据库系统是将关系数据库系统与面向对象数据库系统两方面的特征相结合,不仅支持核心的面向对象数据模型,而且支持传统数据库系统所具有的特征. 主要特点有: 1) 具有原来关系数据库的各种特点;2) 扩充数据类型;3) 支持复杂对象;4) 支持继承的概念;5) 提供通用的规则系统; 实现对象-关系数据库系统的方法主要有以下五类. 1) 从头开发对象-关系DBMS. 2) 在现有的关系型DBMS基础上进行扩展.扩展方法有两种:a) 对关系型DBMS核心进行扩充,逐渐增加对象特性.b) 不修改现有的关系型DBMS核心,而是在现有关系型DBMS外面加一个包装层. 3) 将现有的关系型DBMS与其他厂商的对象-关系型DBMS连接在一起,使现有的关系型DBMS直接而迅速地具有了对象-关系特征.连接方法主要有两种:a) 关系型DBMS使用网关技术与其他厂商的对象-关系型DBMS连接.b) 将对象-关系型引擎与关系型存储管理器结合起来,即以关系型DBMS作为系统的最底层,对象-关系型系统作为上层.4) 将现有的OO型DBMS与其他厂商的对象-关系型DBMS连接在一起,使现有的面向对象型DBMS直接而迅速地具有了对象-关系特征. 5) 扩充现有的面向对象的DBMS,使之成为对象-关系型DBMS. 第十四章 分布式数据库系统 什么样的数据库系统是分布式数据库系统 图14.1的系统配置在什么情况下只能算分散的数据库系统 在什么条件下才是分布式数据库系统 答案要点: 分布式数据库是由一组数据组成的,这组数据分布在计算机网络的不同计算机上,网络中的每个结点具有独立处理的能力(称为场地自治),可以执行局部应用.同时,每个结点也能通过网络通信子系统执行全局应用. 分布式数据库定义的要点:分布性,逻辑整体性,自治性和协作性. 解析: 1) 分布性,数据库中的数据不是存储在同一场地上,这就可以和集中式数据库相区别.2) 逻辑整体性,这些数据逻辑上是互相联系的,是一个整体,逻辑上如同集中数据库.3) 自治性,分布数据库中每个结点上的DBMS具有独立处理的能力(如果没有连入网络,也是一个完整的DBMS).4) 协作性,分布数据库中各个结点上的DBMS能相互协调,执行全局应用. 答案要点: 《概论》图14.1中,如果用户既可以通过客户机对本地服务器中的数据库执行局部应用,也可以对两个或两个以上结点中的数据库执行全局应用,这样的系统是分布式数据库系统.不支持全局应用的系统不能称为分布式数据库系统,即只是分散的数据库系统. (详细说明参见《概论》14.1.1) 分布式数据库系统有什么特点 答案要点: 分布式数据库系统是在集中式数据库系统技术的基础上发展起来的,但不是简单地把集中式数据库分散地实现,它是具有自己的性质和特征的系统.数据独立性:除了数据的逻辑独立性与物理独立性外,还具有数据分布独立性亦称分布透明性. 集中与自治相结合的控制结构:各局部的DBMS可以独立地管理局部数据库,具有自治的功能.同时又有集中控制机制,协调各局部DBMS的工作,执行全局应用. 数据可以适当冗余以提高系统的可靠性,可用性和性能. 全局的一致性,可串行性和可恢复性.分布式数据库系统中各局部数据库应满足集中式数据库的一致性,并发事务的可串行性和可恢复性.除此以外还应保证数据库的全局一致性,全局并发事务的可串行性和系统的全局可恢复性. (详细说明参见《概论》14.1.2). 试述研制分布式数据库系统的目的和动机. 答案要点:研制分布式数据库系统的目的和动机,主要包括技术和组织两方面. 适应部门分布的组织结构,降低费用;提高系统的可靠性和可用性;充分利用数据库资源,提高数据库的利用率和共享程度;逐步地扩展系统处理能力和系统规模. (详细说明参见《概论》14.1.3). 试述分布式数据库系统的模式结构. 答案要点: 分布式数据库系统的模式结构可以分为两大部分:集中式数据库系统的模式结构和分布式数据库系统增加的模式级别,其中包括: 1) 全局外模式,它们是全局应用的用户视图,是全局概念模式的子集.2) 全局概念模式,它定义分布式数据库中数据的整体逻辑结构,使得数据如同没有分布一样.3) 分片模式,定义片段以及全局关系到片段的映象.4) 分布模式,定义片段的存放结点.分布模式的映象类型确定了分布式数据库是冗余的还是非冗余的. (详细可参考《概论》图14.3分布式数据库系统的模式结构). 什么是数据分片 有几种分片方式 数据分片的目的是什么 有什么优点 答案要点: 数据分片就是将数据表按照一定条件划分成若干子集,每个子集称为一个片段.分片的方式有多种,水平分片和垂直分片是两种基本的分片方式,混合分片和导出分片是较复杂的分片方式. 水平分片是指按一定的条件将关系表按行(水平方向)分为若干不相交的子集,每个子集为关系的一个片段. 垂直分片是指将关系按列(垂直方向)分为若干子集.垂直分片的各个片段都要包含关系的码.这样才能从各个片段重构原来的关系. 导出分片是指导出水平分片,即水平分片的条件不是本身属性的条件而是其他关系的属性的条件. 混合分片是指按上述三种分片方式得到的片段继续按另一种方式分片. 数据分片的优点是:数据不是按照关系而是按片段来存放,有利于更好地根据用户需求来组织数据的分布,也有利于控制数据的冗余度. 试述分布透明性的内容. 答案要点: 分布透明性包括分片透明性,位置透明性和局部数据模型透明性. 分片透明性指用户或应用程序只对全局关系进行操作而不必考虑关系的分片.当分片模式改变了,由于全局模式到分片模式的映象,全局模式不变,应用程序不必改写. 位置透明性指用户或应用程序不必了解片段的存储场地,当存储场地改变了,由于分片模式到分布模式的映象,应用程序不必改变.同时,若片段的重复副本数目改变了,数据的冗余度改变了,用户也不必关心如何保持各副本的一致性,这就是重复副本的透明性. 局部数据模型透明性指用户或用户程序不必了解局部场地上使用的是哪种数据模型. 什么是同构型D-DBMS 什么是异构型D-DBMS 答案要点: D-DBMS的同构和异构可以有三级:硬件级,操作系统级和局部DBMS级.其中最主要的是局部DBMS这一级,因为硬件和操作系统的不同将由通信软件处理和管理.所以,同构型D-DBMS定义为:在分布数据库系统中若每个结点的局部数据库具有相同的DBMS则成为同构型D-DBMS;若各结点的局部数据库具有不同的DBMS,则成为异构型的D-DBMS. (详细说明参见《概论》14.2.4) 设在《概论》14.2.3节的分布式数据库系统例子中,还有全局关系SC(SNO,CNO,G),它具有两个导出分片SC_A,SC_B,分别存储理学院和文学院学生的选课记录.SC_A存放在场地4,SC_B存放在场地5.今有一个稍复杂的查询,从终端输入一个课程号,查找选修该课程的学生学号和姓名,并把它们显示在屏幕上.请写出具有不同层次分布透明性(类比例子中的三种情况)的应用程序.不必给出细节,只需写出算法思想. 情况1 若系统具有分片透明性,则 123456Scanf(〃% s〃,SCnumber); /*从终端读入课程号到变量SCnumber中 */EXEC SQL SELECT Sno,Sname INTO :SNO, :NAME/ * SNO,NAME为程序变量*/FROM SC,Student /*在全局关系SC,Student中查找*/WHERE SC.Cno =:SCnumber AND SC.Sno=Student.Sno;Printf(〃% s,% s〃,SNO,NAME); /*把SNO,NAME输出在屏幕上*/ 情况2 若系统具有位置透明性,但不具有分片透明性,则 12345678910Scanf(〃% s〃,SCnumber);EXEC SQL SELECT Sno,Sname INTO :SNO, :NAMEFROM SC_A,S_AWHERE SC_A.Cno =:SCnumber AND SC_A.Sno=S_A.Sno;If(! FOUND){EXEC SQL SELECT Sno,Sname INTO :SNO, :NAMEFROM SC_B,S_BWHERE SC_B.Cno =:SCnumber AND SC_B.Sno=S_B.Sno;}Printf(〃% s,% s〃,SNO,NAME); 情况3 若系统只具有局部数据模型透明性,不具有位置透明性(当然也就不具有分片透明性),则 12345678910111213Scanf(〃% s〃,SCnumber);EXEC SQL SELECT Sno,Sname INTO :SNO,:NAMEFROM SC_A AT Site4, S_A AT Site1/*先在场地4的片段SC_A和场地1的片段S_A中查找*/WHERE SC_A.Cno =:SCnumber AND SC_A.Sno=S_A.Sno;If(! FOUND){EXEC SQL SELECT Sno,Sname INTO :SNO,:NAMEFROM SC_B AT Site5,S_B AT Site2/*再在场地5的片段SC_B和场地2的片段S_B中查找*//*也可以在场地5的片段SC_B和场地3的片段S_B中查找*/WHERE SC_B.Cno =:SCnumber AND SC_B.Sno=S_B.Sno;}Printf(〃% s,% s〃,SNO,NAME); 试述下列概念:两段提交协议(2PC);分布事务的原子性;全局死锁. 答案要点:2PC:2PC把一个分布事务的事务管理分为协调者和参与者.2PC的第一阶段:协调者向所有参与者发出”准备提交”信息.如果某个参与者准备提交,就回答”就绪”信息,否则回答”撤销”信息.参与者在回答前,应把有关信息写入自己的日志中.协调者在发出准备提交信息前也要把有关信息写入自己的日志中.如果在规定时间内协调者收到了所有参与者”就绪”的信息,则将作出提交的决定,否则将作出撤销的决定. 2PC的第二阶段:协调者将有关决定的信息先写入日志,然后把这个决定发送给的所有的参与者.所有参与者收到命令之后首先往日志中写入”收到提交(或撤销)”决定的信息,并向协调者发送”应答(ACK)”消息,最后执行有关决定.协调者收到所有参与者的应答消息后,一个事务的执行到此结束,有关日志信息可以脱机保存. 分布事务的原子性:分布事务的原子性就应该是:组成一个全局事务的所有子事务要么一致地全部提交,要么一致地全部滚回. 全局死锁:全局事务执行时发生的涉及两个以上场地上的死锁. 在分布式数据库系统中,对多副本的封锁有几种解决方法 处理多副本的封锁可采取如下几种方法: 1) 对写操作,要申请对所有副本的X锁.对于读操作,只要申请对某个副本的S锁.2) 无论是写操作还是读操作都要对多数(大于半数)副本申请X锁或S锁.3) 规定某个场地上的副本为主副本,所有的读写操作均申请对主副本的封锁. 第十五章 并行数据库系统 什么是并行数据库系统 答案要点:并行数据库系统是在并行机上运行的具有并行处理能力的数据库系统.并行数据库系统是数据库技术与并行计算技术相结合的产物. 试述并行数据库系统的研制目标. 答案要点: 并行数据库系统该实现如下目标: 1) 高性能并行数据库系统通过将数据库管理技术与并行处理技术有机结合,发挥多处理机结构的优势,提供比相应的大型机系统更高的性能价格比和可用性.2) 高可用性并行数据库系统可通过数据复制来增强数据库的可用性.3) 可扩充性系统通过增加处理和存储能力来平滑地扩展性能,应具有线性伸缩比和线性加速比. 具体说明可参考《概论》15.2. 什么是并行数据库系统的伸缩比和加速比 答案要点: 线性伸缩比是指当任务扩大N倍,系统处理和存储能力也扩大N倍时系统性能不变.线性伸缩比=(小任务在小系统上的运行时间)/(大(N倍)任务在大任务上的运行时间)=1线性加速比是指当任务不变而系统处理和存储能力扩大N倍时,系统性能也提高N倍.线性加速比=(小系统上执行一个任务的时间)/(大(N倍)系统上执行同一任务的时间)=N 并行数据库系统有哪几种体系结构 试比较它们的特点. 答案要点:从硬件结构来看,根据处理机与磁盘,内存的相互关系可以将并行计算机分为三种基本的体系结构: ·共享内存结构(SM);·共享磁盘结构(SD);·无共享资源结构(SN). 此外还有混合结构,即整个系统是Shared_Nothing结构而每个结点是Shared_Memory结构.这种结构综合了SM与SN的优点. 1) SM并行结构SM并行结构由多个处理机,一个共享内存(主存储器)和多个磁盘存储器构成.多处理机和共享内存由高速通讯网络连接,每个处理机可直接存取一个或多个磁盘,即所有内存与磁盘为所有处理机共享.2) SD并行结构SD并行结构由多个具有独立内存的处理机和多个磁盘构成.每个处理机都可以读写任何磁盘.3) SN并行结构SN并行结构由多个处理节点构成.每个处理节点具有自己独立的处理机,内存和磁盘存储器.多个处理机结点由高速通信网络连接. 并行数据库系统中并行查询优化的必要性和困难何在 答案要点: 查询优化始终是数据库管理系统的重要组成部分,查询优化的目标在于提高执行效率.由于并行数据库环境中存在多个处理机,并行查询优化应尽可能地使每个操作并行处理,充分利用系统资源提高并行度来达到提高系统性能的目的.并行查询优化面临的两大困难在于: 1) 执行计划的搜索空间十分庞大2) 执行时的某些系统参数比如CPU数目,内存大小在优化时是未知的. 试述数据划分在并行查询处理中的重要性. 答案要点: 数据划分是并行查询处理的重要基础.研究和实际表明,数据划分对于并行数据库系统的性能具有很大的影响. 通过将每个关系的数据划分为小的片段,并把这些小片段均匀地分布在系统的多个磁盘驱动器上可以降低数据的聚集度,使得每个操作能够由多个处理机来承担,从而减少查询的响应时间并提高整个系统的吞吐量.若负载不均,往往会造成多个处理机结点能力的浪费.所以使用正确的数据分布算法以达到负载均衡是并行数据库中数据分布的关键问题. 7.并行数据库系统中有哪几种常用的数据划分方法 答案要点: 划分数据时可以依据一个属性的值,也可以同时依据多个属性的值,前者称为一维数据划分,后者则称为多维数据划分. 一维数据划分方法相对比较简单,常用的数据划分方法有: ·轮转法·Hash法·值域划分法 此外,还有用户定义的划分法,模式划分法,Hybrid_Range划分法等. 试述并行数据库系统与分布式数据库系统的区别. 答案要点: 分布式数据库系统与并行数据库系统特别是与SN结构的并行数据库系具有很多相似点: 1) 它们都是用网络连接各个数据处理结点;2) 整个网络中的所有结点构成一个逻辑上统一的整体;3) 用户可以对各个结点上的数据进行透明存取等等. 分布式数据库系统和并行数据库系统的应用目标和具体实现方法不同,使得它们具有很大的不同: 4) 应用目标不同 并行数据库系统的目标是充分发挥并行计算机的优势,利用各个处理机结点并行地完成任务,提高系统的整体性能.分布式数据库系统的目标是实现场地自治和数据的全局透明共享,而不要求利用网络中的各个结点来提高系统处理性能. 5) 实现方式不同 在并行数据库系统中各结点间采用高速网络互连,结点间的数据传输代价相对较低,因此当某些结点处于空闲状态时,可以将工作负载过大的结点上的部分任务通过高速网传送给空闲结点处理,从而实现系统的负载平衡. 在分布式数据库系统中,各结点间一般采用局域网或广域网相连,网络带宽较低,点到点的通信开销较大,因此在查询处理时一般应尽量减少结点间的数据传输量. 6) 各结点的地位不同 在并行数据库系统中,不存在全局应用和局部应用的概念.各结点是非独立的. 而在分布式数据库系统中,各结点除了能通过网络协同完成全局事务外,更重要的是各结点具有场地自治性.","link":"/posts/SQLtest.html"},{"title":"SQL 范式","text":"SQL范式 数据库基本概念要理解范式，首先必须对知道什么是关系数据库，简单的说：关系数据库就是用二维表来保存数据。 概念 实体现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，不如说“老师与学校的关系”。 字段 就是一项数据，也就是我们平常所说的“列”。 记录 一个实体的一个实例所特有的相关数据项的集合，也就是我们平常所说的“行”。 码 表中可以唯一确定一个元组的某个属性（或者属性组），如果这 样的码有不止一个，那么大家都叫 候选码，我们从候选码中挑一个出 来做老大，它就叫主码。 主码 被数据库设计者选中的，用来在同一实体集中区分不同实体的&gt; 候选码；此外，应该选择哪些从不或极少变化的属性； 键 可唯一标识一条记录的一个字段或字段集，有时翻译为“码”。 主键（primary key)用于唯一标识一个表中的一条记录的键。每个主键应该具有下列特征： 唯一的。 最小 的（尽量选择最少键的组合）。 非空。 不可更新的（不能随时更改） 外键（foreign keys 对连接父表和子表的相关记录的主键字段的复制。 依赖表（dependent table) 也称为弱实体（weak entity）是需要用父表标识的子表。 关联表（associative table） 是多对多关系中两个父表的子表。 实体完整性 每个表必须有一个有效的主 键。 参照完整性 没有不相匹配的外键值。 属性 教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。 元组 表中的一行就是一个元组。 分量 元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。 候选码 如果任意超码的真子集不能包括超码，则称其为候选码；超码包括候选码； 候选码 若关系中的某一属性或属性组的值能唯一的标识一个元组，&gt; 而其任何真子集都不能再标识，则称该属性组为（超级码）候选码。 全码 如果一个码包含了所有的属性，这个码就是全码。 主属性(码属性) 一个属性只要在任何一个候选码中出现过，这个属性就是主属性。 非主属性(非码属性) 与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。 超码 一个或多个属性的集合，这些属性的组合可以使我们在一个实&gt; 体集中唯一的标识一个实体。 外部码 一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。 范式概念(数据库设计范式，数据库的设计范式）是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式。 满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。 第一范式(1NF)如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF（即R符合第一范式）。简单的说，就是每一个列（属性）只有一个，没有重复。 特点 有主键，且主键不能为空。 字段不能再分。 要求 1.必须有主键来加以识别。 2.每个字段只能存放单一的值并确保有数据没有重复的组。 例如： 姓名 班级 课程 小明 1班 数学,语文 小红 2班 英语 小明 2班 数学 里面还有重复组并且没有存放单一的值，并不符合第一范式，给其增加主键学号加以区别： 学号 姓名 班级 课程 101 小明 1班 数学 101 小明 1班 语文 201 小红 2班 英语 202 小明 2班 数学 第二范式(2NF)概念 首先要满足第一范式。它的规则是要求数据表里的所有数据都要和该数据表的主键有完全依赖关系。 若关系模式R€1NF，并且每一个 非主属性 都 完全函数依赖 于 R 的 候选吗，则R€2NF。 判断方法：是否存在某个非主属性，它部分依赖候选码，或者说依赖候选码的一部分，存在则属于2NF。 特点 满足第一范式。 表中的每一个非主属性，必须完全依赖于本表码。 只有当一个表中，主码由两个或以上的属性组成的时候，才会出现不符合第二范式的情况 例如有表：|货物|供应商ID|供应商|价格|供应商地址||:—|:—|:—|:—|:—|:—||毛巾|01|世纪联华|10.0|星光大道||牙刷|01|世纪联华|5.0|星光大道||毛巾|02|十足|12.0|月光大道| 可知，这里的主键有货物和供应商ID，价格和两个主键都有关，可是供应商地址只和供应商ID有依赖关系。那么不符合第二范式，我们可以将其修改为两张表： 供应商ID 供应商 供应商地址 01 世纪联华 星光大道 02 十足 月光大道 货物 供应商ID 价格 毛巾 01 10.0 牙刷 01 5.0 毛巾 01 12.0 这样就符合了第二范式要求的表内数据和表内主键完全依赖的关系。 第三范式(3NF)概念 在第二范式的基础上，要求所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。 若关系模式R€1NF,并且每一个 非主属性 都非传递依赖 于 候选码，R€3NF。 判断方法： 是否存在某个非主属性，它传递依赖候选码或者函数依赖某个非主属性，存在则不属于3NF，不存在则属于3NF。 特点： 满足第二范式。 非主属性不能传递依赖于码 从上述表来说，供应商和供应商地址是相关的，知道了供应商也就知道了供应商地址（不考虑一厂多址的情况）。可以分为： 供应商ID 供应商 01 世纪联华 02 十足 供应商ID 供应商地址 01 星光大道 02 月光大道 BC范式(BCNF)概念 BCNF是修正的第三范式。 若关系模式R€1NF，对每个非平凡的函数依赖X–&gt;Y，X一定是超码（具有唯一性） 判断方法： 能够找到平凡函数依赖 X—&gt;Y，左边的X不是超码 BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了任何属性(不光是非主属性，2NF和3NF所限制的都是非主属性)对候选键的传递依赖与部分依赖。 要求：在满足第三范式的基础上，且不允许主键的一部分被另一部分或其它部分决定。特点： 满足第三范式。 所有非主属性对每一个码都是完全函数依赖。 所有的主属性对每一个不包含它的码，也是完全函数依赖。 没有任何属性完全函数依赖于非码的任何一组属性。 参考 转载来源1 转载来源2","link":"/posts/SQLnfs.html"},{"title":"SQL 函数赖与模式分解","text":"函数依赖 Functional Dependency数据依赖的一种，它反映属性或属性组之间相依存，互相制约的关系，即反映现实世界的约束关系。 定义设R(U)是属性U上的一个关系模式，X和Y均为U={A1，A2，…，An}的子集，r为R的任一关系，如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X，记为X→Y。 例： 1234(sno-学生ID，tno-教师ID，cno-课程ID，sname-学生姓名，tname-教师姓名，cname-课程名称，grade-成绩）sno→sname, cno→cname,(sno,cno)→grade √sname→sno, tno→cno, sno→tname × 函数依赖是语义范畴 语义：数据所反映的现实世界事物本质联系 根据语义来确定函数依赖性的存在与否 函数依赖反映属性之间的一般规律，必须在关系模式下的任一个关系r中都满足约束条件。 属性间的联系决定函数依赖关系例子设X、Y均是U的子集 X和Y间联系是1:1，则X→Y,Y→X。（相互依赖，可记作X←→Y） X和Y间联系是M:1(M)， 则X→Y。 X和Y间联系是M:N(M,N)，则X、Y间不存在函数依赖。 完全函数依赖和部分函数依赖函数依赖分为完全函数依赖和部分函数依赖 定义 在R(U)中，如果X→Y，并且对于X的任何真子集X’都有X’Y’，则称 Y 完全依赖于 X ，记作X→Y；否则，如果X→Y，且X中存在一个真子集X’，使得X’→Y成立，则称 Y 部分依赖 于 X。 例 123456学生ID，学生姓名，所修课程ID，课程名称，成绩（学生ID，所修课程ID）→成绩成绩既不能单独依赖于学生ID，也不能单独依赖于所修课程ID，因此成绩完全函数依赖于关键字。（学生ID，所修课程ID）→学生姓名学生ID→学生姓名学生姓名可以依赖于关键字的一个主属性——学生ID，因此学生姓名部分函数依赖于（学生ID，所修课程ID）。 平凡函数依赖和非平凡函数依赖平凡函数依赖 当关系中属性集合Y是属性集合X的子集时(Y?X)，存在函数依赖X→Y，即一组属性函数决定它的所有子集，这种函数依赖称为 平凡函数依赖 非平凡函数依赖 当关系中属性集合Y不是属性集合X的子集时，存在函数依赖X→Y，则称这种函数依赖为 非平凡函数依赖。 设X，Y均为某关系上的属性集，且X→Y 若Y包含于X，则称X→Y为：平凡函数依赖；(Sno, Cno) → Sno (Sno, Cno) → Cno 若Y不包含于X，则称X→Y为：非平凡函数依赖。(Sno, Cno) → GradeY包含于X内，W于X相交，与Y无直接交集。则：X→Y为平凡函数依赖X→W, W→Y为非平凡函数依赖 传递函数依赖 X→Y，Y→Z 则Z传递函数依赖于X例1设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。 函数依赖设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。X称为这个函数依赖的决定属性集(Determinant)。Y=f(x) 说明： 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。 函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。例如“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立 数据库设计者可以对现实世界作强制的规定。例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝装入该元组。 例2Student(Sno, Sname, Ssex, Sage, Sdept) 假设不允许重名，则有: 123456Sno → Ssex， Sno → Sage , Sno → Sdept，Sno ←→ Sname, Sname → Ssex， Sname → SageSname → Sdept但Ssex －\\→Sage若X→Y，并且Y→X, 则记为X←→Y。若Y不函数依赖于X, 则记为X－\\→Y。 在关系模式R(U)中，对于U的子集X和Y， 12如果X→Y，但Y 不为 X的子集，则称X→Y是非平凡的函数依赖若X→Y，但Y 为 X的子集, 则称X→Y是平凡的函数依赖 例3在关系SC(Sno, Cno, Grade)中 凡函数依赖:(Sno, Cno) → Grade 平凡函数依赖：(Sno, Cno) → Sno(Sno, Cno) → Cno 部分函数依赖：若x-&gt;y 并且，存在X的真子集x1，使得x1-&gt;y,则 y部分依赖于 x。 完全函数依赖：若x-&gt;y并且，对于x的任何一个真子集x1，都不在x1-&gt;y 则称y完全依赖于x 传递与直接函数依赖概念设有两个非平凡函数依赖 X → Y，Y → Z，当 X 不依赖于 Y，则称 Z传递函数依赖于 X。-这里之所以规定” X 不函数依赖于 Y”，是因为当 Y → X 时，X 与 Y 就一一对应了，在这种情况下 Z 就直接函数依赖于 X（而不是我们所说的传递函数依赖）。 Z 传递函数依赖于 X，表名 Z 间接依赖于 X，从而表明 X 和 Z 之间关联较弱。 函数依赖的 Armstrong 公理无冗余的函数依赖集 和 函数依赖的完备集（闭包）是好的关系设计。由已知的函数依赖集可以推导出 无冗余的函数依赖集 和 函数依赖的完备集（闭包）。 基本公理和推理规则：基本公理： 自反律如果 Y ∈ X∈ U，则 X → Y 成立。（平凡函数依赖） 增广律如果 X → Y 在 R(U) 成立，且 Z∈ U，则 XZ → XY 传递律如果 X → Y，Y → Z 成立，则 X → Z 成立。 推理规则： 合并规则{X → Y，X → Z}，则 X → YZ 分解规则{X → Y，Z ∈ Y}，则 X → Z。（或：X → YZ，那么 X → Y，X → Z） 伪传递规则 {X → Y,YW → Z}，则 WX → Z 复合规则{X → Y，W → Z},则 XW → YZ 自积律规则{X → YZ，Z → W}，则 X → YZW 属性闭包概念 设 F 是属性集合 U 上的一个函数依赖集，X ∈ U，称 X+ = { A|: A∈U,X → A 由 F 按照 Armstrong 公理系统推导得到 } 为属性集的 x 关于 F 的闭包。 例子：设有关系模式 R（U，F），U = ABC，F={A→B，B → C}，则有 A 的闭包 A+ = ABC，B+=BC，C+=C。 函数依赖闭包和属性集闭包 一般来说，我们很少会求函数依赖闭包，因为这样会产生大量“无意义”或者意义不大的函数依赖。多数时候，我们关心的只是 F+ 的一个子集，常常伴随的问题是某函数依赖 X → Y 是否在 F+中。而求解这个问题的解决方式，通常是求在 F 下，属性集合 X 的闭包 X+（至于其证明，有兴趣的可以查阅一下相关资料）。 如何求解 X 的属性闭包： 设置初始值：令X(0) = ?，X(1)= X，F’=?。 若X(0)≠X(1),令 X(0)=X(1)。否则转向 4）。 构造函数依赖集合 F’={Y→Z | (Y→Z)∈F∩Y∈X(1)}，令 F = F – F’,对于其中的每个函数依赖 Y→Z，令X(1) = X(1)∪Z，转向 2）。 输出 X(1),它就是X+ 最小函数依赖集概念对于函数集 F ，称函数集Fmin 为F 的最小函数依赖集，如果 Fmin满足一下条件： Fmin与 F等价：Fmin+=F+。 Fmin中每个函数依赖 X→Y 的依赖因素为单元素集，即Y中只含有一个属性集合。 Fmin中每个函数依赖 X→Y的决定因素不存在冗余，即既要删除X中任何一个属性，就会改变Fmin的闭包。 Fmin中每个函数毒不是冗余的，即删除 Fmin 中任意一个函数依赖，就会改变Fmin 的闭包。 无损分解概念 无损分解指的是对关系模式分解时，原关系模型下任一合法的关系值在分解之后应能通过自然联接运算恢复起来。反之，则称为有损分解。 这里解释一下：“损”代表了信息的丢失的丢失，可能发生的情况是：分解后的关系模式通过自然连接合并，原有元组丢失或增加了无意义的元组，此情况记为“损”。在实际应用当中，我们希望通过自然连接之后可恢复原有关系模式，既不减少也不增加新的元组。那如何才可以做到无损分解呢？？答案是：保持原有关系模式的函数依赖 保持函数依赖的分解 分解需要保持函数依赖，因为 F 中每一个函数依赖都代表数据库的一个约束。如果模式分解不保持函数依赖，那在模式分解中就会丢失一些函数依赖。注意：这里保持原有的函数依赖，包括了通过原有函数依赖推到出来的函数依赖，可以理解为保持原有函数的 F+Via 源地址 函数依赖与模式分解","link":"/posts/SQLfunDep.html"},{"title":"SQL 授权","text":"SQL授权 授权命令语法 12grant &lt;权限名&gt;[ ,&lt;权限名&gt;] on &lt;对象&gt;to 用户1,用户2,... | public [with grant option] 对应不同对象,有不可权限,代表不同的操作(语句)。 注音: All Privileges–對象上的所有权限的总和。 public –表示所有用户 指定With grant option时,用户可以获得的权限转受给其他用户;否則,用户只能使用而不能转受。 SQL 标准允许具有with grant option 的用户把相应的权限或其子集传递授予其他用户,但不允许循环授权,即被授权者不能把权限再授回给授权者或其祖先. DBA 执行了如下语句: 12grant select, update on Student to Limingwith grant option 则 DBA 把对 Student (基本表或视图)的权限赋给用户 Liming,因为有with grant option,所以 Lining 可以把这个权限再转授给其他用户。 用户 Liming 执行了如下语句: 12grant select(Sno, Sname), update (Sname)on Student to U5 则 Liming 把对 Student 上某些列的权限赋给用户U5,但 U5不可以把这个权限再转授给其他用户。 DBA 对表查询的权限授予所有用户 1grant select on SC to public Grant 还可以实现数据库类型和模式类型权限管理,格式如下: 12grant 权限名[,...] to user1,user2,...| public[with grant option] 授予用户 Liming 具有创建数据表和图的权限 1grant create table, create view to Liming 收回权限语法 12revoke 权限名[ ,…] on 对象 form用户1,用户2,… | public 收回权限时,若该用户已将权限转授给其他用户，则这些转受的权限也一并收回。 DBA 执行以下语句: 1revoke update on Student from Liming DBA 回收用户Liming 的对Student 的更新权限.理论上，Liming转受给用户U5的对Student某些列的更新权限也一并收回udent 某些列的更新权限也要一并收回 收回所有用户对表 SC 的查询权 1Revoke select on SC from public revoke还可以实现数据库类型和模式类型权限收回,格式如下 1revoke 权限名[ ,…] from 用户1,用户2,... | public 收回Liming 创建表的权限。 1Revoke create table from Liming","link":"/posts/SQLgrant.html"},{"title":"SQL 存储过程","text":"SQL存储过程 建立 1234567create procedure lianxi66@arel char(20)@x1 int output,@x2 float outputasselect @x1=count(*),@x2=avg(年龄)from Swhere 所在系=@arel 引用 1234declare @ok int, @ck floatexec lianxi66 &quot;会计系&quot;,@ok output,@ck outputprint @okprint @ck 建立 1234567CREATE PROCEDURE lianxi3511@varl char(10), @var3 int outputasselect @var3=S.年龄frоm ѕwhere s.学号=@varl 引用 123Declare @res intExecute liarixi3511 '101101', @res outputPrint @res 建立 1234CREATE PROCEDURE lianxi2511@var1 int, @var2 int, var3 int outputAsSet @var3 = @vari*@var2 引用 12345Declare @res intExecute liarxi2511 5, 7, @res outputPrint @resexec liarxi2511 3,4 建立 123456789CREATE PROCEDURE lianxi1511@student_no char (10),@course_no char (20)ASSELECT S.姓名, S.学号,SC.课程号,C.课程名, SC.成绩FROM S JOIN SC ON S.学号=SC.学号INNER JOIN C ON C.课程号=SC.课程号WHERE S.学号=@student_noANO SC.课程号=@course_no 引用 1exec lianxi1511 '101101','101' 习题若输入的学号存在则删除 创建 123456789create procedure del_cno1@cno char(20)asbegin tran t1 --事件t1开始delete from kcgx where 课程号=@cnoif exists (select * from xkgx where 课程号=@cno)rollback tran t1elsecommit tran t1 引用与验证 123exec del_cno1 '305'select * from xkgxselect * from kcgx 存储过程使用事务实例 1234567891011121314151617Create Procedure MyProcedureASBeginSet NOCOUNT ON;Set XACT_ABORT ON;begin tran ok --开始一个事务OKdelete from rxqz where qz= 'rx015 ' --删除数据save tran bcd --保存一个事务点命名为bcdupdate sz set name='李丽s' where name= '李丽'--修改数据if @@error&lt;&gt;0 --判断修改数据有没有出错begin --如果出错rollback tran bcd -- 回滚事务到BCD 的还原点commit tran ok --提交事务endelse --没有出错commit tran ok --提交事务End 12345678create proc 1@si chark20),@pi char(20),@Ji chark20),@shu intinsert into SPJ values(@si,@pi,@Ji,@shu)bdgin tran t1if exists (select * from p where Pno=@Pi)commit tran t1elserollback tran t1","link":"/posts/SQLprocedure.html"},{"title":"SQL 级联","text":"SQL级联 主键约束在创建表的时候创建主键约束。 1234create table customer(customerld int identity not nullprimary key, --创建主键约CustomerName nvarchar(30) not null) 在已存在的表上创建主键约 123alter table personadd constraint PK_Employee_Id --约束名称primary key(personld) --personld 字段名 外键约束创建表的时候创建外 1234567create table orders (orderld int identity not nullprimary key,customerld int not nullforeign key references customer(customerid)--约束类型-外键引用表(例名)) 在已存在的表中添加一个外键 假设上面的代码去掉了添加外键行,那么可以书写代码如下: 1234alter table ordersadd constraint FK_Orders_Customerldforeign key(customerid) references customer(customerld)--外键约束, 外键列名, 被引用列名 级联动语法 123456alter table ordersadd constraint FK_Orders_Customerld --添加约束 名称foreign key (customerid) references customer(customerld)--外揵约束, 外键列名 被引用 列名on update no action --默认 修改时不级联更新子表on delete cascade --删除时級联删除依赖行 CHECK约束语法 1234alter table Accountadd constraint CN_AccountAgecheck (Account_Age&gt;18)--插入年龄必须大于18 如果此时视,添加一条不满足的记录,将报如下错误:1insert into Account values (22,'洪','17') 例子 123456alter table AocountWITH NOCHECKadd constraint CN_AccountAge18check(Account_Age&gt;18)--插入年龄心须大于18 1234567begin transelect * from s with(holdlock) --holdlock人为加锁where 学号='001'waitfor delay'00 00:35' --等待秒commit tranupdate s set 姓名='平安夜'where 学号='001'","link":"/posts/SQLconstraint.html"},{"title":"BaiduPCS-Go","text":"BaiduPCS-Go 为仿 Linux shell文件处理命令的百度网盘命令行客户端 安装 Github Release 选择自己系统平台版本 参考项目 wiki 安装即可 运行登录123cd BaiduPCS-Go./BaiduPCS-Gologin 下载文件1d 文件名","link":"/posts/BaiduPCS-Go.html"},{"title":"SSH 的使用","text":"SSH的简单运用 基础使用SSH 登录远程主机 host 1ssh root@host 本地用户名与远程用户名一致，登录时可以省略用户名。 1ssh host SSH 的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 1ssh -p 2222 root@host 公钥登录ssh-keygen 生成公钥 1ssh-keygen 运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件 id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。 将公钥传送到远程主机 host 上面 1ssh-copy-id user@host 如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 重启远程主机的 ssh 服务 Ubuntu系统 1service ssh restart Debian 系统 1/etc/init.d/ssh restart","link":"/posts/SSH.html"},{"title":"SQL 约束","text":"SQL：约束 UNIQUE 约束各约束意义 UNIQUE约束唯一标识数据库表中的每条记录。 UNIQUE和PRIMARY KEY约束均为列或列集合提供了唯一性的保证。 PRIMARY KEY约束拥有自动定义的 UNIQUE 约束。 请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。 CREATE TABLE 时的 UNIQUE 约束 在 “Persons” 表创建时在 “P_Id” 列上创建 UNIQUE 约束 MySQL 123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (P_Id)) SQL Server/Oracle/MS Access 12345678CREATE TABLE Persons(P_Id int NOT NULL UNIQUE,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束 MySQL/SQL Server/Oracle/MS Access 123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)) ALTER TABLE 时的 UNIQUE 约束语法 当表已被创建时，如需在 “P_Id” 列创建 UNIQUE 约束 12ALTER TABLE PersonsADD UNIQUE (P_Id) 如需命名 UNIQUE 约束，并添加 UNIQUE 约束，语法 MySQL / SQL Server / Oracle / MS Access： 12ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName) 撤销 UNIQUE 约束撤销 UNIQUE 约束MySQL 12ALTER TABLE PersonsDROP INDEX uc_PersonID SQL Server / Oracle / MS Access： 12ALTER TABLE PersonsDROP CONSTRAINT uc_PersonID PRIMARY KEY 约束PRIMARY KEY 约束唯一标识数据库表中的每条记录。 主键必须包含唯一的值。 主键列不能包含 NULL 值。 每个表都应该有一个主键，并且每个表只能有一个主键。 CREATE TABLE 时的 PRIMARY KEY 约束下面的 SQL 在 “Persons” 表创建时在 “P_Id” 列上创建 PRIMARY KEY 约束 123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),PRIMARY KEY (P_Id)) SQL Server / Oracle / MS Access 12345678CREATE TABLE Persons(P_Id int NOT NULL PRIMARY KEY,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束 123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)) 注释：在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。 ALTER TABLE 时的 PRIMARY KEY 约束 当表已被创建时，如需在 “P_Id” 列创建 PRIMARY KEY 约束 12ALTER TABLE PersonsADD PRIMARY KEY (P_Id) 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束 12ALTER TABLE PersonsADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName) 注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。 撤销 PRIMARY KEY 约束MySQL 12ALTER TABLE PersonsDROP PRIMARY KEY SQL Server / Oracle / MS Access 12ALTER TABLE PersonsDROP CONSTRAINT pk_PersonID FOREIGN KEY 约束一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。 解释外键 P_Id LastName FirstName Address City 1 Hansen Ola Timoteivn 10 2 Svendson Tove Borgvn 23 3 Pettersen Kari Storgt 20 “Orders” O_Id OrderNo P_Id 1 77895 3 2 44678 3 3 22456 2 4 24562 1 请注意，”Orders” 表中的 “P_Id” 列指向 “Persons” 表中的 “P_Id” 列。 “Persons” 表中的 “P_Id” 列是 “Persons” 表中的 PRIMARY KEY。 “Orders” 表中的 “P_Id” 列是 “Orders” 表中的 FOREIGN KEY。 FOREIGN KEY 约束用于预防破坏表之间连接的行为。作用: FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 CREATE TABLE 时的 FOREIGN KEY 约束下面的 SQL 在 “Orders” 表创建时在 “P_Id” 列上创建 FOREIGN KEY 约束： MySQL： 12345678CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),FOREIGN KEY (P_Id) REFERENCES Persons(P_Id)) SQL Server / Oracle / MS Access： 123456CREATE TABLE Orders(O_Id int NOT NULL PRIMARY KEY,OrderNo int NOT NULL,P_Id int FOREIGN KEY REFERENCES Persons(P_Id)) 如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束 123456789CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id)REFERENCES Persons(P_Id)) ALTER TABLE 时的 FOREIGN KEY 约束 当 “Orders” 表已被创建时，如需在 “P_Id” 列创建 FOREIGN KEY 约束 123ALTER TABLE OrdersADD FOREIGN KEY (P_Id)REFERENCES Persons(P_Id) 如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束 1234ALTER TABLE OrdersADD CONSTRAINT fk_PerOrdersFOREIGN KEY (P_Id)REFERENCES Persons(P_Id) 撤销 FOREIGN KEY 约束撤销 FOREIGN KEY 约束： MySQL 12ALTER TABLE OrdersDROP FOREIGN KEY fk_PerOrders SQL Server / Oracle / MS Access12ALTER TABLE OrdersDROP CONSTRAINT fk_PerOrders CHECK 约束范围及作用 CHECK 约束用于限制列中的值的范围。 如果对单个列定义 CHECK 约束，那么该列只允许特定的值。 如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。 CREATE TABLE 时的 CHECK 约束 下面的 SQL 在 “Persons” 表创建时在 “P_Id” 列上创建 CHECK 约束。CHECK 约束规定 “P_Id” 列必须只包含大于 0 的整数。 MySQL 123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CHECK (P_Id&gt;0)) SQL Server / Oracle / MS Access： 12345678CREATE TABLE Persons(P_Id int NOT NULL CHECK (P_Id&gt;0),LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) 如需命名 CHECK 约束，并定义多个列的 CHECK 约束 123456789CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City='Sandnes')) ALTER TABLE 时的 CHECK 约束 当表已被创建时，如需在 “P_Id” 列创建 CHECK 约束，请使用下面的 SQL MySQL / SQL Server / Oracle / MS Access: 12ALTER TABLE PersonsADD CHECK (P_Id&gt;0) 如需命名 CHECK 约束，并定义多个列的 CHECK 约束 12ALTER TABLE PersonsADD CONSTRAINT chk_Person CHECK (P_Id&gt;0 AND City='Sandnes') 撤销 CHECK 约束撤销 CHECK 约束SQL Server / Oracle / MS Access： 12ALTER TABLE PersonsDROP CONSTRAINT chk_Person MySQL： 12ALTER TABLE PersonsDROP CHECK chk_Person SQL DEFAULT 约束作用 DEFAULT 约束用于向列中插入默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。 CREATE TABLE 时的 DEFAULT 约束下面的 SQL 在 “Persons” 表创建时在 “City” 列上创建 DEFAULT 约束：My SQL / SQL Server / Oracle / MS Access 12345678CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255) DEFAULT 'Sandnes') 通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值： 1234567CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,OrderDate date DEFAULT GETDATE()) ALTER TABLE 时的 DEFAULT 约束 当表已被创建时，如需在 “City” 列创建 DEFAULT 约束 MySQL 12ALTER TABLE PersonsALTER City SET DEFAULT 'SANDNES' SQL Server / MS Access 12ALTER TABLE PersonsALTER COLUMN City SET DEFAULT 'SANDNES' Oracle 12ALTER TABLE PersonsMODIFY City DEFAULT 'SANDNES' 撤销 DEFAULT 约束撤销 DEFAULT 约束 MySQL 12ALTER TABLE PersonsALTER City DROP DEFAULT SQL Server / Oracle / MS Access 12ALTER TABLE PersonsALTER COLUMN City DROP DEFAULT 来源 菜鸟教材","link":"/posts/SQLconstraint.html"},{"title":"Linux 基础命令","text":"Linux 基础命令 目录操作命令ls123456789101112命令英文原意：list命令所在路径：/bin/ls执行权限：所有用户功能描述：显示目录文件ls # 显示当前目录下文件ls 目录名 # 显示指定目录下文件ls -l # 长格式显示目录文件ls -l 文件名 # 长格式显示指定文件ls -a # 显示所有文件(包含隐藏文件)ls -al # 长格式显示当前目录下所有文件)ls -h # 文件大小显示为常见大小单位 B KB MB ...ls -d # 显示目录本身，而不是里面的子文件 cd123456789101112命令英文原意：change directory命令所在路径：shell内置命令执行权限：所有用户功能描述：切换所在目录cd /usr/local/src 切换到指定路径(使用绝对路径方式)cd ~ # 进入当前用户的家目录cd - # 进入上次目录cd .. # 进入上一级目录cd . # 进入当前目录绝对路径：cd ../usr/local 参照当前所在目录，进行查找。一定要先确定当前所在目录。相对路径：cd /usr/local 从根目录开始指定，一级一级递归查找。在任何目录下，都能进入指定位置。 pwd1234命令英文原意：print working directory命令所在路径：/bin/pwd执行权限：所有用户功能描述：显示当前所在目录(当前工作目录) mkdir123456命令英文原意：make directories命令所在路径：/bin/mkdir执行权限：所有用户功能描述：建立目录mkdir test # 创建名为test的目录mkdir -p test1/test2/test3 #递归创建 rmdir1234命令英文原意：remove empty directories命令所在路径：/bin/rmdir执行权限：所有用户功能描述：删除目录 (只能删除空目录) 文件操作命令touch1234命令所在路径：/bin/touch执行权限：所有用户功能描述：创建空文件 或 修改文件时间touch test.py # 创建空文件，如果文件存在，则修改文件创建时间 rm12345678命令英文原意：remove命令所在路径：/bin/rm执行权限：所有用户功能描述：删除rm 文件名 # 删除文件rm -r 目录名 # 递归删除文件和目录rm -f 文件名 # 强制删除rm -rf 目录名 # 强制删除目录和文件 cat12345命令所在路径：/bin/cat执行权限：所有用户功能描述：查看文件内容，从头到尾的内容。cat 文件名 # 查看文件内容内容cat -n 文件名 # 查看文件内容，并列出行号 more1234567命令所在路径：/bin/more执行权限：所有用户功能描述：分屏显示文件内容more 文件名 分屏显示文件内容向上翻页 空格键向下翻页 b键退出查看 q键 head12345678命令所在路径：/usr/bin/head执行权限：所有用户功能描述：显示文件头head 文件名 # 显示文件头几行(默认显示10行)head -n 20 文件名 # 显示文件前20行head -n -20 文件名 # 显示文件最后20行ctrl + c # 强制终止查看模式ctrl + l # 清屏 ln123456789命令英文原意：link命令所在路径：/bin/ln执行权限：所有用户功能描述：链接文件等同于Windows中的快捷方式新建的链接，占用不同的硬盘位置修改一个文件，两边都会改变删除源文件，软连接文件打不开ln -s 源文件 目标文件 # 创建链接文件(文件名都必须写绝对路径) 文件和目录都能操作的命令rm删除文件或目录 cp1234567891011命令英文原意：copy命令所在路径：/bin/cp执行权限：所有用户功能描述：复制文件或目录cp 源文件 目标位置 # 复制cp 源文件 目标位置/目标名称 # 复制并改名cp -r # 复制目录cp -p # 连带文件属性一起复制cp -d # 若源文件是链接文件，则复制链接属性cp -a # 相当于 cp -pdr mv12345678命令英文原意：move命令所在路径：/bin/mv执行权限：所有用户mv 源文件 目标位置mv /root/test /tmp/ # 将/root/下的test文件移动到/tmp/目录下mv /root/test /root/newtest # 将/root/下的test文件改名为newtest 挂载命令mount1234命令所在路径：/bin/mount执行权限：所有用户功能描述：挂载linux所有存储设备都必须挂载使用，包括硬盘 光盘挂载123456/dev/sda1 # 第一个scsi硬盘的第一分区/dev/cdrom # 光盘/dev/hdc # fIDE硬盘 centos 5.5/dev/sr0 # 光盘 centos 6.xmount -t 文件系统 设备描述文件 挂载点（已经存在空目录）mount -t iso9660 /dev/cdrom /mnt/cdrom 光盘卸载1234umount /dev/cdromumount /mnt/cdrom 注意：退出挂载目录，才能卸载fdisk -l 查看设备名mount -t vfat /dev/sdb1 /mnt/usb 网络命令ping1234命令所在路径：/bin/ping执行权限：所有用户功能描述：测试网络畅通性ping -c 次数 ip # 探测网络通畅 ifconfig1234命令英文原意：interface configure命令所在路径：/sbin/ifconfig执行权限：root功能描述：查询本机网络信息 Linux 系统分类 RedHat 系列：Redhat、Centos、Fedora 等 RPM (Red Hat系)：CentOS、Fedora Debian 系列：Debian、Ubuntu 等 Dpkg (Debian系)：Ubuntu LinuxMint ArchLinux ArchLinux、Manjaro、Antergos 等. 软件包管理工具Debian 系列 常见的安装包格式 deb 包，安装 deb 包的命令是dpkg -选项 -xxx.deb 选项12345678-i：安装软件包-r：删除软件包-P：删除软件包的同时删除其配置文件-L：显示于软件包关联的文件-l：显示已安装软件包列表--unpack：解开软件包-c：显示软件包内文件列表--confiugre：配置软件包 包管理工具 apt-get 支持 tar 包 dpkg 实例 12345678910dpkg -i package.deb #安装包dpkg -r package #删除包dpkg -P package #删除包（包括配置文件）dpkg -L package #列出与该包关联的文件dpkg -l package #显示该包的版本dpkg --unpack package.deb #解开deb包的内容dpkg -S keyword #搜索所属的包内容dpkg -l #列出当前已安装的包dpkg -c package.deb#列出deb包的内容dpkg --configure package#配置包 apt 包管理 1apt-get (选项)(参数) 实例 12345678apt-get update #更新源apt-get upgrade #更新所有已安装的软件包apt-get install packagename #安装软件包apt-get remove packagename #卸载软件包(保留配置文件)apt-get –purge remove packagename # 卸载软件包(删除配置文件)apt-get autoclean apt #删除你已经删掉的软件apt-get dist-upgrade #将系统升级到新版本apt-get autoclean #清除已经卸载的软件包的.deb文件 RedHat 系列 常见的安装包格式 rpm 包，安装rpm包的命令是`rpm -参数 [-rpm包] 参数1234567891011121314151617-a：查询所有套件；-b&lt;完成阶段&gt;&lt;套件档&gt;+或-t &lt;完成阶段&gt;&lt;套件档&gt;+：设置包装套件的完成阶段，并指定套件档的文件名称；-c：只列出组态配置文件，本参数需配合&quot;-l&quot;参数使用；-d：只列出文本文件，本参数需配合&quot;-l&quot;参数使用；-e&lt;套件档&gt;或--erase&lt;套件档&gt;：删除指定的套件；-f&lt;文件&gt;+：查询拥有指定文件的套件；-h或--hash：套件安装时列出标记；-i：显示套件的相关信息；-i&lt;套件档&gt;或--install&lt;套件档&gt;：安装指定的套件档；-l：显示套件的文件列表；-p&lt;套件档&gt;+：查询指定的RPM套件档；-q：使用询问模式，当遇到任何问题时，rpm指令会先询问用户；-R：显示套件的关联性信息；-s：显示文件状态，本参数需配合&quot;-l&quot;参数使用；-U&lt;套件档&gt;或--upgrade&lt;套件档&gt;：升级指定的套件档；-v：显示指令执行过程；-vv：详细显示指令执行过程，便于排错。 包管理工具yum -选项 -参数 选项 123456789-h：显示帮助信息；-y：对所有的提问都回答“yes”；-c：指定配置文件；-q：安静模式；-v：详细模式；-d：设置调试等级（0-10）；-e：设置错误等级（0-10）；-R：设置yum处理一个命令的最大等待时间；-C：完全从缓存中运行，而不去下载或者更新任何头文件。 参数 12345678910111213install：安装rpm软件包；update：更新rpm软件包；check-update：检查是否有可用的更新rpm软件包；remove：删除指定的rpm软件包；list：显示软件包的信息；search：检查软件包的信息；info：显示指定的rpm软件包的描述信息和概要信息；clean：清理yum过期的缓存；shell：进入yum的shell提示符；resolvedep：显示rpm软件包的依赖关系；localinstall：安装本地的rpm软件包；localupdate：显示本地rpm软件包进行更新；deplist：显示rpm软件包的所有依赖关系。 支持 tar 包 yum 实例 安装 123yum install #全部安装yum install package1 #安装指定的安装包package1yum groupinsall group1 #安装程序组group1 更新和升级 12345yum update #全部更新yum update package1 #更新指定程序包package1yum check-update #检查可更新的程序yum upgrade package1 #升级指定程序包package1yum groupupdate group1#升级程序组group1 查找和显示 1234yum info package1 #显示安装包信息package1yum list #显示所有已经安装和可以安装的程序包yum list package1 #显示指定程序包安装情况package1 yum groupinfo group1#显示程序组group1信息yum search string 根据关键字string查找安装包 删除程序 123yum remove &amp;#124; erase package1 #删除程序包package1yum groupremove group1 #删除程序组group1yum deplist package1 #查看程序package1依赖情况 清除缓存 123yum clean packages #清除缓存目录下的软件包yum clean headers #清除缓存目录下的 headersyum clean oldheaders #清除缓存目录下旧的 headers 参考 Linux命令 查询命令find12345678find [搜索范围] [搜索文件]`find / -name install.log避免大范围搜索,会非常耗费系统资源find是在系统当中搜索符合条件的文件名,如果需要匹配 使用通配符匹配,通配符是完全匹配。find /root -iname installlog #不区分大小写find /root -user root #按照所有者搜索find/root -nouser #查找没有所有者的文件 find /var/log/ -mtime +10 #查找10天前修改的文件 -10 10天内修改文件 10 10天当天修改的文件 +10 10天前修改的文件 atime 文件访问时间 find . -size #查找文件大小是25KB的文件 -25k 小于25KB的文件 25k 等于25KB的文件 +25k 大于25KB的文件 find -inum 262422 #查找 节点是262422的文件 find /etc -size +20k -a -size -50k #查找/etc/目录下,大于20KB并且小于50KB的文件 a and逻辑与,两个条件都满足 or 逻辑或,两个条件满足一个即可 find /etc-size +20k-a-size-50k -exec ls-lh {} 1; #查找/etc/目录下,大于20KB并且小于50KB的文件,并显示详细信 #-exec/-ok命令() 对搜索结果执行操 搜索字符串命令grep grep [选项]字符串文件名在文件当中匹配符合条件的字符串选项: -i 忽略大小写 -v排除指定字符串 find命令与grep命令的区别 find命令:在系统当中搜索符合条件的文件名,如果需要匹配 使用通配符匹配,通配符是完全匹配。 grep命令:在文件当中搜索符合条件的字符串,如果需要匹配 使用正则表达式进行匹配,正则表达式时包含匹配 man 命令man 命令 #获取指定命令的帮助man ls #查看ls的帮助 查看命令拥有那个级别的帮助man -f 命令 相当于 whatis 命令 举例: 123man -5 passwdman -4 nullman -8 ifconfig shell 内部命令帮助help shell 内部命令 #获取shell内部命令的帮助 例如: 12whereis cd #确定是否是shell内部命令help cd #获取内部命令帮助 详细命令帮助info info命令回车|进入子帮助页面(带有*号标记) |:—:|:—:||u|进入上层页面||n|进入下一个帮助小节||p|进入上一个帮助小节||q|退出| 压缩zip格式压缩12zip 压缩文件名 源文件 #压缩文件zip -r 压缩文件名 源目录 #压缩目录 gzip格式压缩12gzip 源文件 #压缩为.gz格式的压缩文件.源文件会消失gzip -c 源文件&gt;压缩文件 # 压缩为.gzi格式,源文件保留 gz格式解压缩12gzip -d 压缩文件 #解压缩文件gunzip 压缩文件 #解压缩文件 bz2格式压缩123bzip2 源文件 #压缩为.bz2格式.不保留源文件bzip2 -k 源文件 #压缩之后保留源文件注意: bzip2命令不能压缩目录 打包tar1234tar -cvf 打包文件名 源文件选项: -c打包-v显示过程-f指定打包后的文件名 解打包命令123tar -xvf 打包文件名选项:-x解打包 tar.gz压缩格式其实.tar.gz格式是先打包为.tar格式,再压缩为.gz格式 tar -zcvf 压缩包名tar.gz 源文件 选项: -z压缩为.tar.gz格式 tar -zxvf 压缩包名tar.gz 选项:-x 解压缩.tar.gz格式 tar.bz2压缩格式:1. tar -jcvf压缩包名.tar.bz2 源文件 选项:-z压缩为.tar.bz2格式 tar -jxvf 压缩包名·tar.bz2 选项: -x解压缩.tar.bz2格式 shell命令shutdown命令12345shutdown [选项] 时间选项:-c 取消前一个关机命令-h 关机 -r 重启 其他关机命令12345678910111213haltpoweroffinit 0重启命令rebootinit 6系统运行级别查看系统运行级别cat /etc/inittab程序员之路: Linux关机与重启退出登录logout 切记,一般服务器只允许少量用户连接, 如果不正常退出会占用用户id 查询当前登录和过去登录的用户信息last last #命令默认是读取/var/log/wtmp文件数据 命令输出 -用户名 登录终端 登录IP 登录时间 退出时间(在线时间) echo输出命令echo [选项] [输出内容] 选项: -e 支持反斜线控制的字符转换 控制字符 作用 \\a 输出警告音 \\b 退格键，也就是向左删除键 \\n 换行键 \\r 回车键 \\t 制表键，也就是Tab键 \\v 垂直制表键 \\Onnn 按照八进制ASCII码表输出字符。其中0表示数字0，nnn是三位八进制数 \\xhh 按照16进制ASCII码表输出字符。其中hh是两位16进制数 脚本执行1234赋予执行权限,直接运行chmod 755 hello.sh/hello.shbash hello.sh 别名 查看与设定别名 alias #查看系统中所有的命令别名 alias 别名=”原命令” #设定命令别名 别名永久生效与删除别名12vi /.bashrc #写入环境变量配置文件unalias 别名 #删除别名 shell常用快捷键 ctrl+c 强制终止当前命令 ctrl+l 清屏 crtl+a 光标移动到命令行首 ctrl+e 光标移动到命令行尾 ctrl+u 从光标所在位置删除到行首 ctrl+z 把命令放入后台 ctrl+r 在历史命令中搜 历史命令1234history [选项] [历史命令保存文件]选项:-c:清空历史命令w:把缓存中的历史命令写入历史命令保存文件~/.bash.history 输出重定向 类型 符号 作用 标准输出重定向 命令&gt;文件 以覆盖的方式,把命令的正确输出 输出到指定的文件或设备当中 空 命令&gt;&gt;文件 以追加的方式,把命令的正确输出! 输出到指定的文件或设备当中 准错误输出重定向 错误命令2&gt;&gt;文件 以覆盖的方式,把命令的错误输出 输出到指定的文件或设备当中。 多命令顺序执行 多命令执行符 格式 作用 : 命令1:命令2 多个命顺序执行,命令之间没有逻辑关系 &amp;&amp; 命令1&amp;&amp;命令2 逻辑与当命令1正确执行,则命令2才会执行,1不正确，2不执行 丨丨 命令1丨丨命令2 逻辑或，命令1不正确，2才执行，命令1正确，2不会执行 通配符 通配符 作用 ? 匹配一个任意字符 * 匹配0或任意多个任意符，也可以是匹配任何内容 [] 匹配括号中的任意一个字符 [-] 匹配括号中任意一个字符，-代表一个范围。［a-z］小写字母表 [^] 逻辑非，表示匹配不是括号中的一个字符.［^0-9］不是数字的字符 Bash中其他特殊符号 符号 作用 ‘’ 单引号。在单引号中所有的特俗符合，如“$”和“`”（反引号）都没特俗意义 “” 双引号,在双引号中特殊符号都没有特殊含义,但是“S” 、“.”和“&quot;是例外. 拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义 `` 反引号。反引号括起来的都是系统命令，在bash中会先执行和$()作用一样。不过推荐使用$(), 因为反引号非常容易看错 $() 和反引号作用一样，用来引用系统命令 # shell中#开头的行代表注释 $ 用于调用变量的值，如要调用变量name的值时，需要用$name的方式得到变量的值 \\ 转义符，跟在\\后面的特俗符号失去特俗含义，变为普通字符，。如$将输出$符号，而不是变量引用 磁盘管理df [参数] 查看磁盘分区使用状况1234567891011121314-l仅显示本地磁盘(默认)-a显示所有文件系统的磁盘使用情况,包含比如/proc/-h以1024进制计算最合适的单位显示磁盘容量-H以1000进制计算最合适的单位显示磁盘容量-T显示磁盘分区类型-t显示指定类型文件系统的磁盘分区-x不显示指定类型文件系统的磁盘分- du统计磁盘上的文件大小-b以byte为单位统计文件-k以KB为单位统计文件-m以MB为单位统计文件-h按照1024进制以最适合的单位统计文件-H按照1000进制以最适合的单位统计文件-s指定统计目标 权限-rw-r–r–123文件类型(-文件d目录1软链接文件)rw- u所有者 r-- g所属组 r-- o其他人r 读 w 写 x 执行 chmod 命令123chmod [选项] 模式 文件名选项 -R递归 模式 [ugoa][+-=][rwx][mode=421] 修改权限123chmod u+x cangls.avchmod g+w,o+w furong.avchmod a=rwx fengjie.av 权限的数字表示r—4 w—2 x—1 rwxr-xr-x — 755 权限对文件的作用 r:读取文件内容(cat more head tail) w:编辑、新增、修改文件内容( vi echo ) 但是不包含删除文件 x:可执行 权限对目录的作用 r:可以查询目录下文件名 (ls) w:具有修改目录结构的权限。如新建文件和目录,删除此目录下文件和目录,重命名此目录下文件和目录,剪切(touch rm mv cp) x:可以进入目录 (cd) 对文件来讲: 最高权限是 x 对目录来讲:最高权限是 w 修改文件的所有者12chown 用户名 文件名例如: chown ds h.c 修改文件的所属组12chgrp 组名 文件名例如: chgrp group1 h.c 查看默认权限的命令12umask查看默认权限0022 第一位0 :文件特殊权限 022 :文件默认权限 文件的默认权限 文件默认不能建立为执行文件,必须手工赋予执行权限 所以文件默认权限最大为666 默认权限需要换算成字母再相减 建立文件之后的默认权限,为666减去umask 例如: 文件默认最大权限666 umask值022 -rw-rw-rw- 减去 —- w–w-等于 -rw-r-r- 例如: 文件默认最大权限666 umask值033 -rw-rw-rw- 减去 —- wx-wx 等于 -rw-r-r 目录的默认权限 目录默认权限最大为777 默认权限需要换算成字母再相减 建立文件之后的默认权限,为777减去umask值 例如: 目录默认最大权限为777 umask值022 -rwxrwxrwx 减去 —-w–w- 等于 -rwxr-xr-x 修改umask12临时修改 umask 0002永久修改 vi/etc/profile 进程 查看所有进程12345678910111213141516ps aux #查看系统中所有进程,使用BSD操作系统格式ps -le #查看系统中所有进程,使用Linux标准命令格式选项a:显示一个终端的所有进程,除了会话引线-u:显示进程的归属用户及内存的使用情况-x:显示没有控制终端的进程-l:长格式显示,显示更加详细的信息-e:显示所有进程,和-A作用一致- ps命令的输出USER:该进程是由哪个用户产生的PID:进程的ID号;%CPU:该进程占用CPU资源的百分比,占用越高,进程越耗费资源;%MEM:该进程占用物理内存的百分比,占用越高,进程越耗费资源VSZZ:该进程占用虚拟内存的大小,单位KB:Rss:该进程占用实际物理内存的大小,单位KB:TTY:该进程是在哪个终端中运行的,其中tty1-tty7代表本地控制台 终端, tty1-tty6是本地的字符界面终端, 255代表虚拟终端。 tty7是图形终端. pts/0 12345STAT :进程状态,常见的状态有R:运行 S:睡眠 T:停止状态 -s:包含子进程 +:位于后台START:该进程的启动时间TIME:该进程占用CPU的运算时间, 不是系统时间COMMAND:产生此进程的命令名","link":"/posts/Linux-Commands.html"},{"title":"Termux 安装 R","text":"Termux 安装 R 步骤建立 storage 1termux-setup-storage 添加镜像 12export EDITOR=viapt edit-sources 进入之后输入 i 进入编辑模式。 添加如下源 1deb [trusted=yes] https://its-pointless.github.io/files/ termux extras 环境更新 12apt-get updateapt-get upgrade 安装 R 1pkg install r-cran","link":"/posts/Termux-R.html"},{"title":"ADB 与 Fastboot 常用命令","text":"Adb 与 Fastboot 常用命令 ADB刷机命令 解释 命令 查看连接状态 adb devices 重启命令 adb reboot 重启到Rec adb reboot recovery 重启到Fastboot adb reboot bootloader 推送ROM包 adb sideload &lt;Rom包&gt; 安装卸载 解释 命令 安装 adb install 卸载 adb uninstall 保留数据卸载 adb uninstall -k 复制文件 解释 命令 复制设备到电脑 adb pull &lt;设备文件路径&gt; &lt;电脑目录&gt; 例如：adb pull /sdcard/1.txt E:\\ 复制电脑到设备 abd pull &lt;电脑文件路径&gt; &lt;设备目录&gt; 例如：adb pull E:\\1.txt /sdcard/ 查看手机信息 解释 命令 查看设备型号 adb shell getprop ro.product.model 获取IMEI adb shell [回车] su [回车] service call iphonesubinfo 1 获取手机程序包名 adb shell pm list packages 获取序列号 adb get-serialno 其他 解释 命令 查看log adb logcat 终止adb服务进程 adb kill-server 重启adb服务进程 adb start-server 获取机器MAC地址 adb shell cat /sys/class/net/wlan0/address 获取CPU序列号 adb shell cat /proc/cpuinfo 安装APK adb install 卸载APK adb uninstall 查看设备cpu和内存占用情况 adb shell top 查询各进程内存使用情况 adb shell procrank 查看wifi密码 adb shell cat /data/misc/wifi/*.conf Fastboot 解释 命令 查看连接状态 fastboot devices 解锁 fastboot flashing unlock或fastboot oem unlock 上锁 fastboot flashing lock或fastboot oem lock 重启 fastboot reboot 重启到Fastboot fastboot reboot-bootloader 清除分区数据 fastboot erase &lt;boot/system/data/cache/userdata/recovery&gt; 清除分区(四清) fastboot erase system -w 格式化分区数据 fastboot format &lt;boot/system/data/cache/userdata/recovery&gt; 烧写分区 fastboot flash &lt; boot/system /recovery/radio/bootloader/ splash1/&gt; &lt;*.img&gt;","link":"/posts/Adb.html"},{"title":"SQL EXISTS","text":"SQL 中 EXISTS 三点概念概念 EXISTS 子查询找到的提交 NOT EXISTS子查询中 找不到的提交 说明 不要去翻译为存在和不存在，把脑袋搞晕。 exists代表存在量词ョ，该查询结果没有值，只有逻辑值真true和逻辑假false两个值。 建立程序循环的概念，这是一个动态的查询过程。如 FOR循环. Exists执行的流程Exists首先执行外层查询，再执行内存查询,与IN相反。 流程为首先取出外层中的第一元组，再执行内层查询，将外层表的第一元组代入,若内层查询为真，即有结果时。返回外层表中的第一元 组，接着取出第二元组，执行相同的算法。一直到扫描完外层整表。1234for(int i =0; i&lt;&gt;EOFout;i++) { for (int j = 0 ; j&lt;EOFint,j++) } 例子表学生表student (Sno,Sname) 课程表course (Cno,Cname) 选课表SC(Sno,Cno) 要求查询出 ：选修了全部课程的学生姓名 思路思路一首先学生的选课信息存在于SC表中， 要想知道某个学生是否选修了全部课程，至少我们需要知道一共有几门课程，这是首要的条件。其次，学生选修了与否，我们又要扫描SC全表，统计出选修了所有课程的学生号，最后在STUDENT表中根据学生号打出姓名 。 语句如下：1234567select Sname from studentwhere Sno IN(select Sno from SCgroup by Sno //根据Sno分组，统计每个学生选修了几门课程。如果等于course的总数，就是我们要找的Snohaving count(*) = (select count(*) from course ))//统计course中共有几门课程 另一种思路： 引入：将题目换为 查找学号为 00003 没有选修的科目 思路：我们可以将已知学号代入，把每一个科目代入（循环），这将形成1*count(*)种组合。将这组成作为条件，一一与SC表种进行比对，找不到匹配的我们提交.1234select Cname from course wherenot exists //找不到的组合，提交course(select * from SC where course.cno = cno and sno = ''00002'')//在SC中匹配 查找没有 没有选修科目的学生姓名 思路： 学号未知,科目未知，说明有两个未知变量。应该有两个EXISTS。我们可以扫描student 和 course共有 s * c 中组合，将这些组合与SC的每一项进行匹配，注意s*c组合已经包含所有可能。如果全部找到 ，就说明已经选修了全部课程。找不到就说明有课程没选修 。再将没选修的的提交给上一exists 循环 。若上一exists 不存在的再提交给外循环。123456select Sname from studentwhere NOT exists //(select * from coursewhere NOT exists //不存在的提交给course(select * from SC whereSno = student.sno and cno = Course.Cno)) // 代入两个未知变量 选修了全部课程的学生姓名.将这组成作为条件，一一与SC表种进行比对，找不到匹配的我们提交 。 1234select Cname from course wherenot exists //找不到的组合，提交course(select * from SC where course.cno = cno and sno = ''00003'')//在SC中匹配 查找没有选修科目的学生姓名 思路：1. 学号未知 科目未知 说明有两个未知变量。2. 应该有两个EXISTS。我们可以扫描student和course共有s*c中组合，将这些组合与SC的每一项进行匹配，注意s*c组合已经包含所有可能。如果全部找到 ，就说明已经选修了全部课程。找不到就说明有课程没选修 。再将没选修的的提交给上一exists 循环 。若上一exists 不存在的再提交给外循环。 查询选修了全部课程的学生姓名。 12345678910SELECT SnameFROM StudentWHERE NOT EXISTS（SELECT *FROM CourseWHERE NOT EXISTS(SELECT *FROM SCWHERE Sno= Student.SnoAND Cno= Course.Cno） 查询所有选修了001课程的学生名单 123456select snamefrom student awhere exists (select *from sc bwhere a.sno=b.sno and cno='001') 查询没有选修了001课程的学生名单 123456select snamefrom student awhere not exists (select *from sc bwhere a.sno=b.sno and cno='001') 查询选修了所有课程的学生名单。 由于SQL中没有全称量词，可以这样理解：查询这样的学生，没有一门课程他没有选 123456789select snamefrom student awhere not exists (select *from course bwhere not exists (select *from sc cwhere a.sno=c.sno and c.cno=b.cno)) 注意：SQL没有蕴涵谓词，可以使用等价变换进行转换p→q ≡ ┑p∨q 查询至少选修了学生95002选修的全部课程的学生名单。 将查询进行变换： p表示的谓词：95002选修了课程y q表示的谓词：学生x选修了课程y 该查询转换为：( y)p→q 进一步转换：( y)p→q ≡ ┑(ョy( ┑(p→q))) ≡ ┑(ョy( ┑(┑p∨q))) ≡ ┑ョy(p∧q) 德模根定律 它所表达的含义为：不存在这样的课程y，95002选修了y而x没有选，SQL语句如下： 123456789select sname,snofrom student awhere sno &lt;&gt; '95002' and not exists (select *from sc bwhere sno='95002' and not exists (select *from sc cwhere a.sno=c.sno and c.cno=b.cno)) 参考：","link":"/posts/SQL-Exists.html"},{"title":"Git Push 错误解决方法","text":"git push用法和常见问题分析 Git push1234git push origin test:master// 提交本地test分支作为远程的master分支git push origin test:test// 提交本地test分支作为远程的test分支 如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。 12git push origin :test// 刚提交到远程的test将被删除，但是本地还会保存的，不用担心 举个例子: 1234567git push origin :origin/Android_HK_K501_77-W916//由于:前面为空所以本来在服务器上面存在的分支origin/Android_HK_K501_77-W916和Android_HK_K501_77-W916现在就只有一个了,因为分支origin/Android_HK_K501_77-W916被删除了,但是本地的还在 git push ssh://git@dev.lemote.com/rt4ls.git master // 把本地仓库提交到远程仓库的master分支中git remote add origin ssh://git@dev.lemote.com/rt4ls.gitgit push origin master 这两个操作是等价的，第二个操作的第一行的意思是添加一个标记，让origin指向ssh://git@dev.lemote.com/rt4ls.git，也就是说你操 作origin的时候，实际上就是在操作ssh://git@dev.lemote.com/rt4ls.git。origin在这里完全可以理解为后者 的别名。 注意：需要说明的是，默认情况下这条语句等价于提交本地的master仓库到远程仓库，并作为远程的master分支。 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。常见错误: 1.error:failed to push some refs to … 当要push代码到git时，出现提示： 12345678910111213141516error:failed to push some refs to ...Dealing with “non-fast-forward” errorsFrom time to time you may encounter this error while pushing:git push origin masterTo ../remote/ ! [rejected] master -&gt; master (non-fast forward)error: failed to push some refs to &apos;../remote/&apos;To prevent you from losing history, non-fast-forward updates were rejectedMerge the remote changes before pushing again. See the &apos;non-fast forward&apos;section of &apos;git push --help&apos; for details. 问题（Non-fast-forward）的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。于是你有2个选择方式： 强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容 1git push -f 先把git的东西fetch到你本地然后merge后再push12git fetchgit merge 这2句命令等价于git pull 可是，这时候又出现了如下的问题： 上面出现的 [branch “master”]是需要明确(.git/config)如下的内容 12345[branch &quot;master&quot;] remote = origin merge = refs/heads/master 这等于告诉git2件事: 1，当你处于master branch, 默认的remote就是origin。 2，当你在master branch上使用git pull时，没有指定remote和branch，那么git就会采用默认的remote（也就是origin）来merge在master branch上所有的改变 如果不想或者不会编辑config文件的话，可以在bash上输入如下命令行： 12git config branch.master.remote origingit config branch.master.merge refs/heads/master 之后再重新git pull下。最后git push你的代码. 参考 CSDN-Renkangke","link":"/posts/Git-error.html"},{"title":"SQL 上机实验题","text":"SQL 上机习题与练习 实验一 SQL SERVER 2008的基本知识与操作实验日期： 实验目标：（1） 以SQL Server2008为实验平台掌握SQL Server服务器的注册、启动、暂停、查看与设置服务器的属性等操作； （2） 了解SQL Server Management Studio的功能 （3） 学习SQL Server2008所提供的系统数据库； （4） 学习利用SQL Server Management Studio创建数据库。掌握数据库中这主数据文件、辅助数据文件、日志文件三类文件的作用； （5） 学习利用SQL Server Management Studio数据库中创建表；创建表的字段、字段的数据类型、设置表的主键； （6） 学习利用SQL Server Management Studio修改数据库中表的数据，删除表的数据、向表中插入数据； （7） 利用SQL Server Management Studio删除数据库中的表； （8） 利用SQL Server Management Studio删除数据库、分离数据库、附加数据库库。 实验内容SQL Server 2008将数据保存在数据库中，并为用户提供了访问这些数据的接口。对数据库的基本操作包括创建、查看、修改和删除数据库等。在学习这些操作之前，先来了解一下数据库文件和SQL Server系统数据库。 1. 数据库文件在SQL Server中数据库文件是存储数据的文件，其可以分为三类。 主数据文件：扩展名是.mdf，它包含数据库的启动信息以及数据库数据，每个数据库只能包含一个主数据文件。在SQL Server中数据的存储单位是页。 辅助数据文件：扩展名是.ndf,因为有些数据库可能非常大，用一个主数据文件可能放不下，因此就需要有一个多个辅助数据文件存储这些数据，可以和主数据文件放在相同的位置也可以存放在不同的位置。 日志文件：用来记录页的分配和释放以及对数据库数据的修改操作，扩展名为.ldf,包含用于恢复数据库的日志信息。每个数据库必须至少有一个日志文件，也可以有多个。 创建数据库时，一个数据库至少包含一个主数据文件和一个或多个日志文件，还可能包含一些辅助数据文件。这些文件默认的位置为：\\program files\\Microsoft SQL Server\\MSSQL\\Data文件夹。 2. SQL Server系统数据库在 SQL Server 2008有两类数据库：系统数据库和用户数据库。系统数据库存储有关SQL Server 的系统信息，它们是SQL Server 2008管理数据库的依据。如果系统数据库遭到破坏，那么SQL Server将不能正常启动。在安装了SQL Server 2008的系统共中将创建4个可见系统数据库。 （1）master数据库master数据库是SQL Server中最重要的数据库，它是SQL Server的核心数据库，如果该数据库被损坏，SQL Server将无法正常工作，master数据库中包含所有的登录名或用户ID所属的角色、服务器中的数据库的名称及相关的信息、数据库的位置、SQL Server如何初始化四个方面的重要信息。 （2）model数据库用户创建数据库时是以一套预定义的标准为模型。例如，若希望所有的数据库都有确定的初始大小，或者都有特定的信息集，那么可以吧这些信息放在model数据库中，以model数据库作为其他数据库的模板数据库。如果想要使用所有的数据库都有一个特定的表，可以把该表放在model数据库里。model数据库是tempdb数据库的基础。对model数据库的任何改动都将反映在tempdb数据库中，所以，在决定对model数据库有所改变时，必须预先考虑好。 （3）msdb数据库msdb数据库给SQL Server代理提供必要的信息来运行作业，其供SQL Server 2008代理程序调度警报作业以及记录操作时使用。 （4）tempdb数据库tempdb数据库用作系统的临时存储空间，其主要作用是存储用户建立的临时表和临时存储过程，存储用户说明的全局变量值，为数据排序创建临时表，存储用户利用游标说明所筛选出来的数据。 3. 创建数据库选择开始菜单中→程序→【Management SQL Server 2008】→【SQL Server Management Studio】命令，打开【SQL Server Management Studio】窗口，并使用Windows或 SQL Server身份验证建立连接。 图1.1 新建数据库 在【对象资源管理器】窗口中展开服务器，然后选择【数据库】节点。右键单击【数据库】节点，从弹出来的快捷菜单中选择【新建数据库】命令。执行上述操作后，会弹出【新建数据库】对话框。在对话框、左侧有3个选项，分别是【常规】、【选项】和【文件组】。完成这三个选项中的设置会后，就完成了数据库的创建工作，在【数据库名称】文本框中输入要新建数据库的名称。例如，这里以“Students”。【数据库文件】列表中包括两行，一行是数据库文件，而另一行是日志文件。通过单击下面的【添加】、【删除】按钮添加或删除数据库文件，如图1.1。 【逻辑名称】指定该文件的文件名。 【文件类型】用于区别当前文件是数据文件还是日志文件。 【文件组】显示当前数据库文件所属的文件组。一个数据只能存在一个文件组里。 【初始大小】指定该文件的初始容量。默认值为3MB.日志默认值为1MB。 【自动增长】用于设置文件的容量不够用时，文件根据何中增长方式自动增长。 完成以上操作后，单击【确定】按钮关闭【新建数据库】对话框。至此“新建的数据”数据库创建成功。新建的数据库可以再【对象资源管理器】窗口看到，如下图1.2所示。 图1.2建好后的数据库Students 4. 修改数据库建立一个数据库之后，可以根据需要对该数据库的结构进行修改。 启动SSMS，在“对象资源管理器”窗格中展开数据库节点，右击要修改的数据库名称，在弹出的快捷菜单中选择“属性”命令，打开“数据库属性”对话框。可以通过修改数据库属性来修改数据库。修改数据库的操作包括增减数据库文件、修改文件属性（包括数据库的名称、大小和属性）、修改数据库选项等。 5. 删除数据库为了减少系统资源的消耗，对于不再需要的用户创建数据库，应当把它从数据库服务器中删除，从而将其所占的磁盘空间全部释放掉。删除数据库的具体操作如下： 启动SSMS，在“对象资源管理器”窗格中展开数据库节点，右击要删除的数据库名称，在弹出的快捷菜单中选择“删除”命令，打开“删除对象”对话框，单击“确定”按钮，数据库就被删除。 1. 分离和附件数据库当数据库需要从一台计算机移到另一台计算机，或者需要从一个物理磁盘移到另一个物理磁盘时，常要进行数据库的附加与分离操作。附加数据库是指将当前数据库以外的数据库附加到当前数据库服务器中。附加数据库的具体操作如下： 启动SSMS，在“对象资源管理器”窗格中右击“数据库”节点在快捷菜单中选择“附加”命令，打开“附加数据库”对话框，如图1.3所示，单击“添加”按钮，打开“定位数据库文件”对话框，选择要附加的数据库主数据文件（.mdf），单击“确定”按钮，返回上述“附加数据库”对话框，单击“确定”按钮，完成数据库的附加操作。 图1.3 附加数据库 图1.4 分离数据库 分离数据库就是讲数据库从SQLserver2008服务器中卸载，但依然保存数据库的数据文件和日志文件。需要时，分离的数据库，可以重新附加到SQL server2008服务器中。 分离数据库的具体操作如下： 启动SSMS，在“对象资源管理器”窗格中展开数据库节点，右击要分离的数据库名称，在弹出的快捷菜单中单击“任务”→“分离”命令，如图1.4所示，打开“分离数据库”对话框，单击“确定”按钮，实现数据库的分离。 简答题：（1）打开SQL Server Management Studio时，怎样进行数据库的登录认证？ 答： 打开 SQL Server Management Studio，以 Windows身份认证方式登录 在对象资源管理器下，右键 Security ==&gt; Logins ==&gt; New Login 点击图片中的Logins 会显示SQL server 的所有用户 （2）对象资源管理器的作用是什么？答：“对象资源管理器”是服务器中所有数据库对象的树视图。此树视图可以包括SQL Server Database Engine、Reporting Services、Analysis Services、Integration Services和SQL Server Mobile的数据库。对象资源管理器包括与其链接的所有服务器的信息。 实验二 管理数据库操作实验日期： 实验目标：（1）熟练掌握用SQL语句创建数据库的方法。 （2）熟练掌握数据库属性的设置。 （3）掌握数据库的修改和删除方法。 实验内容：（1）利用SQL Server Management Studio创建一个”SM”的数据库，初始大小为3MB,最大为50MB，数据库自动增长，增长方式按10%；日志文件初始大小为2MB，最大值不受限制，按1MB增长。 （2）通过SQL语句创建一个名为“学籍”的数据库，指定主文件名为“学籍_data”，存储路径为“d:\\example\\学籍_data.mdf”，该数据文件的初始大小为10MB，最大为100MB，增长方式按10MB增长；指定主日志文件名为“学籍_log”，存储路径为“d:\\example\\学籍_log.ldf”，该日志文件初始大小为20MB，最大为200MB，按10MB增长。 ① 在工具栏单击“新建查询”按钮，打开代码编辑器，输入如下SQL语句。 12345678910111213 Create database 学籍 On primary(name=学籍_data,Filename=’d:\\example\\学籍_data.mdf’,Size=10,Maxsize=100,Filegrowth=10)Log on(name=学籍_log,Filename=’d:\\example\\学籍_log.ldf’,Size=20,Maxsize=200,Filegrowth=10) 请执行该语句，即可创建“学籍”数据库。 ② 使用对象资源管理器，可以修改“学籍”数据库。选择“学籍”数据库的节点，点击右键，在弹出的快捷菜单中选择“属性”命令，打开“数据库属性”对话框，即可进行数据库的修改操作。 ③ 使用”SQL”语句，在“学籍”数据库中添加一个数据文件“学籍_data1”，指定其初始大小为4MB，最大不受限制，增长方式按10%增长。 12345678Alter database 学籍Add file(name=’学籍_data1’,Filename=’d:\\example\\学籍_data1.mdf’,Size=4,Maxsize=unlimited,Filegrowth=10%)Go ④ 使用SQL语句删除“学籍”数据库。 12Drop database 学籍GO 提示：当数据库正在参与复制是不能删除，当数据库正在被复制时不能删除，当有用户正在使用数据库时不能删除。 简答题：（1）SQL Server2008中的数据库能否只包含数据文件？ 实验三 用T-SQL创建与修改表的操作实验日期： 实验目标：（1）熟练掌握各种数据类型。 （2）熟练运用T-SQL（Transact-SQL）语句正确创建表。 （3）掌握常用的数据完整性约束。 实验内容：（1）创建“学籍”数据库，在该数据库中创建Student表。表3.1 Student表的结构 列名 数据类型 长度 字段说明 能否为空 是否主键 Sno CHAR 10 学号 否 是 Sname CHAR 10 姓名 是 否 Ssex CHAR 2 性别 是 否 Sage TINYINT 年龄 是 否 Sdept CHAR 10 系 是 否 利用T-SQL命令创建Student表，表的结构如表3.1所示。代码如下： 1234567CREATE TABLE Student( Sno CHAR(10) primary key, Sname CHAR(10), Ssex CHAR(2) check (Ssex in (‘男’,’女’)), Sage TINYINT, Sdept CHAR(10) ) （2）利用T-SQL命令创建Course表，表的结构如表3.2所示。 表3.2 Course表的结构 列名 数据类型 长度 字段说明 能否为空 是否主键 Cno CHAR 5 课程号 否 是 Cname CHAR 10 课程名 否 否 Credits TINYINT 学分 是 否 PCno CHAR 5 先修课程号 是 否 代码如下： 12345678CREATE TABLE Course (Cno char(5) NOT NULL,Cname char(10) NOT NULL, PCno char(5),Credit tinyint CHECK (Credit &gt; 0),PRIMARY KEY(Cno),FOREIGN KEY (PCno) REFERENCES Course(Cno),) （3）为已经创建了的Student表创建一个约束，规定在Student表中，如果学生没有提供所在系，就写入默认值“计算机系”。df_dept为该约束的名。代码如下： 123Alter table StudentAdd constraint df_deptDefault ‘计算机系’ for Sdept （4）利用T-SQL命令创建SC表，表的结构如表3.3所示。表3.3 SC表的结构 列名 数据类型 长度 字段说明 能否为空 是否主键 Sno CHAR 10 学号 否 是 Cno CHAR 5 课程号 否 是 Grade TINYINT 成绩 是 否 代码如下： 123456CREATE TABLE SC(Sno char(10) FOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE,Cno char(5) FOREIGN KEY(Cno) REFERENCES Course(Cno),Grade tinyint CHECK(grade&lt;=100 and grade&gt;=0),PRIMARY KEY(Sno,Cno)) 执行并思考Sno char(10) FOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE语句中ON DELETE CASCADE的含义与作用。 问答题（1）T-SQL支持的数据类型有哪些？ 答：整数数据类型，浮点数据类型，字符型数据类型，日期和时间数据类型。 （2）Tinyint数据类型定义的数据的取值范围是多少？ 存储0~255之间的整数 （3）写出创建以下表3.4-3.6所示的表结构的SQL语句，要求在定义表的同时定义数据的完整性约束。 123456Create table 图书表( 书号 nchar(6) primary key, 书名 nvarchar(30) not null, 第一作者 char(10) not null, 出版日期 smalldatetime, 价格：numeric(4,1) ) 123456Create table 书店表( 书店编号 nchar(6) primary key, 店名 nvarchar(30) not null, 电话char(8) check(电话 like ‘[0-9][0-9][0-9][0-9][0-9][0-9][0-9] [0-9]’), 地址 varchar(40), 邮政编码 char(6) ) 123456Create table 图书销售表( 书号 nchar(6) not null, 书店编号 nchar(6) not null, 销售日期 smalldatetime no tnull,销售数量 smalldatetime check(销售数量 &gt;= 1) ) 表3.4 图书表 列名 数据类型 约束 书号 统一字符编码定长类型，长度为6 主键 书名 统一字符编码可变长类型，长度为30 非空 第一作者 普通编码定长字符，长度为10 非空 出版日期 小日期时间型 非空 价格 定点小数，小数部分1位，整数部分3位 表3.5 书店表 列名 数据类型 约束 书店编号 统一字符编码定长类型，长度为6 主键 店名 字符编码可变长类型，长度为30 非空 电话 普通编码定长字符类型，长度为8 地址 普通编码可变长字符类型，长度40 邮政编码 普通编码定长字符类型，长度6 表3.6 销售表 列名 数据类型 约束 书号 统一字符编码定长类型，长度为6 主键，外键 书店编号 统一字符编码定长类型，长度为6 主键，外键 销售日期 小日期时间型 主键 销售数量 小整型 邮政编码 普通编码定长字符类型，长度6 （4）删除“销售表”中的“邮政编码”列； 1alter table 书店表 Drop column 邮政编码 （5）将“销售表”中的“销售数量”列的数据类型改为整型 1alter table 图书销售表 Alter column 销售数量 int 实验四 数据查询的操作（一）实验日期： 实验目标：（1）掌握SELECT子句以及WHERE子句的使用方法。 （2）学会应用ORDER BY子句。 （3）掌握5种基本的聚合函数。 （4）学会分组统计和二次查询。 （5）学会数据的导入与导出的方法。 实验内容：在SELECT语句中使用WHERE子句，在WHERE子句后跟一个条件式，就可以查询满足条件的行。WHERE子句的格式：WHERE〈条件〉。表4.1 常用的查询条件 查询条件 运算符 说明 比较 =、&lt;、&lt;=、&gt;、&gt;=、&lt;&gt;、!=、!&lt;、!&gt; 范围谓词 BETWEEN AND 、NOT BETWEEN AND 介于二者之间（包括两端）、不介于二者之间 集合谓词 IN 、 NOT IN 在集合中、不在集合中 字符匹配谓词 LIKE、NOT LIKE 匹配、不匹配 空值 IS NULL 、IS NOT NULL 是空值、不是空值 逻辑运算 NOT、AND、OR 逻辑非、逻辑与、逻辑或 打开对象资源管理器，创建一个名为”lianxi1”的数据库，在该数据库中导入以下的仓库表4.2和职工表4.3。表4.2 仓库表 仓库号 城市 面积 WH1 北京 370 WH2 上海 500 WH3 广州 200 WH4 广州 300 WH5 天津 340 WH6 上海 350 WH7 上海 600 WH8 天津 300 注意：面积以平方为单位。 表4.3 职工表 职工号 姓名 仓库号 月工资 性别 E1 朱迪 WH2 2220 女 E2 牛丽丽 WH1 1810 女 E4 李安 WH2 1850 男 E5 王进步 WH3 1530 男 E6 李光铭 WH1 1550 男 E7 赵芙蓉 WH4 2300 女 E8 刘山 WH4 2000 男 E9 张尚琳 WH5 2050 女 E10 王玛丽 WH5 1900 女 E11 胡尼克 WH6 2100 男 E12 古梅 WH7 1700 女 E15 胡俊 WH5 1780 男 E16 胡轩 WH1 1600 男 用SQL语句完成以下的练习题： 从职工关系中检索所有工资值。 12select 月工资from zg 检索仓库关系中的所有元组。 12select *from ck 检索工资多于2000元的职工对应的职工号，姓名。 123select 职工号,月工资 from zg where 月工资&gt;2000 检索哪些仓库的面积在400到550平方之间，列出仓库号和所在的城市。 1234select 仓库号,城市 from ck where 面积&lt;=550 and 面积&gt;=400 检索出有广州哪些仓库，列出仓库号。 123select 仓库号from ck where 城市='广州' 检索出所在城市为广州的仓库的个数。 123select count(仓库号)from ck where 城市='广州' 检索出所有职工的平均工资。 12select avg(月工资) from zg 检索出在WH5仓库工作的职工的人数。 123select count(职工号) from zg where 仓库号='WH5' 检索出职工表的所有的仓库号，去掉重复值。 1select distinct 仓库号 from zg 检索出每个仓库的人数。 123select 仓库号,count(*) as 人数 from zg group by 仓库号 检索出上海的仓库有哪些，列出仓库号、面积。查询结果按面积降序排列。 1234select 仓库号,面积 from ck where 城市='上海' order by 面积 检索出哪些仓库女职工的人数达到了3人。 12345select 仓库号,count(职工号)人数from zg where 性别='女'group by 仓库号 having count(职工号)&gt;3 检索出所有姓胡的职工的职工号、姓名、性别、工资。查询结果按性别排降序、工资排升序。 1234select 职工号,姓名,性别,月工资from zgwhere 姓名 like'胡%'order by 性别 desc,月工资 asc 检索出职工“王玛丽”的年工资。 123select 月工资*12 as 年薪from zgwhere 姓名='王玛丽' 检索出“WH1”和“WH2”两个仓库工作的职工的基本信息。 123select *from zgwhere 仓库号='WH1'or 仓库号='WH2' 检索出年工资在24000以上的职工的姓名，年工资值。 123select 姓名from zgwhere 月工资*12&gt;24000 问答题：（1）WHERE子句与HAVING子句有和不同？ 答：Where子句–指定查询条件，having短语—选择出只有满足指定条件的组. where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。 （2）在WHERE子句中可以使用的运算符有哪些？WHERE子句中能不能使用聚集函数？ 答：in，not in；字符匹配：like，not like；空值：is null，is not null；多重条件：and，or。Where子句中不能使用聚集函数。 不能使用聚集函数 实验五 数据查询的操作（二）实验日期： 实验目标：（1）熟练掌握基本的连接操作，掌握内连接与外连接的方法，学会应用自身连接。 （2）熟练掌握不相关子查询。 （3）掌握相关子查询。 （4）学会给表命别名。 （5）学会数据的导入与导出的方法。 实验内容：打开对象资源管理器，创建一个名为”lianxi2”的数据库，在该数据库中导入以下的仓库表5.1、职工表5.2、订购表5.3和供应商表5.4。 表5.1仓库表 仓库号 城市 面积 WH1 北京 3700 WH2 上海 5000 WH3 广州 2000 WH4 武汉 4000 WH5 上海 4560 WH6 广州 6700 WH7 珠海 4800 表5.2职工表 仓库号 职工号 月工资 WH2 E1 2220 WH1 E2 2210 WH2 E3 4050 WH3 E4 3230 WH1 E5 3250 WH1 E6 2300 WH4 E7 5000 WH5 E8 4000 WH5 E9 3400 WH6 E10 3800 表5.3 订购表 职工号 供应商号 订购单号 订购日期 E3 S7 OR091204 2009-12-4 E1 S4 OR090101 2009-4-1 E7 S4 OR100402 2010-4-2 E6 S6 OR100121 2010-1-21 E3 S4 OR091115 2009-11-15 E1 S6 OR060201 2006-2-1 E3 S6 OR100312 2010-3-12 E3 S3 OR090302 2009-3-2 E8 S7 OR100928 2010-9-28 E6 S7 OR100712 2010-7-12 E5 S3 OR100507 2010-5-7 表5.4 供应商表 供应商号 供应商名 地址 S3 振华电子厂 西安 S4 华通电子公司 北京 S6 607厂 郑州 S7 爱华电子厂 北京 用SQL语句完成以下的练习题： 查询每个城市的仓库总面积。 123select 城市,sum(面积) as 总面积from ckgroup by 城市 查询每个仓库的职工人数，如果该仓库没有职工，也要列出人数为0。 1234select 仓库号,count(职工号) as 职工人数from zggroup by 仓库号having count(职工号)&gt;=0 123select ck.仓库号,count(职工号)as 职工人数from ck left join zg on ck.仓库号=zg.仓库号group by ck.仓库号 查询在上海工作的职工有多少个。 123456select 城市,count(职工号) as 上海职工数from ck,zgwhere ck.仓库号=zg.仓库号and ck.城市='上海'group by 城市 查询哪些职工在上海工作，列出他们的职工号，仓库号。 12345select 职工号,zg.仓库号from ck,zgwhere ck.城市='上海' and ck.仓库号=zg.仓库号 查询与E3号职工有订购业务联系的供应商号，供应商名。 123select dg.供应商号,gys.供应商名from dg,gyswhere 职工号='E3' and dg.供应商号=gys.供应商号 查询哪些职工与爱华电子厂有订购业务联系，列出他们的职工号，仓库号。 123select zg.职工号,zg.仓库号from zg,gywhere gy.供应商名='爱华电子厂' 1234select zg.职工号,zg.仓库号from dg join gys on dg.供应商号=gys.供应商号join zg on zg.职工号=dg.职工号where 供应商名='爱华电子厂' 查询每个供应商的订购单数目，列出供应商号和他们的订购单数目。1234select dg.供应商号,count(dg.订购单号) as 订购单数目from dg,gywhere gy.供应商号=dg.供应商号group by gy.供应商名,dg.供应商号 123select dg.供应商号,count(订购单号) 订购单数目from dg join gys on dg.供应商号=gys.供应商号group by dg.供应商号 查询工资在3000元以上，并在北京或上海工作的职工，列出他们的职工号和工资。1234select zg.职工号,zg.月工资from zg,ckwhere (ck.城市='北京' or ck.城市='上海')and zg.月工资&gt;3000 123select 职工号,月工资from ck join zg on ck.仓库号=zg.仓库号where (城市='北京'or 城市='上海') and 月工资&gt;3000 查询与供应商为S3的供应商有业务联系的职工他们的职工号、订购单号、仓库号、城市。 12345select dg.职工号,dg.订购单号,ck.仓库号,ck.城市from gys join dg on gys.供应商号=dg.供应商号join zg on dg.职工号=zg.职工号join ck on zg.仓库号=ck.仓库号where gys.供应商号='S3' 查询出哪些仓库没有分配职工。 123select ck.仓库号from ck left join zg on ck.仓库号=zg.仓库号where zg.职工号 is null 1234select ck.仓库号,count(zg.仓库号) 人数from ck left join zg on zg.仓库号 = ck.仓库号group by ck.仓库号having count(zg.仓库号)=0 123select 仓库号from ckwhere 仓库号 not in (select distinct 仓库号 from zg) 查询出哪些职工的工资高于全体职工平均工资。 123select 职工号from zgwhere 月工资&gt;(select avg(月工资) from zg ) 查询出哪些职工的工资高于他所在仓库的职工的平均工资。 12345select 职工号from zg join (select 仓库号 avg(月工资) as 平均工资from zg group by 仓库号) as a on zg.仓库号=ck.职工号where zg.月工资&gt;a.avg(月工资) 12345select 职工号from zg awhere 月工资&gt;(select avg(月工资) from zg bwhere b.仓库号=a.仓库号) 123456select 职工号from zg as a join(select 仓库号,avg(月工资) as 平均工资 from zg group by 仓库号)as b on a.仓库号=b.仓库号where a.月工资&gt; b.平均工资 求出哪个职工所发出的订购单最多。1234select top 1 职工号,count(订购单号) as 订购单数from dggroup by 职工号order by 订购单数 desc 12345678select 职工号from dggroup by 职工号having count(订购单号)=(select top 1 count(订购单号) as 订单数from dggroup by 职工号order by 订单数 desc) 实验六 数据查询的操作（三）实验日期： 实验目标：（1）熟练掌握基本的连接操作，掌握内连接与外连接的方法，学会应用自身连接。 （2）熟练掌握不相关子查询。 （3）掌握相关子查询。 （4）学会给表命别名。 （5）学会在FROM子句中派生关系，构造查询。 实验内容：假设“教学管理”数据库中有4个基本表（关系）： 学生关系：学生（学号，姓名，性别，所在系） 课程关系：课程（课程号，课程名，开课学期，教师号） 选课关系：选课（学号，课程号，成绩） 教师关系：教师（教师号，姓名，职称，部门） 每个关系的当前值分别如表所示。 打开对象资源管理器，创建一个名为”教学管理”的数据库，在该数据库中导入以下的 表6.1—6.4。 表6.1 学生关系 学号 姓名 性别 年龄 所在系 S101101 陈名军 男 18 计算机系 S101102 吴小晴 女 19 计算机系 S101103 王明燕 女 19 计算机系 S101104 严利 男 20 计算机系 S101105 朱欣 男 20 计算机系 S101201 李国庆 男 21 信息系 S101202 李祥 男 21 信息系 S101203 孙渝研 男 20 信息系 S101204 赵艳 女 18 信息系 S101205 刘唯 女 19 信息系 S101206 林玉霞 女 20 信息系 S101207 王江 男 21 信息系 S101301 王成 男 20 会计系 S101302 张平安 男 18 会计系 S101401 钟琴 女 19 会计系 S101402 吴娟娟 女 21 会计系 S101403 李月 女 22 会计系 S101404 陈名军 男 23 会计系 S101405 赵艳 女 21 会计系 表6.2课程关系 课程号 课程名 开课学期 学分 教师号 101 计算机基础 1 3 T1 102 体育 2 4 T2 201 英语 1 4 T3 202 大学语文 3 4 T4 305 操作系统 4 4 T5 304 计算机原理 4 4 T5 301 计算机网络 3 3 T6 302 电子技术 3 4 T6 303 数据库应用 4 3 T7 表6.3 选课关系 学号 课程号 成绩 S101101 101 60 S101101 102 83 S101101 201 78 S101101 305 79 S101101 202 87 S101101 304 89 S101101 303 64 S101101 302 90 S101102 101 84 S101101 301 83 S101102 102 75 S101102 202 86 S101102 303 67 S101201 101 78 S101201 102 72 S101201 303 76 S101201 201 50 S101301 101 90 S101302 101 90 S101302 303 83 表6.4教师表 教师号 姓名 职称 部门 T1 胡美丽 讲师 公共教学 T2 王珊珊 讲师 公共教学 T3 王新 讲师 公共教学 T4 李再敏 副教授 公共教学 T5 李红玉 教授 计算机系 T6 周进 助教 计算机系 T7 张丽丽 助教 计算机系 T8 王晓舟 副教授 计算机系 T9 周樱 讲师 信息系 查询“101”课程成绩比“102”课程成绩高的所有学生的学号。提示：12345select a.学号From (select 学号,成绩 from xkgx where 课程号='101') a,(select 学号,成绩from xkgx where 课程号='102') bwhere a.成绩&gt;b.成绩 and a.学号=b.学号 自然连接： 1234select a.学号from xkgx a join xkgx b on a.学号=b.学号where a.课程号='101' and b.课程号='102' and a.成绩&gt;b.成绩 查询全部选修课程表中所有课的同学的学号、姓名。 123456select 学号,姓名from xsgxwhere 学号 in(select 学号 from xkgx group by 学号 having count(课程号)=(select count(课程号) from kcgx)) 查询哪些老师没有教授任何课程。列出老师的全部列。（not in和not EXISTS两种方式实现）。 12345select *from jswhere 教师号 not in(select 教师号 from xkgx join kcgx on xkgx.课程号=kcgx.课程号) 12345select *from jswhere 教师号 not in (select 教师号 from kcgx where kcgx.教师号=jsgx.教师号) 123456select *from jswhere NOT EXISTS(select distinct js.教师号 from kcgx where kcgx.教师号=js.教师号) 查询出只选修了一门课程的学生的学号和姓名。123456select xsgx.学号,xsgx.姓名from xsgxwhere xsgx.学号 in(select xkgx.学号 from xkgx group by xkgx.学号 having count(xkgx.课程号)=1) 1234select xsgx.学号,姓名from xsgx join xkgx on xsgx.学号=xkgxx.学号group by xsgx.学号,xsgx.姓名having count(xkgx.课程号)=1 查询张丽丽老师教过的学生的学号、姓名。12345678select xsgx.学号,xsgx.姓名from xsgxwhere kcgx.课程号 in(select 课程号 from xkgxwhere kcgx.教师号 in(select js.教师号from jswhere js.姓名='张丽丽') 123456789select xsgx.学号,xsgx.姓名from xsgx,kcgx,xkgx,jswhere xsgx.学号=xkgx.学号 and kcgx.课程号=xkgx.课程号 andjs.教师号=kcgx.教师号and js.姓名='张丽丽' 123456select sxgx.学号,s.姓名from js join kcgx on js.教师号=kcgx.教师号join xkgx on kcgx.课程号=xkgx.课程号join xsgx on xkgx.学号=xsgx.学号where t.姓名='张丽丽'group by xsgx.学号,xsgx.姓名 查询相同姓名的学生，列出相同的姓名及相应的同名人数。（有几个学生同名）提示：考虑按姓名分组，分组内元组的个数。 12345select *from xsgxwhere 姓名 in(select 姓名 from xsgxgroup by 姓名having count(*)&gt;1) 查询每门功成绩最好的前两名。 提示： 1234567SELECT t1.学号,t1.课程号,成绩FROM 选课 t1WHERE 成绩 IN (SELECT TOP 2 成绩FROM 选课WHERE 课程号= t1.课程号ORDER BY 成绩 DESC) 1234567SELECT t1.学号,t1.课程号,成绩FROM xkgx t1WHERE 成绩 IN (SELECT TOP 2 成绩FROM xkgxWHERE 课程号= t1.课程号ORDER BY 成绩 DESC)ORDER BY 课程号 DESC 这道题每次父亲查询都提供课程号的值给子查询，其子查询的功能就是计算父查询对应课程的前两名。 查询学过“101”并且也学过编号“102”课程的同学的学号、姓名。1234567select xsgx.学号,xsgx.姓名from xsgxgroup by xkgx.学号where 学号 in (select 学号 from xkgxwhere 课程号='101')and 学号 in (select 学号 from xkgxwhere 课程号='102') 9.查询没有选修课程表中所有课的同学的学号、姓名。 123456select xsgx.学号,xsgx.姓名from xsgxwhere 学号 in(select 学号 from xkgx group by 学号having count(课程号)&lt;(select count(课程号) from kcgx)) 12345select xsgx.学号,xsgx.姓名from xsgx join xkgx on xsgx.学号=xkgx.学号group by xsgx.学号,xkgx.姓名having count(kcgs.课程号)&lt;(select count (课程号) from kcgx ) 或者 1234567select distinct kcgx.学号,xsgx.姓名from xkgx join xsgx on xkgx.学号=xsgx.学号where xkgx.学号 not in(select 学号 from xkgxgroup by 学号having count(课程号) =(select count (课程号) from kcgx)) 10.查询全部学生都选修过的课程对应的课程号和课程名。提示：意味着该课程的选课人数与学生总人数相等。考虑按课程号分组，查询哪个分组中学号的个数与学生个数相等，得到这样的分组它的课程号。 1234567select kcgx.课程号,kcgx.课程名from kcgxwhere 课程号 in(select 课程号 from xkgx group by 课程号 having count(学号)=(select count(学号) from xsgx)) 1234567select 课程名,课程号from kcgxwhere kcgx.课程号 in (select 课程号from xkgxgroup by 课程号having count(学号) =(select count(学号)from xsgx)) 11.查询没学过“李红玉”老师讲授的任一门课程的学生姓名。（not in不相关即可实现） 123456789select 姓名from xsgxwhere 学号 not in(select 学号 from xkgx,js,kcgx where xkgx.课程号=kcgx.课程号 andkcgx.教师号=js.教师号 and js.姓名='李红玉') 1234567select 姓名from xsgxwhere 学号 not in(select 学号 from xkgx join kcgx on xkgx.课程号=kcgx.课程号join t on kcgx.教师号=xkgx.教师号where 姓名='李红玉') 实验七 视图与索引实验日期： 实验目标：（1）掌握创建视图、删除视图； （2）查询视图。 （3）更新视图、修改视图对应的数据。 （4）理解索引的概念和索引的作用，学会使用索引。 （5）了解聚簇索引和非聚簇索引。 实验内容：假设“学生选课”数据库中有3个基本表（关系）： 学生关系：学生（学号，姓名，性别，所在系） 课程关系：课程（课程号，课程名，开课学期，教师号） 选课关系：选课（学号，课程号，成绩） 每个关系的当前值分别如表所示。 打开对象资源管理器，创建一个名为”学生选课”的数据库，在该数据库中导入以下的 表7.1—7.3。表7.1 学生关系 学号 姓名 性别 年龄 所在系 S101101 陈名军 男 18 计算机系 S101102 吴小晴 女 19 计算机系 S101103 王明燕 女 19 计算机系 S101104 严利 男 20 计算机系 S101105 朱欣 男 20 计算机系 S101201 李国庆 男 21 信息系 S101202 李祥 男 21 信息系 S101203 孙渝研 男 20 信息系 S101204 赵艳 女 18 信息系 S101205 刘唯 女 19 信息系 S101206 林玉霞 女 20 信息系 S101207 王江 男 21 信息系 S101301 王成 男 20 会计系 S101302 张平安 男 18 会计系 S101401 钟琴 女 19 会计系 S101402 吴娟娟 女 21 会计系 S101403 李月 女 22 会计系 S101404 陈名军 男 23 会计系 S101405 赵艳 女 21 会计系 表7.2课程关系 课程号 课程名 开课学期 学分 教师号 101 计算机基础 1 3 T1 102 体育 2 4 T2 201 英语 1 4 T3 202 大学语文 3 4 T4 305 操作系统 4 4 T5 304 计算机原理 4 4 T5 301 计算机网络 3 3 T6 302 电子技术 3 4 T6 303 数据库应用 4 3 T7 表7.3 选课关系 学号 课程号 成绩 S101101 102 83 S101101 101 60 S101101 201 78 S101101 202 87 S101101 305 79 S101101 304 89 S101101 303 64 S101101 302 90 S101101 301 83 S101102 101 84 S101102 102 75 S101102 202 86 S101102 303 67 S101201 101 78 S101201 102 72 S101201 303 76 S101201 201 50 S101301 101 90 S101302 101 90 S101302 303 83 用学生、课程、选课这三张表，利用SQL语句完成以下练习题。 （1）创建V1视图，学生的学号、姓名、所在系、课程号、课程名、课程学分的视图。 123456create view V1 asselect xs.学号,姓名,所在系,xk.课程号,kc.课程名,学分from xs join xk on xs.学号=xk.学号 join kc on xk.课程号=kc.课程号 （2）创建V2视图，查个学生的平均成绩的视图，要求列出学生学号及平均成绩。 12345create view V2asselect 学号,avg(成绩) as 平均成绩from xkgroup by 学号 （3）创建V3视图，每个学生的修课学分的视图，要求列出学生学号及总学分。 12345create view V3asselect 学号,sum(学分) as 总学分from xk join kc on xk.课程号=kc.课程号group by 学号 （4）上面的视图V3能否对其总学分对应的数据进行修改？ 12update V3 set 总学分=10 where 学号='S101101'select * from V3 对视图或函数 ‘V3’ 的更新或插入失败，因其包含派生域或常量域。 （5）创建V4视图，计算机系的学生基本信息的视图。该视图能否更新学生的姓名？（无需选课的信息）。 12345678create view V4asselect *from xswhere 所在系='计算机系'update V4 set 姓名='陈大军' where 姓名='陈名军' 可以更新 （6）创建V5视图，每个学生获得的最高成绩，要求列出学号和最高成绩 12345create view V5asselect 学号,max(成绩) as 最高成绩from xkgroup by 学号 （7）借助视图V5，实现该查询，对每个学生找出他获得最高成绩的课程号。 1234select V5.学号,课程号from V5 join xk on V5.学号=xk.学号where 成绩=top 1group by xk.课程号 （8）删除视图V1。 1drop view V1 （9）为学生关系的姓名列创建一个非聚簇索引。 1create nonclustered index 非聚簇索引 on xs(姓名) （10）为课程表的课程名创建一个聚簇索引。 1create clustered index 聚簇索引 on kc(课程名) 简答题 视图可以加快数据的查询速度，这句话对吗？为什么？ 不对，因为通过视图查询数据时，比直接针对基本表查询数据多了一个转换过程，即从外模式到模式的转换。 视图可以简化查询，这句话对吗？为什么？ 对，简化操作 视图是一个虚表，数据库中只存放视图的定义，而不存放视图包含的数据，这些数据仍存放在原来基本表中。这句话对吗？ 对 基本表中的数据如果发生变化，视图中查询出数据也随之变化。这句话对吗？ 对 索引是否越多越好？ 否 索引需要在内存和物理磁盘驱动器上使用更多的存储空间。在执行插入声明的过程中可能会在一定程度上导致系统性能的下降，因为在插入数据的时候是需要根据索引的顺序插入，而不是在第一个可用的位置直接插入数据，这样一来，存在的索引越多将导致插入或者更新声明所需要的时间就越多。 1)索引影响DML操作,任何DML操作都要更新INDEX, 这是代价。 2)任何方便都是有代价的，select的时候方便，insert、update、delete的时候就要维护index。 3)索引多了, 执行计划的制定要费更多的资源。 4)创建和维护索引是有成本的。 5)索引能够极大的提高数据检索效率，也能够改善排序分组操作的性能，但是我们不能忽略的 一个问题就 是索引是完全独立于基础数据之外的一部分数据。 哪些视图不能更新？ 若视图的属性来自集函数、表达式，则该视图肯定是不可以更新的 若视图是由两个以上基本表导出的，则次视图不允许更新。– 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。 若视图的字段来自集函数，则此视图不允许更新。 若视图定义中含有GROUP BY子句，则此视图不允许更新若视图中含有DISTINCT短语，则此视图不允许更新 若视图定义中有嵌套查询，并且内层查询FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。 一个不允许更新的视图上定义的视图也不允许更新。 聚簇索引和非聚簇索引有何区别，为什么每个表只能有一个聚簇索引？ 答：聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。一个表只能有一个聚簇索引，因为数据一旦存储，顺序只能有一种。 聚簇索引 (1) 一个索引项直接对应实际数据记录的存储页，可谓“直达” (2) 主键缺省使用它 (3) 索引项的排序和数据行的存储排序完全一致，利用这一点，想修改数据的存储顺序，可以通过改变主键的方法（撤销原有主键，另找也能满足主键要求的一个字段或一组字段，重建主键） (4) 一个表只能有一个聚簇索引（理由：数据一旦存储，顺序只能有一种） 非聚簇索引 (1) 不能“直达”，可能链式地访问多级页表后，才能定位到数据页 (2)一个表可以有多个非聚簇索引 聚簇索引的顺序就是数据的物理存储顺序，而对非聚簇索引的解释是:索引顺序与数据物理排列顺序无关。正式因为如此，所以一个表最多只能有一个聚簇索引。 实验八 数据操作实验日期： 实验目标：（1）掌握插入数据到表中。 （2）掌握删除表中的数据。 （3）掌握修改表中的数据。 实验内容：建立一个名叫“仓库职工”的数据库，接下来请利用实验五的数据，将表中的数据导入到“仓库职工”数据库中。用T-SQL语句完成以下练习题。 查询每个城市的仓库的总面积，将查询的结果插入到新表t1中，该表需要自己创建。创建表t1的代码如下：1234Create table t1(cityname char(20),Sumarea int) 运行代码创建了表t1。接下来向t1中插入数据，其中数据为某个子查询的结果。代码提示如下： 1234Insert into t1Select 城市,sum(面积)From 仓库Group by 城市 插入一个新的供应商元组（S9，智通公司，沈阳） 12insert into 供应商表values ('S9','智通公司','沈阳') 北京的所有仓库增加100M2的面积。 1 update ck set 面积=面积+100 where 城市='北京' 给低于所有职工平均工资的职工提高5%（注意要用0.05表示5%）的工资。 1234update 职工表set 月工资=月工资*(1+0.005)where 月工资&lt;(select avg(月工资) from 职工表) 给北京的职工加900元工资。（相关子查询，不相关子查询，多表三种方法实现 ）。 用相关子查询实现的代码如下： 12345Update 职工Set 月工资=月工资+900Where ‘北京’=(select 城市From 仓库Where 仓库.仓库号=职工.仓库号) 用不相关子查询实现的代码如下： 12345Update 职工Set 月工资=月工资+900Where 仓库号=(select 仓库号From 仓库Where 城市=’北京’) 6． 删除目前没有任何订购单的供应商。 123delete from 供应商表where 供应商号 not in(select 供应商号 from 订购表) 7． 删除由在上海仓库工作的职工发出的所有订购单。 1234delete from 订购表where 职工号 in(select 职工号 from 职工表 where 仓库号 in( select 仓库号 from 仓库表 where 城市='上海')) 实验九 流程控制语句（选做）实验日期： 实验目标： （1）掌握流程控制关键字。 （2）查询流程控制关键字的使用方法。实验内容：流程控制语句是指那些用来控制程序执行和流程分支的语句，在SQL Server 2008中，流程控制语句用来控制SQL语句、语句块或者存储过程的执行流程。 Transact-SQL 语言使用的流程控制命令与常见的程序设计语言类似，主要有以下几种控制命令。 假设有“学生选课”的数据库，数据如实验七。 （1）使用IF…ELSE 语句IF...ELSE语句是条件判断语句，其中，ELSE子句是可选的，最简单的IF语句没有ELSE子句部分。IF…ELSE语句用来判断当某一条件成立时执行某段程序，条件不成立时执行另一段程序。SQL Server允许嵌套使用IF…ELSE语句，而且嵌套层数没有限制。IF…ELSE语句的语法形式为： 1234IF &lt;布尔表达式&gt; &lt;SQL语句&gt;|&lt;语句块&gt; [ELSE &lt;SQL语句&gt;|&lt;语句块&gt;] 例 在Student表中查询是否有‘张力’这个学生。如果有，则显示这个学生的姓名和系，否则显示没有此人。 12345678910USE 学生选课GODECLARE @message VARCHAR(20)IF EXISTS(SELECT * FROM Student WHERE SNAME='张力') SELECT SNAME,SDEPT FROM Student WHERE SNAME='张力'ELSE BEGIN SET @message='没有此人' PRINT @messageEND 例 在SC表中查询是否有成绩大于90分的学生，有则输出有学生的成绩高于90分，否则输出没有学生的成绩高于90分。 123456789USE STUDENTSGODECLARE @message VARCHAR(20)IF EXISTS(SELECT * FROM SC WHERE GRADE&gt;90) PRINT '有学生的成绩高于90分'ELSE BEGIN SET @message='抱歉，没有学生的成绩高于90分' PRINT @messageEND （2）使用BEGIN...END 语句在控制流程中需要执行两条或两条以上的语句，应该将这些语句定义为一个语句块（称为复合语句）。BEGIN和END必须成对实现。语法格式： 123BEGIN &lt;SQL语句&gt;|&lt;语句块&gt; END （3）使用CASE语句CASE结构提供比IF……ELSE结构更多的选择和判断的机会。使用CASE表达式可以很方便的实现多重选择的情况，从而可以避免编写多重的IF……ELSE嵌套循环。CASE语句按照使用形式不同，可以分为简单CASE语句和搜索CASE语句，它们的语法形式分别为： 简单CASE函数：123456CASE &lt;表达式&gt;WHEN &lt;表达式&gt; THEN &lt;表达式&gt;…WHEN &lt;表达式&gt; THEN &lt;表达式&gt;[ELSE &lt;表达式&gt;]END 例 从学生表Student中，选取SNO，SSEX，如果SSEX为“男”则输出“M”，如果为“女”输出“F”。 123456SELECT SNO,SSEX=CASE SSEX WHEN '男' THEN 'M' WHEN '女' THEN 'F' ENDFROM Student 运行结果如图8.10所示。2. CASE搜索函数： 1234567CASE WHEN &lt;条件表达式&gt; THEN &lt;表达式&gt; …WHEN &lt;条件表达式&gt; THEN &lt;表达式&gt; [ELSE &lt;表达式&gt;]END 例 从SC表中查询所有同学选课成绩情况，凡成绩为空者输出“未考”、小于60分输出“不及格”、60分至70分输出“及格”、70分至90分输出“良好”、大于或等于90分时输出“优秀”。 123456789SELECT SNO,CNO,GRADE,GRADE=CASE WHEN GRADE IS NULL THEN '未考' WHEN GRADE&lt;60 THEN '不及格' WHEN GRADE&gt;=60 AND GRADE&lt;70 THEN '及格' WHEN GRADE&gt;=70 AND GRADE&lt;90 THEN '良好' WHEN GRADE&gt;=90 THEN '优秀' ENDFROM SC （4）使用循环：WHILE语句WHILE语句用来处理循环。在条件为TRUE的时候，重复执行一条或一个包含多条T-SQL语句的语句块，直到条件表达式为FALSE时退出循环体.其语法如下： 1234567WHILE &lt;条件表达式&gt; [BEGIN] &lt;程序块&gt; [BREAK] [CONTINUE] [程序块] [END] 说明：CONTINUE 命令可以让程序跳过CONTINUE 命令之后的语句，回到WHILE 循环的第一行，继续进行下一次循环。BREAK 命令则让程序完全跳出循环，结束WHILE 命令的执行。WHILE语句也可以嵌套。例 编程求1到100的和。 12345678910declare @i intdeclare @sum intset @i=1set @sum =0while @i&lt;=100begin set @sum =@sum+@i set @i=@i+1endselect @sum as 合计 ,@i as 循环数 图9.1运行结果如图9.1所示。 请读下列程序并回答下列程序的功能。 123456789101112DECLARE @i INTSET @i = 1WHILE (@i &lt; 11) BEGIN IF(@i &lt; 5) BEGIN SET @i = @i + 1 CONTINUE END PRINT @i SET @i = @i + 1 END （5）使用GOTO 语句GOTO：可以将执行流程改变到由标签指定的位置。系统跳过GOTO关键字之后的语句，并在GOTO 语句中指定的标签处继续执行操作。语法：GOTO 标识符求1＋2＋3＋…＋10的总和。 1234567891011DECLARE @S SMALLINT,@I SMALLINTSET @I=1SET @S=0BEG:IF (@I&lt;=10) BEGIN SET @S=@S+@I SET @I=@I+1 GOTO BEG ENDPRINT @S 运行结果如图9.2所示。 （6）调度执行：WAIT FOR该语句可以指定它以后的语句在某个时间间隔之后执行，或未来的某一时间执行。语法如下： 1WAIT FOR{DELAY 'time'|TIME 'time'} 参数含义：DELAY 'time'是指定SQL Server 等待的时间间隔，最长可达24小时。TIME 'time'是指定SQL Server等待到某一时刻。例 若变量“@等待”的值等于“间隔”，查询Studnet表是在等待2分钟后执行，否则在下午2:10执行。 123456789101112DECLARE @等待 CHAR(10)SET @等待= '间隔'IF @等待= '间隔' BEGIN WAITFOR DELAY '00:02:00' SELECT * FROM STUDENT ENDELSE BEGIN WAITFOR TIME '14:10:00' SELECT * FROM STUDENT END 实验十 SQL SERVER事务设计（选做）实验时间： 实验目的： （1）通过实验理解事务的概念、特性，掌握事务的设计思想和事务创建、执行的方法； （2）掌握事务的提交COMMIT； （3）掌握事务的回滚ROLLBACK； （4）了解事务的锁。实验内容：创建一个名为“仓库职工”的数据库，导入以下的四张表到该数据库中，完成以下各题仓库表 仓库号 城市 面积 WH1 北京 370 WH2 上海 500 WH3 广州 200 WH4 武汉 400 职工表 仓库号 职工号 工资 WH2 E1 1220 WH1 E2 1210 WH2 E3 1250 WH3 E4 1230 WH1 E5 1250 WH3 E6 2000 WH1 E7 2080 订购表 职工号 供应商号 订购单号 订购日期 E3 S7 OR67 2009-12-4 E1 S4 OR73 2009-4-1 E7 S4 OR76 2009-4-2 E6 S6 OR77 2009-1-21 E3 S4 OR79 2009-11-15 E1 S6 OR80 2009-2-1 E3 S6 OR90 2009-3-12 E3 S3 OR91 2009-3-2 供应商表 供应商号 供应商名 地址 S3 振华电子厂 西安 S4 华通电子公司 北京 S6 607厂 郑州 S7 爱华电子厂 北京 S8 胖熊公司 广州 S9 巧姑娘日化 北京 创建事务,并执行。功能为实现广州的职工加10%的工资.123456789Begin transactionUse cangkuGoUpdate 职工 set 工资=工资*1.1From 职工,仓库 Where 职工.仓库号=仓库.仓库号 and 城市=’广州’GoCommitGo （2）在select 语句中加锁，悲观锁定职工表。 123456Begin transactionSelect * From职工表with(xlock)Insert into 职工表(仓库号,职工号) values(‘WH2’,’E10’)Update 职工表 set 工资=2980Where 仓库号=‘WH2’ and 职工号=‘E10’Commit transaction （3）使用HOLDLOCK对供应商表加共享锁。 1234Begin transaction t2Select 供应商号 From 供应商表with(holdlock)Select count(供应商号) From 供应商表Commit 思考题： 什么是事务？事务和程序是一个概念吗？ 事务是由一系列访问和更新操作组成的程序执行单元 事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。 不是同一概念 解释语句rollback和commit的作用。 Commit是提交事务，即提交某个事务的所有的操作；具体地说，就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。 Rollback表示回滚，即将事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始的状态。3. 为何使用事务？ 答：通过事务，SQL Server能将逻辑相关的一组操作绑定在一起，以便服务器保持数据的完整性。主要用于一些对操作过程的完整性比较高的程序。比如银行系统，用户在转账的过程中程序出现错误，但是这个转账操作没有完成。那么这个操作就被退回。 乐观锁和悲观锁的优缺点各是什么？ 答：乐观锁:优势是:乐观锁机制避免了长事务中的数据库加锁解锁开销，大大提升了大并发量下的系统整体性能表现； 劣势是，只能在提交数据时才发现业务事务将要失败，如果系统的冲突非常的多，而且一旦冲突就要因为重新计算提交而造成较大的代价的话，乐观锁也会带来很大的问题，在某些情况下，发现失败太迟的代价会非常的大。而且乐观锁也无法解决读”脏”数据的问题。 悲观锁: 优势是，能避免冲突的发生； 劣势是，开销较大，而且加锁时间较长，对于并发的访问性支持不好。 实验十一 SQL SERVER的存储过程（选做）实验时间： 实验目的：（1）掌握存储过程的定义；（2）掌握存储过程的有点；（3）掌握定义带输入与输出参数的存储过程；（4）调用存储过程。（5）删除存储过程 实验内容：注意：这次实验的示例数据库为学生选课数据库，请运行例题中的代码。 存储过程（procedure）类似于C语言中的函数，JAVA的方法。它可以重复调用。当存储过程执行一次后，可以将语句缓存中，这样下次执行的时候直接使用缓存中的语句。这样就可以提高存储过程的性能。存储过程是一组编译在单个执行计划中的Transact-SQL语句，将一些固定的操作集中起来交给SQL Server数据库服务器完成，以实现某个任务。 存储过程的优点：（1）与其他应用程序共享应用程序逻辑，因而确保了数据访问和修改的一致性。 （2）防止数据库中表的细节暴露给用户。 （3）提供安全机制。 （4）改进性能。 （5）减少网络流量。 1．存储过程的分类（1) 用户定义的存储过程 用户定义的Transact-SQL存储过程中包含一组Transact-SQL 语句集合，可以接受和返回用户提供的参数。 （2）扩展存储过程 扩展存储过程是指Microsoft SQL Server的实例可以动态加载和运行的 DLL，是由用户使用编程语言（例如C）创建的自己的外部例程，扩展存储过程一般使用sp_或xp_前缀。 （3）系统存储过程 由系统提供的存储过程，可以作为命令执行各种操作。系统存储过程定义在系统数据库master中，其前缀是sp_，例如常用的显示系统信息的sp_help存储过程。 2．如何创建存储过程创建简单的存储过程的语法: 1234CREATE PROC[EDURE] 存储过程名[WITH ENCRYPTION][WITH RECOMPILE]AS SQL语句说明：WITH ENCRYPTION–对存储过程进行加密，加密的存储过程用sp_helptext查看不到存储过程的原码；WITH RECOMPILE–对存储过程重新编译。执行存储过程的语法：EXEC 存储过程名例 创建一个名为GetInfo存储过程，用于获取所有学生信息。 12345CREATE PROCEDURE GetInfoAS SELECT * FROM Student执行存储过程：EXEC GetInfo 接下来学习编写带参数的存储过程。上例中的存储过程可以获取所有学生信息，如果要获取指定学生的信息怎么做？这里就需要创建带参数的存储过程。 存储过程的参数分两种：输入参数和输出参数。输入参数用于向存储过程传入值，类似C语言的按值传递；输出参数用于在调用存储过程后返回结果，类似C语言的按引用传递； 带参数的存储过程的语法： 12345CREATE PROC[EDURE] 存储过程名@参数1 数据类型 = 默认值[OUTPUT], …,@参数n 数据类型 = 默认值 [OUTPUT]AS SQL语句 例 创建一个带输入参数的存储过程，要求用于获取指定学生的信息。 12345678CREATE PROCEDURE StuInfo@name CHAR(10)AS SELECT * FROM STUDENT WHERE SNAME=@name执行存储过程EXEC StuInfo @name='李晨'或按位置传递参数值EXEC StuInfo '李晨' 执行完毕的结果如图11.1所示： 图11.1执行存储过程结果例 创建一个带输入和输出参数的存储过程GetScore，获取指定课程的平均成绩、最高成绩、最低成绩，并返回结果。 123456789101112CREATE PROCEDURE GetScore@kcID CHAR(10),@AVGScore INT OUTPUT,@MAXScore INT OUTPUT,@MINScore INT OUTPUTASSELECT @AVGScore=AVG(Grade),@MAXScore=MAX(Grade),@MINScore=MIN(Grade) FROM SC WHERE Cno=@kcID SELECT @AVGScore as 平均成绩,@MAXScore as 最高成绩,@MINScore as 最低成绩执行存储过程DECLARE @kcID CHAR(10),@AVGScore INT,@MAXScore INT,@MINScore INTSET @kcID='C001'EXEC GetScore @kcID,@AVGScore,@MAXScore,@MINScore 执行完毕的结果如图8.20所示： 图11.2 执行存储过程结果3．查看存储过程在SQL Server中，根据不同需要，可以使用sp_helptext、sp_help、sp_depends系统存储过程来查看用户自定义函数的不同信息。例29. 查看Students数据库中存储过程GetInfo信息。代码如下： 123EXEC sp_helptext GetInfoEXEC sp_help GetInfoEXEC sp_depends GetInfo 运行后得到存储过程的定义、参数和依赖信息。4．存储过程的修改修改存储过程是由ALTER语句来完成的，其语法如下： 12345ALTER PROCEDURE procedure_name[WITH ENCRYPTION][WITH RECOMPILE]ASSql_statement 例 修改存储过程StuInfo，根据用户提供的系名进行统计这个系的人数，并要求加密。 1234567ALTER PROCEDURE StuInfo@dept CHAR(10),@num INT OUTPUTWITH ENCRYPTIONASSELECT @num=COUNT(*) FROM Student WHERE SDEPT=@deptPRINT @num 执行存储过程 123DECLARE @dept CHAR(10),@num INTSET @dept='CS'EXEC StuInfo @dept,@num 5．存储过程的删除 存储过程的删除是通过DROP语句来实现的。 例31. 使用Transact-SQL语句来删除存储过程StuInfo。 1DROP PROCEDURE StuInfo","link":"/posts/SQLexam.html"},{"title":"Ubuntu 美化","text":"Ubuntu美化 主题unity-tweak-tool 1sudo apt-get install unity-tweak-tool Flatabulous 主题 123sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme 配套的图标 123sudo add-apt-repository ppa:noobslab/iconssudo apt-get updatesudo apt-get install ultra-flat-icons oh-my-zsh12wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | shchsh -s zsh 问题错误agnoster 主题不正常 修改字体即可 错误提示 12zsh compinit: insecure directories, run compaudit for list.Ignore insecure directories and continue [y] or abort compinit [n]? 解决方法 12345678910compaudit//会显示如下内容There are insecure directories: usr/local/share/zsh/site-functions//cd cd /usr/local/share/zshsudo chown -R root:root ./site-functionscd /usr/local/share/sudo chmod -R 755 zshsudo chown -R root:staff zsh 参考 zsh compinit: insecure directories","link":"/posts/Ubuntu-Theme.html"},{"title":"Ubuntu 下 Node.Js 安装与版本升级","text":"Ubuntu 下 nodejs 安装与版本升级 在Github上获取 Node.Js 源码1sudo git clone https://github.com/nodejs/node.git nodejs 安装12345678910sudo chmod -R 755 node//修改目录权限cd node//进入node目录sudo ./configure使用 ./configure 创建编译文件sudo make//下一步，可能时间有点长，耐心等待sudo make install$ node -v 如果 Node 不是最新的，Node 有一个模块叫 Npm，是专门用来管理 Node.Js的版本的。使用 npm安装 Npm 模块 1sudo npm install -g n 然后，升级node.js到最新稳定版 1sudo n stable 旧版本的 npm，也可以很容易地通过 npm 命令来升级，命令如下： 1sudo npm install npm -g 将 Node 和 Npm 设置为全局12sudo ln /opt/nodejs/bin/node(安装目录) /usr/local/bin/nodesudo ln /opt/nodejs/bin/npm（安装目录） /usr/local/bin/npm 几个 Npm 常用命令 命令 解析 npm -v 显示版本，检查npm 是否正确安装 npm install -g express 全局安装express模块 npm list 列出已安装模块 npm show express 显示模块详情 npm update 升级当前目录下的项目的所有模块 npm update express 升级当前目录下的项目的指定模块 npm update -g express 升级全局安装的express模块 npm uninstall express 删除指定的模块 参考 ubuntu下nodejs安装与版本升级","link":"/posts/Ubuntu-Nodejs.html"},{"title":"Vim 基础","text":"Vim 基础 Vim 基础指令图 Vim（ViImproved）编辑器是vi的扩展版，比vi功能更加强大，是功能强大的跨平台文本文件编辑工具，可以利用它可以建立、修改文本文件等。Vim有三种操作模式，分别称为 编辑模式、插入模式 和 命令模式，当运行Vim时，首会进入命令模式。 命令模式Vim命令模式下可以进行很多操作，例如光标跳动到指定的单词、行；复制、删除某行甚至很多行以及全文都可以，反正功能真的太强大了，以下就作出详解： 小范围 如果键盘上有上、下、左、右箭头的导航键，就由这些键来完成光标的移动。另外，可以用下面的键完成同样的 按字符移动 功能： 命令 说明 k 向上移动 j 向下移动 h 向左移动 l 向右移动 30j 向下移动30行 0 到行首 ^ 到行首第一个字符，如果前面有空格的话 $ 到行尾 gg 快速到文件头 G 快速到文件尾 100G 跳转到第100行 稍大范围移动光标的命令 命令 说明 ctrl+f 向文件尾部翻一屏 ctrl+b 向文件首部翻一屏 ctrl+d 向文件尾部翻半屏 ctrl+u 向文件首部翻半屏 指定某行大范围移动 命令 说明 G 光标跳到文件尾行 gg 光标跳到文件首行 #G “#”指数字，输入随意一个数字就会调到指定的行数 跳转字母 命令 说明 H 光标跳到当前一页的首行的第一个字母 M 光标跳到当前一页的中间行的第一个字母 L 光标跳到当前一页的尾行的第一个字母 H M L 命令还可以加数字。如2H表示将光标移到屏幕的第2行；3M 表示将光标移动到中间行的上面第三行；3L 表示将光标移到屏幕的倒数第3行。 行内移动 命令 说明 w 右移光标到下一个字的开头 e 右移光标到一个字的末尾 b 左移光标到前一个字的开头 ^ 移动光标，到本行的第一个非空字符 $ 右移光标，到本行的末尾 0 数字０，左移光标到本行的开始 搜索匹配vim除了在命令模式下进行光标移动外，还提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。 搜索方法键入字符 / 后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入 n 命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符 ? 取代 / ，可以实现反向搜索（朝文件开头方向）例如： 命令 说明 /root 正向搜索字符串root n 继续搜索，找出root下次出现在的位置 N 继续搜索，找出root上次出现在的位置 ?root 反向搜索字符串root 字符编辑、替换Vim常规的删除命令是d、x(前者删除行后者删除字符),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如： 命令 说明 x 删除光标处的字符 #x 删除光标处起始的#个字符 xp 交换光标所在处的字符及其后面字符的位置 ~ 转换大小写 J 删除当前行后的换行符 r 替换光标所在处的字符 R 切换成REPLACE模式 复制、粘贴、剪切、删除黏贴从正文中删除的内容（如字符、字或行）并没有真正丢失，而是被剪切并复制到了一个内存缓冲区中。用户可将其粘贴到正文中的指定位置。完成这一操作的命令是： 命令 说明 p 粘贴复制或剪切的内容 p 小写字母 p，将缓冲区的内容粘贴到光标的后面 P 大写字母 P，将缓冲区的内容粘贴到光标的前面 3p 将复制或剪切的内容粘贴三次 复制有时需要复制一段正文到新位置，同时保留原有位置的内容。这种情况下，首先应当把指定内容复制（而不是剪切）到内存缓冲区。完成这一操作的命令是： 命令 说明 y 复制整行；同时y后面还可以和w,e,b,$,^,等符号连用，例如：yw表示复制光标所在处的一个单词 10yy 向下复制10行 yw 复制光标开始的一个单词 y$ 复制光标到行尾 yfB 复制光标到第一个大写B中间的内容 y2fB 复制光标到第二个大写B中间的内容 yy 复制行 #yy “#”表示数字也就是复制几行 #”tyy “#”表示任何数，“t“表示T这个寄容器，linux中有36个剪寄容器，即a-z，0-9；复制行数可以选择放到任何这36个寄容器上；粘贴的话”tp表示将t寄存器内容粘贴到文件中。 剪切 命令 说明 x 向剪切一个一个字符，如果是在行尾，则为向前剪切 3x 剪切三个 xp 非行尾交换两个字符，如从bs变成sb 删除删除的内容会放到剪贴板，按 p 即可粘贴到其他地方 命令 说明 dd 删除一行 %d 删除全文 200dd 删除200行 dw 删除一个单词 （最喜欢啦） df” 删除到出现的第一个双引 撤销和重复在编辑文档的过程中，为消除某个错误的编辑命令造成的后果，可以用撤消命令。另外，如果用户希望在新的光标位置重复前面执行过的编辑命令，可用重复命令。 命令 说明 u 撤消前一条命令的结果，可以和数字连用 . 重复最后一条修改正文的命令 插入模式(Insert)（编辑模式） 进入插入模式在编辑模式下正确定位光标之后，可用以下命令切换到插入模式： 命令 说明 i 在光标左侧插入正文 a 在光标右侧插入正文 o 在光标所在行的下一行增添新行 I 在光标所在行的末尾插入 A 在光标所在行的末尾插入 O 在光标所在行的上一行增添新行 退出插入模式退出插入模式的方法是，按 ESC 退出插入模式之后，将会进入编辑模式 。 扩展命令模式(extended command )在 Vim 的命令模式下，可以使用复杂的命令。在命令模式下按 shift+ ：并显示冒号，此时已进入命令模式。命令模式又称末行模式，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim 执行命令。 打开、保存、退出 命令 说明 ：！file 在打开的vim中，如果想看一个文件可以：！后面跟文件 ：r！file 将打开的文件读入到vim中 ：w file将当前文件另存为 字符串搜索如果希望进行正向搜索，将待搜索的字符串置于两个 / 之间；如果希望反向搜索，则将字符串放在两个 ? 之间。 命令 说明 n 查找下一个匹配 N 查找上一个匹配 2n 查找下面第二个匹配 :/root/ 正向搜索，将光标移到下一个包含字符串 root 的行 :?root? 反向搜索，将光标移到上一个包含字符串 root 的行 :/root/w file 正向搜索，并将第一个包含字符串 root的行写入 file 文件 /str1/,str2/w file 正向搜索，并将包含字符串 str1 的行至包含字符串 str2 的行写 正文替换利用 ：s 命令可以实现字符串的替换。具体的用法包括： 命令 说明 :%s/str1/str2/ 用字符串 str2 替换行中首次出现的字符串 str1 :s/str1/str2/ 用字符串 str2 替换行中所有出现的字符串 str1 :.,$ s/str1/str2/g 用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1 :1,$ s/str1/str2/g 用字符串 str2 替换正文中所有出现的字符串 str1 :g/str1/s//str2/g 功能同上 :m,ns/str1/str2/g 将从m行到n行的str1替换成str2 从上述例子中可以总结这些： g 放在命令末尾，表示对搜索字符串的每次出现进行替换,不止匹配每行中的第一次出现；不加 g，表示只对搜索字符串的首次出现进行替换；g 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作 表示后面跟着一串替换的命令 表示替换范围是所有行，即全文 分屏管理普通的Vim模式，打开一个Vim程序只能查看一个文件，如果想同时查看多个文件，就需要用到Vim分屏与标签页功能。 多文件分割 vim -o|-O FILE1 FILE2 … -o：水平分割 -O：垂直分割 单文件窗口分割： 命令 说明 Ctrl+w,s 水平分割 Ctrl+w,v 垂直分割 Ctrl+w,q 取消相邻窗口 Ctrl+w,o 取消全部相邻窗口 wqall 退出 Via Vimi基础","link":"/posts/Vim.html"},{"title":"Termux 安装 Openjdk","text":"Termux 安装 Openjdk 下载 OpenjdkJDK1.8 aarch64谷歌云盘 aarch64百度云盘密码:ryea JDK1.9 aarch64下载 安装 Openjdk12cd storage/downloadsdpkg -i openjdk9_9.2017.8.20_aarch64.deb","link":"/posts/Termux-Openjdk.html"},{"title":"Linux 中 .Deb 相关","text":"Lineu中 .deb 包的使用，修改。 为何物.deb 是 Unix系统(其实主要是Linux)下的安装包，基于 tar 包，因此本身会记录文件的权限(读/写/可执行)以及所有者/用户组。 怎么用制作.deb包 原理1) deb包通常包含两部分：控制信息(DEBIAN目录)、安装内容(模拟”/“目录)2) 通过解开已有的 deb 包看其中内容 释放安装内容到dirname目录中 1dpkg -X xxx.deb dirname 释放控制信息到当前目录下的DEBIAN子目录中 1dpkg -e xxx.deb 准备1sudo apt-get install dh-make checkinstall 下载软件源码包 使用checkinstall方法创建deb包 checkinstall 不仅可以生成 deb 包，还可以生成 rpm 包，使用简单。1234tar xvjf fceu-0.98.12.src.tar.bz2 # 解包cd fceu;./configure;make # 编译checkinstall -D -install=no --pkgversion=0.98 --pkgname=fceuxy make install# 制作deb包 此时当前目录下生成了deb包。 使用dpkg方法创建deb包 dpkg是最基本的制作deb包的方法，推荐使用12345tar xvjf fceu-0.98.12.src.tar.bz2 # 解包mv fceu fceu-0.98 # 改目录名为 包名-版本号cd fceu-0.98dh_make -f ../fceu-0.98.12.src.tar.bz2# 生成制作deb包所需的默认信息 此时当前目录下生成了debian目录，此时通常修改两个文件： 1. 修改debian/control文件，配置你的信息，具体字段见参考资料部分 2. 修改debian/rules脚本，它决定编译参数(也可以不改) 12:::bashdpkg-buildpackage -rfakeroot 此时可以看到，上层目录中已建立了deb包。 修改已有deb包 自己创建deb所需目录结构(控制信息和安装内容)，然后打包，一般使用这种方法来修改已有的deb包，而不是新建deb包，命令如下： 1234mkdir -p testdpkg -X xxx.deb test # 解包安装内容cd testdpkg -e ../xxx.deb # 解包控制信息 修改DEBIAN目录下的内容，然后重新打包： 12cd ../dpkg -b test xxx_new.deb # 重新打包 修改DEBIAN目录下的内容，然后重新打包： 12cd ../dpkg -b test xxx_new.deb # 重新打包 deb包常用命令 查看deb包含有哪些文件 12dpkg -c xxx.deb # 安装前根据deb文件查看dpkg -L debname # 安装后根据包名查看 查看某个文件属于哪个deb包 1dpkg -S filefullpath 根据软件包名模糊检索 1234dpkg -l|grep xxx# 在已安装的软件包列表中搜索apt-cache search xxx# 在源中的所有软件包列表中搜索 下载源码包 1apt-get source packagename 安装 安装deb包1dpkg -i xxx.deb 卸载 卸载deb包 1dpkg -r debname 完全卸载deb包（包含配置文件) 1dpkg -P debname Via 从源代码制作deb包的两种方法以及修改已有deb包","link":"/posts/Linux-Deb.html"},{"title":"Oh-My-Zsh 主题","text":"自定义主题shell提示符. 修改oh-my-zsh主题主题目录12cd ~/.oh-my-zsh/themesvim theme-name 主题提示符 代码 解释 %T 系统时间(时：分) %* 系统时间(时：分：秒) %D 系统日期(年-月-日) %n 你的用户名 %B - %b 开始到结束使用粗体打印 %U - %u 开始到结束使用下划线打印 %d 你目前的工作目录 %~ 你目前的工作目录相对于～的相对路径 %M 计算机的主机名 %m 计算机的主机名(在第一个句号之前截断) %l 你当前的tty %n 登录名 顏色語法 “%{$fg[cyan]%}XXX” “%{$fg[yellow]%}和%{$reset_color%}” 上面是一对的中间夹的文字会用 yellow 颜色显示，颜色要用小写。 事例 Before 123456789101112PROMPT=&quot;%{$terminfo[bold]$fg[blue]%}#%{$reset_color%} \\%(#,%{$bg[yellow]%}%{$fg[black]%}%n%{$reset_color%},%{$fg[cyan]%}%n) \\%{$fg[white]%}@ \\%{$fg[green]%}%m \\%{$fg[white]%}in \\%{$terminfo[bold]$fg[yellow]%}%~%{$reset_color%}\\${hg_info}\\${git_info}\\ \\%{$fg[white]%}[%*] $exit_code%{$terminfo[bold]$fg[red]%}$ %{$reset_color%}&quot; Affter 1234567891011PROMPT=&quot;%{$terminfo[bold]$fg[blue]%}#%{$reset_color%} \\%(#,%{$bg[yellow]%}%{$fg[black]%}%n%{$reset_color%},%{$fg[cyan]%}% Vitan) \\%{$fg[white]%}@ \\%{$fg[green]%}% OnePlus \\%{$fg[white]%}in \\%{$terminfo[bold]$fg[yellow]%}%~%{$reset_color%}\\${hg_info}\\${git_info}\\\\%{$fg[white]%} [%*] $exit_code%{$terminfo[bold]$fg[red]%}➜ %{$reset_color%}&quot;","link":"/posts/Oh-My-ZSH-Theme.html"},{"title":"分屏&游戏","text":"分屏与游戏。 游戏月球车 1pkg install moon-buggy Start:moon-buggy fortz 1pkg install fortz start: zgames tmux 分屏 在ubuntu系统中使用 sudo apt-get install tmux ArchLinux yacman -S tmux Termux安装：1pkg install tumx tmux主要包括以下几个模块 名词 含义 解析 session 会话 一个服务器可以包含多个会话 window 窗口 一个会话可以包含多个窗口 pane 面板 一个窗口可以包含多个面板[强悍的分屏] 输入命令 tmux 使用工具 命令 分屏状态 Ctrl+b ? 显示快捷键帮助 Ctrl+b C-o 调换窗口位置，类似与vim 里的C-w Ctrl+b 空格键 采用下一个内置布局 Ctrl+b ! 把当前窗口变为新窗口 Ctrl+b “ 横向分隔窗口 Ctrl+b % 纵向分隔窗口 Ctrl+b q 显示分隔窗口的编号 Ctrl+b o 跳到下一个分隔窗口 Ctrl+b 上下键 上一个及下一个分隔窗口 Ctrl+b C-方向键 调整分隔窗口大小 Ctrl+b c 创建新窗口 Ctrl+b 0~9 选择几号窗口 Ctrl+b c 创建新窗口 Ctrl+b n 选择下一个窗口 Ctrl+b l 切换到最后使用的窗口 Ctrl+b p 选择前一个窗口 Ctrl+b w 以菜单方式显示及选择窗口 Ctrl+b t 显示时钟 Ctrl+b ; 切换到最后一个使用的面板 Ctrl+b x 关闭面板 Ctrl+b &amp; 关闭窗口 Ctrl+b s 以菜单方式显示和选择会话 Ctrl+b d 退出tumx，并保存当前会话，这时，tmux仍在后台运行，可以通过tmux attach进入 到指定的会话","link":"/posts/Termux-game-tools.html"},{"title":"Markdown 表格","text":"Markdown 建表格。 单元格和表头表头和其他行 使用|来分隔不同的单元格，使用 -来分隔表头和其他行：1234name| ge----|---LearnShare|12Mike|32 name age LearnShare 12 Mike 32 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界：1234|name|age||----------|---||LearnShare|12||Mike|32| name age LearnShare 12 Mike 32 为了使 Markdown 更清晰，| 和-两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 对齐在表头下方的分隔线标记中加入:，即可标记下方单元格内容的对齐方式： :---代表左对齐 :--:代表居中对齐 ---:代表右对齐 1234| left | center | right || :--- | :----: | ----: || aaaa | bbbbbb | ccccc || a | b | c | left center right aaaa bbbbbb ccccc a b c 如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现）。 插入其他内容表格中可以插入其他 Markdown 中的行内标记：","link":"/posts/Markdown-table.html"},{"title":"SQL Select 语句","text":"SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。 SELECT语法12SELECT column_name,column_nameFROM table_name; 1SELECT * FROM table_name; SELECT Column 实例下面的 SQL 语句从 “Websites” 表中选取 “name” 和 “country” 列： 1SELECT name,country FROM Websites; SQL SELECT DISTINCT 语句在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。 SELECT DISTINCT 语法 12SELECT DISTINCT column_name,column_nameFROM table_name; SELECT DISTINCT 实例下面的 SQL 语句仅从 “Websites” 表的 “country” 列中选取唯一不同的值，也就是去掉 “country” 列重复值： 1SELECT DISTINCT country FROM Websites SQL WHERE 子句WHERE 子句用于提取那些满足指定标准的记录。 SQL WHERE 语法 123SELECT column_name,column_nameFROM table_nameWHERE column_name operator value; WHERE 子句实例下面的 SQL 语句从 “Websites” 表中选取国家为 “CN” 的所有网站： 1SELECT * FROM Websites WHERE country='CN'; WHERE 子句中的运算符下面的运算符可以在 WHERE 子句中使用： 运算符 描述 = 等于 &lt;&gt; 不等于 注释:在SQL的一些版本中该操作符可被写成!= &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 SQL AND &amp; OR 运算符AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。AND &amp; OR 运算符 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。 从 “Websites” 表中选取国家为 “CN” 且alexa排名大于 “50” 的所有网站： 123SELECT * FROM WebsitesWHERE country='CN'AND alexa &gt; 50; 从 “Websites” 表中选取国家为 “USA” 或者 “CN” 的所有客户： 123SELECT * FROM WebsitesWHERE country='USA'OR country='CN'; SQL ORDER BY 关键字ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。 ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，可以使用 DESC 关键字。 SQL ORDER BY 语法 123SELECT column_name,column_nameFROM table_nameORDER BY column_name,column_name ASC|DESC; 从 “Websites” 表中选取所有网站，并按照 “alexa” 列排序： 12SELECT * FROM WebsitesORDER BY alexa; ORDER BY DESC 实例下面的 SQL 语句从 “Websites” 表中选取所有网站，并按照 “alexa” 列降序排序： 12SELECT * FROM WebsitesORDER BY alexa DESC; ORDER BY 多列下面的 SQL 语句从 “Websites” 表中选取所有网站，并按照 “country” 和 “alexa” 列排序： 12SELECT * FROM WebsitesORDER BY country,alexa; SQL INSERT INTO 语句INSERT INTO 语句用于向表中插入新记录。 SQL INSERT INTO 语法INSERT INTO 语句可以有两种编写形式。 第一种形式无需指定要插入数据的列名，只需提供被插入的值即可： 12INSERT INTO table_nameVALUES (value1,value2,value3,...); 需要指定列名及被插入的值： 12INSERT INTO table_name (column1,column2,column3,...)VALUES (value1,value2,value3,...); INSERT INTO 实例假设我们要向 “Websites” 表中插入一个新行。 12INSERT INTO Websites (name, url, alexa, country)VALUES ('百度','https://www.baidu.com/','4','CN'); 在指定的列插入数据下面的 SQL 语句将插入一个新行，但是只在 “name”、”url” 和 “country” 列插入数据（id 字段会自动更新）： 12INSERT INTO Websites (name, url, country)VALUES ('stackoverflow', 'http://stackoverflow.com/', 'IND'); SQL LIKE 操作符LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。 SQL LIKE 语法 123SELECT column_name(s)FROM table_nameWHERE column_name LIKE pattern; SQL LIKE 操作符实例下面的 SQL 语句选取 name 以字母 “G” 开始的所有客户： 12SELECT * FROM WebsitesWHERE name LIKE 'G%'; 提示：”%” 符号用于在模式的前后定义通配符（缺省字母）。您将在下一章中学习更多有关通配符的知识。 选取 name 以字母 “k” 结尾的所有客户： 12SELECT * FROM WebsitesWHERE name LIKE '%k'; 通过使用 NOT 关键字，您可以选取不匹配模式的记录。 下面的 SQL 语句选取 name 不包含模式 “oo” 的所有客户 12SELECT * FROM WebsitesWHERE name NOT LIKE '%oo%'; SQL 连接(JOIN)SQL join 用于把来自两个或多个表的行结合起来。SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。 1234SELECT Websites.id, Websites.name, access_log.count, access_log.dateFROM WebsitesINNER JOIN access_logON Websites.id=access_log.site_id; 不同的 SQL JOINJOIN 类型： INNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 SQL INNER JOIN 语法,INNER JOIN 与 JOIN 是相同的。 1234SELECT column_name(s)FROM table1INNER JOIN table2ON table1.column_name=table2.column_name; 或： 1234SELECT column_name(s)FROM table1JOIN table2ON table1.column_name=table2.column_name; LEFT JOINLEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。 SQL LEFT JOIN 语法 1234SELECT column_name(s)FROM table1LEFT JOIN table2 ON table1.column_name=table2.column_name; 或： 1234SELECT column_name(s)FROM table1LEFT OUTER JOIN table2ON table1.column_name=table2.column_name; SQL RIGHT JOINRIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。 1234SELECT column_name(s)FROM table1RIGHT JOIN table2ON table1.column_name=table2.column_name; 或： 1234SELECT column_name(s)FROM table1RIGHT OUTER JOIN table2ON table1.column_name=table2.column_name; FULL OUTER JOIN 关键字FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。 12345SQL FULL OUTER JOIN 语法SELECT column_name(s)FROM table1FULL OUTER JOIN table2ON table1.column_name=table2.column_name; SQL UNION 操作符SQL UNION 操作符合并两个或多个 SELECT 语句的结果。 UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 123SELECT column_name(s) FROM table1UNIONSELECT column_name(s) FROM table2; 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 SQL UNION ALL 语法 123SELECT column_name(s) FROM table1UNION ALLSELECT column_name(s) FROM table2; 注释：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 带有 WHERE 的 SQL UNION ALL下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的中国(CN)的数据（也有重复的值）： 123456SELECT country, name FROM WebsitesWHERE country='CN'UNION ALLSELECT country, app_name FROM appsWHERE country='CN'ORDER BY country;","link":"/posts/SQL-Select.html"},{"title":"SQL 经典语句","text":"经典SQL语句大全 基础创建数据库 1CREATE DATABASE database-name 删除数据库 1drop database dbname 备份sql server创建备份数据的 device 12USE masterEXEC sp_addumpdevice 'disk', 'testBack', 'c:\\mssql7backup\\MyNwind_1.dat' 开始备份 123BACKUP DATABASE pubs TO testBack创建新表create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..) 根据已有的表创建新表： A：create table tab_new like tab_old (使用旧表创建新表)B：create table tab_new as select col1,col2… from tab_old definition only 删除新表 1drop table tabname 增加一个列 1Alter table tabname add column col type 注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。 添加主键 1Alter table tabname add primary key(col) 说明：删除主键： Alter table tabname drop primary key(col) 创建索引 1create [unique] index idxname on tabname(col….) 删除索引： 1drop index idxname 注：索引是不可更改的，想更改必须删除重新建。 创建视图 1create view viewname as select statement 删除视图 1drop view viewname 几个简单的基本的 SQL 语句语句 1234567891011选择：select * from table1 where 范围插入：insert into table1(field1,field2) values(value1,value2)删除：delete from table1 where 范围更新：update table1 set field1=value1 where 范围查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!排序：select * from table1 order by field1,field2 [desc]总数：select count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1最小：select min(field1) as minvalue from table1 几个高级查询运算词UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 注：使用运算词的几个查询结果行必须是一致的。 使用外连接left （outer） join 左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。 SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c right （outer） join右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。 full/cross （outer） join全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。 分组:Group by一张表，一旦分组完成后，查询后只能得到组相关的信息。 组相关的信息统计信息） count,sum,max,min,avg 分组的标准)SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据,在selecte统计函数中的字段，不能和普通的字段放在一起对数据库进行操作 分离数据库sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名 如何修改数据: 库的名称 1sp_renamedb 'old_name', 'new_name' 提升复制表(只复制结构,源表名：a 新表名：b) 法一：select * into b from a where 1&lt;&gt;1（仅用于SQlServer） 法二：select top 0 * into b from a 拷贝表(拷贝数据,源表名：a 目标表名：b) 1insert into b(a, b, c) select d,e,f from b 跨数据库之间表的拷贝(具体数据使用绝对路径) 1insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件 例子：..from b in ‘“&amp;Server.MapPath(“.”)&amp;”\\data.mdb” &amp;”‘ where.. 子查询(表名1：a 表名2：b) 1select a,b,c from a where a IN (select d from b ) 或者1select a,b,c from a where a IN (1,2,3) 显示文章、提交人和最后回复时间 1select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b 外连接查询(表名1：a 表名2：b) 1select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c 第二部分在线视图查询(表名1：a ) 1`select * from (SELECT a,b,c FROM a) T where t.a &gt; 1 between的用法,between限制查询数据范围时包括了边界值,not between不包括 12select * from table1 where time between time1 and time2select a,b,c, from table1 where a not between 数值1 and 数值2 in 的使用方法 1select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’) 两张关联表，删除主表中已经在副表中没有的信息 1delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 ) 四表联查问题 1select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where ..... 日程安排提前五分钟提醒 1SQL: select * from 日程安排 where datediff('minute',f开始时间,getdate())&gt;5 一条sql 语句搞定数据库分页 1select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段 具体实现： 关于数据库分页 1234declare @start int,@end int@sql nvarchar(600)set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’exec sp_executesql @sql 注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引） 第三部分前10条记录 1select top 10 * form table1 where 范围 选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.) 1select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b) 包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表 1(select a from tableA ) except (select a from tableB) except (select a from tableC) 随机取出10条数据 1select top 10 * from tablename order by newid() 随机选择记录 1select newid() 删除重复记录 1234delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)select distinct * into temp from tablenamedelete from tablenameinsert into tablename select * from temp 评价：这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作 例如:在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段 1alter table tablename 加一个自增列 1234add column_b int identity(1,1) delete from tablename where column_b not in(select max(column_b) from tablename group by column1,column2,...)alter table tablename drop column column_b 第四部分列出数据库里所有的表名 1select name from sysobjects where type='U' // U代表用户 列出表里的所有的列名 1select name from syscolumns where id=object_id('TableName') 列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case 1select type,sum(case vender when 'A' then pcs else 0 end),sum(case vender when 'C' then pcs else 0 end),sum(case vender when 'B' then pcs else 0 end) FROM tablename group by type 显示结果： type vender pcs电脑 A 1电脑 A 1光盘 B 2光盘 A 2手机 B 3手机 C 3 初始化表table1 1TRUNCATE TABLE table1 选择从10到15的记录 1select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc 技巧 1=1，1=2的使用，在SQL语句组合时用的较多 “where 1=1” 是表示选择全部 “where 1=2”全部不选，如： 12345678if @strWhere !=''beginset @strSQL = 'select count(*) as Total from [' + @tblName + '] where ' + @strWhereendelsebeginset @strSQL = 'select count(*) as Total from [' + @tblName + ']'end 我们可以直接写成 错误！未找到目录项。 1set @strSQL = 'select count(*) as Total from [' + @tblName + '] where 1=1 安定 '+ @strWhere 2、收缩数据库 第五部分 重建索引 12DBCC REINDEXDBCC INDEXDEFRAG 收缩数据和日志 12DBCC SHRINKDBDBCC SHRINKFILE 压缩数据库 1dbcc shrinkdatabase(dbname) 转移数据库 给新用户以已存在用户权限 12exec sp_change_users_login 'update_one','newname','oldname'go 检查备份集 1RESTORE VERIFYONLY from disk='E:\\dvbbs.bak' 修复数据库 123456ALTER DATABASE [dvbbs] SET SINGLE_USERGODBCC CHECKDB('dvbbs',repair_allow_data_loss) WITH TABLOCKGOALTER DATABASE [dvbbs] SET MULTI_USERGO 日志清除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849SET NOCOUNT ONDECLARE @LogicalFileName sysname, @MaxMinutes INT, @NewSize INTUSE tablename -- 要操作的数据库名SELECT @LogicalFileName = 'tablename_log', -- 日志文件名@MaxMinutes = 10, -- Limit on time allowed to wrap log. @NewSize = 1 -- 你想设定的日志文件的大小(M)Setup / initializeDECLARE @OriginalSize intSELECT @OriginalSize = size FROM sysfiles WHERE name = @LogicalFileNameSELECT 'Original Size of ' + db_name() + ' LOG is ' + CONVERT(VARCHAR(30),@OriginalSize) + ' 8K pages or ' + CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + 'MB' FROM sysfiles WHERE name = @LogicalFileNameCREATE TABLE DummyTrans (DummyColumn char (8000) not null)DECLARE @Counter INT, @StartTime DATETIME, @TruncLog VARCHAR(255)SELECT @StartTime = GETDATE(), @TruncLog = 'BACKUP LOG ' + db_name() + ' WITH TRUNCATE_ONLY'DBCC SHRINKFILE (@LogicalFileName, @NewSize)EXEC (@TruncLog)-- Wrap the log if necessary.WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName) AND (@OriginalSize * 8 /1024) &gt; @NewSize BEGIN -- Outer loop.SELECT @Counter = 0 WHILE ((@Counter &lt; @OriginalSize / 16) AND (@Counter &lt; 50000)) BEGIN -- update INSERT DummyTrans VALUES ('Fill Log') DELETE DummyTrans SELECT @Counter = @Counter + 1 END EXEC (@TruncLog) ENDSELECT 'Final Size of ' + db_name() + ' LOG is ' + CONVERT(VARCHAR(30),size) + ' 8K pages or ' + CONVERT(VARCHAR(30),(size*8/1024)) + 'MB' FROM sysfiles WHERE name = @LogicalFileNameDROP TABLE DummyTransSET NOCOUNT OFF 说明：更改某个表 1exec sp_changeobjectowner 'tablename','dbo' 存储更改全部表 12345678910111213141516171819202122232425262728CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch@OldOwner as NVARCHAR(128),@NewOwner as NVARCHAR(128)ASDECLARE @Name as NVARCHAR(128)DECLARE @Owner as NVARCHAR(128)DECLARE @OwnerName as NVARCHAR(128)DECLARE curObject CURSOR FORselect 'Name' = name, 'Owner' = user_name(uid)from sysobjectswhere user_name(uid)=@OldOwnerorder by nameOPEN curObjectFETCH NEXT FROM curObject INTO @Name, @OwnerWHILE(@@FETCH_STATUS=0)BEGINif @Owner=@OldOwnerbegin set @OwnerName = @OldOwner + '.' + rtrim(@Name) exec sp_changeobjectowner @OwnerName, @NewOwnerend-- select @name,@NewOwner,@OldOwnerFETCH NEXT FROM curObject INTO @Name, @OwnerENDclose curObjectdeallocate curObjectGO SQL SERVER中直接循环写入数据 1234567declare @i intset @i=1while @i&lt;30begin insert into test (userid) values(@i) set @i=@i+1end 案例：有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格: Name score Zhangshan 80 Lishi 59 Wangwu 50 Songquan 69 123456789while((select min(score) from tb_table)&lt;60)beginupdate tb_table set score =score*1.01where score&lt;60if (select min(score) from tb_table)&gt;60 break else continueend 数据开发-经典 按姓氏笔画排序: 1Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多 数据库加密: 12345select encrypt('原始密码')select pwdencrypt('原始密码')select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同 encrypt('原始密码')select pwdencrypt('原始密码')select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同 取回表中字段: 12345declare @list varchar(1000),@sql nvarchar(1000)select @list=@list+','+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name='表A'set @sql='select '+right(@list,len(@list)-1)+' from 表A'exec (@sql) 查看硬盘分区: 1EXEC master..xp_fixeddrives 比较A,B表是否相等: 123456if (select checksum_agg(binary_checksum(*)) from A) = (select checksum_agg(binary_checksum(*)) from B)print '相等'elseprint '不相等' 杀掉所有的事件探察器进程: 123DECLARE hcforeach CURSOR GLOBAL FOR SELECT 'kill '+RTRIM(spid) FROM master.dbo.sysprocessesWHERE program_name IN('SQL profiler',N'SQL 事件探查器')EXEC sp_msforeach_worker '?' 记录搜索: 1234567开头到N条记录Select Top N * From 表-------------------------------N到M条记录(要有主索引ID)Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc----------------------------------N到结尾记录 1Select Top N * From 表 Order by ID Desc 案例 例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段，写一个SQL语句， 找出表的第31到第40个记录。 1select top 10 recid from A where recid not in(select top 30 recid from A) 分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。 解决方案 用order by select top 30 recid from A order by ricid如果该字段不是自增长，就会出现问题 在那个子查询中也加条件：select top 30 recid from A where recid&gt;-1 例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。 12set @s = 'select top 1 * from T where pid not in (select top ' + str(@count-1) + ' pid from T)'print @s exec sp_executesql @s 获取当前数据库中的所有用户表 1select Name from sysobjects where xtype='u' and status&gt;=0 获取某一个表的所有字段 12select name from syscolumns where id=object_id('表名')select name from syscolumns where id in (select id from sysobjects where type = 'u' and name = '表名') 两种方式的效果相同 查看与某一个表相关的视图、存储过程、函数 1select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like '%表名%' 查看当前数据库中所有存储过程 1select name as 存储过程名称 from sysobjects where xtype='P' 查询用户创建的所有数据库 1select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name=&apos;sa&apos;) 或者1select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01 查询某一个表的字段和数据类型 12select column_name,data_type from information_schema.columnswhere table_name = '表名' 不同服务器数据库之间的数据操作 创建链接服务器 12exec sp_addlinkedserver 'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 'exec sp_addlinkedsrvlogin 'ITSV ', 'false ',null, '用户名 ', '密码 ' 查询示例 1select * from ITSV.数据库名.dbo.表名 导入示例 1select * into 表 from ITSV.数据库名.dbo.表名 以后不再使用时删除链接服务器 1exec sp_dropserver 'ITSV ', 'droplogins ' 连接远程/局域网数据(openrowset/openquery/opendatasource) –1、openrowset 查询示例 1select * from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名) 生成本地表 1select * into 表 from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名) 把本地表导入远程表 12insert openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)select *from 本地表 更新本地表 1234update bset b.列A=a.列Afrom openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)as a inner join 本地表 bon a.column1=b.column1 openquery用法需要创建一个连接 12--首先创建一个连接创建链接服务器exec sp_addlinkedserver 'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 ' 查询 12select *FROM openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ') –把本地表导入远程表 12insert openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ')select * from 本地表 更新本地表 1234update bset b.列B=a.列BFROM openquery(ITSV, &apos;SELECT * FROM 数据库.dbo.表名 &apos;) as ainner join 本地表 b on a.列A=b.列A 3、opendatasource/openrowset 12SELECT *FROM opendatasource( 'SQLOLEDB ', 'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ' ).test.dbo.roy_ta 把本地表导入远程表 1234insert opendatasource( 'SQLOLEDB ', 'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ').数据库.dbo.表名select * from 本地表SQL Server基本函数SQL Server基本函数 字符串函数 长度与分析用例子 1datalength(Char_expr) 返回字符串包含字符数,但不包含后面的空格 1substring(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度 1right(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用left于之相反 1isnull( check_expression , replacement_value ) 如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类 12Sp_addtype--自定義數據類型 例如： 1EXEC sp_addtype birthday, datetime, 'NULL' 1set nocount {on|off} 使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。 SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。 SET NOCOUNT 为 OFF 时，返回计数 常识SQL中1.在SQL查询中：from后最多可以跟多少张表或视图：2562. 在SQL语句中出现 Order by,查询时，先排序，后取3. 在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。 SQLServer2000同步复制技术实现步骤预备工作创建一个同名的 windows 用户 发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户 123456--管理工具--计算机管理--用户和组--右键用户--新建用户--建立一个隶属于administrator组的登陆windows的用户（SynUser） 在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作: 123456我的电脑--D:\\ 新建一个目录,名为: PUB--右键这个新建的目录--属性--共享--选择&quot;共享该文件夹&quot;--通过&quot;权限&quot;按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser) 具有对该文件夹的所有权限--确定 设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布/订阅服务器均做此设置) 12345开始--程序--管理工具--服务--右键SQLSERVERAGENT--属性--登陆--选择&quot;此账户&quot;--输入或者选择第一步中创建的windows登录用户名（SynUser）--&quot;密码&quot;中输入该用户的密码 设置SQL Server身份验证模式,解决连接时的权限问题(发布/订阅服务器均做此设置) 12345企业管理器--右键SQL实例--属性--安全性--身份验证--选择&quot;SQL Server 和 Windows&quot;--确定 在发布服务器和订阅服务器上互相注册企业管理器 1234567--右键SQL Server组--新建SQL Server注册...--下一步--可用的服务器中,输入你要注册的远程服务器名 --添加--下一步--连接使用,选择第二个&quot;SQL Server身份验证&quot;--下一步--输入用户名和密码（SynUser）--下一步--选择SQL Server组,也可以创建一个新组--下一步--完成 对于只能用IP,不能用计算机名的,为其注册服务器别名（此步在实施中没用到）(在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP) 12345开始--程序--Microsoft SQL Server--客户端网络实用工具--别名--添加--网络库选择&quot;tcp/ip&quot;--服务器别名输入SQL服务器名--连接参数--服务器名称中输入SQL服务器ip地址--如果你修改了SQL的端口,取消选择&quot;动态决定端口&quot;,并输入对应的端口号 正式配置配置发布服务器打开企业管理器，在发布服务器（B、C、D）上执行以下步骤: 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导 [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器（选择自己） [下一步] 设置快照文件夹 采用默认\\servername\\Pub [下一步] 自定义配置 可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置否,使用下列默认设置（推荐） [下一步] 设置分发数据库名称和位置 采用默认值 [下一步] 启用发布服务器 选择作为发布的服务器 [下一步] 选择需要发布的数据库和发布类型 [下一步] 选择注册订阅服务器 [下一步] 完成配置 创建出版物发布服务器B、C、D上 从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令 选择要创建出版物的数据库，然后单击[创建发布] 在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助) 单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型, SQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。但是在这里我们选择运行”SQL SERVER 2000”的数据库服务器 单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表 注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表 选择发布名称和描述 自定义发布属性 向导提供的选择: 是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性 否 根据指定方式创建发布 （建议采用自定义的方式） [下一步] 选择筛选发布的方式 [下一步] 可以选择是否允许匿名订阅 如果选择署名订阅,则需要在发布服务器上添加订阅服务器 [工具]-&gt;[复制]-&gt;[配置发布、订阅服务器和分发的属性]-&gt;[订阅服务器] 中添加 否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅 如果仍然需要匿名订阅则用以下解决办法[企业管理器]-&gt;[复制]-&gt;[发布内容]-&gt;[属性]-&gt;[订阅选项] 选择允许匿名请求订阅 如果选择匿名订阅,则配置订阅服务器时不会出现以上提示[下一步] 设置快照 代理程序调度 [下一步] 完成配置 当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库 有数据 12srv1.库名..author有字段:id,name,phone,srv2.库名..author有字段:id,name,telphone,adress 要求： 1234srv1.库名..author增加记录则srv1.库名..author记录增加rv1.库名..author的phone字段更新，则srv1.库名..author对应字段t&gt;elphone更新*/ 大致的处理步创建连接服务器 在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步 123exec sp_addlinkedserver 'srv2','','SQLOLEDB','srv2的sql实例名或ip'exec sp_addlinkedsrvlogin 'srv2','false',null,'用户名','密码'go 在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动 我的电脑–控制面板–管理工具–服务–右键 Distributed Transaction Coordinator–属性–启动–并将启动类型设置为自动启动go 然后创建一个作业定时调用上面的同步处理存储过程就行了 企业管理器 123456789101112131415161718--管理--SQL Server代理--右键作业--新建作业--&quot;常规&quot;项中输入作业名称--&quot;步骤&quot;项--新建--&quot;步骤名&quot;中输入步骤名--&quot;类型&quot;中选择&quot;Transact-SQL 脚本(TSQL)&quot;--&quot;数据库&quot;选择执行命令的数据库--&quot;命令&quot;中输入要执行的语句: exec p_process--确定--&quot;调度&quot;项--新建调度--&quot;名称&quot;中输入调度名称--&quot;调度类型&quot;中选择你的作业执行安排--如果选择&quot;反复出现&quot;--点&quot;更改&quot;来设置你的时间安排 然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行 设置方法: 我的电脑–控制面板–管理工具–服务–右键 SQLSERVERAGENT–属性–启动类型–选择”自动启动”–确定. -3.实现同步处理的方法2,定时同步 在srv1中创建如下的同步处理存储过程 123create proc p_processas` 更新修改过的数据 1234update b set name=i.name,telphone=i.telphonefrom srv2.库名.dbo.author b,author iwhere b.id=i.id and(b.name &lt;&gt; i.name or b.telphone &lt;&gt; i.telphone) 插入新增的数据 1234insert srv2.库名.dbo.author(id,name,telphone)select id,name,telphone from author iwhere not exists(select * from srv2.库名.dbo.author where id=i.id) 删除已经删除的数据(如果需要的话)12345delete bfrom srv2.库名.dbo.author bwhere not exists(select * from author where id=b.id)go","link":"/posts/SQL-Command.html"},{"title":"Java 变量类型","text":"Java 变量类型 Java变量类型在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下： type identifier [ = value][, identifier [= value] …] ;格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。 以下列出了一些变量的声明实例。注意有些包含了初始化过程。 123456int a, b, c; // 声明三个int型整数：a、 b、cint d = 3, e = 4, f = 5; // 声明三个整数并赋予初值byte z = 22; // 声明并初始化 zString s = \"runoob\"; // 声明并初始化字符串 sdouble pi = 3.14159; // 声明了双精度浮点型变量 pichar x = 'x'; // 声明变量 x 的值是字符 'x'。 Java语言支持的变量类型有 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。 实例1234567891011public class Variable{ static int allClicks=0; // 类变量 String str=\"hello world\"; // 实例变量 public void method(){ int i =0; // 局部变量 }} Java 局部变量 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例 1 在以下实例中age是一个局部变量。定义在pupAge()方法中，它的作用域就限制在这个方法中。 1234567891011121314package com.runoob.test;public class Test{ public void pupAge(){ int age = 0; age = age + 7; System.out.println(\"小狗的年龄是: \" + age); } public static void main(String args[]){ Test test = new Test(); test.pupAge(); }} 以上实例编译运行结果如下: 小狗的年龄是: 7 实例 2 在下面的例子中 age 变量没有初始化，所以在编译时会出错： 1234567891011121314package com.runoob.test;public class Test{ public void pupAge(){ int age; age = age + 7; System.out.println(\"小狗的年龄是 : \" + age); } public static void main(String args[]){ Test test = new Test(); test.pupAge(); }} 以上实例编译运行结果如下: Test.java:4:variable number might not have been initializedage = age + 7; ^1 error 实例变量 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 实例 123456789101112131415161718192021222324252627Employee.java 文件代码：import java.io.*;public class Employee{ // 这个实例变量对子类可见 public String name; // 私有变量，仅在该类可见 private double salary; //在构造器中对name赋值 public Employee (String empName){ name = empName; } //设定salary的值 public void setSalary(double empSal){ salary = empSal; } // 打印信息 public void printEmp(){ System.out.println(\"名字 : \" + name ); System.out.println(\"薪水 : \" + salary); } public static void main(String args[]){ Employee empOne = new Employee(\"RUNOOB\"); empOne.setSalary(1000); empOne.printEmp(); }} 以上实例编译运行结果如下: $ javac Employee.java$ java Employee名字 : RUNOOB薪水 : 1000.0 类变量（静态变量） 类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在程序开始时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 实例： 12345678910111213Employee.java 文件代码：import java.io.*;public class Employee { //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = \"开发人员\"; public static void main(String args[]){ salary = 10000; System.out.println(DEPARTMENT+\"平均工资:\"+salary); }} 以上实例编译运行结果如下: 开发人员平均工资:10000.0 注意：如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT。","link":"/posts/Java-variable-types.html"},{"title":"Java 基本数据类型","text":"Java基本数据类型。 Java 的两大数据类型: 内置数据类型 引用数据类型 内置数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 byte： byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是-128（-2^7； 最大值是127（2^7-1)； 默认值是0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short： short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是-32768（-2^15）； 最大值是32767（2^15 - 1)； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是0； 例子：short s = 1000，short r = -20000。 int： int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是-2,147,483,648（-2^31）； 最大值是2,147,483,647（2^31 - 1)； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000, int b = -200000。 long： long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是-9,223,372,036,854,775,808（-2^63）； 最大值是9,223,372,036,854,775,807（2^63 -1)； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。 “L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是0.0f； 浮点数不能用来表示精确的值，如货币；例子：float f1 = 234.5f。 double： double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是0.0d； 例子：double d1 = 123.4。 boolean: boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false；例子：boolean one = true。 char： char类型是一个单一的 16 位 Unicode 字符； 最小值是\\u0000（即为0）`； 最大值是\\uffff（即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’;。 引用类型 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用任何与之兼容的类型。 例子：Site site = new Site(“Runoob”)。 Java 常量 常量在程序运行时是不能被修改的。 在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：final double PI = 3.1415927; 虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。 字面量可以赋给任何内置类型的变量。例如： 12byte a = 68;char a = 'A' byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。 当使用常量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如： 123int decimal = 100;int octal = 0144;int hexa = 0x64; 和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子： 123\"Hello World\"\"two\\nlines\"\"\\\"This is in quotes\\\"\" 字符串常量和字符常量都可以包含任何Unicode字符。例如： 12char a = '\\u0001';String a = \"\\u0001\"; 自动类型转换整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级。 低 ————————————&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 数据类型转换必须满足如下规则： 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度，例如：123int i =128;byte b = (byte)i;因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：12(int)23.7 == 23;(int)-45.89f == -45 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 实例 12345678910public class ZiDongLeiZhuan{ public static void main(String[] args){ char c1='a';//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println(\"char自动类型转换为int后的值等于\"+i1); char c2 = 'A';//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println(\"char类型和int计算后的值等于\"+i2); }} 运行结果为: char自动类型转换为int后的值等于97char类型和int计算后的值等于66 解析：c1的值为字符’a’,查ascii码表可知对应的int类型值为97，’A’对应值为65，所以i2=65+1=66。 强制类型转换 条件是转换的数据类型必须是兼容的。 格式：(type)value type是要强制类型转换后的数据类型 实例： 实例 1234567public class QiangZhiZhuanHuan{ public static void main(String[] args){ int i1 = 123; byte b = (byte)i1;//强制类型转换为byte System.out.println(\"int强制类型转换为byte后的值等于\"+b); }} 运行结果： int强制类型转换为byte后的值等于123 隐含强制类型转换 整数的默认类型是 int。 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。","link":"/posts/Java-basic-datatypes.html"},{"title":"Java 中 String 方法","text":"Java 中 Srting 常用方法。 length()字符串长度1234567891011public class Test { public static void main(String args[]) { String Str1 = new String(\"www\"); String Str2 = new String(\"github\" ); System.out.print(\"字符串 Str1 长度 :\"); System.out.println(Str1.length()); System.out.print(\"字符串 Str2 长度 :\"); System.out.println(Str2.length()); }} charAt()截取一个字符12345678public class Test { public static void main(String args[]) { String s = \"www.qq.com\"; char result = s.charAt(8); System.out.println(result); }} 结果：c 12char ch:ch=\"abc\".charAt(1); //返回b getChars()截取多个字符语法 1public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 参数: srcBegin – 字符串中要复制的第一个字符的索引。 srcEnd – 字符串中要复制的最后一个字符之后的索引。 dst – 目标数组。 dstBegin – 目标数组中的起始偏移量。 1234567891011121314public class Test { public static void main(String args[]) { String Str1 = new String(\"www.runoob.com\"); char[] Str2 = new char[6]; try { Str1.getChars(4, 10, Str2, 0); System.out.print(\"拷贝的字符串为：\" ); System.out.println(Str2 ); } catch( Exception ex) { System.out.println(\"触发异常...\"); } }} 以上程序执行结果为：拷贝的字符串为：runoob sourceStart指定了子串开始字符的下标，sourceEnd指定了子串结束后的下一个字符的下标。因此， 子串包含从sourceStart到sourceEnd-1的字符。接收字符的数组由target指定，target中开始复制子串的下标值是targetStart。 123String s=\"this is a demo of the getChars method.\"; char buf[]=new char[20]; s.getChars(10,14,buf,0); getBytes()替代getChars()的一种方法是将字符存储在字节数组中，该方法即getBytes()。getBytes() 方法有两种形式： getBytes(String charsetName): 使用指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 getBytes(): 使用平台的默认字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 语法 1public byte[] getBytes(String charsetName) throws UnsupportedEncodingException 或 1public byte[] getBytes() 参数:charsetName – 支持的字符集名称。 返回值:返回 byte 数组。 实例 1234567891011121314151617181920import java.io.*;public class Test { public static void main(String args[]) { String Str1 = new String(\"runoob\"); try{ byte[] Str2 = Str1.getBytes(); System.out.println(\"返回值：\" + Str2 ); Str2 = Str1.getBytes( \"UTF-8\" ); System.out.println(\"返回值：\" + Str2 ); Str2 = Str1.getBytes( \"ISO-8859-1\" ); System.out.println(\"返回值：\" + Str2 ); } catch ( UnsupportedEncodingException e){ System.out.println(\"不支持的字符集\"); } }} 以上程序执行结果为： 123返回值：[B@7852e922返回值：[B@4e25154f返回值：[B@70dea4e toCharArray()public char[] toCharArray() 12345678public class Test { public static void main(String args[]) { String Str = new String(\"vitan.xyzm\"); System.out.print(\"返回值 :\" ); System.out.println( Str.toCharArray() ); }} equals()和equalsIgnoreCase() 比较两个字符串String.equals()对大小写敏感，而String.equalsIgnoreCase()忽略大小写. 例如： 12\"ABC\".equals(\"abc\")//是false\"ABC\".equalsIgnoreCase(\"abc\")//为ture regionMatches() regionMatches()方法用于检测两个字符串在一个区域内是否相等。 语法: 1public boolean regionMatches(int toffset,String other, int ooffset,int len) or 1public boolean regionMatches(boolean ignoreCase,int toffset, String other,int ooffset,int len) 参数： ignoreCase – 如果为 true，则比较字符时忽略大小写。 toffset – 此字符串中子区域的起始偏移量。 other – 字符串参数。 ooffset – 字符串参数中子区域的起始偏移量。 len – 要比较的字符数。 用于比较一个字符串中特定区域与另一特定区域，它有一个重载的形式允许在比较中忽略大小写。 12 boolean regionMatches(int startIndex,String str2,int str2StartIndex,int numChars) boolean regionMatches(boolean ignoreCase,int startIndex,String str2,int str2StartIndex,int numChars) 12345678910111213141516public class Test { public static void main(String args[]) { String Str1 = new String(\"www.runoob.com\"); String Str2 = new String(\"runoob\"); String Str3 = new String(\"RUNOOB\"); System.out.print(\"返回值 :\" ); System.out.println(Str1.regionMatches(4, Str2, 0, 5)); System.out.print(\"返回值 :\" ); System.out.println(Str1.regionMatches(4, Str3, 0, 5)); System.out.print(\"返回值 :\" ); System.out.println(Str1.regionMatches(true, 4, Str3, 0, 5)); }} 以上程序执行结果为： 123返回值 :true返回值 :false返回值 :true startsWith()和endsWith()startsWith()方法决定是否以特定字符串开始，endWith()方法决定是否以特定字符串结束 123456789101112131415161718192021222324public class StringDemo{public static void main(String args[]){ String s1=\"this is my original string\"; String sd=\"original\"; if (s1.startsWith(sd)) //startsWith()方法判断字符串s1是否从字符串sd开始 s1=s1.substring(sd.length()); else if(s1.endsWith(sd)) //endWith()方法判断字符串s1是否从字符串sd结尾 s1=s1.substring(0,s1.length()-sd.length()); else { int index=s1.indexOf(sd); //indexOf()搜索字符或子字符串首次出现，这里的index等于11 if(index!=-1) { String s2=s1.substring(0,index); //从字符串s1的首字符开始，取index个字符 String s3=s1.substring(index+sd.length());//取字符串s1的第19个字符后面的字符串 s1=s2+s3; } else System.out.println(\"string /\"\"+sd+\"/\" not found\"); } System.out.println(s1); }} equals()和==equals()方法比较字符串对象中的字符，==运算符比较两个对象是否引用同一实例。 1234String s1=\"Hello\"; String s2=new String(s1); s1.eauals(s2); //true s1==s2; //false compareTo()和compareToIgnoreCase()比较字符串compareTo() 字符串与对象进行比较。 按字典顺序比较两个字符串。 语法;int compareTo(Object o)或int compareTo(String anotherString)参数: o – 要比较的对象。anotherString – 要比较的字符串。返回值: 返回值是整型,它是先比较对应字符的大小(ASCII码顺序),如果第一个字符和参数的第一个字符不等,结束比较,返回他们之间的差值,如果第一个字符和参数的第一个字符相等,则以第二个字符和参数的第二个字符做比较,以此类推,直至比较的字符或被比较的字符有一方。 如果参数字符串等于此字符串，则返回值 0； 如果此字符串小于字符串参数，则返回一个小于 0 的值； 如果此字符串大于字符串参数，则返回一个大于 0 的值。 实例: 1234567891011121314151617public class Test { public static void main(String args[]) { String str1 = \"Strings\"; String str2 = \"Strings\"; String str3 = \"Strings123\"; int result = str1.compareTo( str2 ); System.out.println(result); result = str2.compareTo( str3 ); System.out.println(result); result = str3.compareTo( str1 ); System.out.println(result); }} 以上程序执行结果为： 1230-33 compareToIgnoreCase() 方法用于按字典顺序比较两个字符串，不考虑大小写。 参数: str – 要比较的字符串。 返回值: 如果参数字符串等于此字符串，则返回值 0； 如果此字符串小于字符串参数，则返回一个小于 0 的值； 如果此字符串大于字符串参数，则返回一个大于 0 的值。 1234567891011121314151617public class Test { public static void main(String args[]) { String str1 = \"STRINGS\"; String str2 = \"Strings\"; String str3 = \"Strings123\"; int result = str1.compareToIgnoreCase( str2 ); System.out.println(result); result = str2.compareToIgnoreCase( str3 ); System.out.println(result); result = str3.compareToIgnoreCase( str1 ); System.out.println(result); }} indexOf()和lastIndexOf()indexOf() 查找字符或者子串第一次出现的地方。 indexOf() 方法有以下四种形式： public int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int indexOf(int ch, int fromIndex): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 int indexOf(String str, int fromIndex): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1 语法: 1public int indexOf(int ch ) 或 1public int indexOf(int ch, int fromIndex) 或 1int indexOf(String str) 或 1int indexOf(String str, int fromIndex) 参数:ch – 字符。fromIndex – 开始搜索的索引位置。str – 要搜索的子字符串。 返回值: 指定子字符串在字符串中第一次出现处的索引，从指定的索引开始。 实例: 123456789101112131415161718public class Test { public static void main(String args[]) { String Str = new String(\"菜鸟教程:www.runoob.com\"); String SubStr1 = new String(\"runoob\"); String SubStr2 = new String(\"com\"); System.out.print(\"查找字符 o 第一次出现的位置 :\" ); System.out.println(Str.indexOf( 'o' )); System.out.print(\"从第14个位置查找字符 o 第一次出现的位置 :\" ); System.out.println(Str.indexOf( 'o', 14 )); System.out.print(\"子字符串 SubStr1 第一次出现的位置:\" ); System.out.println( Str.indexOf( SubStr1 )); System.out.print(\"从第十五个位置开始搜索子字符串 SubStr1 第一次出现的位置 :\" ); System.out.println( Str.indexOf( SubStr1, 15 )); System.out.print(\"子字符串 SubStr2 第一次出现的位置 :\" ); System.out.println(Str.indexOf( SubStr2 )); }} 以上程序执行结果为： 12345查找字符 o 第一次出现的位置 :12从第14个位置查找字符 o 第一次出现的位置 :17子字符串 SubStr1 第一次出现的位置:9从第十五个位置开始搜索子字符串 SubStr1 第一次出现的位置 :-1子字符串 SubStr2 第一次出现的位置 :16。 lastIndexOf()查找字符或者子串是后一次出现的地方。 lastIndexOf() 方法有以下四种形式： public int lastIndexOf(int ch): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int lastIndexOf(int ch, int fromIndex): 返返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int lastIndexOf(String str): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 public int lastIndexOf(String str, int fromIndex): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 语法: 12345678910111213public int lastIndexOf(int ch)或public int lastIndexOf(int ch, int fromIndex)或public int lastIndexOf(String str)或public int lastIndexOf(String str, int fromIndex) 参数:ch – 字符。fromIndex – 开始搜索的索引位置。str – 要搜索的子字符串。 返回值指定子字符串在字符串中第一次出现处的索引值。 实例 123456789101112131415161718public class Test { public static void main(String args[]) { String Str = new String(\"菜鸟教程:www.runoob.com\"); String SubStr1 = new String(\"runoob\"); String SubStr2 = new String(\"com\"); System.out.print(\"查找字符 o 最后出现的位置 :\" ); System.out.println(Str.lastIndexOf( 'o' )); System.out.print(\"从第14个位置查找字符 o 最后出现的位置 :\" ); System.out.println(Str.lastIndexOf( 'o', 14 )); System.out.print(\"子字符串 SubStr1 最后出现的位置:\" ); System.out.println( Str.lastIndexOf( SubStr1 )); System.out.print(\"从第十五个位置开始搜索子字符串 SubStr1最后出现的位置 :\" ); System.out.println( Str.lastIndexOf( SubStr1, 15 )); System.out.print(\"子字符串 SubStr2 最后出现的位置 :\" ); System.out.println(Str.lastIndexOf( SubStr2 )); }} 以上程序执行结果为： 12345查找字符 o 最后出现的位置 :17从第14个位置查找字符 o 最后出现的位置 :13子字符串 SubStr1 最后出现的位置:9从第十五个位置开始搜索子字符串 SubStr1最后出现的位置 :9子字符串 SubStr2 最后出现的位置 :16 substring()它有两种形 第一种是：public String substring(int startIndex) 第二种是：public String substring(int startIndex,int endIndex) 参数: beginIndex – 起始索引（包括）。 endIndex – 结束索引（不包括）。 返回值 子字符串。 实例 1234567891011public class Test { public static void main(String args[]) { String Str = new String(\"www.runoob.com\"); System.out.print(\"返回值 :\" ); System.out.println(Str.substring(4) ); System.out.print(\"返回值 :\" ); System.out.println(Str.substring(4, 10) ); }} 以上程序执行结果为： 12返回值 :runoob.com返回值 :runoob concat() 连接两个字符串语法: public String concat(String s)参数: s – 要连接的字符串。 返回值:返回连接后的新字符串。 实例 1234567public class Test { public static void main(String args[]) { String s = \"你好：\"; s = s.concat(\"Hellom\"); System.out.println(s); }} 以上程序执行结果为：你好：Hello replace()替换replace() 方法通过用 newChar 字符替换字符串中出现的所有 oldChar 字符，并返回替换后的新字符串。 语法:public String replace(char oldChar, char newChar)参数:oldChar – 原字符。newChar – 新字符。 返回值: 替换后生成的新字符串。 实例: 1234567891011public class Test { public static void main(String args[]) { String Str = new String(\"hello\"); System.out.print(\"返回值 :\" ); System.out.println(Str.replace('o', 'T')); System.out.print(\"返回值 :\" ); System.out.println(Str.replace('l', 'D')); }} 以上程序执行结果为： 12返回值 :hellT返回值 :heDDo trim() 去掉起始和结尾的空格123String s=\" abc \";String s2=s.trim();s2=\"abc\" valueOf()=== valueOf() 方法用于返回给定参数的原生 Number 对象值，参数可以是原生数据类型, String等。该方法是静态方法。该方法可以接收两个参数一个是字符串，一个是基数。 语法: 该方法有以下几种语法格式： 123static Integer valueOf(int i)static Integer valueOf(String s)static Integer valueOf(String s, int radix) 参数 i – Integer 对象的整数。 s – Integer 对象的字符串。 radix –在解析字符串 s 时使用的基数，用于指定使用的进制数。 返回值 Integer valueOf(int i)：返回一个表示指定的 int 值的 Integer 实例。 Integer valueOf(String s):返回保存指定的 String 的值的Integer 对象。 Integer valueOf(String s, int radix): 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。 实例 1234567891011121314public class Test{public static void main(String args[]){ Integer x =Integer.valueOf(9); Double c = Double.valueOf(5); Float a = Float.valueOf(&quot;80&quot;); Integer b = Integer.valueOf(&quot;444&quot;,16); // 使用 16 进制 System.out.println(x); System.out.println(c); System.out.println(a); System.out.println(b); }} 输出结果为： 123495.080.01092 toLowerCase()转换为小写 toLowerCase() 方法将字符串转换为小写。 语法 1public String toLowerCase() 或 1public String toLowerCase(Locale locale) 返回值 转换为小写的字符串。 实例 12345678public class Test { public static void main(String args[]) { String Str = new String(\"VITAN\"); System.out.print(\"返回值 :\" ); System.out.println( Str.toLowerCase() ); }} 以上程序执行结果为：返回值 :vitan toUpperCase() 转换为大写 StringBuffer构造函数 Via 参考","link":"/posts/JavaString.html"},{"title":"Oh-My-Zsh 插件","text":"Oh-my-zsh插件 使用方法12345vim ~/.zshrc//找到下面这句，添加相应的插件 插件之间用空格分隔plugins=(git z zsh-syntax-highlighting zsh-autosuggestions)//使配置文件生效source ~/.zshrc Git 默认已开启 可以使用各种 git 命令缩写。比如 12git add --all ===&gt; gaagit commit -m ===&gt; gcmsg 看所有 git 命令缩写 1cat ~/.oh-my-zsh/plugins/git/git.plugin.zsh autojump Hithub Rpo 已经内置了，直接在.zshrc 配置文件添加即可。 目录间快速跳转,不用再一直 cd 了 使用 使用 autojump 的缩写 j cd 命令进入~/user/github/Noye 文件夹，下一次再想进入Notr 文件夹的时候,直接j Note 即可,或者只输入 Note 的一部分 Not 都行. 删除无效路径 j --purge 无效路径类似组件Z (也内置了,直接改配置文件即可)删除无效路径它的命令更短z -x 无效路径 zscrh-syntax-highlighting Github Rpo 作用:平常用的 ls cd 等命令输入正确会绿色高亮显示，输入错误会显示其他的颜色。 安装 克隆项目 12git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitecho \"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" &gt;&gt; ${ZDOTDIR:-$HOME}/.zshrc 在 ~/.zshrc 中配置 1plugins=(zsh-syntax-highlighting) zsh-autosuggestions输入命令时，会给出建议的命令 安装 克隆项目 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 在 ~/.zshrc 中配置 1plugins=(zsh-autosuggestions) incr Ubuntu sudo 1apt-get install zsh ArchLinux 1yacman -S #!/usr/bin/env zsh 安装完成后执行： 1chsh -s /bin/zsh 安装 oh my zsh 自动安装： 1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 手动安装： 1234git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.zshrc ~/.zshrc.origcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrcchsh -s /bin/zsh 下载 incr: 下载地址 代码摘录如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142# Incremental completion for zsh# by y.fujii &lt;y-fujii at mimosa-pudica.net&gt;, public domainautoload -U compinitzle -N self-insert self-insert-incrzle -N vi-cmd-mode-incrzle -N vi-backward-delete-char-incrzle -N backward-delete-char-incrzle -N expand-or-complete-prefix-incrcompinitbindkey -M viins &apos;^[&apos; vi-cmd-mode-incrbindkey -M viins &apos;^h&apos; vi-backward-delete-char-incrbindkey -M viins &apos;^?&apos; vi-backward-delete-char-incrbindkey -M viins &apos;^i&apos; expand-or-complete-prefix-incrbindkey -M emacs &apos;^h&apos; backward-delete-char-incrbindkey -M emacs &apos;^?&apos; backward-delete-char-incrbindkey -M emacs &apos;^i&apos; expand-or-complete-prefix-incrunsetopt automenucompdef -d scpcompdef -d tarcompdef -d makecompdef -d javacompdef -d svncompdef -d cvs# TODO:# cp dir/now_predict=0function limit-completion{ if ((compstate[nmatches] &lt;= 1)); then zle -M &quot;&quot; elif ((compstate[list_lines] &gt; 6)); then compstate[list]=&quot;&quot; zle -M &quot;too many matches.&quot; fi}function correct-prediction{ if ((now_predict == 1)); then if [[ &quot;$BUFFER&quot; != &quot;$buffer_prd&quot; ]] || ((CURSOR != cursor_org)); then now_predict=0 fi fi}function remove-prediction{ if ((now_predict == 1)); then BUFFER=&quot;$buffer_org&quot; now_predict=0 fi}function show-prediction{ # assert(now_predict == 0) if ((PENDING == 0)) &amp;&amp; ((CURSOR &gt; 1)) &amp;&amp; [[ &quot;$PREBUFFER&quot; == &quot;&quot; ]] &amp;&amp; [[ &quot;$BUFFER[CURSOR]&quot; != &quot; &quot; ]] then cursor_org=&quot;$CURSOR&quot; buffer_org=&quot;$BUFFER&quot; comppostfuncs=(limit-completion) zle complete-word cursor_prd=&quot;$CURSOR&quot; buffer_prd=&quot;$BUFFER&quot; if [[ &quot;$buffer_org[1,cursor_org]&quot; == &quot;$buffer_prd[1,cursor_org]&quot; ]]; then CURSOR=&quot;$cursor_org&quot; if [[ &quot;$buffer_org&quot; != &quot;$buffer_prd&quot; ]] || ((cursor_org != cursor_prd)); then now_predict=1 fi else BUFFER=&quot;$buffer_org&quot; CURSOR=&quot;$cursor_org&quot; fi echo -n &quot;\\e[32m&quot; else zle -M &quot;&quot; fi}function preexec{ echo -n &quot;\\e[39m&quot;}function vi-cmd-mode-incr{ correct-prediction remove-prediction zle vi-cmd-mode}function self-insert-incr{ correct-prediction remove-prediction if zle .self-insert; then show-prediction fi}function vi-backward-delete-char-incr{ correct-prediction remove-prediction if zle vi-backward-delete-char; then show-prediction fi}function backward-delete-char-incr{ correct-prediction remove-prediction if zle backward-delete-char; then show-prediction fi}function expand-or-complete-prefix-incr{ correct-prediction if ((now_predict == 1)); then CURSOR=&quot;$cursor_prd&quot; now_predict=0 comppostfuncs=(limit-completion) zle list-choices else remove-prediction zle expand-or-complete-prefix fi} 执行如下命令： 12345cd ~/.oh-my-zsh/plugins/mkdir -p incrcd incrvim incr-0.2.zsh //（将代码复制粘贴到incr-0.2.zsh文件中）chmod 777 incr-0.2.zsh 配置 .zshrc 文件 vim ~/.zshrc末尾加入 ource ~/.oh-my-zsh/plugins/incr/incr*.zsh source ~/.zshrc #使其立即生效","link":"/posts/Oh-My-ZSH-complete.html"},{"title":"SQL 笔记","text":"SQL笔记 从职工关系中检索所有工资值。 12select 月工资from zg 检索仓库关系中的所有元组。 12select *from ck 检索工资多于2000元的职工对应的职工号，姓名。 12select 职工号,月工资 from zgwhere 月工资&gt;2000 检索哪些仓库的面积在400到550平方之间，列出仓库号和所在的城市。 123select 仓库号,城市from ckwhere 面积&gt;400 and 面积&lt;550 检索出有广州哪些仓库，列出仓库号。 12select 仓库号 from ckwhere 城市='广州' 检索出所在城市为广州的仓库的个数。123select count(仓库号)from ckwhere 城市='广州' 检索出所有职工的平均工资。 12select avg(月工资)from zg 检索出在WH5仓库工作的职工的人数。 12select count(仓库号) from zgwhere 仓库号='WH5' 检索出职工表的所有的仓库号，去掉重复值。 12select distinct 仓库号from zg 检索出每个仓库的人数。 123select 仓库号,count(*)人数 from zggroup by 仓库号 检索出上海的仓库有哪些，列出仓库号、面积。查询结果按面积降序排列。 1234select 仓库号,面积 from ckwhere 城市='上海'order by 面积 desc 检索出哪些仓库女职工的人数达到了3人。 123 select 仓库号,count(职工号)人数from zg where 性别='女'group by 仓库号 having count(职工号)&gt;3 检索出所有姓胡的职工的职工号、姓名、性别、工资。查询结果按性别排降序、工资排升序。 1234select 职工号,姓名,性别,月工资from zgwhere 姓名 like'胡%'order by 性别 desc,月工资 asc 检索出职工“王玛丽”的年工资。 123select sum(月工资*12) as 年薪from zgwhere 姓名='王玛丽' 检索出“WH1”和“WH2”两个仓库工作的职工的基本信息。 123select *from zgwhere 仓库号='WH1'or 仓库号='WH2' 检索出年工资在24000以上的职工的姓名，年工资值。 1select 姓名,月工资*12 as 年工资","link":"/posts/SQL-Note.html"},{"title":"Java 控制语句","text":"Java控制语句 简介Java流程控制语句（顺序结构、if条件语句、switch条件语句、循环语句与跳转语句） 顺序语句表达式语句123456i++;i--;x=10;sum=sum+1;new JFrame(); //实例化对象this.setVisible(true); //方法调用 空语句1for(int i=0;i&lt;10;i++); //空语句一个分号 1int x=6;; //两连续分号，第二个是空语句 1234567if (a&gt;b) { ; //条件为真，执行空语句}else { //条件为假，执行本部分} 复合语句123456{ int i=5;//又称代码块语句，一对大括号括起来的语句，中间可有多个变量或语句 int a; a=i; System.out.orint(a);} 选择语句if语句12345678910111213141516171819202122232425/* * \"if条件语句\"示例代码 * 功能：输入三个数，输出最大值 */import java.util.Scanner;public class Program { public static void main(String [] args) { int num1,num2,num3,max; Scanner input = new Scanner(System.in); System.out.println(\"请输入第一个数：\"); num1=input.nextInt(); System.out.println(\"请输入第二个数：\"); num2=input.nextInt(); System.out.println(\"请输入第三个数：\"); num3=input.nextInt(); max=num1; if(num2&gt;max) max=num2; if (num3&gt;max) max=num3; System.out.println(\"max=\"+max); input.close(); }} switch语句12345678910111213141516171819import java.unit.Scanner;public class Switchweek public static void main(String[]args) { Scanner input = new Scanner(System.in); System.out.println(\"请输入1-7的整数\"); int day = input.nextInt(); //对象调用方法获取数据 switch (day) { case 7: System.out.println(\"星期日\"); break; case 1: System.out.println(\"星期一\"); break; case 2: System.out.println(\"星期二\"); break; case 3: System.out.println(\"星期三\"); break; case 4: System.out.println(\"星期四\"); break; case 5: System.out.println(\"星期五\"); break; case 6: System.out.println(\"星期六\"); break; default: Syatem.out.println(\"你输入的日期不在有效范围内！\"); } }} 12345678910111213141516171819public class Switch{ public static void main(String[] args) { char today='日'; switch(today){ case '一': case '三': case '五': System.out.println(\"早餐吃包子\"); break; case '二': case '四': case '六': System.out.println(\"早餐吃油条\"); break; default: System.out.println(\"吃主席套餐\"); } }} 循环语句(主要有while/do-while/for和foreach)while1234while(判断条件){ 语句;} 扩展格式12345678910初始化语句;while(判断条件语句) { 循环体语句; 控制条件语句; } 通过这个格式，我们就可以看到其实和for循环是差不多的。 for(初始化语句;判断条件语句;控制条件语句) { 循环体语句; } 12345678910111213public class WhileSun { public static void main(String[] args) { int i = 1; int n = 10; int sum = 0; while(i&lt;=n) { sum+=i; i++; } System.out.println(\"1加到10但和是:\"+sum); System.out.println(\"循环后变量i但值是:\"+i); }} do-while 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。123do { //代码语句}while(布尔表达式); 注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。 12345678910public class Test { public static void main(String args[]){ int x = 10; do{ System.out.print(\"value of x : \" + x ); x++; System.out.print(\"\\n\"); }while( x &lt; 20 ); }} for循环123for(初始化; 布尔表达式; 更新) { //代码语句} 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。执行一次循环后，更新循环控制变量。再次检测布尔表达式。循环执行上面的过程。 12345678public class Test { public static void main(String args[]) { for(int x = 10; x &lt; 20; x = x+1) { System.out.print(\"value of x : \" + x ); System.out.print(\"\\n\"); } }} Java 增强 for 循环Java5 引入了一种主要用于数组的增强型 for 循环。 Java 增强 for 循环语法格式如下: 1234for(声明语句 : 表达式){ //代码句子} 明语句： 声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法 12345678910111213141516public class Test { public static void main(String args[]){ int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ){ System.out.print( x ); System.out.print(\",\"); } System.out.print(\"\\n\"); String [] names ={\"James\", \"Larry\", \"Tom\", \"Lacy\"}; for( String name : names ) { System.out.print( name ); System.out.print(\",\"); } }} break 关键字break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 break 跳出最里层的循环，并且继续执行该循环下面的语句。 语法:break 的用法很简单，就是循环结构中的一条语句：break; 1234567891011121314public class Test { public static void main(String args[]) { int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ) { // x 等于 30 时跳出循环 if( x == 30 ) { break; } System.out.print( x ); System.out.print(\"\\n\"); } }} 12345678910111213141516/* * \"实战——九九乘法口诀表\"*/public class Program { public static void main(String [] args) { System.out.println(\"九九乘法口诀表：\"); for (int i=1;i&lt;=9;i++){ for(int j=1;j&lt;=i;j++){ System.out.print(j+\"*\"+i+\"=\"+j*i+\"\\t\"); }// 注意print与println的区别 System.out.print(\"\\n\");// System.out.println(); } }} continue 关键字continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。语法 continue 就是循环体中一条简单的语句： continue; 123456789101112public class Test { public static void main(String args[]) { int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ) { if( x == 30 ) { continue; } System.out.print( x ); System.out.print(\"\\n\"); } }}","link":"/posts/JavaControl.html"},{"title":"Vim 设置默认中文并加行数","text":"Vim 设置默认中文并加行数 .vimrc配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&quot; 设置行号显示set number&quot; 将行号设置为相对行号set relativenumber&quot;显示标尺set ruler&quot;编码set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1set enc=utf8set fencs=utf8,gbk,gb2312,gb18030&quot; 语法高亮syntax enablesyntax on&quot; 高亮字符，让其不受100列限制:highlight OverLength ctermbg=red ctermfg=white guibg=red guifg=white:match OverLength &apos;\\%101v.*&apos;&quot; 状态行颜色highlight StatusLine guifg=SlateBlue guibg=Yellowhighlight StatusLineNC guifg=Gray guibg=White&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 我的状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\\[POS=%l,%v][%p%%]\\%{strftime(\\&quot;%d/%m/%y\\ -\\ %H:%M\\&quot;)}&quot; 总是显示状态行set laststatus=2&quot;命令行补全参数set wildmenu&quot;设置tab键空4格set tabstop=4&quot;自动检测文件类型filetype plugin indent on&quot;开启自动缩进，智能缩进set autoindentset cindentset smartindentset shiftwidth=4&quot;插件安装列表set rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &apos;godlygeek/tabular&apos;Plugin &apos;plasticboy/vim-markdown&apos;call vundle#end() Vim 设置默认中文编码.vimrc 添加下面内容即可 1234set encoding=utf-8set fileencodings=ucs-bom,utf-8,cp936set fileencoding=gb2312set termencoding=utf-8 设置行数1234567891011set nuset nobackupset noswapfilesyntax onset tabstop=4set shiftwidth:4set expandtabset smarttabset hlsearchset showmatchset matchtime=2","link":"/posts/Vim-utf-8.html"},{"title":"Ubuntu 常用命令","text":"Ununtu常用命令。 磁盘目录 目录 作用 / 根目录 /bin 存放必要的命令 /boot 存放内核以及启动所需的文件等 /dev 存放设备文件 /etc 存放系统的配置文件 /home 用户文件的主目录，用户数据存放在其主目录中 /lib 存放必要的运行库 /mnt 存放临时的映射文件系统，我们常把软驱和光驱挂装在这里的floppy和cdrom子目录下 /proc 存放存储进程和系统信息 /root 超级用户的主目录 /sbin 存放系统管理程序 /tmp 存放临时文件的目录 /usr 包含了一般不需要修改的应用程序，命令程序文件、程序库、手册和其它文档 /var 包含系统产生的经常变化的文件 文件/文件夹管理 命令 作用 ls 列出当前目录下的所有文件（不显示隐藏文件） ls -a 列出当前目录下的所有文件（显示隐藏文件） ls -l 列出当前目录下所有文件的详细信息 cd 或者 cd ~ 进入用户主目录 cd .. 回到上一级目录 cd - 返回进入此目录之前所在的目录 mkdir dirname 新建目录 rmdir dirname 删除空目录 rm filename 删除文件 rm -rf dirname 删除非空目录及其包含的所有文件 mv file1 file2 将文件1重命名为文件2 mv file1 dir1 将文件1移动到目录1中 find 路径 -name “字符串” 查找路径所在范围内满足字符串匹配的文件和目录 程序安装与卸载 命令 作用 apt-get + 程序安装与卸载命令的标志，需要管理员权限 install 安装指定程序，举例：`sudo apt-get install vim remove 卸载指定的程序，一般最好加上--purge执行清除式卸并在程序名称后添加*号。举例 sudo apt-get remove–purge nvidia *卸载 nvidia 的驱动及其配置文件 update 更新本地软件源文件，需要管理员权限，举例：sudo apt-get update 打包/解压 参数 参数 含义 -c 建立压缩档案 -z 有gzip属性的 -t 查看内容 -j 有bz2属性的 -u 更新原压缩包中的文件 -Z 有compress属性的 -x 解压 -v 显示所有过程 -r 向压缩归档文件末尾追加文件 -O 将文件解开到标准输出 参数是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。右边五个参数是根据需要在压缩或解压时可选的。 压缩 命令 作用 tar -cvf jpg.tar *.jpg 将目录里所有jpg文件打包成tar.jpg tar -czf jpg.tar.gz *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar -cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar -cZf jpg.tar.Z *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg rar 格式的压缩，需要先下载rar for linux zip jpg.zip *.jpg zip 格式的压缩，需要先下载zip for linux 解压 命令 作用 tar -xvf file.tar 解压 tar包 tar -xzvf file.tar.gz 解压 tar.gz tar -xjvf file.tar.bz2 解压 tar.bz2 tar -xZvf file.tar.Z 解压 tar.Z unrar e file.rar 解压 rar unzip file.zip 解压 zip 总结 .tar用 tar -xvf 解压 .gz 用 gzip -d或者gunzip 解压 .tar.gz和.tgz 用tar -xzf 解压 .bz2 用bzip2 -d或者用bunzip2解压 .tar.bz2用tar -xjf 解压 .Z 用 uncompress 解压 .tar.Z 用tar -xZf 解压 rar 用 unrar e解压 .zip 用 unzip 解压 用户管理 命令 作用 sudo useradd username 创建一个新的用户username sudo passwd username 设置用户username的密码 sudo groupadd groupname 创建一个新的组groupname sudo usermod -g groupname username 把用户username加入到组groupname中 sudo chown username:groupname dirname 将指定文件的拥有者改为指定的用户或组 系统管理 命令 作用 uname -a 查看内核版本 cat /etc/issue 查看ubuntu版本 sudo fdisk -l 查看磁盘信息 df -h 查看硬盘剩余空间 free -m 查看当前的内存使用情况 ps -A 查看当前有哪些进程 kill 进程号 或者 killall 进程名 杀死进程 kill -9 进程号 强制杀死进程","link":"/posts/UbuntuCommand.html"},{"title":"解决 \"Npm Err! Cannot Read Property 'Length' of Undefined\"","text":"解决 Termux出现npm err! cannot read property ‘length’ of undefined 问题 方法 复制以下内容 1(require('os').cpus() || { length: 1 }).length 编辑 1vim ../usr/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js 修改如下保存即可 已知问题 Npm 无法升级。","link":"/posts/Termux-Npm-Error.html"},{"title":"Ubuntu 安装 Android Studio","text":"Ubuntu安装Android Studio SDK安装 Android SDK 下载SDK传送门 解压并移动到指定目录tar -zxvf android-sdk-linux.tgz -C /usr/local/andriod-sdksudo mv -r /usr/local/ android-sdk-linux 更改属主、属组·cd /usr/local/··sudo chown -R vitan:vitan android-sdk/ 配置SDK环境变量 vim /etc/profile后添加 123set sdk environmentexport SDK_HOME=/usr/local/android-sdk-linuxexport PATH=$SDK_HOME/tools:$SDK_HOME/platform-tools:$PATH source /etc/profile 使上面的配置立即生效。 Studio 步骤1.下载Android Studio 传送门 2.解压到指定目录sudo tar zxvf android-studio-ide-171.4443003-linux.zip /opt/Android-Studio/ 3.安装 cd /opt/Android-Studio/bin sh ./studio.sh 4.Android SDK Location选择SDK目录/usr/local/android-sdk-linux","link":"/posts/UbuntuAndroidStudio.html"},{"title":"Ubuntu 安装 Eclipse","text":"Ubuntu 安装 Eclipse 前提已经安装Java JDK 下载连接 安装 cd到文件目录 tar zxvf eclipse-java-oxygen-2-linux-gtk-x86_64.tar.gz /opt/eclipse 创建Dash Home图标sudo vim /usr/share/applications/eclipse.desktop 复制下面内容 1234567891011[Desktop Entry]Encoding=UTF-8Version=1.0Type=ApplicationName=eclipseIcon=/opt/eclipse/icon.xpmExec=/opt/eclipse/eclipseStartupNotify=falseStartupWMClass=eclipseOnlyShowIn=Unity;X-UnityGenerated=true","link":"/posts/UbuntuEclipse.html"},{"title":"Ubuntu 安装并配置 Java 环境","text":"Ubuntu 安装并配置 java 环境 下载链接 安装 JDK在usr目录下建立java安装目录 12cd /usrsudo mkdir java 将jdk文件移动到java目录下并解压 12345cd /home/downloadsudo mv dk-8u161-linux-x64.tar.gz /usr/java #移动cd /usr/javatar -zxvf dk-8u161-linux-x64.tar.gz #解压ln -s /usr/java/jdk1.8.0_121/ /usr/jdk #创建快捷方式 环境配置 sudo vim /etc/profile 在最后加入 1234export JAVA_HOME=/usr/jdkexport CLASSPATH=.:$JAVA_HOME/lib/export PATH=$PATH:$JAVA_HOME/binexport JAVA_HOME PATH CLASSPATH 保存退出 加载配置信息source /etc/profile 验证java version","link":"/posts/UbuntuJava.html"},{"title":"Git 闯关游戏","text":"Git闯关游戏 安装12apt install rubygem install githug 基本命令githug play - 默认命令，检查是否过关 githug hint - 显示过关提示 githug reset - 重启本关，或者重启到指定的某关 githug levels - 显示关卡列表 第一关（Init）紧接着，马上进入到了第一个关卡, 按照提示初始化这个这个 githug 文件夹为仓库。完成关卡可以通过调用 githug play 验证操作，成功则会进入下一个关卡 12cd git_huggit init 相关:cd （Change Directory），跳转目录、切换路径。 git init在当前目录新建一个Git代码库 第二关（Config）设置 Git 用户名和邮箱，为了不影响全局的配置，我设置的是仓库级别的。 12git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 相关: git config git 的设置文件为.gitconfig,他可以在全局配置（加上–global），也可以项目配置。 另： git config --list 显示当前的git配置 git config -e [--global] 编辑git的配置文件 第三关 （Add）使用 add 命令将 README 文件添加到 staging area. 1git add .README 相关 git add将所有修改过的工作文件提交暂存区 将所有文件添加到暂存区git add .或者git add -A git add .和git add -A的区别 git add .会监控工作区的状态树，使它会把工作时的所有变化提交到暂存区，包括文件内容修改（modified）以及新文件（new），但不包括被删除的文件。 git add -u（git add –update的缩写）仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u不会提交新文件（untracked file）。 git add -A（git add –all的缩写）是上面两个功能的合集。即包括修改的文件、删除的文件以及新文件。 第四关 （Commit）提交 README 文件，记得每次 commit 使用 -m 参数加上备注是个好习惯 1git commit -m &apos;message&apos; 相关: git commit -m [message]提交暂存区到仓库区;还可以提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]。 同时，必须要写 Commit message(提交说明),否则就不允许提交。 git commit -a提交工作区自上次commit之后的变化，直接到仓库区 git commit -v提交时显示所有diff信息,-v参数表示可以看commit的差异 git commit --amend -m [message]使用一次新的commit，替代上一次提交。如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend [file1] [file2] ...重做上一次commit，并包括指定文件的新变化 第五关（Clone)克隆一个仓库，默认的文件夹名是远端的仓库名 1git clone https://github.com/Gazler/cloneme 相关: git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 1234567git clone http[s]://example.com/path/to/repo.git/git clone ssh://example.com/path/to/repo.git/git clone git://example.com/path/to/repo.git/git clone /opt/git/project.gitgit clone file:///opt/git/project.gitgit clone ftp[s]://example.com/path/to/repo.git/git clone rsync://example.com/path/to/repo.git/ SSH协议的另一种写法 git clone [user@]example.com:path/to/repo.git/ 第六关（Clone to folder）同样是克隆一个仓库，不同的是可以指定一个文件夹名 1git clone https://github.com/Gazler/cloneme my_cloned_repo 相关 git clone&lt;版本库的网址&gt; &lt;本地目录名&gt; 该命令会在本地主机生成一个目录。如果不指定目录名，则与远程主机的版本库同名。 第七关（Ignore)忽略所有 .swp 后缀名的文件。这里使用 vim 编辑器打开 .gitignore，这个文件记录了 git 忽略文件的规则, 不会 vim 的同学可以用自己熟悉的编辑。 12touch .gitignore echo &apos;*.swp&apos;&gt;&gt;.gitignore 使用正则(glob 模式)匹配所有的 .swp 文件，然后保存并退出 123.progile.yml.gitignore*.swp 相关: 忽略掉某个文件，需要修改.gitignore文件的方法。可以在你的用户目录下创建 ~/.gitignoreglobal 文件中设置全局。 需要执行 git config –global core.excludesfile ~/.gitignoreglobal来使得它生效。 *.a 忽略所有 .a 结尾的文件 !lib.a 但 lib.a 除外 /TODO仅仅忽略项目根目录下的 TODO 文件，但不包括 subdir/TODO build/ 忽略 build/ 目录下的所有文件 doo/*.txt 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。 git update-index --assume-unchanged PATH 在PATH处输入要忽略的文件。 git update-index --no-assume-unchanged PATH 还原。 另外 git 还提供了另一种exclude的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去，用来保存的是公共的需要排除的文件。而.git/info/exclude 这里设置的则是你自己本地需要排除的文件。他不会影响到其他人。也不会提交到版本库中去。 第八关（Include除了 lib.a文件，其他所有的 .a 后缀名的文件都忽略。和上一关的操作一样，修改 .gitignore 文件 12echo &apos;*.a&apos;&gt;&gt;.gitignoreecho &apos;!lib.a&apos;&gt;&gt;.gitignore 其中 # 开头的是注释，用*.a 匹配所有 .a 文件，! 开头代表不要忽略 123456.profile.yml.gitignore# ignore all file with &quot;.a&quot; extensions expect &quot;lib.a&quot; file*.a!lib.a 第九关（Status)查看所有处于untracked状态的文件。使用git status 查看当前仓库的状态，可以看到红色部分就是 untracked 状态的文件 1git status 答案：database.yml 相关:git status 显示有变更的文件 第十关（Number of files committed）其实就是查看处于 staged 状态的文件，图中黄色部分就是，所以个数就是2 1git status 相关 git status命令可以列出当前目录所有还没有被git管理的文件和被git管理且被修改但还未提交(git commit)的文件。 命令中”Changes to be committed“中所列的内容是在Index中的内容，commit之后进入Git Directory。 命令中“Changed but not updated”中所列的内容是在Working Directory中的内容，add之后将进入Index。 命令中“Untracked files”中所列的内容是尚未被Git跟踪的内容，add之后进入Index 第十一关（rm）有一个文件从硬盘中删除了，但是并未从 git 仓库中删除，找到它并从 git 仓库中删除。删除也是修改的一种，提交这个修改就好了 12git statusgit rm deleteme.rb 相关:git rm [file1] [file2] ...删除工作区文件，并且将这次删除放入暂存区。 第十二关（rm cached）讲一个新文件从 staging area 中删除。按照要求，不应该直接从硬盘上删除这个文件，只是从 Git 中删除而已。加上--cache 可以是文件只是从 staging area 中移除，不会真正的删除物理文件，如果要连这个物理文件也一起删除，请使用 -f 选项 12git statusgit rm --cached deleteme.rb 相关: git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区。 第十三关（stash）临时提交某个文件。这个操作在需要临时保存修改，而又不想提交的时候特别好用！而且 git 中维护了一个栈来保存，所以支持提交多次。如果需要恢复某次提交，使用 git stash apply 即可。 123git statusgit stashgit status 相关: git stash 用于保存和恢复工作进度。 git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存。 git stash list 显示进度列表。 git stash pop [–index] [] 如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。如果提供参数（来自git stash list显示的列表），则从该中恢复。恢复完毕 也将从进度列表中删除。选项–index除了恢复工作区的文件外，还尝试恢复暂存区。 git stash [save [--patch] [-k|--[no]keep-index] [-q|--quiet] [&lt;message&gt;]] 这是第一条命令的完整版。 使用参数--patch会显示工作区和HEAD的差异，通过对差异文件的编辑决定在进度中最终要保存的工作区的内容，通过编辑差异文件可以在进度中排除无关内容。 使用-k或者--keep-index参数，在保存进度后不会将暂存区重置。默认会将暂存区和工作区强制重置。 git stash apply [--index] [&lt;stash&gt;] 除了不删除恢复的进度之外，其余和git stash pop 命令一样。 git stash drop [&lt;stash&gt;] 删除一个存储的进度。默认删除最新的进度。 git stash clear删除所有存储的进度。 git stash branch &lt;branchname&gt; &lt;stash&gt; 基于进度创建分支。 第十四关（Rename)重命名文件。首先这个文件需要是已经是已追踪状态，才可以使用git mv 命令，操作完成后自动处于 staging 状态 1git mv oldfile.txt newfile.txt 相关:git mv 重命名文件 第十五关（Restructure）移动所有 .html 文件到 src 文件夹。git mv 后面的第二个参数可以接受文件或目录，如果是目录，则文件会直接放入目录内，可以使用正则（glob模式）匹配所有 .html 文件 12mkdir srcgit mv *.html src/ 相关: mkdir(make directory) Mkdir 是一个用来在 Linux 系统下创建目录的命令。此命令属于内建命令。 mkdir test1 默认情况下不带任何参数运行mkdir命令会在当前目录下创建目录。 mkdir test2[ test22 test222] 创建多个目录。 mkdir -p test3/test33 递归创建多个目录。例如创建的目录包含子目录，如果找不到父目录，那么这个参数会首先帮助创建父目录。 mkdir -m=r test4 使用-m参数，给生成的新目录设置权限。参考：工作中常用Linux命令：mkdir命令 mkdir -v test5 创建目录显示信息。 第十六关（Log）找到最新的 commit 的 hash 值。使用 git log 查看历史提交记录, 找到最新的 commit 的 hash 值，记录下来用户回答问题 1git log 答案为：34b2fd7(commit后 前7位) 这里是按照倒叙排列的，最新的在最前面，commit 关键字后面跟着的就是这个 commit 的hash值 相关: git log 显示当前分支的版本历史。 git log --stat 显示commit历史，以及每次commit发生变更的文件 git log -s [keyword] 搜索提交历史，根据关键词 git log -p [file] 显示指定文件相关的每一次diff git log -5 --pretty --oneline 显示过去5次提交 git log --follow [file]git whatchanged [file] 显示某个文件的版本历史，包括文件改名 git log [tag] HEAD --pretty-format:%s 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD --grep feature 显示某个commit之后的所有变动，其“提交说明”必须符合搜索条件 第十七关（Tag）为最新的 commit 打 tag。不加额外参数就是为当前 commit 记录tag, 当然可以为特定的 commit 打 1git tag new_tag 相关: git tag 列出所有的tag，在控制台打印出当前仓库的所有标签 git tag [tag] 新建一个tag在当前commit git tag [tag] [commit] 新建一个tag在指定commit git tag d [tag] 删除本地tag 第十八关（Push tags）将所有本地 tag 都推送到远端。–tags 参数代表将所有的 tags 都推送到远端 1git push --tags origin master 相关： 默认 git push 不会罢 tag 标签传送到远端服务器上，只有通过显示命令才能分享标签到远端仓库。 git push origin [tagname] push 单个 tag git push [origin] --tags push 所有 tag 第十九关（Commit amend）某个文件在上次提交中遗漏了，在那次提交中补上这个文件。 其实，使用git commit --amend 会进入编辑界面修改备注信息，我这里直接 :wq 保存并退出 123git statusgit add forgotten_file.rbgit commit --amend -m &apos;message&apos; 相关: git commit --amend 合并缓存区的修改和最近的一次commit, 然后用生成的新的commit替换掉老的. 如果缓存区没有内容, 那么利用amend可以修改上一次commit的描述. 第二十关（Commit in feature） 为提交指定一个未来的时间。 123git commit --date 2016.10.08 -m &apos;message&apos;#或者git commit --date=05.01.2018T14:00:00 相关:git commit --date &lt;date&gt;修改提交时间 第二十一关（Reset）两个文件都被添加到了 staging area, 但是只想提交其中一个。使用 git reset 可以用仓库中的版本覆盖 staging area 的版本。 12git statusgit reset HEAD to_commit_second.rb git reset使用仓库中的版本覆盖 staging area 中的，如果 working directory 该文件没有其他修改，则 staging area 中的修改将应用到 working directory 中。反之working directory 中的版本将被保留，丢弃 staging area中的修改。 git checkout 则是使用 staging area 的中的版本覆盖 working directory。 相关:reset 命令移动 HEAD 到当前分支的一个 commit， 这可以用来撤销当前分支的一些 commit git reset [-q] [commit] [--] &lt;paths&gt; 第一种用法是不会重置引用的，即不会修改master文件。 git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;]第二种用法不使用&lt; paths &gt; 则会重置引用，并且参数不同决定是否覆盖暂存区和工作区： git reset -mixed 此为默认方式，不带任何参数的git reset，会退到某个版本只保留源码，回退commit和index信息，staged snapshot 被更新， working directory 未被更改。 git reset -soft 回退到某个版本，只回退了commit信息，staged snapshot 和 working directory 都未被改变 (建议在命令行执行后，再输入 git status 查看状态) git reset -hard彻底回退到某个版本，本地的源码也会变为上一个版本的内容，即staged snapshot 和 working directory 都将回退 例子： 123456789101112#回退所有内容到上一版本 HEAD^的意思是最近一次的提交git reset HEAD^#回退a.py这个文件的版本到上一个版本git reset HEAD^ a.py#向前回退到第3个版本git reset –soft HEAD~3#将本地的状态回退到和远程的一样git reset –hard origin/master#回退到某个版本git reset 38679ed#回退到上一次提交的状态，按照某一次的commit完全反向的进行一次commitgit revert HEAD 第二十二关（Reset soft）撤销上一次提交。 1git reset --soft HEAD^1 相关： --soft 参数将上一次的修改放入 staging area --mixed参数将上一次的修改放入 working directory --hard 参数直接将上一次的修改抛弃 第二十三关（Checkout file）抛弃某一次的修改，使用上次提交的版本。checkout 和 reset 的区别参照第二十一关 1git checkout config.rb 相关:git checkout 检出。 创建分支git branch branchName 切换分支git checkout branchName 上面两个命令可以合成一个命令 git checkout -b branchName 第二十四关（Remote）查看远端仓库。其实可以不加-v参数，加这个参数只是可以将地址也一起输出(没想到下一关就是考察这个参数，平常习惯加这个参数了。) 1git remote -v 答案：my_remote_repo 相关: git remote 不带参数，列出已经存在的远程分支 git remote -v --verbose 列出详细信息，在每个名字后面 git clone -o jQuery https://github.com/jquery/jquery.gitgit remote 想用其他的主机名 需要用 git clone命令的 -o 选项指定 git remote show &lt;主机名&gt;可以查看主机的详细信息 git remote add &lt;主机名&gt; &lt;网址&gt; 添加远程主机 git remote rm &lt;主机名&gt; 删除远程主机 git remore rename &lt;原主机名&gt; &lt;新主机名&gt; 远程主机的改名 tail .git/config 查看remote信息。 第二十五关（remote url）查看远端仓库的 URL 1git remote -v 答案：https://github.com/githug/not_a_repo 第二十六关（pull）拉取远端仓库。 1git pull origin master 相关: git push origin master 的意思就是上传本地当前分支代码到master分支其实可以指定分支，格式如下 git pull origin remote : local对应的推送的格式如下 git push origin local : remote需要注意的两个操作的分支顺序是相反的，记忆的方法很简单，拉取是从远端到本地，所以远端在前，而推送是从本地到远端，所以本地在前。 第二十七关（Remote add）添加一个远端仓库 1git remote add origin https://github.com/githug/githug 第二十八关（Push）推送本地修改到远端 12git rebase origin mastergit push origin master 相关:git rebase用于把一个分支的修改合并到当前分支。 第二十九关（Diff）1git diff app.rb 答案：26 相关： git diff app.rb查看文件改动查看 staging area 和 working directory 中文件的差异。 git diff: 查看 working directory 与 staging area 之间的差异 git diff --cached: 查看 repository 与 staging area 之间的差异 git diff HEAD: 查看 working directory 与 repository 之间的差异 第三十关（Blame）查看某个文件的修改人。这个命令简直邪恶，锅终于有人背了！！！ 1git blame config.rb 答案：Spider Man 相关:git blame得到整个文件的每一行的详细修改信息:包括SHA串,日期和作者。 第三十一关（Branch）创建一个分支 12git branch test_codegit branch 第三十二关（Checkout）创建一个分支，并切换过去。其实，git checkout -b my_branch 就是创建一个分支，并切换过去，而且这种方法更方便，平常用的更多 1git checkout -b my_branch 第三十三关（Checkout tag）切换到某个特定的 tag 12git taggit checkout v1.2 相关:标签可以针对某一时间点的版本做标记，常用于版本发布。 列出标签 Git tag 在控制台打印出当前仓库的所有标签 git tag -l 'v0.1.*' 搜索符合模式的标签打标签 git标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，标注标签则是仓库中的一个独立对象。建议使用附注标签。 git tag v0.1.2-light创建轻量标签 git tag -a v0.1.2 -m &quot;0.1.2版本”创建附注标签 git tag -a v0.1.1 9fbc3d0给指定的commit打标签切换到标签 git checkout [tagname]查看标签信息 git show v0.1.2查看标签的版本信息删除标签 git tag -d v0.1.2 删除标签标签发布 git push 不会将标签对象提交到git服务器，我们需要进行显示的操作： git push origin v0.1.2将标签提交到git服务器 git push origin -tags将本地所有标签一次性提交到git服务器 第三十四关（Checkout tag over branch）切换到某个特定的分支，但是分支名和标签名重叠了 1git checkout tags/v1.2 相关:git checkout tags/v1.2 当标签和分支名相同时，需要指定标签检出 第三十五关（branch at）根据一个特定的提交创建新分支 一种方法： 1git branch test_branch HEAD^1 第二种方法： 12git loggit branch test_branch -v 00740b4 找到第二条的id，输入前7位 第三十六关（delete branch）删除一个分支 1git branch -d delete_me 第三十七关（Push branch）将分支推送到远端仓库 12git branchgit push origin test_branch 相关: git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 git push origin :master省略本地的分支名,则表示删除指定的远程分支，因为这等同与推送一个空的本地分支到远程分支。等同于：git push origin –delete master git push origin如果当前分支与远程分支直接存在追踪关系，则本地分支和远程分支都可以省略 git push 如果当前分支只有一个追踪分支，那么主机名都可以省略 git push -u origin master 如果当前分支和多个主机存在追踪关系，则可以使用 -u 选项指定一个默认主机，这样后面就可以不加任何参数使用 git push git push --all origin不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机。 git push origin --tags git push 不会推送标签（tag），除非使用 -tags 选项 第三十八关（merge）合并分支。为了简化分支模型，可以使用 rebase 代替，后续关卡会遇到。 1git merge feature 相关:git merge合并分支 第三十九关（fetch）获取远端的修改，但是并不合并到当前分支。其实，git pull 就是 git fetch 和 git merge 组成的。 1git fetch origin 相关:git fetch origin master取回origin主机的master分支 第四十关（rebase）12git checkout featuregit rebase master 相关： 其实不知道怎么翻译 git rebase 这个命令。大概意思是从某个提交分化出两个分支，然后其中一个分支需要将另一个分支的修改合并过来，但是又不想在提交记录上留下两个分支合并的痕迹，只留下一个分支以前后顺序记录两边的修改。 git rebase 一个分支的所有修改在另一个分支上重新应用一遍，所以在提交记录上看，会发现一个分支的所有提交在另一个分支之前或者之后。然后删除另一个被合并的分支，保持分支简洁。 git rebase master feature表示将 feature 上的修改在 master 上重新应用一遍 git rebase 命令主要用在从上游分支获取commit信息，并有机的将当前分支和上游分支进行合并 git rebase [-i | --interactive] [options] [--onto ] [] git rebase [-i | --interactive] [options] –onto –root [] git rebase –continue | –skip | –abort 第四十一关（rebase_onto）将版本库未打包的松散对象打包 1git rebase --onto master wrong_branch 相关:git rebase --onto A B C A代表的是你实际想要将切片放到哪个分支，B代表切片开始分支（一定要注意的问题是 B 的开闭问题，这里 rebase –onto 的机制是左开右闭）。 git rebase --onto A B~1 temp 如果想要保留A和C的历史，就需要先在切片的末尾建立一个分支temp。这就代表把B到c之间的历史移到了A上，并且当前temp分支的历史状态就是窝想要的。 第四十二关（repack）应用某一个提交的修改。 1git repack -d 相关:git repack [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [--window=&lt;n&gt;] [--depth=&lt;n&gt;] git repack -d包装后，如果新创建的包使一些现有的包冗余，删除多余的包。同时运行 git prune-packed 去除多余的松散对象文件。 第四十三关 （cherry-pick123git branchgit log new-feature$git cherry-pick ca32a6da 相关:Git cherry-pick 可以选择某一个分支中的一个或几个commit来进行操作 git grep支持各种条件搜索及正则表达式，平时用的不多，但感觉功能强大。 第四十四关（grep）1git grep TODO 相关: git grep 查找git库里面的某段文字 git grep xmmap 查看git里面这个仓库里每个使用 ‘xmmap’ 函数的地方。 git grep -n xmmap 显示行号。 git grep --name-only xmmap 只显示文件名。 git grep -c xmmap 查看每个文件里有多少行匹配内容（line matches）。 git grep xmmap v1.5.0 查找git仓库里某个特定版本里的内容，在命令行末尾加上表签名（tag reference）。 git grep -e '#define' --and -e SORT_DIRENT 组合搜索条件：查找在仓库的哪些地方定义了‘SORT_DIRENT’。 git grep --all-match -e '#define' -e SORT_DIRENT进行或条件搜索。 第四十五关（rename commit）重命名提交。当涉及提交修改时，应该想到 git rebase -i 命令，它接受可以一个参数（提交的哈希值），它将罗列出此提交之后的所有提交，然后可以对个个提交做对应的操作。 12git log mastergit rebase -i HEAD~2 查看历史提交记录，看到需要修改的为倒数第二个，进入编辑页面，将需要改动的行的·改为·。保存退出后在弹出的第二个窗口里修改拼写错误 commmit 改为 commit 第四十六关（squash）合并多个提交。 1git rebase -i HEAD~4 将后三个改为s 为新的提交修改备注 第四十七关（merge squash）将某个分支上的所有修改都应用成一个提交。默认修改都将进入暂存区 123git statusgit merge --squash long-feature-branchgit commit -m &apos;message 相关:--squash 选项的含义是：本地文件内容与不使用该选项的合并结果相同，但是不提交、不移动 HEAD ,因此需要一条额外的commit命令。其效果相当于将 another 分支上的多个 commit 合并成一个，放在当前分支上，原来的 commit 历史则没有拿过来。 第四十八关(reorder()重新排列提交顺序。 12git loggit rebase -i HEAD~2 查看历史记录发现提交顺序错误，将前两行顺序调换。 第四十九关(bisect)使用 git log 查看所有的提交记录，太长我就不全贴出来了，找到最开始的提交git bisect start master f608824888b83 123git log --reverse -p prog.rbgit bisect start master f6088248git bisect run make test 查看最初一次为正确提交，得到版本号。执行完毕后日志里找到 “is the first bad commit” ,得到 18ed2ac。 git bisect start master f608824888b83中，master 是有 bug 的节点，f608824888b83是没有 bug 的节点。 相关: git bisect start git bisect good fb088248 git bisect bad master git bisect run make test git bisect reset 回到之前执行 git bisect start 的状态。 第五十关（Stage lines）其实，提交文件的部分修改这种需求平时还是比较常见的，不过平时都是用 Source Tree 来操作的，但是看到这题之后，好像又开启了一扇大门。 1234git statusgit add -p feature.rbgit diffgit status 输入i编辑提交内容，删除第二个。 第五十一关（Find old branch）git reflog 可以列出所有的操作记录，所以找到之前忘记的信息并不是什么难事 12git refloggit checkout solve_world_hunger 相关: reflog 是 git 用来记录引用变化的一种机制。 git reflog 命令可以对 git 误操作进行数据恢复。 第五十二关（Revert）与 reset 不同的是，revert 只会撤销当前的 commit，而之后的 commit 操作的修改还会保留，但是reset 还会将之后的所有commit 操作的修改全部退回 staging area或丢弃。 12git loggit revert HEAD^1 相关: 修复提交文件中的错误： git reset --hard HEAD 把工作目录中所有未提交的内容清空。 git checkout恢复一个文件 git revert HEAD 撤销一次提交 第五十三关（Restore）根据之前的经验，git reflog 可以查看所有的操作记录，所以只要能找到误操作之前的 commit id，一样能够恢复现场。 12git refloggit checkout bdbe33d 相关: 恢复已修改的文件： 第五十四关（Conflict）冲突处理在平常的协同工作中真是再常见不过了，需要注意的是存在冲突的文件是在 working directory 中的，在解决完冲突之后需要添加到 staging area 并提交。 12345git branchgit merge mybranchvim poem.txtgit add poem.txtgit commit -m &apos;message 相关： 其实冲突解决完成的图片丢失了，只能口述了。 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 到 ======= 之间的内容代表 master 分支的修改，======= 到 &gt;&gt;&gt;&gt;&gt;&gt; mybranch 之间的内容代表 mybranch 分支的修改，保留 mybranch 分支的修改，删除master 分支的修改即可，当然这些特殊符号所在行也要一并删除。 第五十五关（Submodule）submodule是一个很方便的将一个仓库分解成多个子模块的命令，特别是项目比较大且依赖其他 Git 项目的时候，比如 Cocos2d-x。虽然好用，但是门槛也相对高点，如果维护好 submodule还是需要好好研究一下。 1git submodule add http://github.com/jackmaney/githug-include-me 相关: git submodule add 子模块仓库地址 路径 第五十六关（Contribute）其实到这里已经可以算是通关，如果感兴趣的话可以到 GitHub 为这个项目贡献代码。 参考：Ryeeeeee风花花","link":"/posts/GitGame.html"},{"title":"使用手机更新文章","text":"此文由手机端使用MarkdownX编辑并通过Termux发布。","link":"/posts/mobile.html"},{"title":"Termux 安装 Linux","text":"Termux安装Linux 安装脚本添加源 1echo \"deb [trusted=yes] https://yadominjinta.github.io/files/ termux extras\" &gt;&gt; $PREFIX/etc/apt/sources.list 安装 1pkg install atilo-cn -y 使用1atilo [命令] [参数] 安装 Linux 1atilo ubuntu 运行 linux 1startubuntu 设置中文修改/etc/locale.gen 12locale-gen zh_CN.UTF-8export LC_ALL=\"zh_CN.UTF-8\"","link":"/posts/TermuxLinux.html"},{"title":"Hexo 多设备源码同步","text":"Hexo 多设备源码同步 主设备操作部署 Hexo12345678# 在本地博客根目录下安装 hexonpm install -g hexo-cli# 初始化hexonpm init# 安装依赖npm install# 安装部署相关的配置npm install hexo-deployer-git Push 源码 新建分支后,在本地博客根目录下使用 git 指令上传项目到 Github 123456789101112# git初始化git init# 添加仓库地址git remote add origin https://github.com/iVitan/ivitan.github.io.git# 新建分支并切换到新建的分支git checkout -b hexo# 添加所有本地文件到gitgit add .# git提交git commit -m \"\"# 文件推送到hexo分支git push origin hexo 其他设备操作克隆Github分支上的文件: 1git clone -b hexo https://github.com/iVitan/ivitan.github.io.git 安装 Hexo 1234567# 安装hexonpm install -g hexo-cli# 注意这里不需要hexo初始化：hexo init；否则之前的hexo配置参数会重置# 安装依赖库npm install# 安装部署相关配置npm install hexo-deployer-git 主题 cutie 下载 相关 npm 123456npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm i markdown-it-emoji --savenpm i markdown-it-mark --savenpm i markdown-it-deflist --savenpm i markdown-it-container --save 更新文章 1hexo new \"tittle\" 分别同步到master,hexo分支 后续 Push123456789# 添加源文件git add .# Git 提交git commit -m \"\"# 先拉原来Github分支上的源文件到本地，进行合并# 分支名后面的“--allow-unrelated-histories”是为了弹出“fatal: refusing to merge unrelated histories.”的错误git pull origin hexo --allow-unrelated-histories# 比较解决前后版本冲突后，push源文件到Github的分支git push origin hexo 问题无法Push 强制 Push 1git push -f origin hexo 根目录的.gitconfig文件一般写上需要忽略的文件及文件夹 1234567.DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/","link":"/posts/HexoDevices.html"},{"title":"Git 笔记","text":"Git 配置笔记。 基础命令 文件管理 命令 解析 pwd 查看当前文件目录 mkdir 创建文件 touch xxx.xx 创建文件 git rm xxx 从git删除文件 设置 SSH Key 配置github账户信息 12git config --global user.name \"Vitan\"git config --global user.email \"vitan.me@gmail.com\" 创建 SSH 1ssh-keygen -t rsa -C \"vitan.me@gmail.com\" 1ssh-keygen -t rsa -C \"vitan.me@gmail.com\" -f ~/.ssh/vitan-github 参数含义： t 指定密钥类型，默认即 rsa ，可以省略 C 设置注释文字，比如你的邮箱 f 指定密钥文件存储文件名，会生成 vitan-github 和 vitan-github.pub 两个密钥文件 复制 Key 12cd ~/.sshcat id_rsa.pub 验证 SSH 12ssh -T git@github.comgit config --list #查看key配置 查看 Git 配置 1git config --list 其他123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161git clone xxxx#克隆项目git init# 初始化本地git仓库（创建新仓库）git config --global user.name \"xxx\"# 配置用户名git config --global user.email \"xxx@xxx.com\"# 配置邮件git config --global color.ui true# git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy# remove proxy configuration on gitgit clone git+ssh://git@192.168.53.168/VT.git# clone远程仓库git status# 查看当前版本状态（是否修改）git add xyz# 添加xyz文件至indexgit add .# 增加当前子目录下所有更改过的文件至indexgit commit -m 'xxx'# 提交git commit --amend -m 'xxx'# 合并上一次提交（用于反复修改）git commit -am 'xxx'# 将add和commit合为一步git rm xxx# 删除index中的文件git rm -r *# 递归删除git log# 显示提交日志git log -1# 显示1行日志 -n为n行git log -5git log --stat# 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818# 显示某个提交的详细内容git show dfb02# 可只用commitid的前几位git show HEAD# 显示HEAD提交日志git show HEAD^# 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag# 显示已存在的taggit tag -a v2.0 -m 'xxx'# 增加v2.0的taggit show v2.0# 显示v2.0的日志及详细内容git log v2.0# 显示v2.0的日志git diff# 显示所有未添加至index的变更git diff --cached# 显示所有已添加index但还未commit的变更git diff HEAD^# 比较与上一个版本的差异git diff HEAD -- ./lib# 比较与HEAD版本lib目录的差异git diff origin/master..master# 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat# 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git# 增加远程定义（用于push/pull/fetch）git branch# 显示本地分支git branch --contains 50089# 显示包含提交50089的分支git branch -a# 显示所有分支git branch -r# 显示所有原创分支git branch --merged# 显示所有已合并到当前分支的分支git branch --no-merged# 显示所有未合并到当前分支的分支git branch -m master master_copy# 本地分支改名git checkout -b master_copy# 从当前分支创建新分支master_copy并检出git checkout -b master master_copy# 上面的完整版git checkout features/performance# 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933# 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0# 检出版本v2.0git checkout -b devel origin/develop# 从远程分支develop创建新本地分支devel并检出git checkout -- README# 检出head版本的README文件（可用于修改错误回退）git merge origin/master# 合并远程master分支至当前分支git cherry-pick ff44785404a8e# 合并提交ff44785404a8e的修改git push origin master# 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933# 删除远程仓库的hotfixes/BJVEP933分支git push --tags# 把所有tag推送到远程仓库git fetch# 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune# 获取所有原创分支并清除服务器上已删掉的分支git pull origin master# 获取远程分支master并merge到当前分支git mv README README2# 重命名文件README为README2git reset --hard HEAD# 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933# 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933# 强制删除分支hotfixes/BJVEP933git ls-files# 列出git index包含的文件git show-branch# 图示当前分支历史git show-branch --all# 图示所有分支历史git whatchanged# 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818# 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD# 内部命令：显示某个git对象git rev-parse v2.0# 内部命令：显示某个ref对于的SHA1 HASHgit reflog# 显示所有提交，包括孤立节点git show HEAD@{5}git show master@{yesterday}# 显示master分支昨天的状态git log --pretty=format:'%h %s' --graph# 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash# 暂存当前修改，将所有至为HEAD状态git stash list# 查看所有暂存git stash show -p stash@{0}# 参考第一次暂存git stash apply stash@{0}# 应用第一次暂存git grep \"delete from\"# 文件中搜索文本“delete from”git grep -e '#define' --and -e SORT_DIRENTgit gcgit fsck","link":"/posts/GitNote.html"},{"title":"Termux 折腾记","text":"Termux oh-my-zsh 主题设置，去欢迎字等。 软件下载 官网 Google Play CoolApk 百度网盘密码: 7eyf 常用快捷键音量-键模拟（Ctrl）键 123456789音量-键(Ctrl)+L 清除屏幕内容音量-键(Ctrl)+C 终止当前操作音量-键(Ctrl)D 退出当前会话session音量+键+D Tab键（可自动补全命令或文件名）音量+键+W 方向键 上（可显示前一条命令）音量+键+S 方向键 下（可显示后一条命令）音量+键+A 方向键 左（可左移动光标）音量+键+D 方向键 右（可右移动光标）音量+键+Q 显示或关闭扩展键（ESC、插入链接CTR、ALT、TAB、-、/、|以及左滑扩展键一栏可切换到全功能支持手机输入法的输入框） 常用命令更新 12345678910termux-setup-storage 挂载Storageapt update 更新源apt search &lt;query&gt; 全文搜索可安装包apt install &lt;package&gt; 安装软件包apt upgrade 升级软件包apt show &lt;package&gt; 显示软件包的信息apt list [--installed] 列出所有（或已安装）的软件包信息apt remove &lt;package&gt; 删除软件包chmod 修改文件权限chown 修改文件归属 cd 命令 12345678910cd# 你当前在 /root目录中，使用这个命令会进入 /root/bash目录，这是相对路径cd bash# 如果你不在 /root目录中的话，就不能用上面的相对路径了，就需要绝对路径cd /root/bash# 假设你当前在 /root/bash目录中，使用相对路径，你可以用这个命令进入上一级 /root目录， `..` 代表相对路径 上级目录cd ..# 当然你也可以用绝对路径来进入上一级 /root目录cd /root路径的输入zsh有个方 ls 命令 1234567# 显示当前目录下的所有文件ls -als -a bash/log# 相对路径，当前目录是 /root ，欲查看的目录是 /root/bash/logls -a /root/bash/log# 绝对路径， 当前目录是 /root ，欲查看的目录是 /root/bash/log#更多的命令可以用 ls --help 来查看。 tree 包命令 1234567891011121314151617181920212223242526272829# 复制当前目录内的 log.txt文件到 /var目录cp log.txt /var/log.txt# 复制当前目录内的 bash文件夹到 /home目录cp -R bash /home/bash———————————————————————————————————————————————# 复制当前目录内的所有.txt后缀的文件到 /var/log目录cp *.txt /var/log# 复制当前目录内的所有以 doubi开头的文件到 /var/log目录cp doubi* /var/log# 复制当前目录内的所有以 doubi开头 以.txt后缀结尾的文件到 /var/log目录cp doubi*.txt /var/log———————————————————————————————————————————————# 假设当前目录是 /root/doubi/log，要把这个目录中的所有.txt后缀的文件复制到上一级目录 /root/doubi，那么这样做cp *.txt ..# .. 就是相对路径，代表上一级目录，��然你也可以用绝对路径，这样更不容易出错cp *.txt /root/doubi——————————————————————————————————————————————# 重命名当前目录内的 log.txt文件为 log2.txtcp log.txt log2.txt# 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txtcp log.txt /var/log1.txt# 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2cp -R bash /home/bash2——————————————————————————————————————————————#复制当前目录内的 log.txt文件到 /var目录，但是 /var 目录中已经存着 log.txt，那么会提示 cp: overwrite `/var/log.txt'? 可以用 -f 强制覆盖cp -f log /var/log.txt# 复制当前目录内的 log.txt log1.txt log2.txt文件和 log233目录到 /home/log目录中cp -R log.txt log1.txt log2.txt log233 /home/log#更多的命令可以用 cp --help 查看。 去欢迎字1touch ~/.hushlogin oh-my-zsh123apt install git curl zsh -ysh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"chsh -s zsh 带字体，配色管理版 123sh -c \"$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\" //安装~/.termux/colors.sh //修改配色~/.termux/fonts.sh //修改字体 ssh1apt install openssh -y 连接 1ssh -p443 root@主机ip hexo博客install 12345678apt updateapt install git openssh nodejs make python2 vimmkdir blogcd blognpm install -g hexohexo initnpm installnpm install hexo-deployer-git –save 在站点配置文件_config.yml的Deployment字段处添加并修改 1234deploy:type: gitrepo: git@github.com:username/username.github.io.gitbranch: master 创建ssh密钥 123git config –global user.name “Vitan”git config –global user.email “ivitan95@gmailcom”ssh-keygen -t rsa -C “ivitan@gmail.com” 添加本地私钥文件 1cat ~/.ssh/id_rsa.pub 添加到 Github 测试并发布 GithubPage 上 123cd ~/bloghexo ghexo d","link":"/posts/TermuxNote.html"},{"title":"Hexo 常用命令","text":"Hexo 常用命令 Hexo 用命令 [新建文章]hexo new &quot;my blog&quot;新建的文件在hexo/source/_posts/my-blog.md 编译hexo generate一般部署上去的时候都需要编译一下，编译后，会出现一个public文件夹，将所有的md文件编译成html文件 开启本地服务hexo server这个命令，我之前已经用过了，开启本地hexo服务用的 部署 hexo deploy部署到git上的时候，需要用这个命令，下一篇中，我们会使用到这个命令 清除publichexo clean 版本更新npm update -g 主题更新 12cd themes/indigogit pull","link":"/posts/Hexo-Command.html"},{"title":"Markdown 语法","text":"Markdown 语法. 文章开头123456789---title: Hexodate: 2018-01-18 8:18:38tags: [Markdown,教程]categories: 学习description: 摘要toc: truemathjax: true--- 如何设置文章摘要&lt;!-- more --&gt; 1234--- 这是摘要&lt;!-- more --&gt;这是正文 斜体和粗体 使用*和 ** 表示斜体和粗体，格式如下：12*斜体***粗体** 斜体 粗体 标题12345这是一个一级标题============================这是一个二级标题----------------------------### 这是一个三级标题 列表无序列表 使用 *，+，- 表示无序列表。123456+ 无序列表项 一 - 子无序列表 一 - 子无序列表 二 * 子无序列表 三+ 无序列表项 二+ 无序列表项 三 无序列表项 一 子无序列表 一 子无序列表 二 子无序列表 三 无序列表项 二 无序列表项 三 有序列表 使用数字和点表示有序列表。123451. 有序列表项 一 1. 子有序列表项 一 2. 子有序列表项 二2. 有序列表项 二3. 有序列表项 三 有序列表项 一 子有序列表项 一 子有序列表项 二 有序列表项 二 有序列表项 三 注释用 \\表示注释，\\后面的文字解析为纯文本格式。 分割线在单独的一行使用*** 或者 ---表示分割线 删除线使用~~ 表示删除线 绘制表格 绘制表格格式如下，|控制分列，-控制分行，: 控制对齐方式。 12345| Item | Value | Qty || :------- | --------: | :---: || Computer | 1600 USD | 5 || Phone | 12 USD | 12 || Pipe | 1 USD | 234 | Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 其他 分段： 两个回车 换行 两个空格 + 回车 标题#~######井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题 引用 &gt; 列表*，+，-，1.，``选其中之一，注意后面有个空格 代码区块 四个空格开头 链接 [文字](链接地址) 图片 ![图片说明](图片地址)，图片地址可以是本地路劲，也可以是网络地址 强调 **文字**，__文字__，_文字_，*文字* 图片大小123&lt;img src=&quot;链接&quot; width =&quot;256&quot; height=256 /&gt; //固定大小&lt;img src=&quot;链接&quot; width =&quot;50%&quot; height=&quot;50%&quot; /&gt; //一定比列&lt;img src=&quot;链接&quot; width = &quot;450&quot; alt=&quot;图片描述&quot; align=center /&gt; 其中width和height后面的50%就是根据窗口的大小以一定的比例显示图片。值得一说的是，这种按照百分比显示方法，是以width方向为准，并保持纵横比的，换句话说，把设置width的部分去掉，height的值改为任意百分比，显示的图像都是原图大小（个人觉得这根博客窗口有关，毕竟现实截面的宽度相对是固定的，而高度/长度却是变化着的）。因此用此方法的时候，可以把height设置缺省。","link":"/posts/Markdown.html"},{"title":"Hexo 安装笔记","text":"Hexo 从零开始到搭建完整 准备安装 Git Bash下载链接安装好后，打开 GitBash，查看版本：命令：git version 或者 git -v 安装NodeJsHexo是基于 NodeJS 环境的静态博客，里面的npm工具很有用下载地址(说明：LTS为长期支持版，Current为当前最新版)下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量） npm 换源1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo123456mkdir hexocd d:\\hexonpm install hexo-cli -gnpm installhexo initnpm install hexo-deployer-git --save Github 创建一个 repo，名称为 ivitan.github.io, 其中 ivitan 是你的 Github 用户名。 回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的） 将博客与 Github 关联打开本地文件夹项目内的_config.yml配置文件，将其中的 type 设置为 git 1234deploy:type: gitrepository: https://github.com/用户名/用户名.github.io.gitbranch: master 创建 SSH Key123git config --global user.name \"Vitan\"git config --global user.email \"ivitan95@gmail.com\"ssh-keygen -t rsa -C \"ivtan95@gmail.com\" 复制 id_rsa.pub 内的密匙添加到 GitHub 验证是否添加成功：ssh -T git@github.com 修改_config.yml1234deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master GitBash进入blog 目录1234hexo cleanhexo ghexo shexo d 浏览器：http://localhost:4000","link":"/posts/HexoInstall.html"},{"title":"折腾了一天","text":"这是一篇测试文章 折腾了一天，终于搞定了。感觉良好！","link":"/posts/first.html"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"ADB","slug":"ADB","link":"/tags/ADB/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Win","slug":"Win","link":"/tags/Win/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"ArchLinux","slug":"ArchLinux","link":"/tags/ArchLinux/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Notes","slug":"Notes","link":"/tags/Notes/"},{"name":"Atom","slug":"Atom","link":"/tags/Atom/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Note","slug":"Note","link":"/tags/Note/"},{"name":"Termux","slug":"Termux","link":"/tags/Termux/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"WebCrawler","slug":"WebCrawler","link":"/tags/WebCrawler/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Eclipse","slug":"Eclipse","link":"/tags/Eclipse/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Excel","slug":"Excel","link":"/tags/Excel/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Ununtu","slug":"Ununtu","link":"/tags/Ununtu/"},{"name":"RaspberryPi","slug":"RaspberryPi","link":"/tags/RaspberryPi/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Typography","slug":"Typography","link":"/tags/Typography/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"TvBox","slug":"TvBox","link":"/tags/TvBox/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"R","slug":"R","link":"/tags/R/"},{"name":"Node.Js","slug":"Node-Js","link":"/tags/Node-Js/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"Batch","slug":"Batch","link":"/tags/Batch/"},{"name":"Wine","slug":"Wine","link":"/tags/Wine/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"}],"categories":[{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Coding","slug":"Coding","link":"/categories/Coding/"},{"name":"Web","slug":"Coding/Web","link":"/categories/Coding/Web/"},{"name":"Java","slug":"Coding/Java","link":"/categories/Coding/Java/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Python","slug":"Coding/Python","link":"/categories/Coding/Python/"}]}