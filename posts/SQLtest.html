<!DOCTYPE html><html lang="zh-CN"><head>
<script>(n=>{"use strict";let r,s,e;const l=["cdn.jsdelivr.net","fastly.jsdelivr.net","gcore.jsdelivr.net","cdn.zenless.top","testingcf.jsdelivr.net","test1.jsdelivr.net"],t="//",a=l[0],i=Date.now(),o=2e3,c="jsdelivr-auto-fallback",f="/gh/PipecraftNet/jsdelivr-auto-fallback@main/empty.css?",d=e=>e&&e.includes(t+a),m=e=>e.replace(t+a,t+r),u=window.setTimeout,v=n.querySelectorAll.bind(n),g=()=>{let e,t;for(e of v('link[rel="stylesheet"]'))t=e.href,d(t)&&!t.includes(f)&&(e.href=m(t));for(e of v("script"))if(t=e.src,d(t)){const r=n.createElement("script");r.src=m(t),e.defer=!0,e.src="",e.before(r),e.remove()}for(e of v("img"))t=e.src,d(t)&&(e.src="",e.src=m(t));for(e of v("*[style]"))t=e.getAttribute("style"),d(t)&&e.setAttribute("style",m(t));for(e of v("style"))t=e.innerHTML,d(t)&&(e.innerHTML=m(t))},y=()=>{!e&&s&&r&&(console.warn(a+" is not available. Use "+r),e=!0,u(g,0),u(g,20),setInterval(g,500))},b=(()=>{try{return Object.assign({},JSON.parse(localStorage.getItem(c)||"{}"))}catch{return{}}})();var h=()=>{b.time=i,b.failed=!1,b.fastNode=null;for(const t of l)((e,t)=>{let r;const s=n.createElement("link"),l=e=>{r&&(clearTimeout(r),r=0,e||(s.href="data:text/plain;base64,"),s.remove(),t(e))};r=u(l,o),s.addEventListener("error",()=>l(!1)),s.addEventListener("load",()=>l(!0)),s.rel="stylesheet",s.text="text/css",s.href=e+f+i,n.head.insertAdjacentElement("afterbegin",s)})("https://"+t,e=>{e||t!==a||(s=!0,b.failed=!0),e&&!r&&(r=t),e&&!b.fastNode&&(b.fastNode=t),y()});u(()=>{s&&!r&&(r=l[1],y()),localStorage.setItem(c,JSON.stringify(b))},o+100)};b.time&&i-b.time<36e5&&b.failed&&b.fastNode?(s=!0,r=b.fastNode,y(),u(h,1e3)):h()})(document);</script><meta charset="utf-8"><meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0"><meta name="generator" content="Hexo 7.1.1"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#f8f8f8"><title>SQL 各章练习题 - 維坦</title><meta name="description" content="SQL数据库原理练习题"><meta property="og:type" content="article"><meta property="og:title" content="SQL 各章练习题"><meta property="og:url" content="https://ivitan.com/posts/SQLtest.html"><meta property="og:site_name" content="維坦"><meta property="og:description" content="SQL数据库原理练习题"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2018-05-23T12:24:38.000Z"><meta property="article:modified_time" content="2024-03-11T17:41:38.810Z"><meta property="article:author" content="VITAN"><meta property="article:tag" content="SQL"><meta name="twitter:card" content="summary"><meta name="keywords" content="SQL"><link rel="alternate" href="/xml/atom.xml" title="維坦" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=1.27.0"><link rel="shortcut icon" href="/assets/logo/favicon.svg"><script defer async src="https://www.googletagmanager.com/gtag/js?id=G-XEHQ8YBEN0"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-XEHQ8YBEN0")</script></head><body><div class="l_body s:aa content tech" id="start" layout="post"><aside class="l_left"><div class="leftbar-container"><header class="header"><div class="logo-wrap"><a class="avatar" href="/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp)"></div><img no-lazy class="avatar" src="/assets/avatar/ivitan.png" onerror="javascript:this.classList.add('error');this.src='https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">config.title</div><div class="sub normal cap">⁣⁣⁣Never Settle</div><div class="sub hover cap" style="opacity:0">ivitan.com</div></a></div></header><div class="nav-area"><div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div><nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1bcdfc"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="项目" href="/wiki/" style="color:#3dc550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="关于" href="/about/" style="color:#fa6400"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a></nav></div><div class="widgets"><widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span><a class="cap-action" id="rss" title="Subscribe" href="/xml/atom.xml"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M5 21q-.825 0-1.412-.587T3 19q0-.825.588-1.412T5 17q.825 0 1.413.588T7 19q0 .825-.587 1.413T5 21m13.5 0q-.65 0-1.088-.475T16.9 19.4q-.275-2.425-1.312-4.537T12.9 11.1q-1.65-1.65-3.762-2.687T4.6 7.1q-.65-.075-1.125-.512T3 5.5q0-.65.45-1.062t1.075-.363q3.075.275 5.763 1.563t4.737 3.337q2.05 2.05 3.338 4.738t1.562 5.762q.05.625-.363 1.075T18.5 21m-6 0q-.625 0-1.075-.437T10.85 19.5q-.225-1.225-.787-2.262T8.65 15.35q-.85-.85-1.888-1.412T4.5 13.15q-.625-.125-1.062-.575T3 11.5q0-.65.45-1.075t1.075-.325q1.825.25 3.413 1.063t2.837 2.062q1.25 1.25 2.063 2.838t1.062 3.412q.1.625-.325 1.075T12.5 21"/></svg></a></div><div class="widget-body fs14"><a class="item title" href="/posts/TermuxConfig.html"><span class="title">Termux Config Shell</span></a><a class="item title" href="/posts/TermuxLinux.html"><span class="title">Termux 安装 Linux</span></a><a class="item title" href="/posts/TermuxNote.html"><span class="title">Termux 折腾记</span></a><a class="item title" href="/posts/TermuxPython.html"><span class="title">Termux Python 相关库</span></a><a class="item title" href="/posts/TermuxRepo.html"><span class="title">Termux 的 Bintray 库已关闭，解决办法</span></a></div></widget></div></div></aside><div class="l_main" id="main"><div class="article banner top"><div class="content"><div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a> <span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Database/">Database</a></div><div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2018-05-23T12:24:38.000Z">2018-05-23</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-03-11T17:41:38.810Z">2024-03-12</time></span></div></div></div><div class="bottom only-title"><div class="text-area"><h1 class="text title"><span>SQL 各章练习题</span></h1></div></div></div></div><article class="md-text content"><p>SQL数据库原理练习题</p><span id="more"></span><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="一-选择题"><a href="#一-选择题" class="headerlink" title="一,选择题"></a>一,选择题</h2><ol><li>DBS是采用了数据库技术的计算机系统,DBS是一个集合体,包含数据库,计算机硬件,软件和( C ).</li></ol><p>A.系统分析员 B. 程序员 C. 数据库管理员 D. 操作员<br>2. 数据库(DB),数据库系统(DBS)和数据库管理系统(DBMS)之间的关系是( A).</p><p>A. DBS包括DB和DBMS B. DBMS包括DB和DBS<br>C. DB包括DBS和DBMS D. DBS就是DB,也就是DBMS<br>3. 下面列出的数据库管理技术发展的三个阶段中,没有专门的软件对数据进行管理的是( D).<br>I.人工管理阶段<br>II.文件系统阶段<br>III.数据库阶段</p><p>A. I 和 II B. 只有 II<br>C. II 和 III D. 只有 I<br>4. 下列四项中,不属于数据库系统特点的是( C) .</p><p>A. 数据共享 B. 数据完整性 C. 数据冗余度高 D. 数据独立性高<br>5. 数据库系统的数据独立性体现在( B) .</p><p>A.不会因为数据的变化而影响到应用程序<br>B.不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序<br>C.不会因为存储策略的变化而影响存储结构<br>D.不会因为某些存储结构的变化而影响其他的存储结构<br>6. 描述数据库全体数据的全局逻辑结构和特性的是( A) .</p><p>A. 模式 B. 内模式 C. 外模式 D. 用户模式<br>7. 要保证数据库的数据独立性,需要修改的是(C ) .</p><p>A. 模式与外模式 B. 模式与内模式<br>C. 三层之间的两种映射 D. 三层模式<br>8. 要保证数据库的逻辑数据独立性,需要修改的是(A ) .</p><p>A. 模式与外模式的映射 B. 模式与内模式之间的映射<br>C. 模式 D. 三层模式<br>9. 用户或应用程序看到的那部分局部逻辑结构和特征的描述是(C),它是模式的逻辑子集.</p><p>A.模式 B. 物理模式 C. 子模式 D. 内模式<br>10. 下述(D )不是DBA数据库管理员的职责 .</p><p>A.完整性约束说明 B. 定义数据库模式<br>C.数据库安全 D. 数据库管理系统设计</p><p>选择题答案:</p><p>(1) C (2) A (3) D (4) C (5) B<br>(6) A (7) C (8) A (9) C (10) D</p><h2 id="二-简答题"><a href="#二-简答题" class="headerlink" title="二,简答题"></a>二,简答题</h2><ol><li>试述数据,数据库,数据库系统,数据库管理系统的概念.</li></ol><p><code>数据</code>:<br>描述事物的符号记录称为数据.数据的种类有文字,图形,图象,声音,正文等等.数据与其语义是不可分的.</p><p>解析:</p><p>在现代计算机系统中数据的概念是广义的.早期的计算机系统主要用于科学计算,处理的数据是整数,实数,浮点数等传统数学中的数据等.现在计算机能存储和处理的对象十分广泛,表示这些对象的 数据也越来越复杂.<br>数据与其语义是不可分的.500这个数字可以表示一件物品的价格是500元,也可以表示一个学术会议参加的人数有500人.还可以表示一袋奶粉重500克.</p><p><code>数据库</code>:<br>数据库是长期储存在计算机内,有组织的,可共享的数据集合.数据库中的数据按一定的数据模型组织,描述和储存,具有较小的冗余度,较高的数据独立性和易扩展性,并可为各种用户共享.</p><p>解析:简单地讲,数据数据库数据具有永久储存,有组织和可共享三个特点.<br>数据模型是数据库的核心概念.每个数据库中数据的都是按照某一种数据模型来组织的.</p><p><code>数据库系统</code>:<br>数据库系统(DBS)是指在计算机系统中引入数据库后的系统构成.数据库系统由数据库,数据库管理系统(及其开发工具),应用系统,数据库管理员构成.</p><p>解析:</p><p>数据库系统和数据库是两个概念.数据库系统是一个人-机系统,数据库是数据库系统的一个组成部分.但是在日常工作中人们常常把把数据库系统简称为数据库.希望读者能够从人们讲话或文章的上下文中区分”数据库系统”和”数据库”.</p><p>不要引起混淆.</p><p><code>数据库管理系统</code>:<br>数据库管理系统(DBMS)是位于用户与操作系统之间的一层数据管理软件.用于科学地组织和存储数据,高效地获取和维护数据.DBMS主要功能包括数据定义功能,数据操纵功能,数据库的运行管理功能,数据库的建立和维护功能.</p><p>解析:</p><p>DBMS是一个大型复杂的软件系统.是计算机中的基础软件.目前,专门研制DBMS的厂商及其研制的DBMS产品很多.著名的有美国IBM公司的DB2关系数据库管理系统,IMS层次数据库管理系统;美国ORACLE公司的ORACLE关系数据库管理系统;SYBASE公司的SYBASE关系数据库管理系统;美国微软公司的SQL SERVER关系数据库管理系统等等.</p><ol start="2"><li>使用数据库系统有什么好处<br>使用数据库系统的好处是由数据库管理系统的特点或优点决定的.<br>使用数据库系统的好处很多,例如可以大大提高应用开发的效率,方便用户的使用,减轻数据库系统管理人员维护的负担等.</li></ol><p>为什么有这些好处,可以结合第5题来回答.</p><p>使用数据库系统可以大大提高应用开发的效率.因为在数据库系统中应用程序不必考虑数据的定义,存储和数据存取的具体路径,这些工作都由DBMS来完成.用一个通俗的比喻,使用了DBMS就如有了一个好参谋好助手,许多具体的技术工作都由这个助手来完成.开发人员就可以专注于应用逻辑的设计而不必为管理数据的许许多多复杂的细节操心.</p><p>还有,当应用逻辑改变,数据的逻辑结构需要改变时,由于数据库系统提供了数据与程序之间的独立性.数据逻辑结构的改变是DBA的责任,开发人员不必修改应用程序,或者只需要修改很少的应用程序.从而既简化了应用程序的编制,又大大减少了应用程序的维护和修改.</p><p>使用数据库系统可以减轻数据库系统管理人员维护系统的负担.因为DBMS在数据库建立,运用和维护时对数据库进行统一的管理和控制,包括数据的完整性,安全性,多用户并发控制,故障恢复等等都由DBMS执行.</p><p>总之,使用数据库系统的优点是很多的,既便于数据的集中管理,控制数据冗余,可以提高数据的利用率和一致性,又有利于应用程序的开发和维护.读者可以在自己今后的工作中结合具体应用,认真加以体会和总结.</p><ol start="3"><li>试述文件系统与数据库系统的区别和联系.<br>文件系统与数据库系统的区别:</li></ol><p>文件系统面向某一应用程序,共享性差,冗余度大,独立性差,纪录内有结构,整体无结构,应用程序自己控制.</p><p>数据库系统面向现实世界,共享性高,冗余度小,具有高度的物理独立性和一定的逻辑独立性,整体结构化,用数据模型描述,由数据库管理系统提供数据安全性,完整性,并发控制和恢复能力.</p><p>读者可以参考《概论》书中表1.1 中的有关内容.</p><p>文件系统与数据库系统的联系是:文件系统与数据库系统都是计算机系统中管理数据的软件.<br>解析:</p><p>文件系统是操作系统的重要组成部分,而DBMS是独立于操作系统的软件.但是DBMS是在操作系统的基础上实现的.数据库中数据的组织和存储是通过操作系统中文件系统来实现的.</p><p>读者可以参考书中第十一章《数据库管理系统》.或者说,读者进一步学习数据库管理系统实现的有关课程(第十一章只是DBMS实现技术的概述)后可以对本题有深入的理解和全面的解答.因为DBMS的实现与操作系统中的文件系统是紧密相关的.例如,数据库实现的基础是文件,对数据库的任何操作最终要转化为对文件的操作.所以在DBMS实现中数据库物理组织的基本问题是如何利用或如何选择操作系统提供的基本的文件组织方法.这里我们就不具体展开了.</p><ol start="4"><li>举出适合用文件系统而不是数据库系统的例子;再举出适合用数据库系统的应用例子.<br>适用于文件系统而不是数据库系统的应用例子</li></ol><p>数据的备份,软件或应用程序使用过程中的临时数据存储一般使用文件比较合适.<br>早期功能比较简单,比较固定的应用系统也适合用文件系统.<br>适用于数据库系统而非文件系统的应用例子</p><p>目前,几乎所有企业或部门的信息系统都以数据库系统为基础,都使用数据库.如一个工厂的管理信息系统(其中会包括许多子系统,如库存管理系统,物资采购系统,作业调度系统,设备管理系统,人事管理系统等等),还比如学校的学生管理系统,人事管理系统,图书馆的图书管理系统等等都适合用数据库系统.</p><p>希望同学们能举出自己了解的应用例子.</p><ol start="5"><li>试述数据库系统的特点.</li></ol><p>数据库系统的主要特点有:</p><ul><li>一,数据结构化<br>数据库系统实现整体数据的结构化,这是数据库的主要特征之一,也是数据库系统与文件系统的本质区别.</li></ul><p>解析:</p><p>注意这里”整体”两个字.在数据库系统中,数据不再针对某一个应用,而是面向全组织,具有整体的结构化.不仅数据是结构化的,而且数据的存取单位即一次可以存取数据的大小也很灵活.可以小到某一个数据项(如一个学生的姓名),大到一组记录(成千上万个学生记录).而在文件系统中,数据的存取单位只有一个:记录.如一个学生的完整记录.</p><ul><li>二. 数据的共享性高,冗余度低,易扩充</li></ul><p>数据库的数据不再面向某个应用而是面向整个系统,因此可以被多个用户,多个应用,用多种不同的语言共享使用.由于数据面向整个系统,是有结构的数据,不仅可以被多个应用共享使用,而且容易增加新的应用,这就使得数据库系统弹性大,易于扩充.</p><p>解析:</p><p>数据共享可以大大减少数据冗余,节约存储空间,同时还能够避免数据之间的不相容性与不一致性.</p><p>所谓”数据面向某个应用”是指数据结构是针对某个应用设计的,只被这个应用程序或应用系统使用.可以说数据是某个应用的”私有资源”.</p><p>所谓”弹性大”是指系统容易扩充也容易收缩,即应用增加或减少时不必修改整个数据库的结构,或者只要做很少的修改.</p><p>我们可以取整体数据的各种子集用于不同的应用系统,当应用需求改变或增加时,只要重新选取不同的子集或加上一部分数据便可以满足新的需求.<br>三,数据独立性高</p><p>数据独立性包括数据的物理独立性和数据的逻辑独立性.</p><p>数据库管理系统的模式结构和二级映象功能保证了数据库中的数据具有很高的物理独立性和逻辑独立性.</p><p>解析:</p><p>所谓”独立性”即相互不依赖.数据独立性是指数据和程序相互不依赖.即数据的逻辑结构或物理结构改变了,程序不会跟着改变.数据与程序的独立,把数据的定义从程序中分离出去,加上数据的存取又由DBMS负责,简化了应用程序的编制,大大减少了应用程序的维护和修改.</p><p>四,数据由DBMS统一管理和控制</p><p>数据库的共享是并发的共享,即多个用户可以同时存取数据库中的数据甚至可以同时存取数据库中同一个数据.为此,DBMS必须提供统一的数据控制功能,包括数据的安全性保护,数据的完整性检查,并发控制和数据库恢复.</p><p>解析:</p><p>DBMS数据控制功能包括四个方面:</p><p>数据的安全性保护:保护数据以防止不合法的使用造成的数据的泄密和破坏;</p><p>数据的完整性检查:将数据控制在有效的范围内或保证数据之间满足一定的关系;</p><p>并发控制:对多用户的并发操作加以控制和协调,保证并发操作的正确性;</p><p>数据库恢复:当计算机系统发生硬件故障,软件故障,或者由于操作员的失误以及故意的破坏影响数据库中数据的正确性,甚至造成数据库部分或全部数据的丢失时,能将数据库从错误状态恢复到某一已知的正确状态(亦称为完整状态或一致状态).</p><p>下面我们可以得到”什么是数据库”的一个定义:</p><p>数据库是长期存储在计算机内有组织的大量的共享的数据集合.它可以供各种用户共享,具有最小冗余度和较高的数据独立性.DBMS在数据库建立,运用和维护时对数据库进行统一控制,以保证数据的完整性,安全性,并在多用户同时使用数据库时进行并发控制,在发生故障后对系统进行恢复.</p><p>数据库系统的出现使信息系统从以加工数据的程序为中心转向围绕共享的数据库为中心的新阶段.</p><ol start="6"><li>数据库管理系统的主要功能有哪些</li></ol><p>① 数据库定义功能;</p><p>② 数据存取功能;</p><p>③ 数据库运行管理;</p><p>④ 数据库的建立和维护功能.</p><ol start="7"><li>试述数据模型的概念,数据模型的作用和数据模型的三个要素.</li></ol><p>数据模型是数据库中用来对现实世界进行抽象的工具,是数据库中用于提供信息表示和操作手段的形式构架.</p><p>一般地讲,数据模型是严格定义的概念的集合.这些概念精确地描述系统的静态特性,动态特性和完整性约束条件.因此数据模型通常由数据结构,数据操作和完整性约束三部分组成.</p><p>① 数据结构:是所研究的对象类型的集合,是对系统的静态特性的描述.<br>② 数据操作:是指对数据库中各种对象(型)的实例(值)允许进行的操作的集合,包括操作及有关的操作规则,是对系统动态特性的描述.<br>③ 数据的约束条件:是完整性规则的集合,完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则,用以限定符合数据模型的数据库状态以及状态的变化,以保证数据的正确,有效,相容.</p><p>解析:</p><p>数据模型是数据库系统中最重要的概念之一.同学们必须通过《概论》的学习真正掌握</p><p>数据模型的概念和作用.</p><p>数据模型是数据库系统的基础.任何一个DBMS都以某一个数据模型为基础,或者说支持某一个数据模型.</p><p>数据库系统中模型有不同的层次.根据模型应用的不同目的,可以将模型分成两类或说两个层次:一是概念模型,是按用户的观点来对数据和信息建模,用于信息世界的建模,强调语义表达能力,概念简单清晰;另一是数据模型,是按计算机系统的观点对数据建模,用于机器世界,人们可以用它定义,操纵数据库中的数据.一般需要有严格的形式化定义和一组严格定义了语法和语义的语言,并有一些规定和限制,便于在机器上实现.</p><ol start="8"><li>试述概念模型的作用.<br>概念模型实际上是现实世界到机器世界的一个中间层次.概念模型用于信息世界的建模,是现实世界到信息世界的第一层抽象,是数据库设计人员进行数据库设计的有力工具,也是数据库设计人员和用户之间进行交流的语言.</li><li>定义并解释概念模型中以下术语:<br>实体,实体型,实体集,属性,码,实体联系图(E-R图)</li></ol><ul><li><code>实体</code>:客观存在并可以相互区分的事物叫实体.</li><li><code>实体型</code>:具有相同属性的实体具有相同的特征和性质,用实体名及其属性名集合来抽象和刻画同类实体称为实体型.</li><li><code>实体集</code>:同型实体的集合称为实体集.</li><li><code>属性</code>:实体所具有的某一特性,一个实体可由若干个属性来刻画.</li><li><code>码</code>:唯一标识实体的属性集称为码.</li><li><code>实体联系图</code>:E-R图提供了表示实体型,属性和联系的方法:</li><li><code>实体型</code>:用矩形表示,矩形框内写明实体名.</li><li><code>属性</code>:用椭圆形表示,并用无向边将其与相应的实体连接起来.</li><li><code>联系</code>:用菱形表示,菱形框内写明联系名,并用无向边分别与有关实体连接起来,同时在无向边旁标上联系的类型(1 : 1,1 : n或m : n).</li></ul><ol start="10"><li>试给出三个实际部门的E-R图,要求实体型之间具有一对一,一对多,多对多各种不同的联系.</li></ol><h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h1><h2 id="一-选择题-1"><a href="#一-选择题-1" class="headerlink" title="一.选择题"></a>一.选择题</h2><ol><li>下面的选项不是关系数据库基本特征的是(A ).</li></ol><p>A.不同的列应有不同的数据类型<br>B.不同的列应有不同的列名<br>C.与行的次序无关<br>D.与列的次序无关<br>2. 一个关系只有一个(D) .</p><p>A.候选码 B. 外码 C. 超码 D. 主码<br>3. 关系模型中,一个码是(C ).</p><p>A.可以由多个任意属性组成<br>B.至多由一个属性组成<br>C.可有多个或者一个其值能够唯一表示该关系模式中任何元组的属性组成<br>D.以上都不是<br>4. 现有如下关系:<br>患者(患者编号,患者姓名,性别,出生日起,所在单位)</p><p>医疗(患者编号,患者姓名,医生编号,医生姓名,诊断日期,诊断结果)<br>其中,医疗关系中的外码是(A ).</p><p>A. 患者编号 B. 患者姓名<br>C. 患者编号和患者姓名 D. 医生编号和患者编号<br>5. 现有一个关系:借阅(书号,书名,库存数,读者号,借期,还期),假如同一本书允许一个读者多次借阅,但不能同时对一种书借多本,则该关系模式的外码是( D).</p><p>A. 书号 B. 读者号<br>C. 书号+读者号 D. 书号+读者号+借期<br>6. 关系模型中实现实体间 N:M 联系是通过增加一个(A ) .</p><p>A.关系实现 B. 属性实现 C. 关系或一个属性实现 D. 关系和一个属性实现<br>7. 关系代数运算是以( C)为基础的运算 .</p><p>A. 关系运算 B. 谓词演算 C. 集合运算 D. 代数运算<br>8. 关系数据库管理系统应能实现的专门关系运算包括( B).</p><p>A. 排序,索引,统计 B. 选择,投影,连接<br>C. 关联,更新,排序 D. 显示,打印,制表<br>9. 五种基本关系代数运算是( A).</p><p>A.∪-×σπ<br>B.∪-σπ<br>C.∪∩×σπ<br>D.∪∩σπ<br>10. 关系代数表达式的优化策略中,首先要做的是(B ) .</p><p>A.对文件进行预处理 B.尽早执行选择运算<br>C.执行笛卡尔积运算 D.投影运算<br>11. 关系数据库中的投影操作是指从关系中(B ) .</p><p>A.抽出特定记录 B. 抽出特定字段<br>C.建立相应的影像 D. 建立相应的图形<br>12. 从一个数据库文件中取出满足某个条件的所有记录形成一个新的数据库文件的操作是(C )操作 .</p><p>A.投影 B. 联接 C. 选择 D. 复制<br>13. 关系代数中的联接操作是由(B )操作组合而成 .</p><p>A.选择和投影 B. 选择和笛卡尔积<br>C.投影,选择,笛卡尔积 D. 投影和笛卡尔积<br>14. 自然联接是构成新关系的有效方法.一般情况下,当对关系R和S是用自然联接时,要求R和S含有一个或者多个共有的(C).</p><p>A.记录 B. 行 C. 属性 D. 元组<br>15. 假设有关系R和S,在下列的关系运算中,(D )运算不要求:”R和S具有相同的元数,且它们的对应属性的数据类型也相同” .</p><p>A.R∩S B. R∪S C. R-S D. R×S<br>16. 假设有关系R和S,关系代数表达式R-(R-S)表示的是(A ).</p><p>A.R∩S B. R∪S C. R-S D. R×S<br>17. 下面列出的关系代数表达是中,那些式子能够成立( C) .<br>ⅰ. σf1 ( σf2 (E)) &#x3D; σf1∧f2 (E)<br>ⅱ. E1∞E2 &#x3D; E2∞E1<br>ⅲ. (E1∞E2)∞E3 &#x3D; E1∞ (E2∞E3)<br>ⅳ. σf1 ( σf2 (E)) &#x3D;σf2 ( σf1(E))</p><p>A.全部 B. ⅱ和ⅲ C. 没有 D. ⅰ和ⅳ<br>18. 下面四个关系表达式是等价的,是判别它们的执行效率( A) .<br>E1 &#x3D;πA (σ B&#x3D;C ∧ D&#x3D;E′ (R×S) )<br>E2 &#x3D;πA (σ B&#x3D;C (R× σD&#x3D;E′ (S) )<br>E3 &#x3D;πA (R∞B&#x3D;CσD&#x3D;E′(S) )<br>E3 &#x3D;πA (σD&#x3D;E′ (R∞B&#x3D;C S) )</p><p>A. E3最快 B. E2最快 C. E4最快 D. E1最快<br>19. 有关系SC(S_ID,C_ID,AGE,SCORE),查找年龄大于22岁的学生的学号和分数,正确的关系代数表达式是(D) .<br>ⅰ. πS_ID,SCORE (σ age&gt;22 (SC) )<br>ⅱ. σ age&gt;22 (πS_ID,SCORE (SC) )<br>ⅲ. πS_ID,SCORE (σ age&gt;22 (πS_ID,SCORE,AGE (SC) ) )</p><p>A.ⅰ和 ⅱ B. 只有ⅱ正确 C. 只有 ⅰ正确 D. ⅰ和ⅲ正确</p><p>选择题答案:<br>(1) A (2) D (3) C (4) A (5) D<br>(6) A (7) C (8) B (9) A (10) B<br>(11) B (12) C (13) B (14) C (15)D<br>(16) A (17) C (18) A (19) D</p><h2 id="二-简答题-1"><a href="#二-简答题-1" class="headerlink" title="二,简答题"></a>二,简答题</h2><ol><li>试述关系模型的三个组成部分.</li><li>试述关系数据语言的特点和分类.</li><li>设有一个SPJ数据库,包括S,P,J,SPJ四个关系模式:<br>S( SNO,SNAME,STATUS,CITY);</li></ol><p>P(PNO,PNAME,COLOR,WEIGHT);</p><p>J(JNO,JNAME,CITY);</p><p>SPJ(SNO,PNO,JNO,QTY);</p><p>供应商表S由供应商代码(SNO),供应商姓名(SNAME),供应商状态(STATUS),供应商所在城市(CITY)组成;零件表P由零件代码(PNO),零件名(PNAME),颜色(COLOR),重量(WEIGHT)组成;工程项目表J由工程项目代码(JNO),工程项目名(JNAME),工程项目所在城市(CITY)组成;供应情况表SPJ由供应商代码(SNO),零件代码(PNO),工程项目代码(JNO),供应数量(QTY)组成,表示某供应商供应某种零件给某工程项目的数量为QTY.</p><p>试用关系代数完成如下查询:</p><p>(1) 求供应工程J1零件的供应商号码SNO;</p><p>(2) 求供应工程J1零件P1的供应商号码SNO;</p><p>(3) 求供应工程J1零件为红色的供应商号码SNO;</p><p>(4) 求没有使用天津供应商生产的红色零件的工程号JNO;</p><p>(5) 求至少用了供应商S1所供应的全部零件的工程号JNO.</p><ol start="4"><li>定义并理解下列术语,说明它们之间的联系与区别:</li></ol><p>(1). 域,笛卡尔积,关系,元组,属性<br>(2). 主码,候选码,外码<br>(3). 关系模式,关系,关系数据库</p><ol start="5"><li><p>试述关系模型的完整性规则.在参照完整性中,为什么外码属性的值有时也可以为空 什么情况下才可以为空</p></li><li><p>试述等值连接与自然连接的区别和联系.</p></li><li><p>关系代数的基本运算有哪些</p></li><li><p>试用关系代数的基本运算来表示其他运算.</p></li></ol><h1 id="第三章-SQL语言"><a href="#第三章-SQL语言" class="headerlink" title="第三章 SQL语言"></a>第三章 SQL语言</h1><h2 id="一-选择题-2"><a href="#一-选择题-2" class="headerlink" title="一,选择题"></a>一,选择题</h2><ol><li>SQL语言是(B)的语言,容易学习 .</li></ol><p>A. 过程化 B. 非过程化<br>C. 格式化 D. 导航式</p><ol start="2"><li>SQL语言的数据操纵语句包括SELECT,INSERT,UPDATE,DELETE等.其中最重要的,也是使用最频繁的语句是(A) .</li></ol><p>A. SELECT B. INSERT<br>C. UPDATE D. DELETE<br>3. 在视图上不能完成的操作是( C) .</p><p>A. 更新视图 B. 查询<br>C. 在视图上定义新的表 D. 在视图上定义新的视图<br>4. SQL语言集数据查询,数据操纵,数据定义和数据控制功能于一体,其中,CREATE,DROP,ALTER语句是实现哪种功能(C ).</p><p>A. 数据查询 B. 数据操纵<br>C. 数据定义 D. 数据控制<br>5. SQL语言中,删除一个视图的命令是( B).</p><p>A.DELETE B.DROP C.CLEAR D.REMOVE<br>6. 在SQL语言中的视图VIEW是数据库的( A) .</p><p>A. 外模式 B. 模式 C. 内模式 D. 存储模式<br>7. 下列的SQL语句中,( D)不是数据定义语句.</p><p>A. CREATE TABLE B. DROP VIEW<br>C. CREATE VIEW D. GRANT<br>8. 若要撤销数据库中已经存在的表S,可用(C ).</p><p>A. DELETE TABLE S B. DELETE S<br>C. DROP TABLE S D. DROP S<br>9. 若要在基本表S中增加一列CN(课程名),可用( C).</p><p>A. ADD TABLE S(CN CHAR(8))<br>B. ADD TABLE S ALTER(CN CHAR(8))<br>C. ALTER TABLE S ADD(CN CHAR(8))<br>D. ALTER TABLE S (ADD CN CHAR(8))<br>10. 学生关系模式 S( S#,Sname,Sex,Age),S的属性分别表示学生的学号,姓名,性别,年龄.要在表S中删除一个属性”年龄”,可选用的SQL语句是(B ).</p><p>A. DELETE Age from S<br>B. ALTER TABLE S DROP Age<br>C. UPDATE S Age<br>D. ALTER TABLE S ‘Age’<br>11. 有关系S(S#,SNAME,SAGE),C(C#,CNAME),SC(S#,C#,GRADE).其中S#是学生号,SNAME是学生姓名,SAGE是学生年龄, C#是课程号,CNAME是课程名称.要查询选修”ACCESS”课的年龄不小于20的全体学生姓名的SQL语句是SELECT SNAME FROM S,C,SC WHERE子句.这里的WHERE子句的内容是(A).</p><p>A. S.S# &#x3D; SC.S# and C.C# &#x3D; SC.C# and SAGE&gt;&#x3D;20 and CNAME&#x3D;’ACCESS’<br>B. S.S# &#x3D; SC.S# and C.C# &#x3D; SC.C# and SAGE in&gt;&#x3D;20 and CNAME in ‘ACCESS’<br>C. SAGE in&gt;&#x3D;20 and CNAME in ‘ACCESS’<br>D. SAGE&gt;&#x3D;20 and CNAME&#x3D;’ ACCESS’<br>12. 设关系数据库中一个表S的结构为S(SN,CN,grade),其中SN为学生名,CN为课程名,二者均为字符型;grade为成绩,数值型,取值范围0-100.若要把”张二的化学成绩80分”插入S中,则可用( D).</p><p>A. ADD INTO S VALUES(‘张二’,’化学’,’80’)<br>B. INSERT INTO S VALUES(‘张二’,’化学’,’80’)<br>C. ADD INTO S VALUES(‘张二’,’化学’,80)<br>D. INSERT INTO S VALUES(‘张二’,’化学’,80)<br>13. 设关系数据库中一个表S的结构为:S(SN,CN,grade),其中SN为学生名,CN为课程名,二者均为字符型;grade为成绩,数值型,取值范围0-100.若要更正王二的化学成绩为85分,则可用( A) .</p><p>A. UPDATE S SET grade&#x3D;85 WHERE SN&#x3D;’王二’ AND CN&#x3D;’化学’<br>B. UPDATE S SET grade&#x3D;’85’ WHERE SN&#x3D;’王二’ AND CN&#x3D;’化学’<br>C. UPDATE grade&#x3D;85 WHERE SN&#x3D;’王二’ AND CN&#x3D;’化学’<br>D. UPDATE grade&#x3D;’85’ WHERE SN&#x3D;’王二’ AND CN&#x3D;’化学’<br>14. 在SQL语言中,子查询是(D) .</p><p>A. 返回单表中数据子集的查询语言<br>B. 选取多表中字段子集的查询语句<br>C. 选取单表中字段子集的查询语句<br>D. 嵌入到另一个查询语句之中的查询语句<br>15. SQL是一种(C )语言.</p><p>A. 高级算法 B. 人工智能<br>C. 关系数据库 D. 函数型<br>16. 有关系S(S#,SNAME,SEX),C(C#,CNAME),SC(S#,C#,GRADE).其中S#是学生号,SNAME是学生姓名,SEX是性别, C#是课程号,CNAME是课程名称.要查询选修”数据库”课的全体男生姓名的SQL语句是SELECT SNAME FROM S,C,SC WHERE子句.这里的WHERE子句的内容是( A).</p><p>A.S.S# &#x3D; SC.S# and C.C# &#x3D; SC.C# and SEX&#x3D;’男’ and CNAME&#x3D;’数据库’<br>B.S.S# &#x3D; SC.S# and C.C# &#x3D; SC.C# and SEX in’男’and CNAME in’数据库’<br>C.SEX ‘男’ and CNAME ‘ 数据库’<br>D.S.SEX&#x3D;’男’ and CNAME&#x3D;’ 数据库’</p><ol start="17"><li>若用如下的SQL语句创建了一个表SC:<br>CREATE TABLE SC (S# CHAR(6) NOT NULL,C# CHAR(3) NOT NULL,SCORE INTEGER,NOTE CHAR(20));向SC表插入如下行时,( B)行可以被插入 .</li></ol><p>A.(‘201009’,’111’,60,必修)<br>B.(‘200823’,’101’,NULL,NULL)<br>C.(NULL,’103’,80,’选修’)<br>D.(‘201132’,NULL,86,’ ‘)<br>18. 假设学生关系S(S#,SNAME,SEX),课程关系C(C#,CNAME),学生选课关系SC(S#,C#,GRADE).要查询选修”Computer”课的男生姓名,将涉及到关系( D).</p><p>A. S B. S,SC C. C,SC D. S,C,SC</p><p>选择题答案:<br>(1) B (2) A (3) C (4) C (5) B<br>(6) A (7) D (8) C (9) C (10) B<br>(11) A (12) D (13) A (14) D (15) C<br>(16) A (17) B (18) D</p><h2 id="二-简答题-2"><a href="#二-简答题-2" class="headerlink" title="二,简答题"></a>二,简答题</h2><ol><li>试述SQL语言的特点.</li></ol><p>答:</p><ol><li><p>综合统一. SQL语言集数据定义语言DDL,数据操纵语言DML,数据控制语言DCL的功能于一体.</p></li><li><p>高度非过程化.用SQL语言进行数据操作,只要提出”做什么”,而无须指明”怎么做”,因此无需了解存取路径,存取路径的选择以及SQL语句的操作过程由系统自动完成.</p></li><li><p>面向集合的操作方式.SQL语言采用集合操作方式,不仅操作对象,查找结果可以是元组的集合,而且一次插入,删除,更新操作的对象也可以是元组的集合.</p></li><li><p>以同一种语法结构提供两种使用方式.SQL语言既是自含式语言,又是嵌入式语言.作为自含式语言,它能够独立地用于联机交互的使用方式,也能够嵌入到高级语言程序中,供程序员设计程序时使用.</p></li><li><p>语言简捷,易学易用.</p></li></ol><ol start="2"><li>试述SQL的定义功能.</li></ol><p>答:</p><p>SQL的数据定义功能包括定义表,定义视图和定义索引.</p><p>SQL语言使用CREATE TABLE语句定义建立基本表,;ALTER TABLE语句修改基本表定义,DROP TABLE语句删除基本表;建立索引使用CREATE INDEX语句建立索引, DROP INDEX语句删除索引表;SQL语言使用CREATE VIEW命令建立视图,DROP VIEW语句删除视图.<br>3. 用SQL语句建立第3章习题3中的四个表.</p><p>答:</p><p>对于S表:S( SNO,SNAME,STATUS,CITY);</p><p>建S表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE S</span><br><span class="line">(SNO CHAR(3),</span><br><span class="line">SNAME CHAR(10)</span><br><span class="line">STATUS CHAR(2)</span><br><span class="line">CITY CHAR(10))</span><br></pre></td></tr></table></figure><p>P(PNO,PNAME,COLOR,WEIGHT);</p><p>建P表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> P</span><br><span class="line">(PNO <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">PNAME <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">COLOR <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">WEIGHT <span class="type">INT</span>);</span><br><span class="line">J(JNO,JNAME,CITY);</span><br></pre></td></tr></table></figure><p>建J表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> J</span><br><span class="line">(JNO <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">JNAME <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">CITY <span class="type">CHAR</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>SPJ(SNO,PNO,JNO,QTY)</p><p>建SPJ表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SPJ</span><br><span class="line">(SNO <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">PNO <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">JNO <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">QTY <span class="type">INT</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>针对上题中建立的四个表试用SQL语言完成第3章习题3中的查询.</li></ol><p>答:</p><p>(1) 求供应工程J1零件的供应商号码SNO;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> JNO<span class="operator">=</span><span class="string">&#x27;J1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(2) 求供应工程J1零件P1的供应商号码SNO;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> JNO<span class="operator">=</span><span class="string">&#x27;J1&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> PNO<span class="operator">=</span><span class="string">&#x27;P1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(3) 求供应工程J1零件为红色的供应商号码SNO;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> JNO<span class="operator">=</span><span class="string">&#x27;J1&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> PNO <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> PNO</span><br><span class="line"><span class="keyword">FROM</span> P</span><br><span class="line"><span class="keyword">WHERE</span> COLOR<span class="operator">=</span><span class="string">&#x27;红&#x27;</span>);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ,P</span><br><span class="line"><span class="keyword">WHERE</span> JNO<span class="operator">=</span><span class="string">&#x27;J1&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> SPJ.PNO<span class="operator">=</span>P.PNO</span><br><span class="line"><span class="keyword">AND</span> COLOR<span class="operator">=</span><span class="string">&#x27;红&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(4) 求没有使用天津供应商生产的红色零件的工程号JNO;<br>解析:<br>用SQL语言表示如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> J</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO<span class="operator">=</span>J.JNO</span><br><span class="line"><span class="keyword">AND</span> SNO <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> SNO</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> CITY<span class="operator">=</span><span class="string">&#x27;天津&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> PNO <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> PNO</span><br><span class="line"><span class="keyword">FROM</span> P</span><br><span class="line"><span class="keyword">WHERE</span> COLOR<span class="operator">=</span><span class="string">&#x27;红&#x27;</span>));</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> J</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span><span class="number">1</span></span><br><span class="line"><span class="keyword">FROM</span> SPJ, S, P</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO<span class="operator">=</span>J.JNO</span><br><span class="line"><span class="keyword">AND</span> SPJ.SNO<span class="operator">=</span>S.SNO</span><br><span class="line"><span class="keyword">AND</span> SPJ.PNO<span class="operator">=</span>P.PNO</span><br><span class="line"><span class="keyword">AND</span> S.CITY<span class="operator">=</span><span class="string">&#x27;天津&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> P. COLOR<span class="operator">=</span><span class="string">&#x27;红&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意:从 J 表入手,以包含那些尚未使用任何零件的工程号.</p><p>(5) 求至少用了供应商S1所供应的全部零件的工程号JNO .</p><p>解析:<br>用SQL语言表示如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ SPJZ</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SPJ SPJX</span><br><span class="line"><span class="keyword">WHERE</span> SNO<span class="operator">=</span><span class="string">&#x27;S1&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SPJ SPJY</span><br><span class="line"><span class="keyword">WHERE</span> SPJY.PNO<span class="operator">=</span>SPJX.PNO</span><br><span class="line"><span class="keyword">AND</span> SPJY.JNON<span class="operator">=</span>SPJZ.JNO</span><br><span class="line"><span class="keyword">AND</span> SPJY.SNO<span class="operator">=</span><span class="string">&#x27;S1&#x27;</span>));</span><br><span class="line"><span class="keyword">AND</span> SPJY.SNO<span class="operator">=</span><span class="string">&#x27;S1&#x27;</span> ));</span><br></pre></td></tr></table></figure><ol start="5"><li>针对习题3中的四个表试用SQL语言完成以下各项操作:</li></ol><p>(1) 找出所有供应商的姓名和所在城市.</p><p>(2) 找出所有零件的名称,颜色,重量.</p><p>(3) 找出使用供应商S1所供应零件的工程号码.</p><p>(4) 找出工程项目J2使用的各种零件的名称及其数量.</p><p>(5) 找出上海厂商供应的所有零件号码.</p><p>(6) 找出使用上海产的零件的工程名称.</p><p>(7) 找出没有使用天津产的零件的工程号码.</p><p>(8) 把全部红色零件的颜色改成蓝色.</p><p>(9) 由S5供给J4的零件P6改为由S3供应,请作必要的修改.</p><p>(10) 从供应商关系中删除S2的记录,并从供应情况关系中删除相应的记录.</p><p>(11) 请将 (S2,J6,P4,200) 插入供应情况关系.</p><p>答:</p><p>(1) 找出所有供应商的姓名和所在城市.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SNAME, CITY</span><br><span class="line"><span class="keyword">FROM</span> S;</span><br></pre></td></tr></table></figure><p>(2) 找出所有零件的名称,颜色,重量.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PNAME, COLOR, WEIGHT</span><br><span class="line"><span class="keyword">FROM</span> P</span><br></pre></td></tr></table></figure><p>(3) 找出使用供应商S1所供应零件的工程号码.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SNO<span class="operator">=</span><span class="string">&#x27;S1&#x27;</span></span><br></pre></td></tr></table></figure><p>(4) 找出工程项目J2使用的各种零件的名称及其数量.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> P.PNAME, SPJ.QTY</span><br><span class="line"><span class="keyword">FROM</span> P, SPJ</span><br><span class="line"><span class="keyword">WHERE</span> P.PNO<span class="operator">=</span>SPJ.PNO</span><br><span class="line"><span class="keyword">AND</span> SPJ.JNO<span class="operator">=</span><span class="string">&#x27;J2&#x27;</span>;</span><br></pre></td></tr></table></figure><p>(5) 找出上海厂商供应的所有零件号码.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> PNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SNO <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> SNO</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> CITY<span class="operator">=</span><span class="string">&#x27;上海&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(6) 找出使用上海产的零件的工程名称.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JNAME</span><br><span class="line"><span class="keyword">FROM</span> J, SPJ, S</span><br><span class="line"><span class="keyword">WHERE</span> J. JNO<span class="operator">=</span>SPJ. JNO</span><br><span class="line"><span class="keyword">AND</span> SPJ. SNO<span class="operator">=</span>S.SNO</span><br><span class="line"><span class="keyword">AND</span> S.CITY<span class="operator">=</span><span class="string">&#x27;上海&#x27;</span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JNAME</span><br><span class="line"><span class="keyword">FROM</span> J</span><br><span class="line"><span class="keyword">WHERE</span> JNO <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> SPJ, S</span><br><span class="line"><span class="keyword">WHERE</span> SPJ. SNO<span class="operator">=</span>S.SNO</span><br><span class="line"><span class="keyword">AND</span> S.CITY<span class="operator">=</span><span class="string">&#x27;上海&#x27;</span>);</span><br></pre></td></tr></table></figure><p>(7) 找出没有使用天津产的零件的工程号码.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> J</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO<span class="operator">=</span>J.JNO <span class="keyword">AND</span> SNO <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> SNO</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> CITY<span class="operator">=</span><span class="string">&#x27;天津&#x27;</span>))</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> J</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span><span class="number">1</span></span><br><span class="line"><span class="keyword">FROM</span> SPJ, S</span><br><span class="line"><span class="keyword">WHERE</span> SPJ.JNO<span class="operator">=</span>J.JNO <span class="keyword">AND</span> SPJ.SNO<span class="operator">=</span>S.SNO <span class="keyword">AND</span> S.CITY<span class="operator">=</span><span class="string">&#x27;天津&#x27;</span>)</span><br></pre></td></tr></table></figure><p>(8) 把全部红色零件的颜色改成蓝色.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> P</span><br><span class="line"><span class="keyword">SET</span> COLOR<span class="operator">=</span><span class="string">&#x27;蓝&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> COLOR<span class="operator">=</span><span class="string">&#x27;红&#x27;</span></span><br></pre></td></tr></table></figure><p>(9) 由S5供给J4的零件P6改为由S3供应,请作必要的修改.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> SPJ</span><br><span class="line"><span class="keyword">SET</span> SNO<span class="operator">=</span><span class="string">&#x27;S3&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> SNO<span class="operator">=</span><span class="string">&#x27;S5&#x27;</span> <span class="keyword">AND</span> JNO<span class="operator">=</span><span class="string">&#x27;J4&#x27;</span> <span class="keyword">AND</span> PNO<span class="operator">=</span><span class="string">&#x27;P6&#x27;</span></span><br></pre></td></tr></table></figure><p>(10) 从供应商关系中删除S2的记录,并从供应情况关系中删除相应的记录.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SNO<span class="operator">=</span><span class="string">&#x27;S2&#x27;</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> SNO<span class="operator">=</span><span class="string">&#x27;S2&#x27;</span></span><br></pre></td></tr></table></figure><p>解析:注意删除顺序,应该先从SPJ表中删除供应商S2所供应零件的记录,然后从从S表中删除S2.</p><p>(11) 请将 (S2,J6,P4,200) 插入供应情况关系.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SPJ(SNO, JNO, PNO, QTY)</span><br><span class="line"><span class="keyword">VALUES</span> (S2,J6,P4,<span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SPJ</span><br><span class="line"><span class="keyword">VALUES</span> (S2,P4,J6,<span class="number">200</span>);</span><br></pre></td></tr></table></figure><ol start="6"><li>什么是基本表 什么是视图 两者的区别和联系是什么</li></ol><p>答:</p><p>基本表是本身独立存在的表,在SQL中一个关系就对应一个表.</p><p>视图是从一个或几个基本表导出的表.视图本身不独立存储在数据库中,是一个虚表.即数据库中只存放视图的定义而不存放视图对应的数据,这些数据仍存放在导出视图的基本表中.视图在概念上与基本表等同,用户可以如同基本表那样使用视图,可以在视图上再定义视图.</p><ol start="7"><li>试述视图的优点.</li></ol><p>答:</p><p>(1) 视图能够简化用户的操作.</p><p>(2) 视图使用户能以多种角度看待同一数据.</p><p>(3) 视图对重构数据库提供了一定程度的逻辑独立性.</p><p>(4) 视图能够对机密数据提供安全保护.</p><ol start="8"><li>所有的视图是否都可以更新 为什么</li></ol><p>答:</p><p>不是.视图是不实际存储数据的虚表,因此对视图的更新,最终要转换为对基本表的更新.因为有些视图的更新不能唯一地有意义地转换成对相应基本表的更新,所以,并不是所有的视图都是可更新的.如《概论》3.5.1中的视图S_G(学生的学号及他的平均成绩)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREAT <span class="keyword">VIEW</span> S_G(Sno,Gavg)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno,<span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure><p>要修改平均成绩,必须修改各科成绩,而我们无法知道哪些课程成绩的变化导致了平均成绩的变化.<br>9. 哪类视图是可以更新的,哪类视图是不可更新的 各举一例说明.<br>答:</p><p>基本表的行列子集视图一般是可更新的.如《概论》3.5.3中的例1.<br>若视图的属性来自集函数,表达式,则该视图肯定是不可以更新的.</p><p>如《概论》3.5.3中的S_G视图.<br>10. 试述某个你熟悉的实际系统中对视图更新的规定.</p><p>答:(略)</p><p>解析:不同的系统对视图更新的规定是不同的,读者必须了解你所用系统对视图更新的规定.<br>11. 请为三建工程项目建立一个供应情况的视图,包括供应商代码(SNO),零件<br>代码(PNO),供应数量(QTY).针对该视图完成下列查询:</p><p>(1) 找出三建工程项目使用的各种零件代码及其数量.<br>(2) 找出供应商S1的供应情况.</p><p>答:建视图:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_SPJ <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> SNO, PNO, QTY</span><br><span class="line"><span class="keyword">FROM</span> SPJ</span><br><span class="line"><span class="keyword">WHERE</span> JNO<span class="operator">=</span></span><br><span class="line">(<span class="keyword">SELECT</span> JNO</span><br><span class="line"><span class="keyword">FROM</span> J</span><br><span class="line"><span class="keyword">WHERE</span> JNAME<span class="operator">=</span><span class="string">&#x27;三建&#x27;</span>);</span><br></pre></td></tr></table></figure><p>对该视图查询:</p><p>(1) 找出三建工程项目使用的各种零件代码及其数量.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PNO, QTY</span><br><span class="line"><span class="keyword">FROM</span> V_SPJ;</span><br></pre></td></tr></table></figure><p>(2) 找出供应商S1的供应情况.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PNO, QTY <span class="comment">/* S1供应三建工程的零件号和对应的数量*/</span></span><br><span class="line"><span class="keyword">FROM</span> V_SPJ</span><br><span class="line"><span class="keyword">WHERE</span> SNO<span class="operator">=</span><span class="string">&#x27;S1&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="第四章-关系系统及其优化"><a href="#第四章-关系系统及其优化" class="headerlink" title="第四章 关系系统及其优化"></a>第四章 关系系统及其优化</h1><h2 id="一-选择题-3"><a href="#一-选择题-3" class="headerlink" title="一,选择题"></a>一,选择题</h2><ol><li>概念模型是现实世界的第一层抽象,这一类最著名的模型是(D) .</li></ol><p>A.层次模型 B. 关系模型 C. 网状模型 D. 实体-关系模型<br>2. 区分不同实体的依据是( B) .</p><p>A. 名称 B. 属性 C. 对象 D. 概念<br>3. 关系数据模型是目前最重要的一种数据模型,它的三个要素分别为(B).</p><p>A.实体完整,参照完整,用户自定义完整<br>B.数据结构,关系操作,完整性约束<br>C.数据增加,数据修改,数据查询<br>D.外模式,模式,内模式<br>4. 在(A )中一个结点可以有多个双亲,节点之间可以有多种联系.</p><p>A.网状模型 B. 关系模型<br>C.层次模型 D. 以上都有<br>5. (B )的存取路径对用户透明,从而具有更高的数据独立性,更好的安全保密性,<br>也简化了程序员的工作和数据库开发建立的工作.</p><p>A.网状模型 B. 关系模型<br>D.层次模型 D. 以上都有<br>6. 在关系数据库中,要求基本关系中所有的主属性上不能有空值,其遵守的约束规则是( C) .</p><p>A.数据依赖完整性规则 B. 用户定义完整性规则<br>C.实体完整性规则 D. 域完整性规则</p><p>选择题答案:<br>(1) D (2) B (3) B (4) A (5) B (6) C</p><h2 id="二-简答题-3"><a href="#二-简答题-3" class="headerlink" title="二,简答题"></a>二,简答题</h2><ol><li>试述关系模型的三个组成部分.</li></ol><p>答:关系模型由关系数据结构,关系操作集合和关系完整性约束三部分组成.</p><ol start="2"><li>试述关系数据语言的特点和分类.</li></ol><p>答:关系数据语言可以分为三类:</p><p>关系代数语言 例如ISBL</p><p>关系演算语言 (元组关系演算语言 例如APLHA,QUEL 和 域关系演算语言 例如QBE)</p><p>具有关系代数和关系演算双重特点的语言 例如SQL</p><p>这些关系数据语言的共同特点是,具有完备的表达能力,是非过程化的集合操作语言,功能强,能够嵌入高级语言中使用.</p><ol start="3"><li>定义并理解下列术语,说明它们之间的联系与区别:</li></ol><p>(1) 域,关系,元组,属性</p><p>答:</p><p>域:域是一组具有相同数据类型的值的集合.</p><p>关系:在域D1,D2,…,Dn上笛卡尔积D1×D2×…×Dn的子集称为关系,表示为R(D1,D2,…,Dn)</p><p>元组:关系中的每个元素是关系中的元组.</p><p>属性:关系也是一个二维表,表的每行对应一个元组,表的每列对应一个域.由于域可以相同,为了加以区分,必须对每列起一个名字,称为属性(Attribute).</p><p>(2) 主码,候选码,外部码</p><p>答:</p><p><code>候选码</code>:若关系中的某一属性组的值能唯一地标识一个元组,则称该属性组为候选码(Candidate key).</p><p><code>主码</code>:若一个关系有多个候选码,则选定其中一个为主码(Primary key).<br><code>外部码</code>:设F是基本关系R的一个或一组属性,但不是关系R的码,如果F与基本关系S的主码Ks相对应,则称F是基本关系R的外部码(Foreign key),简称外码.</p><p>基本关系R称为参照关系(Referencing relation),基本关系S称为被参照关系(Referenced relation)或目标关系(Target relation).关系R和S可以是相同的关系.</p><p>(3) 关系模式,关系,关系数据库</p><p>关系模式:关系的描述称为关系模式(Relation Schema).它可以形式化地表示为:R(U,D,dom,F)</p><p>其中R为关系名,U为组成该关系的属性名集合,D为属性组U中属性所来自的域,dom为属性向域的映象集合,F为属性间数据的依赖关系集合.</p><p>关系:在域D1,D2,…,Dn上笛卡尔积D1×D2×…×Dn的子集称为关系,表示为R(D1,D2,…,Dn)</p><p>关系是关系模式在某一时刻的状态或内容.关系模式是静态的,稳定的,而关系是动态的,随时间不断变化的,因为关系操作在不断地更新着数据库中的数据.</p><p><code>关系数据库</code>:关系数据库也有型和值之分.关系数据库的型也称为关系数据库模式,是对关系数据库的描述,它包括若干域的定义以及在这些域上定义的若干关系模式.关系数据库的值是这些关系模式在某一时刻对应的关系的集合,通常就称为关系数据库.</p><ol start="4"><li>试述关系模型的完整性规则.在参照完整性中,为什么外部码属性的值也可以为空 什么情况下才可以为空</li></ol><p>答:</p><p>关系模型的完整性规则是对关系的某种约束条件.关系模型中可以有三类完整性约束:实体完整性,参照完整性和用户定义的完整性.<br>其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件,被称作是关系的两个不变性,应该由关系系统自动支持.</p><p>(1) 实体完整性规则:若属性A是基本关系R的主属性,则属性A不能取空值.</p><p>(2) 参照完整性规则:若属性(或属性组)F是基本关系R的外码,它与基本关系S的主码Ks相对应(基本关系R和S不一定是不同的关系),则对于R中每个元组在F上的值必须为:</p><ul><li>或者取空值(F的每个属性值均为空值);</li><li>或者等于S中某个元组的主码值.</li></ul><p>(3) 用户定义的完整性是针对某一具体关系数据库的约束条件.它反映某一具体应用所涉及的数据必须满足的语义要求.</p><p>在参照完整性中,外部码属性的值可以为空,它表示该属性的值尚未确定.但前提条件是该外部码属性不是其所在关系的主属性.</p><p>例如,在下面的”学生”表中,”专业号”是一个外部码,不是学生表的主属性,可以为空.其语义是,该学生的专业尚未确定.</p><p>学生(学号,姓名,性别,专业号,年龄)<br>专业(专业号,专业名)</p><p>而在下面的”选修”表中的”课程号”虽然也是一个外部码属性,但它又是”选修”表的主属性,所以不能为空.因为关系模型必须满足实体完整性.</p><p>课程(课程号,课程名,学分)<br>选修(学号,课程号,成绩)</p><ol start="5"><li>等值连接与自然连接的区别是什么</li></ol><p>答:</p><p>连接运算中有两种最为重要也最为常用的连接,一种是等值连接(equi-join),另一种是自然连接(Natural join).θ为”&#x3D;”的连接运算称为等值连接.<br>它是从关系R与S的笛卡尔积中选取A,B属性值相等的那些元组.即等值连接为:RA&#x3D;BS&#x3D;{ tr ts| tr∈R ∧ ts∈S ∧ tr[A] &#x3D; ts[B] }</p><p>自然连接(Natural join)是一种特殊的等值连接,它要求两个关系中进行比较的分量必须是相同的属性组,并且要在结果中把重复的属性去掉.即若R和S具有相同的属性组B,则自然连接可记作:RS&#x3D;{ tr ts| tr∈R ∧ ts∈S ∧ tr[B] &#x3D; ts[B] }</p><h2 id="第五章-关系数据理论"><a href="#第五章-关系数据理论" class="headerlink" title="第五章 关系数据理论"></a>第五章 关系数据理论</h2><h2 id="一-选择题-4"><a href="#一-选择题-4" class="headerlink" title="一,选择题"></a>一,选择题</h2><ol><li>为了设计出性能较优的关系模式,必须进行规范化,规范化主要的理论依据是(A ) .</li></ol><p>A. 关系规范化理论 B. 关系代数理论<br>C.数理逻辑 D. 关系运算理论<br>2. 规范化理论是关系数据库进行逻辑设计的理论依据,根据这个理论,关系数据库中的关系必须满足:每一个属性都是(B ) .</p><p>A. 长度不变的 B. 不可分解的<br>C.互相关联的 D. 互不相关的<br>3. 已知关系模式R(A,B,C,D,E)及其上的函数相关性集合F&#x3D;{A→D,B→C ,E→A },该关系模式的候选关键字是( B) .</p><p>A. AB B. BE<br>C. CD D. DE<br>4. 设学生关系S(SNO,SNAME,SSEX,SAGE,SDPART)的主键为SNO,学生选课关系SC(SNO,CNO,SCORE)的主键为SNO和CNO,则关系R(SNO,CNO,SSEX,SAGE,SDPART,SCORE)的主键为SNO和CNO,其满足( A).</p><p>A. 1NF B.2NF C. 3NF D. BCNF<br>5. 设有关系模式W(C,P,S,G,T,R),其中各属性的含义是:C表示课程,P表示教师,S表示学生,G表示成绩,T表示时间,R表示教室,根据语义有如下数据依赖集:D&#x3D;{ C→P,(S,C)→G,(T,R)→C,(T,P)→R,(T,S)→R },关系模式W的一个关键字是( D) .</p><p>A. (S,C) B. (T,R) C. (T,P) D. (T,S)<br>6. 关系模式中,满足2NF的模式(B) .</p><p>A. 可能是1NF B. 必定是1NF<br>C. 必定是3NF D. 必定是BCNF<br>7. 关系模式R中的属性全是主属性,则R的最高范式必定是(C ) .</p><p>A. 1NF B. 2NF C. 3NF D. BCNF<br>8. 消除了部分函数依赖的1NF的关系模式,必定是(B ) .</p><p>A. 1NF B. 2NF C. 3NF D. BCNF<br>9. 如果A-&gt;B ,那么属性A和属性B的联系是( B) .</p><p>A. 一对多 B. 多对一 C.多对多 D. 以上都不是<br>10. 关系模式的候选关键字可以有1个或多个,而主关键字有( C) .</p><p>A. 多个 B. 0个 C. 1个 D. 1个或多个</p><ol start="11"><li>候选关键字的属性可以有( D) .</li></ol><p>A. 多个 B. 0个 C. 1个 D. 1个或多个<br>12. 关系模式的任何属性( A) .</p><p>A. 不可再分 B. 可以再分<br>C. 命名在关系模式上可以不唯一 D. 以上都不是<br>13. 设有关系模式W(C,P,S,G,T,R),其中各属性的含义是:C表示课程,P表示教师,S表示学生,G表示成绩,T表示时间,R表示教室,根据语义有如下数据依赖集:D&#x3D;{ C→P,(S,C)→G,(T,R)→C,(T,P)→R,(T,S)→R },若将关系模式W分解为三个关系模式W1(C,P),W2(S,C,G),W2(S,T,R,C),则W1的规范化程序最高达到( D) .</p><p>A. 1NF B.2NF C. 3NF D. BCNF<br>14. 在关系数据库中,任何二元关系模式的最高范式必定是(D ) .</p><p>A. 1NF B.2NF C. 3NF D. BCNF<br>15. 在关系规范式中,分解关系的基本原则是(B ).<br>I.实现无损连接<br>II.分解后的关系相互独立<br>III.保持原有的依赖关系</p><p>A. Ⅰ和Ⅱ B. Ⅰ和Ⅲ C. Ⅰ D. Ⅱ<br>16. 不能使一个关系从第一范式转化为第二范式的条件是( B).</p><p>A.每一个非属性都完全函数依赖主属性<br>B.每一个非属性都部分函数依赖主属性<br>C.在一个关系中没有非属性存在<br>D.主键由一个属性构成<br>17. 任何一个满足2NF但不满足3NF的关系模式都不存在(D ).</p><p>A.主属性对键的部分依赖<br>B.非主属性对键的部分依赖<br>C.主属性对键的传递依赖<br>D.非主属性对键的传递依赖<br>18. 设数据库关系模式R&#x3D;(A,B,C,D,E),有下列函数依赖:A→BC,D→E,C→D;下述对R的分解中,哪些分解是R的无损连接分解( B) .<br>I.(A,B,C)(C,D,E)<br>II.(A,B)(A,C,D,E)<br>III.(A,C)(B,C,D,E)<br>IV.(A,B)(C,D,E)</p><p>A.只有Ⅳ B. Ⅰ和Ⅱ C. Ⅰ,Ⅱ和Ⅲ D. 都不是<br>19. 设U是所有属性的集合,X,Y,Z都是U的子集,且Z&#x3D;U-X-Y.下面关于多值依赖的叙述中,不正确的是( C).</p><p>A.若X→→Y,则X→→Z B.若X→Y,则X→→Y<br>C.若X→→Y,且Y′∈Y,则X→→Y′ D.若Z&#x3D;∮,则X→→Y<br>20. 若关系模式R(U,F)属于3NF,则(C ).</p><p>A. 一定属于BCNF<br>B. 消除了插入的删除异常<br>C. 仍存在一定的插入和删除异常<br>D. 属于BCNF且消除了插入和删除异常<br>21. 下列说法不正确的是(C ).</p><p>A. 任何一个包含两个属性的关系模式一定满足3NF<br>B. 任何一个包含两个属性的关系模式一定满足BCNF<br>C. 任何一个包含三个属性的关系模式一定满足3NF<br>D. 任何一个关系模式都一定有码<br>22. 设关系模式R(A,B,C),F是R上成立的FD集,F&#x3D;{B→C},则分解P&#x3D;{AB,BC}相对于F( A).</p><p>A. 是无损联接,也是保持FD的分解<br>B. 是无损联接,也不保持FD的分解<br>C. 不是无损联接,但保持FD的分解<br>D. 既不是无损联接,也不保持FD的分解<br>23. 关系数据库规范化是为了解决关系数据库中( A)的问题而引入的.</p><p>A. 插入,删除和数据冗余<br>B. 提高查询速度<br>C. 减少数据操作的复杂性<br>D. 保证数据的安全性和完整性<br>24. 关系的规范化中,各个范式之间的关系是( A) .</p><p>A. 1NF∈2NF∈3NF<br>B. 3NF∈2NF∈1NF<br>C. 1NF&#x3D;2NF&#x3D;3NF<br>D. 1NF∈2NF∈BCNF∈3NF<br>25. 数据库中的冗余数据是指可(D)的数据 .</p><p>A. 容易产生错误 B. 容易产生冲突<br>C. 无关紧要 D. 由基本数据导出<br>26. 学生表(id,name,sex,age,depart_id,depart_name),存在函数依赖是id→name,sex,age,depart_id;dept_id→dept_name,其满足( B).</p><p>A. 1NF B. 2NF C. 3NF D. BCNF<br>27. 设有关系模式R(S,D,M),其函数依赖集:F&#x3D;{S→D,D→M},则关系模式R的规范化程度最高达到(B ).</p><p>A. 1NF B. 2NF C. 3NF D. BCNF<br>28. 设有关系模式R(A,B,C,D),其数据依赖集:F&#x3D;{(A,B)→C,C→D},则关系模式R的规范化程度最高达到( B).</p><p>A. 1NF B. 2NF C. 3NF D. BCNF<br>29. 下列关于函数依赖的叙述中,哪一条是不正确的(B ).</p><p>A.由X→Y,Y→Z,则X→YZ B.由X→YZ,则X→Y, Y→Z<br>C.由X→Y,WY→Z,则XW→Z D.由X→Y,Z∈Y,则X→Z<br>30. X→Y,当下列哪一条成立时,称为平凡的函数依赖(B ).</p><p>A. X∈Y B. Y∈X C. X∩Y&#x3D;∮ D. X∩Y≠∮<br>31. 关系数据库的规范化理论指出:关系数据库中的关系应该满足一定的要求,最起码的要求是达到1NF,即满足( D).</p><p>A.每个非主键属性都完全依赖于主键属性<br>B.主键属性唯一标识关系中的元组<br>C.关系中的元组不可重复<br>D.每个属性都是不可分解的<br>32. 根据关系数据库规范化理论,关系数据库中的关系要满足第一范式,部门(部门号,部门名,部门成员,部门总经理)关系中,因哪个属性而使它不满足第一范式(B).</p><p>A. 部门总经理 B. 部门成员 C. 部门名 D. 部门号<br>33. 有关系模式A(C,T,H,R,S),其中各属性的含义是:</p><p>C:课程 T:教员 H:上课时间 R:教室 S:学生<br>根据语义有如下函数依赖集:</p><p>F&#x3D;{C→T,(H,R)→C,(H,T)RC,(H,S)→R}</p><p>(1) 关系模式A的码是(B ).</p><p>A. C B.(H,S) C.(H,R) D.(H,T)</p><p>(2) 关系模式A的规范化程度最高达到( B).</p><p>A. 1NF B. 2NF C. 3NF D. BCNF</p><p>(3) 现将关系模式A分解为两个关系模式A1(C,T),A2(H,R,S),则其中A1的规范化程度达到(D ).</p><p>A. 1NF B. 2NF C. 3NF D. BCNF</p><p>选择题答案:<br>(1) A (2) B (3) B (4) A (5) D<br>(6) B (7) C (8) B (9) B (10) C<br>(11) D (12) A (13) D (14) D (15) B<br>(16) B (17) D (18) B (19) C (20) C<br>(21) C (22) A (23) A (24) A (25) D<br>(26) B (27) B (28) B (29) B (30) B<br>(31) D (32) B (33) B B D</p><h1 id="二-简答题-4"><a href="#二-简答题-4" class="headerlink" title="二,简答题"></a>二,简答题</h1><ol><li>理解并给出下列术语的定义:</li></ol><p>函数依赖,部分函数依赖,完全函数依赖,候选码,主码, 外码,全码.</p><p>解析:</p><p>解答本题不能仅仅把《概论》上的定义写下来.关键是真正理解和运用这些概念.</p><p>答:</p><p><code>函数依赖</code>:设R (U)是一个关系模式,U是R的属性集合,X和Y是U的子集.对于R (U)的任意一个可能的关系r,如果r中不存在两个元组,它们在X上的属性值相同, 而在Y上的属性值不同, 则称”X函数确定Y”或”Y函数依赖于X”,记作X→Y.</p><p>解析:</p><ol><li><p>函数依赖是最基本的一种数据依赖,也是最重要的一种数据依赖.</p></li><li><p>函数依赖是属性之间的一种联系,体现在属性值是否相等.由上面的定义可以知道,如果X→Y,则r中任意两个元组,若它们在X上的属性值相同,那么在Y上的属性值一定也相同.</p></li><li><p>我们要从属性间实际存在的语义来确定他们之间的函数依赖,即函数依赖反映了(描述了)现实世界的一种语义.</p></li><li><p>函数依赖不是指关系模式R的在某个时刻的关系(值)满足的约束条件,而是指R任何时刻的一切关系均要满足的约束条件.</p></li></ol><p>答:</p><p>完全函数依赖,部分函数依赖:在R(U)中,如果X→Y,并且对于X的任何一个真子集X,都有X′→Y,则称Y对X完全函数依赖;若X→Y,但Y不完全函数依赖于X,则称Y对X部分函数依赖;</p><p><code>候选码</code>,<code>主码</code>: 设K为R(U,F)中的属性或属性组合,若K → U则K为R的候选码.若候选码多于一个,则选定其中的一个为主码.<br>答:</p><p><code>外码</code>:关系模式R中属性或属性组X并非R的码,但X是另一个关系模式的码,则称X是R的外部码也称外码.</p><p><code>全码</code>:整个属性组是码,称为全码(All-key).</p><ol start="2"><li>建立一个关于系,学生,班级,学会等诸信息的关系数据库.</li></ol><p>描述学生的属性有:学号,姓名,出生年月,系名,班号,宿舍区.</p><p>描述班级的属性有:班号,专业名,系名,人数,入校年份.</p><p>描述系的属性有:系名,系号,系办公室地点,人数.</p><p>描述学会的属性有:学会名,成立年份,地点,人数.</p><p>有关语义如下:一个系有若干专业,每个专业每年只招一个班,每个班有若干学生.一个系的学生住在同一宿舍区.每个学生可参加若干学会,每个学会有若干学生.学生参加某学会有一个入会年份.</p><p>请给出关系模式,写出每个关系模式的极小函数依赖集,指出是否存在传递函数依赖,对于函数依赖左部是多属性的情况讨论函数依赖是完全函数依赖,还是部分函数依赖.</p><p>指出各关系的候选码,外部码,有没有全码存在</p><p>答:</p><p>关系模式: 学生S(S#,SN,SB,DN,C#,SA)</p><p>班级C(C#,CS,DN,CNUM,CDATE)</p><p>系 D(D#,DN,DA,DNUM)</p><p>学会P(PN,DATE1,PA,PNUM)</p><p>学生–学会SP(S#,PN,DATE2)</p><p>其中,S#—学号,SN—姓名,SB—出生年月,SA—宿舍区</p><p>C#—班号,CS—专业名,CNUM—班级人数,CDATE—入校年份</p><p>D#—系号,DN—系名,DA—系办公室地点,DNUM—系人数</p><p>PN—学会名,DATE1—成立年月,PA—地点,PNUM—学会人数,DATE2—入会年份</p><p>每个关系模式的极小函数依赖集:</p><p>S:S#→SN,S#→SB,S#→C#,C#→DN,DN→SA</p><p>C:C#→CS,C#→CNUM,C#→CDATE,CS→DN,(CS,CDATE)→C#</p><p>D:D#→DN,DN→D#,D#→DA,D#→DNUM</p><p>P:PN→DATE1,PN→PA,PN→PNUM</p><p>SP:(S#,PN)→DATE2</p><p>S中存在传递函数依赖: S#→DN, S#→SA, C#→SA</p><p>C中存在传递函数依赖:C#→DN</p><p>(S#,PN)→DATE2 和(CS,CDATE)→C# 均为SP中的函数依赖,是完全函数依赖</p><p>关系 候选码 外部码 全码</p><p>S S# C#,DN 无</p><p>C C#,(CS,CDATE) DN 无</p><p>D D#和DN 无 无</p><p>P PN 无 无</p><p>SP (S#,PN) S#,PN 无</p><ol start="3"><li>试由Armostrong公理系统推导出下面三条推理规则:</li></ol><p>(1) 合并规则:若X→Z,X→Y,则有X→YZ</p><p>(2) 伪传递规则:由X→Y,WY→Z有XW→Z</p><p>(3) 分解规则:X→Y,Z 包含于 Y,有X→Z</p><p>证:</p><p>(1) 已知X→Z,由增广律知XY→YZ,又因为X→Y,可得XX→XY→YZ,最后根据传递律得X→YZ.<br>(2) 已知X→Y,据增广律得XW→WY,因为WY→Z,所以XW→WY→Z,通过传递律可知XW→Z.<br>(3) 已知Z 包含于 Y,根据自反律知Y→Z,又因为X→Y,所以由传递律可得X→Z.</p><ol start="4"><li>试举出三个多值依赖的实例.<br>答:</li></ol><p>(1) 关系模式MSC(M,S,C)中,M表示专业,S表示学生,C表示该专业的必修课.假设每个专业有多个学生,有一组必修课.设同专业内所有学生的选修的必修课相同,实例关系如下.按照语义对于M的每一个值M i,S有一个完整的集合与之对应而不问C取何值,所以M→→S.由于C与S的完全对称性,必然有M→→C成立.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">M S C</span><br><span class="line">M 1 S1 C1</span><br><span class="line">M 1 S1 C2</span><br><span class="line">M 1 S2 C1</span><br><span class="line">M 1 S2 C2</span><br><span class="line">…… …… ……</span><br></pre></td></tr></table></figure><p>(2) 关系模式ISA(I,S,A)中,I表示学生兴趣小组,S表示学生,A表示某兴趣小组的活动项目.假设每个兴趣小组有多个学生,有若干活动项目.每个学生必须参加所在兴趣小组的所有活动项目,每个活动项目要求该兴趣小组的所有学生参加.<br>按照语义有I→→S,I→→A成立.</p><p>(3) 关系模式RDP(R,D,P)中,R表示医院的病房,D表示责任医务人员,P表示病人.假设每个病房住有多个病人,有多个责任医务人员负责医治和护理该病房的所有病人.按照语义有R→→D,R→→P成立.</p><ol start="5"><li>下面的结论哪些是正确的,哪些是错误的 对于错误的结论请给出理由或给出一个反例说明之.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1) 任何一个二目关系都是属于3NF的.√</span><br><span class="line">(2) 任何一个二目关系都是属于BCNF的.√</span><br><span class="line">(3) 任何一个二目关系都是属于4NF的.√</span><br><span class="line">(5) 若R.A→R.B,R.B→R.C,则R.A→R.C √</span><br><span class="line">(6) 若R.A→R.B,R.A→R.C,则R.A→R.(B, C) √</span><br><span class="line">(7) 若R.B→R.A,R.C→R.A,则R.(B, C)→R.A √</span><br><span class="line">(8) 若R.(B, C)→R.A,则R.B→R.A,R.C→R.A ×</span><br><span class="line">反例:关系模式 SC(S#,C#,G) (S#,C#)→G,但是S# → G,C#→G</span><br></pre></td></tr></table></figure></li></ol><h1 id="第六章-数据库设计"><a href="#第六章-数据库设计" class="headerlink" title="第六章 数据库设计"></a>第六章 数据库设计</h1><h2 id="一-选择题-5"><a href="#一-选择题-5" class="headerlink" title="一,选择题"></a>一,选择题</h2><ol><li>数据流程图是用于描述结构化方法中(D )阶段的工具.</li></ol><p>A. 概要设计 B. 可行性分析<br>C. 程序编码 D. 需求分析<br>2. 数据库设计中,用E-R图赖描述信息结构但不涉及信息在计算机中的表示,这是数据库设计的( C).</p><p>A. 需求分析阶段 B. 逻辑设计阶段<br>C. 概念设计阶段 D. 物理设计阶段<br>3. 在数据库设计中,将E-R图转换成关系数据模型的过程属于(B ).</p><p>A. 需求分析阶段 B. 逻辑设计阶段<br>C. 概念设计阶段 D. 物理设计阶段<br>4. 子模式DDL是用来描述( B).</p><p>A. 数据库的总体逻辑结构 B. 数据库的局部逻辑结构<br>C. 数据库的物理存储结构 D. 数据库的概念结构<br>5. 数据库设计的概念设计阶段,表示概念结构的常用方法和描述工具是(C).</p><p>A.层次分析法和层次结构图<br>B.数据流程分析法和数据流程图<br>C.实体联系法和实体联系图<br>D.结构分析法和模块结构图<br>6. 在E-R模型向关系模型转换时,M:N的联系转换为关系模式时,其关键字是(C ).</p><p>A.M端实体的关键字<br>B.N端实体的关键字<br>C.M,N端实体的关键字组合<br>D.重新选取其他属性<br>7. 某学校规定,每一个班级最多有50名学生,至少有10名学生;每一名学生必须属于一个班级.在班级与学生实体的联系中,学生实体的基数是( B) .</p><p>A. (0,1) B. (1,1)<br>C. (1,10) D. (10,50)<br>8. 在关系数据库设计中,设计关系模式是数据库设计中(A )阶段的任.</p><p>A. 逻辑设计阶段 B. 概念设计阶段<br>C. 物理设计阶段 D. 需求分析阶段<br>9. 关系数据库的规范化理论主要解决的问题是(A ).</p><p>A.如何构造合适的数据逻辑结构<br>B.如何构造合适的数据物理结构<br>C.如何构造合适的应用程序界面<br>D.如何控制不同用户的数据操作权限<br>10. 数据库设计可划分为七个阶段,每个阶段都有自己的设计内容,”为哪些关系,在哪些属性上,键什么样的索引”这一设计内容应该属于( C)设计阶段.</p><p>A. 概念设计 B. 逻辑设计<br>C. 物理设计 D. 全局设计<br>11. 假设设计数据库性能用”开销”,即时间,空间及可能的费用来衡量,则在数据库应用系统生存期中存在很多开销.其中,对物理设计者来说,主要考虑的是( C).</p><p>A. 规划开销 B. 设计开销<br>C. 操作开销 D. 维护开销<br>12. 数据库物理设计完成后,进入数据库实施阶段,下述工作中,(D )一般不属于实施阶段的工作.</p><p>A. 建立库结构 B. 系统调试<br>C. 加载数据 D. 扩充功能<br>13. 从ER图导出关系模型时,如果实体间的联系是M:N的,下列说法中正确的是(C ).</p><p>A.将N方关键字和联系的属性纳入M方的属性中<br>B.将M方关键字和联系的属性纳入N方的属性中<br>C.增加一个关系表示联系,其中纳入M方和N方的关键字<br>D.在M方属性和N方属性中均增加一个表示级别的属性<br>14. 在ER模型中,如果有3个不同的实体集,3个M:N联系,根据ER模型转换为关系模型的规则,转换为关系的数目是(C ).</p><p>A. 4 B. 5 C. 6 D. 7</p><p>选择题答案:<br>(1) D (2) C (3) B (4) B (5) C<br>(6) C (7) B (8) A (9) A (10) C</p><p>(11) C (12) D (13) C (14) C</p><h2 id="二-简答题-5"><a href="#二-简答题-5" class="headerlink" title="二,简答题"></a>二,简答题</h2><ol><li>试述数据库设计过程.</li></ol><p>解析</p><p>希望同学能够认真阅读《概论》的内容,了解并掌握数据库设计过程.这里只概要列出数据库设计过程的六个阶段:</p><ol><li><p>需求分析</p></li><li><p>概念结构设计</p></li><li><p>逻辑结构设计</p></li><li><p>数据库物理设计</p></li><li><p>数据库实施</p></li><li><p>数据库运行和维护</p></li></ol><p>这是一个完整的实际数据库及其应用系统的设计过程.不仅包括设计数据库本身,还包括数据库的实施,数据库运行和维护.<br>设计一个完善的数据库应用系统往往是上述六个阶段的不断反复.</p><ol start="2"><li>试述数据库设计过程的各个阶段上的设计描述.</li></ol><p>解析:这是进一步了解数据库设计的具体内容.设计描述是指在各个阶段体现设计内容,描述设计结果的各种文档,程序.</p><p>答:</p><p>各阶段的设计要点如下:</p><ol><li><p>需求分析:准确了解与分析用户需求(包括数据与处理).</p></li><li><p>概念结构设计:通过对用户需求进行综合,归纳与抽象,形成一个独立于具体DBMS的概念模型.</p></li><li><p>逻辑结构设计:将概念结构转换为某个DBMS所支持的数据模型,并对其进行优化.</p></li><li><p>数据库物理设计:为逻辑数据模型选取一个最适合应用环境的物理结构(包括存储结构和存取方法).</p></li><li><p>数据库实施:设计人员运用DBMS提供的数据语言,工具及宿主语言,根据逻辑设计和物理设计的结果建立数据库,编制与调试应用程序,组织数据入库,并进行试运行.</p></li><li><p>数据库运行和维护:在数据库系统运行过程中对其进行评价,调整与修改.</p></li></ol><ol start="3"><li>试述数据库设计过程中结构设计部分形成的数据库模式.</li></ol><p>答:</p><p>数据库结构设计的不同阶段形成数据库的各级模式,即:</p><p>在概念设计阶段形成独立于机器特点,独立于各个DBMS产品的概念模式,在本篇中就是E-R图;</p><p>在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型,如关系模型,形成数据库逻辑模式;然后在基本表的基础上再建立必要的视图(View),形成数据的外模式;</p><p>在物理设计阶段,根据DBMS特点和处理的需要,进行物理存储安排,建立索引,形成数据库内模式.</p><p>概念模式是面向用户和设计人员的,属于概念模型的层次;逻辑模式,外模式,内模式是DBMS支持的模式,属于数据模型的层次.可以在DBMS中加以描述和存储.</p><ol start="4"><li>试述数据库设计的特点.</li></ol><p>答:<br>数据库设计既是一项涉及多学科的综合性技术又是一项庞大的工程项目</p><p>其主要特点有:</p><ol><li><p>数据库建设是硬件,软件和干件(技术与管理的界面)的结合.</p></li><li><p>从软件设计的技术角度看,数据库设计应该和应用系统设计相结合,也就是说,整个设计过程中要把结构(数据)设计和行为(处理)设计密切结合起来.</p></li></ol><ol start="5"><li>需求分析阶段的设计目标是什么 调查的内容是什么</li></ol><p>答:</p><p>需求分析阶段的设计目标是通过详细调查现实世界要处理的对象(组织,部门,企业等),充分了解原系统(手工系统或计算机系统)工作概况,明确用户的各种需求,然后在此基础上确定新系统的功能.</p><p>调查的内容是”数据”和”处理”,即获得用户对数据库的如下要求:</p><p>(1) 信息要求.指用户需要从数据库中获得信息的内容与性质.由信息要求可以导出数据要求,即在数据库中需要存储哪些数据.</p><p>(2) 处理要求.指用户要完成什么处理功能,对处理的响应时间有什么要求,处理方式是批处理还是联机处理.</p><p>(3) 安全性与完整性要求.</p><ol start="6"><li>数据字典的内容和作用是什么</li></ol><p>答:</p><p>数据字典是系统中各类数据描述的集合.数据字典的内容通常包括:数据项,数据结构,数据流,数据存储,处理过程五个部分</p><p>其中数据项是数据的最小组成单位,若干个数据项可以组成一个数据结构.数据字典通过对数据项和数据结构的定义来描述数据流,数据存储的逻辑内容.</p><p>数据字典的作用:</p><p>数据字典是关于数据库中数据的描述,在需求分析阶段建立,是下一步进行概念设计的基础,并在数据库设计过程中不断修改,充实,完善.</p><p>(注意,数据库设计阶段形成的数据字典与后面讲到的数据字典不同,后者是DBMS关于数据库中数据的描述,当然两者是有联系的).</p><ol start="7"><li>什么是数据库的概念结构 试述其特点和设计策略.</li></ol><p>答:概念结构是信息世界的结构,即概念模型,其主要特点是:</p><p>(1) 能真实,充分地反映现实世界,包括事物和事物之间的联系,能满足用户对数据的处理要求.是对现实世界的一个真实模型.</p><p>(2) 易于理解,从而可以用它和不熟悉计算机的用户交换意见,用户的积极参与是数据库的设计成功的关键.</p><p>(3) 易于更改,当应用环境和应用要求改变时,容易对概念模型修改和扩充.</p><p>(4) 易于向关系,网状,层次等各种数据模型转换.</p><p>概念结构的设计策略通常有四种:</p><p><code>自顶向下</code>.即首先定义全局概念结构的框架,然后逐步细化;</p><p><code>自底向上</code>.即首先定义各局部应用的概念结构,然后将它们集成起来,得到全局概念<br>结构;</p><p><code>逐步扩张</code>.首先定义最重要的核心概念结构,然后向外扩充,以滚雪球的方式逐步生<br>成其他概念结构,直至总体概念结构;</p><p><code>混合策略</code>.即将自顶向下和自底向上相结合,用自顶向下策略设计一个全局概念结构的框架,以它为骨架集成由自底向上策略中设计的各局部概念结构.</p><ol start="8"><li>什么叫数据抽象 试举例说明.</li></ol><p>答:</p><p>数据抽象是对实际的人,物,事和概念进行人为处理,抽取所关心的共同特性,忽略非本质的细节,并把这些特性用各种概念精确地加以描述,这些概念组成了某种模型.</p><p>如分类这种抽象是:定义某一类概念作为现实世界中一组对象的类型.这些对象具有某些共同的特性和行为.它抽象了对象值和型之间的”is member of”的语义.在E-R模型中,实体型就是这种抽象.例如在学校环境中,李英是老师,表示李英是教师类型中的一员,则教师是实体型,李英是教师实体型中的一个实体值,具有教师共同的特性和行为:在某个系某个专业教学,讲授某些课程,从事某个方向的科研.</p><ol start="9"><li>试述数据库概念结构设计的重要性和设计步骤.</li></ol><p>答:</p><p>重要性:数据库概念设计是整个数据库设计的关键,将在需求分析阶段所得到的应用需求首先抽象为概念结构,以此作为各种数据模型的共同基础,从而能更好地,更准确地用某一DBMS实现这些需求.</p><p>设计步骤:</p><p>概念结构的设计方法有多种,其中最经常采用的策略是自底向上方法,该方法的设计步<br>骤通常分为两步:</p><p>第1步是抽象数据并设计局部视图,第2步是集成局部视图,得到全局的概念结构</p><ol start="10"><li>什么是E-R图 构成E-R图的基本要素是什么</li></ol><p>答:<br>E-R图为实体-联系图,提供了表示实体型,属性和联系的方法,用来描述现实世界的概念模型.</p><p>构成E-R图的基本要素是实体型,属性和联系,其表示方法为:</p><p>实体型:用矩形表示,矩形框内写明实体名;</p><p>属性:用椭圆形表示,并用无向边将其与相应的实体连接起来;</p><p>联系:用菱形表示,菱形框内写明联系名,并用无向边分别与有关实体连接起来,同时在无向边旁标上联系的类型(1 : 1,1 : n或m : n).</p><ol start="11"><li>为什么要视图集成 视图集成的方法是什么</li></ol><p>答:</p><p>在对数据库系统进行概念结构设计时一般采用自底向上的设计方法,把繁杂的大系统分解子系统.首先设计各个子系统的局部视图,然后通过视图集成的方式将各子系统有机的融合起来,综合成一个系统的总视图.这样设计清晰,由简到繁.由于数据库系统是从整体角度看待和描述数据的,因此数据不再面向某个应用而是整个系统.因此必须进行视图集成,使得数据库能被全系统的多个用户,多个应用共享使用.</p><p>一般说来,视图集成可以有两种方式:</p><ul><li>多个分E-R图一次集成;</li><li>逐步集成,用累加的方式一次集成两个分E-R图.</li></ul><p>无论采用哪种方式,每次集成局部E-R图时都需要分两步走:</p><p>(1) 合并.解决各分E-R图之间的冲突,将各分E-R图合并起来生成初步E-R图.</p><p>(2) 修改和重构.消除不必要的冗余,生成基本E-R图.</p><ol start="12"><li>什么是数据库的逻辑结构设计 试述其设计步骤.</li></ol><p>答:</p><p>数据库的逻辑结构设计就是把概念结构设计阶段设计好的基本E-R图转换为与选用的DBMS产品所支持的数据模型相符合的逻辑结构.</p><p>设计步骤为:</p><ul><li>将概念结构转换为一般的关系,网状,层次模型;</li><li>将转换来的关系,网状,层次模型向特定DBMS支持下的数据模型转换</li><li>对数据模型进行优化.</li></ul><ol start="13"><li>试述把E-R图转换为DBTG模型和关系模型的转换规则.</li></ol><p>答:</p><p>E-R图向DBTG模型的转换规则:</p><ol><li>每个实体型转换为记录型,实体的属性转换为记录的数据项;</li><li>实体型之间1:n(n≥1)的联系转换为一个系,没有任何联系的实体型转换为奇异系;</li><li>K(K≥2)个实体型之间多对多的联系,引入一个连结记录,形成K个实体型和连结记录之间的K个系.连结记录的属性由诸首记录的码及联系属性所组成;</li><li>同一实体型内的1:n,n:m联系,引入连结记录,转换为两个系.</li></ol><p>解析</p><p>根据我国实际情况,网状,层次数据库系统已很少使用,因此《概论》第三版把它们删去了,有关的主要概念放在第一章数据模型中介绍.对于DBTG模型的许多概念也介绍得很简单.本题的内容已经超出了书上的内容,同学们只要了解就可以了.但是,下面E-R图向关系模型的转换规则要求同学必须掌握,并且能够举一反三.</p><p>答:</p><p>E-R图向关系模型的转换规则:</p><p>一个实体型转换为一个关系模式.实体的属性就是关系的属性,实体的码就是关系的码.</p><p>对于实体间的联系则有以下不同的情况:</p><p>(1) 一个1:1联系可以转换为一个独立的关系模式,也可以与任意一端对应的关系模式合并.如果转换为一个独立的关系模式,则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性,每个实体的码均是该关系的候选码.如果与某一端实体对应的关系模式合并,则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性.</p><p>(2) 一个1:n联系可以转换为一个独立的关系模式,也可以与n端对应的关系模式合并.如果转换为一个独立的关系模式,则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性,而关系的码为n端实体的码.</p><p>(3) 一个m:n联系转换为一个关系模式.与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性,各实体码的组合组成该关系的码,或码的一部分.</p><p>(4) 三个或三个以上实体间的一个多元联系可以转换为一个关系模式.与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性,而关系的码为各实体码的组合.</p><p>(5) 具有相同码的关系模式可合并.<br>14. 你能给出由E-R图转换为IMS模型的转换规则吗</p><p>答:</p><p>E-R图向IMS模型的转换规则:</p><p>1)每个实体型转换为记录型,实体的属性转换为记录的数据项;</p><p>2)实体型之间1:n(n≥1)的联系转换记录型之间的有向边;</p><p>3)实体型之间m:n(m&gt;1,n&gt;1)的联系则分解成一对多联系,再根据2)转换;</p><p>4)K(K≥2)个实体型之间多对多的联系,可先转换成多对两个实体型之间的联系,再根据3)转换.</p><p>解析</p><p>IMS是IBM公司的层次数据库管理系统.IMS模型是层次模型.E-R图向IMS模型转换的另一种方法是,先把E-R图转换为网状模型,再利用IMS逻辑数据库LDB的概念来表示网状模型.详细方法这里从略.</p><h1 id="第七章-数据库恢复技术"><a href="#第七章-数据库恢复技术" class="headerlink" title="第七章 数据库恢复技术"></a>第七章 数据库恢复技术</h1><h2 id="一-选择题-6"><a href="#一-选择题-6" class="headerlink" title="一,选择题"></a>一,选择题</h2><ol><li>一个事务的执行,要么全部完成,要么全部不做,一个事务中对数据库的所有操作都是一个不可分割的操作序列的属性是(A ) .</li></ol><p>A. 原子性 B. 一致性<br>C. 独立性 D. 持久性</p><ol start="2"><li>表示两个或多个事务可以同时运行而不互相影响的是( C).</li></ol><p>A. 原子性 B. 一致性<br>C. 独立性 D. 持久性<br>3. 事务的持续性是指( B)</p><p>A.事务中包括的所有操作要么都做,要么都不做.<br>B.事务一旦提交,对数据库的改变是永久的.<br>C.一个事务内部的操作对并发的其他事务是隔离的.<br>D.事务必须是使数据库从一个一致性状态变到另一个一致性状态.<br>4. SQL语言中的COMMIT语句的主要作用是( C).</p><p>A. 结束程序 B. 返回系统<br>C. 提交事务 D. 存储数据<br>5. SQL语言中用( B)语句实现事务的回滚</p><p>A. CREATE TABLE B. ROLLBACK<br>C. GRANT和REVOKE D. COMMIT<br>6. 若系统在运行过程中,由于某种硬件故障,使存储在外存上的数据部分损失或全部损失,这种情况称为(A).</p><p>A. 介质故障 B. 运行故障<br>C. 系统故障 D. 事务故障<br>7. 在DBMS中实现事务持久性的子系统是( D ).</p><p>A. 安全管理子系统 B. 完整性管理子系统<br>C. 并发控制子系统 D. 恢复管理子系统<br>8. 后援副本的作用是( C ).</p><p>A. 保障安全性 B. 一致性控制<br>C. 故障后的恢复 D. 数据的转储<br>9. 事务日志用于保存( C )</p><p>A. 程序运行过程 B. 程序的执行结果<br>C. 对数据的更新操作 D. 数据操作<br>10. 数据库恢复的基础是利用转储的冗余数据.这些转储的冗余数据包括( C).</p><p>A. 数据字典,应用程序,审计档案,数据库后备副本<br>B. 数据字典,应用程序,审计档案,日志文件<br>C. 日志文件,数据库后备副本<br>D. 数据字典,应用程序,数据库后备副本</p><p>选择题答案:<br>(1) A (2) C (3) B (4) C (5) B<br>(6) A (7) D (8) C (9) C (10) C</p><h2 id="二-简答题-6"><a href="#二-简答题-6" class="headerlink" title="二,简答题"></a>二,简答题</h2><ol><li>试述事务的概念及事务的四个特性.</li></ol><p>答:</p><p>事务是用户定义的一个数据库操作序列,这些操作要么全做要么全不做,是一个不可分割的工作单位.</p><p>事务具有四个特性:原子性(Atomicity),一致性(Consistency),隔离性(Isolation)和持续性(Durability).这个四个特性也简称为ACID特性.</p><p><code>原子性</code>:事务是数据库的逻辑工作单位,事务中包括的诸操作要么都做,要么都不做.</p><p><code>一致性</code>:事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态.</p><p><code>隔离性</code>:一个事务的执行不能被其他事务干扰.即一个事务内部的操作及使用的数据对其他并发事务是隔离的,并发执行的各个事务之间不能互相干扰.</p><p><code>持续性</code>:持续性也称永久性(Permanence),指一个事务一旦提交,它对数据库中数据的改变就应该是永久性的.接下来的其他操作或故障不应该对其执行结果有任何影响.</p><ol start="2"><li>为什么事务非正常结束时会影响数据库数据的正确性,请列举一例说明之.<br>答:</li></ol><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态.如果数据库系统运行中发生故障,有些事务尚未完成就被迫中断,这些未完成事务对数据库所做的修改有一部分已写入物理数据库,这时数据库就处于一种不正确的状态,或者说是不一致的状态.</p><p>例如某工厂的库存管理系统中,要把数量为Q的某种零件从仓库1移到仓库2存放.<br>则可以定义一个事务T,T包括两个操作;Q1&#x3D;Q1-Q,Q2&#x3D;Q2+Q.如果T非正常终止时只做了第一个操作,则数据库就处于不一致性状态,库存量无缘无故少了Q.</p><ol start="3"><li>数据库中为什么要有恢复子系统 它的功能是什么</li></ol><p>答:</p><p>因为计算机系统中硬件的故障,软件的错误,操作员的失误以及恶意的破坏是不可避免的,这些故障轻则造成运行事务非正常中断,影响数据库中数据的正确性,重则破坏数据库,使数据库中全部或部分数据丢失,因此必须要有恢复子系统.</p><p>恢复子系统的功能是:把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态).</p><ol start="4"><li>数据库运行中可能产生的故障有哪几类 哪些故障影响事务的正常执行 哪些故障破坏数据库数据</li></ol><p>答:数据库系统中可能发生各种各样的故障,大致可以分以下几类:</p><p>(1) 事务内部的故障;</p><p>(2) 系统故障;</p><p>(3) 介质故障;</p><p>(4) 计算机病毒.</p><p>事务故障,系统故障和介质故障影响事务的正常执行;介质故障和计算机病毒破坏数据库数据.</p><p>5.据库恢复的基本技术有哪些</p><p>答:</p><p>数据转储和登录日志文件是数据库恢复的基本技术.</p><p>当系统运行过程中发生故障,利用转储的数据库后备副本和日志文件就可以将数据库恢复到故障前的某个一致性状态.</p><ol start="6"><li>数据库转储的意义是什么 试比较各种数据转储方法.</li></ol><p>答:</p><p>数据转储是数据库恢复中采用的基本技术.所谓转储即DBA定期地将数据库复制到磁带或另一个磁盘上保存起来的过程.当数据库遭到破坏后可以将后备副本重新装入,将数据库恢复到转储时的状态.</p><p><code>静态转储</code>:在系统中无运行事务时进行的转储操作.静态转储简单,但必须等待正运行的用户事务结束才能进行.同样,新的事务必须等待转储结束才能执行.显然,这会降低数据库的可用性.</p><p><code>动态转储</code>:指转储期间允许对数据库进行存取或修改.动态转储可克服静态转储的缺点,它不用等待正在运行的用户事务结束,也不会影响新事务的运行.但是,转储结束时后援副本上的数据并不能保证正确有效.因为转储期间运行的事务可能修改了某些数据,使得后援副本上的数据不是数据库的一致版本.为此,必须把转储期间各事务对数据库的修改活动登记下来,建立日志文件(log file).这样,后援副本加上日志文件就能得到数据库某一时刻的正确状态.转储还可以分为海量转储和增量转储两种方式.</p><p><code>海量转储</code>是指每次转储全部数据库.增量转储则指每次只转储上一次转储后更新过的数据.从恢复角度看,使用海量转储得到的后备副本进行恢复一般说来更简单些.但如果数据库很大,事务处理又十分频繁,则增量转储方式更实用更有效.</p><ol start="7"><li>什么是日志文件 为什么要设立日志文件</li></ol><p>答:<br>(1) 日志文件是用来记录事务对数据库的更新操作的文件.</p><p>(2) 设立日志文件的目的是: 进行事务故障恢复;进行系统故障恢复;协助后备副本进行介质故障恢复.</p><ol start="8"><li>登记日志文件时为什么必须先写日志文件,后写数据库</li></ol><p>答:</p><p>把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作.有可能在这两个操作之间发生故障,即这两个写操作只完成了一个.</p><p>如果先写了数据库修改,而在运行记录中没有登记这个修改,则以后就无法恢复这个修改了.如果先写日志,但没有修改数据库,在恢复时只不过是多执行一次UNDO操作,并不会影响数据库的正确性.所以一定要先写日志文件,即首先把日志记录写到日志文件中,然后写数据库的修改.</p><ol start="9"><li>针对不同的故障,试给出恢复的策略和方法.(即如何进行事务故障的恢复 系统故障的恢复 介质故障恢复 )</li></ol><p>答:</p><p>事务故障的恢复:</p><p>事务故障的恢复是由DBMS自动完成的,对用户是透明的.</p><p>DBMS执行恢复步骤是:</p><p>(1) 反向扫描文件日志(即从最后向前扫描日志文件),查找该事务的更新操作.</p><p>(2) 对该事务的更新操作执行逆操作.即将日志记录中”更新前的值”写入数据库.</p><p>(3) 继续反向扫描日志文件,做同样处理.</p><p>(4) 如此处理下去,直至读到此事务的开始标记,该事务故障的恢复就完成了.</p><p>答:</p><p>系统故障的恢复:</p><p>系统故障可能会造成数据库处于不一致状态:</p><p>一是未完成事务对数据库的更新可能已写入数据库;</p><p>二是已提交事务对数据库的更新可能还留在缓冲区,没来得及写入数据库.</p><p>因此恢复操作就是要撤销(UNDO)故障发生时未完成的事务,重做(REDO)已完成的事务.</p><p>系统的恢复步骤是:</p><p>(1) 正向扫描日志文件,找出在故障发生前已经提交的事务队列(REDO队列)和未完成的事务队列(UNDO队列).</p><p>(2) 对撤销队列中的各个事务进行UNDO处理.<br>进行UNDO处理的方法是,反向扫描日志文件,对每个UNDO事务的更新操作执行逆操作,即将日志记录中”更新前的值”(Before Image)写入数据库.</p><p>(3) 对重做队列中的各个事务进行REDO处理.</p><p>进行REDO处理的方法是:正向扫描日志文件,对每个REDO事务重新执行日志文件登记的操作.即将日志记录中”更新后的值”(After Image)写入数据库.</p><p>解析:<br>在第(1)步中如何找出REDO队列和UNDO队列 请大家思考一下.</p><p>下面给出一个算法:</p><ol><li>建立两个事务队列:</li></ol><p>UNDO-LIST: 需要执行undo操作的事务集合;</p><p>REDO-LIST: 需要执行redo操作的事务集合;</p><p>两个事务队列初始均为空.</p><ol start="2"><li>从日志文件头开始,正向扫描日志文件</li></ol><p>· 如有新开始(遇到Begin Transaction)的事务Ti,把Ti暂时放入UNDO-LIST队列;<br>· 如有提交的事务(遇到End Transaction)Tj,把Tj从UNDO-LIST队列移到REDO-LIST队列;<br>直到日志文件结束</p><p>答:</p><p>介质故障的恢复:</p><p>介质故障是最严重的一种故障.</p><p>恢复方法是重装数据库,然后重做已完成的事务.具体过程是:</p><p>(1) DBA装入最新的数据库后备副本(离故障发生时刻最近的转储副本),使数据库恢复到转储时的一致性状态.</p><p>(2) DBA装入转储结束时刻的日志文件副本</p><p>(3) DBA启动系统恢复命令,由DBMS完成恢复功能,即重做已完成的事务.</p><p>解析</p><ol><li>我们假定采用的是静态转储,因此第(1)步装入数据库后备副本便可以了.</li><li>如果采用的是静动态转储,第(1)步装入数据库后备副本还不够,还需同时装入转储开始时刻的日志文件副本,经过处理后才能得到正确的数据库后备副本.</li><li>第(2)步重做已完成的事务的算法是:<br>a. 正向扫描日志文件,找出故障发生前已提交的事务的标识,将其记入重做队列<br>b. 再一次正向扫描日志文件,对重做队列中的所有事务进行重做处理.即将日志记录中”更新后的值”写入数据库.</li></ol><ol start="10"><li>具有检查点的恢复技术有什么优点</li></ol><p>答:</p><p>利用日志技术进行数据库恢复时,恢复子系统必须搜索日志,确定哪些事务需要REDO,哪些事务需要UNDO.一般来说,需要检查所有日志记录.这样做有两个问题:</p><p>一是搜索整个日志将耗费大量的时间.</p><p>二是很多需要REDO处理的事务实际上已经将它们的更新操作结果写到数据库中了,恢复子系统又重新执行了这些操作,浪费了大量时间.</p><p>检查点技术就是为了解决这些问题.</p><ol start="11"><li>试述使用检查点方法进行恢复的步骤.</li></ol><p>答:</p><p>① 从重新开始文件中找到最后一个检查点记录在日志文件中的地址,由该地址在日志文件中找到最后一个检查点记录.</p><p>② 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST.</p><p>这里建立两个事务队列:<br>· UNDO-LIST: 需要执行undo操作的事务集合;<br>· REDO-LIST: 需要执行redo操作的事务集合;<br>把ACTIVE-LIST暂时放入UNDO-LIST队列,REDO队列暂为空.</p><p>③ 从检查点开始正向扫描日志文件</p><p>· 如有新开始的事务Ti,把Ti暂时放入UNDO-LIST队列;</p><p>· 如有提交的事务Tj,把Tj从UNDO-LIST队列移到REDO-LIST队列,直到日志文件结束;</p><p>④ 对UNDO-LIST中的每个事务执行UNDO操作, 对REDO-LIST中的每个事务执行REDO操作.</p><ol start="12"><li>什么是数据库镜像 它有什么用途</li></ol><p>答:</p><p>数据库镜像即根据DBA的要求,自动把整个数据库或者其中的部分关键数据复制到另一个磁盘上.每当主数据库更新时,DBMS自动把更新后的数据复制过去,即DBMS自动保证镜像数据与主数据的一致性.</p><p>数据库镜像的用途有:</p><p>一是用于数据库恢复.当出现介质故障时,可由镜像磁盘继续提供使用,同时DBMS自动利用镜像磁盘数据进行数据库的恢复,不需要关闭系统和重装数据库副本.<br>二是提高数据库的可用性.在没有出现故障时,当一个用户对某个数据加排它锁进行修改时,其他用户可以读镜像数据库上的数据,而不必等待该用户释放锁.</p><ol start="13"><li>试述你了解的某一个实际的DBMS产品中采用的恢复策略.<br>答:</li></ol><p>下面简单介绍一下Oracle的恢复技术:</p><p>Oracle中恢复机制也采用了转储和登记日志文件两个技术.</p><p>Oracle向DBA提供了多种转储后备副本的方法,如文件拷贝,利用Oracle的Export实用程序,用SQL命令Spool以及自己编程实现等.相应地,Oracle也提供了多种重装后备副本的方法,如文件拷贝,利用Oracle的Import实用程序,利用SQL * LOADER以及自己编程实现等.</p><p>在Oracle 早期版本(V.5)中,日志文件以数据块为单位,也就是说,Oracle的恢复操作是基于数据块的,不是基于操作的.Oracle中记录数据库更新前的旧值的日志文件称为数据库前像文件(Before Image,简称BI文件),记录数据库更新后的新值的日志文件称为数据库的后像文件(After Image,简称AI文件).BI文件是必须配置的,AI文件是可以任选的.</p><p>Oracle7为了能够在出现故障时更有效地恢复数据,也为了解决读”脏”数据问题,提供了REDO日志文件和回滚段(Rollback Segment).REDO日志文件中记录了被更新数据的前像和后像.回滚段记录更新数据的前像,设在数据库缓冲区中.在利用日志文件进行故障恢复时,为减少扫描日志文件的遍数,Oracle7首先扫描REDO日志文件,重做所有操作,包括未正常提交的事务的操作,然后再根据回滚段中的数据,撤销未正常提交的事务的操作.</p><p>详细技术希望同学自己设法了解Oracle最新版本的介绍,例如通过INTERNET访问Oracle公司的网站.也可以了解其他DBMS厂商的产品情况.</p><ol start="14"><li>试用恢复的基本技术设计一个恢复子系统,给出这个子系统的恢复策略,包括:</li></ol><p>(a) 当产生某一类故障时如何恢复数据库的方法;</p><p>(b) 日志文件的结构;</p><p>(c) 登记日志文件的方法;</p><p>(d) 利用日志文件恢复事务的方法;</p><p>(e) 转储的类型;</p><p>(f) 转储的后备副本和日志文件如何配合使用.</p><p>解析</p><p>这是一个大作业.可以综合复习和运用学到的知识.设计一个恢复子系统</p><p>例如,日志文件的结构你可以记录为单位,也可以以数据块为单位.不同的日志文件结构,登记的日志内容,日志文件恢复事务的方法也就不同了.</p><p>对于研究生,还应该上机模拟实现你设计的恢复子系统.</p><h1 id="第八章-数据库并发控制"><a href="#第八章-数据库并发控制" class="headerlink" title="第八章 数据库并发控制"></a>第八章 数据库并发控制</h1><h2 id="一-选择题-7"><a href="#一-选择题-7" class="headerlink" title="一,选择题"></a>一,选择题</h2><ol><li>为了防止一个用户的工作不适当地影响另一个用户,应该采取(D) .</li></ol><p>A. 完整性控制 B. 访问控制<br>C. 安全性控制 D. 并发控制<br>2. 解决并发操作带来的数据不一致问题普遍采用( A)技术.</p><p>A. 封锁 B. 存取控制<br>C. 恢复 D. 协商<br>3. 下列不属于并发操作带来的问题是( C).</p><p>A. 丢失修改 B. 不可重复读<br>C. 死锁 D. 脏读<br>4. DBMS普遍采用(C )方法来保证调度的正确性 .</p><p>A. 索引 B. 授权<br>C. 封锁 D. 日志<br>5. 事务T在修改数据R之前必须先对其加X锁,直到事务结束才释放,这是(A ) .</p><p>A. 一级封锁协议 B. 二级封锁协议<br>C. 三级封锁协议 D. 零级封锁协议<br>6. 如果事务T获得了数据项Q上的排他锁,则T对Q( C) .</p><p>A. 只能读不能写 B. 只能写不能读<br>C. 既可读又可写 D. 不能读也不能写<br>7. 设事务T1和T2,对数据库中地数据A进行操作,可能有如下几种情况,请问哪一种不会发生冲突操作(D ) .</p><p>A. T1正在写A,T2要读A<br>B. T1正在写A,T2也要写A<br>C. T1正在读A,T2要写A<br>D. T1正在读A,T2也要读A<br>8. 如果有两个事务,同时对数据库中同一数据进行操作,不会引起冲突的操作是( D) .</p><p>A. 一个是DELETE,一个是SELECT<br>B. 一个是SELECT,一个是DELETE<br>C. 两个都是UPDATE<br>D. 两个都是SELECT<br>9. 在数据库系统中,死锁属于(B ).</p><p>A. 系统故障 B. 事务故障<br>C. 介质故障 D. 程序故障</p><p>选择题答案:<br>(1) D (2) A (3) C (4) C (5) A<br>(6) C (7) D (8) D (9) B</p><h2 id="二-简答题-7"><a href="#二-简答题-7" class="headerlink" title="二,简答题"></a>二,简答题</h2><ol><li>在数据库中为什么要并发控制</li></ol><p>答:<br>数据库是共享资源,通常有许多个事务同时在运行.<br>当多个事务并发地存取数据库时就会产生同时读取和&#x2F;或修改同一数据的情况.若对并发操作不加控制就可能会存取和存储不正确的数据,破坏数据库的一致性.所以数据库管理系统必须提供并发控制机制.</p><ol start="2"><li>并发操作可能会产生哪几类数据不一致 用什么方法能避免各种不一致的情况</li></ol><p>答:</p><p>并发操作带来的数据不一致性包括三类:丢失修改,不可重复读和读”脏”数据.</p><ol><li>丢失修改(Lost Update)<br>两个事务T1和T2读入同一数据并修改,T2提交的结果破坏了(覆盖了)T1提交的结果,导致T1的修改被丢失.</li><li>不可重复读(Non-Repeatable Read)<br>不可重复读是指事务T1读取数据后,事务T2执行更新操作,使T1无法再现前一次读取结果.</li><li>读”脏”数据(Dirty Read)<br>读”脏”数据是指事务T1修改某一数据,并将其写回磁盘,事务T2读取同一数据后,T1由于某种原因被撤销,这时T1已修改过的数据恢复原值,T2读到的数据就与数据库中的数据不一致,则T2读到的数据就为”脏”数据,即不正确的数据.<br>避免不一致性的方法和技术就是并发控制.最常用的并发控制技术是封锁技术.<br>也可以用其他技术,例如在分布式数据库系统中可以采用时间戳方法来进行并发控制.</li></ol><ol start="3"><li>什么是封锁</li></ol><p>答:<br>封锁就是事务T在对某个数据对象例如表,记录等操作之前,先向系统发出请求,对其加锁.加锁后事务T就对该数据对象有了一定的控制,在事务T释放它的锁之前,其他的事务不能更新此数据对象.</p><p>封锁是实现并发控制的一个非常重要的技术.</p><ol start="4"><li>基本的封锁类型有几种 试述它们的含义.</li></ol><p>答:<br>基本的封锁类型有两种: 排它锁(Exclusive Locks,简称X锁) 和共享锁(Share Locks,简称S锁).</p><p>排它锁又称为写锁.若事务T对数据对象A加上X锁,则只允许T读取和修改A,其他任何事务都不能再对A加任何类型的锁,直到T释放A上的锁.这就保证了其他事务在T释放A上的锁之前不能再读取和修改A.</p><p>共享锁又称为读锁.若事务T对数据对象A加上S锁,则事务T可以读A但不能修改A,其他事务只能再对A加S锁,而不能加X锁,直到T释放A上的S锁.这就保证了其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改.</p><ol start="5"><li>什么是封锁协议 不同级别的封锁协议的主要区别是什么</li></ol><p>答:</p><p>在运用封锁技术对数据加锁时,要约定一些规则.例如,在运用X锁和S锁对数据对象加锁时,要约定何时申请X锁或S锁,何时释放封锁等.这些约定或者规则称为封锁协议(Locking Protocol).对封锁方式约定不同的规则,就形成了各种不同的封锁协议.不同级别的封锁协议,例如《概论》中介绍的三级封锁协议,三级协议的主要区别在于什么操作需要申请封锁,何时申请封锁以及何时释放锁(即持锁时间的长短).</p><p>一级封锁协议:事务T在修改数据R之前必须先对其加X锁,直到事务结束才释放.</p><p>二级封锁协议:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁,读完后即可释放S锁.</p><p>三级封锁协议:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁,直到事务结束才释放.</p><ol start="6"><li>不同封锁协议与系统一致性级别的关系是什么</li></ol><p>答:<br>不同的封锁协议对应不同的一致性级别.</p><p>一级封锁协议可防止丢失修改,并保证事务T是可恢复的.在一级封锁协议中,对读数据是不加S锁的,所以它不能保证可重复读和不读”脏”数据.</p><p>二级封锁协议除防止了丢失修改,还可进一步防止读”脏”数据.在二级封锁协议中,由于读完数据后立即释放S锁,所以它不能保证可重复读.</p><p>在三级封锁协议中,无论是读数据还是写数据都加长锁,即都要到事务结束时才释放封锁.所以三级封锁协议除防止了丢失修改和不读”脏”数据外,还进一步防止了不可重复读.</p><ol start="7"><li>试述活锁的产生原因和解决方法.</li></ol><p>答:</p><p>活锁产生的原因:当一系列封锁不能按照其先后顺序执行时,就可能导致一些事务无限期等待某个封锁,从而导致活锁.</p><p>避免活锁的简单方法是采用先来先服务的策略.当多个事务请求封锁同一数据对象时,封锁子系统按请求封锁的先后次序对事务排队,数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁.</p><ol start="8"><li>请给出预防死锁的若干方法.</li></ol><p>答:</p><p>在数据库中,产生死锁的原因是两个或多个事务都已封锁了一些数据对象,然后又都请求已被其他事务封锁的数据加锁,从而出现死等待.</p><p>防止死锁的发生其实就是要破坏产生死锁的条件.预防死锁通常有两种方法:<br>(1)一次封锁法</p><p>要求每个事务必须一次将所有要使用的数据全部加锁,否则就不能继续执行.<br>(2)顺序封锁法</p><p>预先对数据对象规定一个封锁顺序,所有事务都按这个顺序实行封锁.<br>不过,预防死锁的策略不大适合数据库系统的特点.</p><ol start="9"><li>请给出检测死锁发生的一种方法,当发生死锁后如何解除死锁</li></ol><p>答:</p><p>数据库系统一般采用允许死锁发生,DBMS检测到死锁后加以解除的方法.<br>DBMS中诊断死锁的方法与操作系统类似,一般使用超时法或事务等待图法.</p><p>超时法是:如果一个事务的等待时间超过了规定的时限,就认为发生了死锁.超时法实现简单,但有可能误判死锁,事务因其他原因长时间等待超过时限时,系统会误认为发生了死锁.若时限设置得太长,又不能及时发现死锁发生.</p><p>DBMS并发控制子系统检测到死锁后,就要设法解除.通常采用的方法是选择一个处理死锁代价最小的事务,将其撤消,释放此事务持有的所有锁,使其他事务得以继续运行下去.当然,对撤销的事务所执行的数据修改操作必须加以恢复.</p><ol start="10"><li>什么样的并发调度是正确的调度</li></ol><p>答:</p><p>可串行化(Serializable)的调度是正确的调度.</p><p>可串行化的调度的定义:多个事务的并发执行是正确的,当且仅当其结果与按某一次序串行地执行它们时的结果相同,我们称这种调度策略为可串行化的调度.</p><ol start="11"><li>试述两段锁协议的概念.</li></ol><p>答:</p><p>两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁.在对任何数据进行读,写操作之前,首先要申请并获得对该数据的封锁; 在释放一个封锁之后,事务不再申请和获得任何其他封锁.</p><p>“两段”的含义是,事务分为两个阶段:</p><p>第一阶段是获得封锁,也称为扩展阶段.在这阶段,事务可以申请获得任何数据项上的任何类型的锁,但是不能释放任何锁.</p><p>第二阶段是释放封锁,也称为收缩阶段.在这阶段,事务释放已经获得的锁,但是不能再申请任何锁.</p><ol start="12"><li>为什么要引进意向锁 意向锁的含义是什么</li></ol><p>答:</p><p>引进意向锁是为了提高封锁子系统的效率.该封锁子系统支持多种封锁粒度.</p><p>原因是:在多粒度封锁方法中一个数据对象可能以两种方式加锁—显式封锁和隐式封锁.因此系统在对某一数据对象加锁时不仅要检查该数据对象上有无(显式和隐式)封锁与之冲突;还要检查其所有上级结点和所有下级结点,看申请的封锁是否与这些结点上的(显式和隐式)封锁冲突;显然,这样的检查方法效率很低.为此引进了意向锁.</p><p>意向锁的含义是:对任一结点加锁时,必须先对它的上层结点加意向锁.</p><p>例如事务T要对某个元组加X锁,则首先要对关系和数据库加IX锁.换言之,对关系和数据库加IX锁,表示它的后裔结点—某个元组拟(意向)加X锁.</p><p>引进意向锁后,系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了.例如,事务T要对关系R加X锁时,系统只要检查根结点数据库和R本身是否已加了不相容的锁(如发现已经加了IX,则与X冲突),而不再需要搜索和检查R中的每一个元组是否加了X锁或S锁.</p><ol start="13"><li>试述常用的意向锁:IS锁,IX锁,SIX锁,给出这些锁的相容矩阵.</li></ol><p>答:</p><p>IS锁</p><p>如果对一个数据对象加IS锁,表示它的后裔结点拟(意向)加S锁.例如,要对某个元组加S锁,则要首先对关系和数据库加IS锁</p><p>IX锁</p><p>如果对一个数据对象加IX锁,表示它的后裔结点拟(意向)加X锁.例如,要对某个元组加X锁,则要首先对关系和数据库加IX锁.</p><p>SIX锁</p><p>如果对一个数据对象加SIX锁,表示对它加S锁,再加IX锁,即SIX &#x3D; S + IX.<br>相容矩阵(略)</p><ol start="14"><li>理解并解释下列术语的含义:封锁,活锁,死锁,排它锁,共享锁,并发事务的调度,可串行化的调度,两段锁协议.</li></ol><p>答:(略,已经在上面有关习题中解答)</p><ol start="25"><li>试述你了解的某一个实际的DBMS产品的并发控制机制.</li></ol><p>答:(略,参见《概论》第8节,简单介绍了有关Oracle的并发控制机制.)</p><h1 id="第九章-数据库安全性"><a href="#第九章-数据库安全性" class="headerlink" title="第九章 数据库安全性"></a>第九章 数据库安全性</h1><h2 id="一-选择题-8"><a href="#一-选择题-8" class="headerlink" title="一,选择题"></a>一,选择题</h2><ol><li>以下( D)不属于实现数据库系统安全性的主要技术和方法.</li></ol><p>A. 存取控制技术 B. 视图技术<br>C. 审计技术 D. 出入机房登记和加锁<br>2. SQL中的视图提高了数据库系统的(D ).</p><p>A. 完整性 B. 并发控制<br>C. 隔离性 D. 安全性<br>3. SQL语言的GRANT和REMOVE语句主要是用来维护数据库的(C )</p><p>A. 完整性 B. 可靠性<br>C. 安全性 D. 一致性<br>4. 在数据库的安全性控制中,授权的数据对象的( A),授权子系统就越灵活.</p><p>A. 范围越小 B. 约束越细致<br>C. 范围越大 D. 约束范围大</p><p>选择题答案:<br>(1) D (2) D (3) C (4) A</p><h2 id="三-简答题"><a href="#三-简答题" class="headerlink" title="三,简答题"></a>三,简答题</h2><ol><li>什么是数据库的安全性</li></ol><p>答:数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露,更改或破坏.<br>2. 数据库安全性和计算机系统的安全性有什么关系</p><p>答:</p><p>安全性问题不是数据库系统所独有的,所有计算机系统都有这个问题.只是在数据库系统中大量数据集中存放,而且为许多最终用户直接共享,从而使安全性问题更为突出.<br>系统安全保护措施是否有效是数据库系统的主要指标之一.</p><p>数据库的安全性和计算机系统的安全性,包括操作系统,网络系统的安全性是紧密联系,相互支持的,<br>3. 试述实现数据库安全性控制的常用方法和技术.</p><p>答:</p><p>实现数据库安全性控制的常用方法和技术有:</p><ol><li>用户标识和鉴别:该方法由系统提供一定的方式让用户标识自己的名字或身份.每次用户要求进入系统时,由系统进行核对,通过鉴定后才提供系统的使用权.</li><li>存取控制:通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库,所有未被授权的人员无法存取数据.例如C2级中的自主存取控制(DAC),B1级中的强制存取控制(MAC);</li><li>视图机制:为不同的用户定义视图,通过视图机制把要保密的数据对无权存取的用户隐藏起来,从而自动地对数据提供一定程度的安全保护.<br>4)审计:建立审计日志,把用户对数据库的所有操作自动记录下来放入审计日志中, DBA可以利用审计跟踪的信息,重现导致数据库现有状况的一系列事件,找出非法存取数据的人,时间和内容等.</li><li>数据加密:对存储和传输的数据进行加密处理,从而使得不知道解密算法的人无法获知数据的内容.</li></ol><p>具体内容请参见《概论》9.2.</p><ol start="4"><li>什么是数据库中的自主存取控制方法和强制存取控制方法</li></ol><p>答:<br>自主存取控制方法:定义各个用户对不同数据对象的存取权限.当用户对数据库访问时首先检查用户的存取权限.防止不合法用户对数据库的存取.</p><p>强制存取控制方法:每一个数据对象被(强制地)标以一定的密级,每一个用户也被(强制地)授予某一个级别的许可证.系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象.</p><p>解析:</p><p>自主存取控制中自主的含义是:用户可以将自己拥有的存取权限”自主”地授予别人.即用户具有一定的”自主”权.<br>5. SQL语言中提供了哪些数据控制(自主存取控制)的语句 请试举几例说明它们的使用方法.<br>答:<br>SQL中 的自主存取控制是通过GRANT 语句和 REVOKE 语句来实现的.如:<br>GRANT SELECT, INSERT ON Student TO 王平 WITH GRANT OPTION;<br>就将Student表的SELECT和INSERT权限授予了用户王平,后面的”WITH GRANT OPTION”子句表示用户王平同时也获得了”授权”的权限,即可以把得到的权限继续授予其他用户.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> Student <span class="keyword">FROM</span> 王平 CASCADE;</span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line">就将Student表 的<span class="keyword">INSERT</span>权限从用户王平处收回,选项 CASCADE 表示,如果用户王平将 Student 的 <span class="keyword">INSERT</span> 权限又转授给了其他用户,那么这些权限也将从其他用户处收回.</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 今有两个关系模式:</span><br><span class="line"></span><br><span class="line">职工(职工号,姓名,年龄,职务,工资,部门号)</span><br><span class="line"></span><br><span class="line">部门(部门号,名称,经理名,地址,电话号)</span><br><span class="line"></span><br><span class="line">请用<span class="keyword">SQL</span>的<span class="keyword">GRANT</span>和<span class="keyword">REVOKE</span>语句(加上视图机制)完成以下授权定义或存取控制功能:</span><br><span class="line"></span><br><span class="line">(a) 用户王明对两个表有<span class="keyword">SELECT</span>权力;</span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> 职工,部门</span><br><span class="line"><span class="keyword">TO</span> 王明;</span><br></pre></td></tr></table></figure><p>(b) 用户李勇对两个表有INSERT和DELETE权力;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span>,<span class="keyword">DELETE</span> <span class="keyword">ON</span> 职工,部门 <span class="keyword">TO</span> 李勇</span><br></pre></td></tr></table></figure><p>(c) 每个职工只对自己的记录有SELECT权力;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> 职工 <span class="keyword">WHEN</span> <span class="keyword">USER</span>()<span class="operator">=</span> NAME <span class="keyword">TO</span> <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><p>这里假定系统的GRANT语句支持WHEN子句和USER()的使用.用户将自己的名字作为ID.注意,不同的系统这些扩展语句可能是不同的.读者应该了解你使用的DBMS产品的扩展语句.</p><p>(d) 用户刘星对职工表有SELECT权力,对工资字段具有更新权力;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span>(工资) <span class="keyword">ON</span> 职工</span><br><span class="line"><span class="keyword">TO</span> 刘星;</span><br></pre></td></tr></table></figure><p>(e) 用户张新具有修改这两个表的结构的权力;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">ON</span> 职工,部门</span><br><span class="line"><span class="keyword">TO</span> 张新;</span><br></pre></td></tr></table></figure><p>(f) 用户周平具有对两个表所有权力(读,插,改,删数据),并具有给其他用户授权的权力;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES <span class="keyword">ON</span> 职工,部门 <span class="keyword">TO</span> 周平 <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>(g) 用户杨兰具有从每个部门职工中SELECT最高工资,最低工资,平均工资的权力,他不能查看每个人的工资.<br>答:<br>首先建立一个视图.然后对这个视图定义杨兰的存取权限.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 部门工资 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> 部门.名称,<span class="built_in">MAX</span>(工资),<span class="built_in">MIN</span>(工资),<span class="built_in">AVG</span>(工资)</span><br><span class="line"><span class="keyword">FROM</span> 职工,部门</span><br><span class="line"><span class="keyword">WHERE</span> 职工.部门号 <span class="operator">=</span> 部门. 部门号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 职工.部门号;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> 部门工资 <span class="keyword">TO</span> 杨兰;</span><br></pre></td></tr></table></figure><ol start="7"><li>把习题8中(a)~(g) 的每一种情况,撤销各用户所授予的权力.<br>答:</li></ol><p>(a)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> 职工,部门</span><br><span class="line"><span class="keyword">FROM</span> 王明</span><br></pre></td></tr></table></figure><p>(b)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span>,<span class="keyword">DELETE</span> <span class="keyword">ON</span> 职工,部门</span><br><span class="line"><span class="keyword">FROM</span> 李勇;</span><br></pre></td></tr></table></figure><p>(c)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REOVKE <span class="keyword">SELECT</span> <span class="keyword">ON</span> 职工</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">USER</span>()<span class="operator">=</span> NAME</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">ALL</span>;</span><br></pre></td></tr></table></figure><p>这里假定用户将自己的名字作为ID,且系统的REOVKE语句支持WHEN子句,系统也支持USER()的使用.</p><p>(d)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> 职工</span><br><span class="line"><span class="keyword">FROM</span> 刘星;</span><br></pre></td></tr></table></figure><p>(e)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REVOKE ALTER TABLE ON 职工,部门</span><br><span class="line">FROM 张新</span><br></pre></td></tr></table></figure><p>(f)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILIGES <span class="keyword">ON</span> 职工,部门</span><br><span class="line"><span class="keyword">FROM</span> 周平;</span><br></pre></td></tr></table></figure><p>(g)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT ON 部门工资</span><br><span class="line">FROM 杨兰;</span><br><span class="line">DROP VIEW 部门工资;</span><br></pre></td></tr></table></figure><ol start="8"><li>为什么强制存取控制提供了更高级别的数据库安全性</li></ol><p>答:</p><p>强制存取控制(MAC)是对数据本身进行密级标记,无论数据如何复制,标记与数据是一个不可分的整体,只有符合密级标记要求的用户才可以操纵数据,从而提供了更高级别的安全性.</p><ol start="9"><li>理解并解释MAC机制中主体,客体,敏感度标记的含义.</li></ol><p>答:</p><p>主体是系统中的活动实体,既包括DBMS所管理的实际用户,也包括代表用户的各进程.<br>客体是系统中的被动实体,是受主体操纵的,包括文件,基表,索引,视图等.<br>对于主体和客体,DBMS为它们每个实例(值)指派一个敏感度标记(Label).敏感度标记被分成若干级别,例如绝密(Top Secret),机密(Secret),可信(Confidential),公开(Public)等.主体的敏感度标记称为许可证级别(Clearance Level),客体的敏感度标记称为密级(Classification Level).</p><ol start="10"><li>什么是数据库的审计功能,为什么要提供审计功能</li></ol><p>答:</p><p>审计功能是指DBMS的审计模块在用户对数据库执行操作的同时把所有操作自动记录到系统的审计日志中.</p><p>因为任何系统的安全保护措施都不是完美无缺的,蓄意盗窃破坏数据的人总可能存在.利用数据库的审计功能,DBA可以根据审计跟踪的信息,重现导致数据库现有状况的一系列事件,找出非法存取数据的人,时间和内容等.</p><ol start="11"><li>统计数据库中存在何种特殊的安全性问题</li></ol><p>答:</p><p>统计数据库允许用户查询聚集类型的信息,如合计,平均值,最大值,最小值等,不允许查询单个记录信息.但是,人们可以从合法的查询中推导出不合法的信息,即可能存在隐蔽的信息通道,这是统计数据库要研究和解决的特殊的安全性问题.</p><ol start="12"><li>试述你了解的某一个实际的DBMS产品的安全性措施.</li></ol><p>答:</p><p>不同的DBMS产品以及同一产品的不同版本的安全措施各不相同,仁者见仁,智者见智,请读者自己了解.《概论》上9.4 简单介绍了有关ORACLE数据库的安全性措施.</p><h1 id="第十章-数据库完整性"><a href="#第十章-数据库完整性" class="headerlink" title="第十章 数据库完整性"></a>第十章 数据库完整性</h1><h2 id="一-选择题-9"><a href="#一-选择题-9" class="headerlink" title="一,选择题"></a>一,选择题</h2><ol><li>完整性检查和控制的防范对象( A),防止它们进入数据库.(C)安全性控制的防范对象是(B ),防止他们对数据库数据的存取.(D)</li></ol><p>A. 不合语义的数据 B. 非法用户<br>C. 不正确的数据 D. 非法操作<br>2. 下述哪个是SQL语言中的数据控制命令( A).</p><p>A. GRANT B. COMMIT<br>C. UPDATE D. SELECT<br>3. 下述SQL语言中的权限,哪一个允许用户定义新关系时,引用其他关系的主码作为外码( C).</p><p>A. INSERT B. DELETE<br>C. REFERENCES D. SELECT</p><p>选择题答案:<br>(1) A C B D (2) A (3) C</p><h2 id="二-简答题-8"><a href="#二-简答题-8" class="headerlink" title="二,简答题"></a>二,简答题</h2><ol><li><p>什么是数据库的完整性<br>答:<br>数据库的完整性是指数据的正确性和相容性.</p></li><li><p>数据库的完整性概念与数据库的安全性概念有什么区别和联系<br>答:<br>数据的完整性和安全性是两个不同的概念,但是有一定的联系.</p></li></ol><p>前者是为了防止数据库中存在不符合语义的数据,防止错误信息的输入和输出,即所谓垃圾进垃圾出(Garbage In Garbage Out)所造成的无效操作和错误结果.<br>后者是保护数据库防止恶意的破坏和非法的存取.</p><p>也就是说,安全性措施的防范对象是非法用户和非法操作,完整性措施的防范对象是不合语义的数据.</p><ol start="3"><li>什么是数据库的完整性约束条件 可分为哪几类<br>答:<br>完整性约束条件是指数据库中的数据应该满足的语义约束条件.<br>一般可以分为六类:</li></ol><p>静态列级约束,静态元组约束,静态关系约束,动态列级约束,动态元组约束,动态关系约束.</p><p>静态列级约束是对一个列的取值域的说明,包括以下几方面:</p><ol><li>对数据类型的约束,包括数据的类型,长度,单位,精度等</li><li>对数据格式的约束</li><li>对取值范围或取值集合的约束.</li><li>对空值的约束</li><li>其他约束</li></ol><p>静态元组约束就是规定组成一个元组的各个列之间的约束关系,静态元组约束只局限在单个元组上.</p><p>静态关系约束是在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束.常见的静态关系约束有:</p><ol><li>实体完整性约束.</li><li>参照完整性约束.</li><li>函数依赖约束.</li></ol><p>动态列级约束是修改列定义或列值时应满足的约束条件,包括下面两方面:</p><ol><li>修改列定义时的约束</li><li>修改列值时的约束</li></ol><p>动态元组约束是指修改某个元组的值时需要参照其旧值,并且新旧值之间需要满足某种约束条件.</p><p>动态关系约束是加在关系变化前后状态上的限制条件,例如事务一致性,原子性等约束条件.</p><p>详细内容可以参见《概论》10.1中的介绍.</p><ol start="4"><li>DBMS的完整性控制机制应具有哪些功能</li></ol><p>答:<br>DBMS的完整性控制机制应具有三个方面的功能:</p><ol><li>定义功能,即提供定义完整性约束条件的机制.</li><li>检查功能,即检查用户发出的操作请求是否违背了完整性约束条件.</li><li>违约反应:如果发现用户的操作请求使数据违背了完整性约束条件,则采取一定的动作来保证数据的完整性.</li></ol><ol start="5"><li>RDBMS在实现参照完整性时需要考虑哪些方面</li></ol><p>答:<br>RDBMS在实现参照完整性时需要考虑以下几个方面:</p><ol><li><p>外码是否可以接受空值</p></li><li><p>删除被参照关系的元组时的考虑,这时系统可能采取的作法有三种:</p></li></ol><p>a) 级联删除(CASCADES);<br>b) 受限删除(RESTRICTED);<br>c) 置空值删除(NULLIFIES)</p><ol start="3"><li><p>在参照关系中插入元组时的问题,这时系统可能采取的作法有:<br>a) 受限插入<br>b) 递归插入</p></li><li><p>修改关系中主码的问题</p></li></ol><p>一般是不能用UPDATE语句修改关系主码的.如果需要修改主码值,只能先删除该元组,然后再把具有新主码值的元组插入到关系中.</p><p>如果允许修改主码,首先要保证主码的唯一性和非空,否则拒绝修改.然后要区分是参照关系还是被参照关系.</p><p>详细讨论可以参见《概论》10.2.</p><ol start="6"><li>假设有下面两个关系模式:</li></ol><p>职工(职工号,姓名,年龄,职务,工资,部门号),其中职工号为主码;</p><p>部门(部门号,名称,经理名,电话),其中部门号为主码;</p><p>用SQL语言定义这两个关系模式,要求在模式中完成以下完整性约束条件的定义:<br>定义每个模式的主码;定义参照完整性;定义职工年龄不得超过60岁.</p><p>答</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> DEPT</span><br><span class="line">(Deptno NUMBER(<span class="number">2</span>),</span><br><span class="line">Deptname <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">Manager <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">PhoneNumber <span class="type">Char</span>(<span class="number">12</span>)</span><br><span class="line"><span class="keyword">CONSTRAINT</span> PK_SC <span class="keyword">PRIMARY</span> KEY (Deptno));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EMP(Empno NUMBER(<span class="number">4</span>),</span><br><span class="line">Ename <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">Age NUMBER(<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Age《<span class="operator">=</span><span class="number">60</span>),</span><br><span class="line">Job <span class="type">VARCHAR</span>(<span class="number">9</span>),</span><br><span class="line">Sal NUMBER(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">Deptno NUMBER(<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> FK_DEPTNO</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (Deptno)</span><br><span class="line"><span class="keyword">REFERENCES</span> DEPT(Deptno));</span><br></pre></td></tr></table></figure><ol start="7"><li>关系系统中,当操作违反实体完整性,参照完整性和用户定义的完整性约束条件时,一般是如何分别进行处理的</li></ol><p>答:</p><p>对于违反实体完整性和用户定义的完整性的操作一般都采用拒绝执行的方式进行处理.而对于违反参照完整性的操作,并不都是简单地拒绝执行,有时要根据应用语义执行一些附加的操作,以保证数据库的正确性.具体的处理可以参见上面第5题或《概论》10.2中相应部分.</p><ol start="8"><li>试述你了解的某一个实际的DBMS产品的完整性控制策略.</li></ol><p>答:</p><p>不同的DBMS产品以及同一产品的不同版本的完整性控制策略各不相同,读者要去了解某一个DBMS产品的完整性控制策略.</p><p>《概论》上10.3 简单介绍了有关ORACLE数据库的完整性控制策略.</p><h1 id="第十二章-数据库技术新发展"><a href="#第十二章-数据库技术新发展" class="headerlink" title="第十二章 数据库技术新发展"></a>第十二章 数据库技术新发展</h1><ol><li>试述数据库技术的发展过程.</li></ol><p>答案要点:</p><ol><li>数据模型是数据库系统的核心和基础.数据库技术的三个发展阶段应该按照数据模型的进展来界定.按照数据模型的进展,数据库技术可以相应地分为三个发展阶段.</li><li>数据模型的发展经历了格式化数据模型(包括层次数据模型和网状数据模型),关系数据模型两个阶段,以面向对象数据模型为代表的非传统数据模型的阶段.</li><li>同学们可以从每一代数据库系统的主要特征,代表性系统,主要成就,优点和不足来了解数据库技术的发展过程.</li></ol><p>层次数据库系统和网状数据库系统的数据模型虽然分别为层次模型和网状模型,但实质上层次模型是网状模型的特例.它们都是格式化模型.它们从体系结构,数据库语言到数据存储管理均具有共同特征,是第一代数据库系统.</p><p>关系数据库系统支持关系模型.关系模型不仅简单,清晰,而且有关系代数作为语言模型,有关系数据理论作为理论基础.因此,关系数据库系统具有形式基础好,数据独立性强,数据库语言非过程化等特色,标志着数据库技术发展到了第二代.</p><p>第二代数据库系统的数据模型虽然描述了现实世界数据的结构和一些重要的相互联系,但是仍不能捕捉和表达数据对象所具有的丰富而重要的语义,因此尚只能属于语法模型.</p><p>第三代的数据库系统将是以更加丰富的数据模型和更强大的数据管理功能为特征,从而满足传统数据库系统难以支持的新的应用要求.</p><ol start="2"><li>当前数据库技术发展的主要特征是什么</li></ol><p>答案要点:</p><p>新一代数据库技术的特点是:</p><p>(1) 面向对象的方法和技术对数据库发展的影响最为深远,数据库研究人员借鉴和吸收了面向对象的方法和技术,提出了面向对象数据模型(简称对象模型).该模型克服了传统数据模型的局限性,促进了数据库技术在一个新的技术基础上继续发展.</p><p>(2) 数据库技术与多学科技术的有机结合,计算机领域中其他新兴技术的发展对数据库技术产生了重大影响.传统的数据库技术和其他计算机技术如,网络通信技术,人工智能技术,面向对象程序设计技术,并行计算技术移动计算技术等的互相结合,互相渗透,使数据库中新的技术内容层出不穷.</p><p>(3) 面向应用领域的数据库技术的研究在传统数据库系统基础上,结合各个应用领域的特点,研究适合该应用领域的数据库技术,如数据仓库,工程数据库,统计数据库,科学数据库,空间数据库,地理数据库等,这是当前数据库技术发展的又一重要特征.</p><p>解析<br>我们可以用一个三维空间的视图,比较清晰地从数据模型,新技术内容,应用领域三个方面描述新一代数据库系统及其相互关系.</p><ol start="3"><li>试述第一,二代数据库系统的主要成就.</li></ol><p>答案要点:</p><p>第一代数据库系统指层次和网状数据库系统,其代表是:</p><p>(1) 1969年IBM公司研制的层次模型的数据库管理系统IMS.</p><p>(2) 美国数据库系统语言协商会CODASYL下属的数据库任务组DBTG对数据库方法进行了系统的研究,探讨,于20世纪60年代末70年代初提出了若干DBTG报告.DBTG 报告确定并建立了数据库系统的许多概念,方法和技术.DBTG所提议的方法是基于网状结构的.它是数据库网状模型的典型代表.在DBTG方法和思想的指引下数据库系统的实现技术不断成熟,开发了许多商品化的数据库管理系统,它们都是基于网状模型或层次模型的.</p><p>可以说,层次数据库是数据库系统的先驱,而网状数据库则是数据库概念,方法,技术的奠基.它们是数据库技术中研究得最早的两种数据库系统.支持关系数据模型的关系数据库系统是第二代数据库系统.</p><p>20世纪70年代是关系数据库理论研究和原型开发的时代,.其中以IBM San Jose研究室开发的System R和Berkeley大学研制的INGRES为典型代表.经过大量的高层次的研究和开发取得了一系列的成果,.主要是:</p><p>(1) 奠定了关系模型的理论基础,给出了人们一致接受的关系模型的规范说明.</p><p>(2) 研究了关系数据语言,有关系代数,关系演算,SQL语言及QBE等.这些描述性语言一改以往程序设计语言和网状,层次数据库系统中数据库语言的风格,以其易学易懂的优点得到了最终用户的喜爱,为20世纪80年代数据库语言标准化打下了基础.</p><p>(3) 研制了大量的RDBMS的原型,攻克了系统实现中查询优化,并发控制,故障恢复等一系列关键技术.不仅大大丰富了DBMS实现技术和数据库理论,更重要的是促进了RDBMS产品的蓬勃发展和广泛应用.</p><p>在计算机领域中把20世纪70年代称为数据库时代.20世纪80年代几乎所有新开发的系统均是关系的.关系数据库系统从实验室走向了社会,数据库技术日益广泛地应用到企业管理,情报检索,辅助决策等各个方面,成为实现和优化信息系统的基础和基本技术.</p><ol start="4"><li>第三代数据库系统的主要特点是什么</li></ol><p>答:<br>经过多年的研究和讨论,对第三代数据库系统的基本特征已有了共识.</p><p>(1)第三代数据库系统应支持数据管理,对象管理和知识管理,除提供传统的数据管理服务外,第三代数据库系统将支持更加丰富的对象结构和规则,应该集数据管理,对象管理和知识管理为一体.由此可以导出第三代数据库系统必须支持OO数据模型.</p><p>(2)第三代数据库系统必须保持或继承第二代数据库系统的技术,第三代数据库系统应继承第二代数据库系统已有的技术,.如第二代数据库系统的非过程化数据存取方式和数据独立性.不仅能很好的支持对象管理和规则管理,而且能更好地支持原有的数据管理,支持多数用户需要的即席查询等.</p><p>(3)第三代数据库系统必须对其他系统开放数据库系统的开放性表现在:支持数据库语言标准;在网络上支持标准网络协议;系统具有良好的可移植性,可连接性,可扩展性和可互操作性等.</p><ol start="5"><li>试述数据模型在数据库系统发展中的作用和地位.</li></ol><p>答案要点:</p><ol><li>数据模型是数据库系统的核心和基础.</li><li>数据库的发展集中表现在数据模型的发展.</li></ol><ol start="6"><li>请用实例阐述数据库技术与其他学科的技术相结合的成果.<br>答案要点:</li></ol><p>数据库技术与其他学科的内容相结合,是新一代数据库技术的一个显著特征,涌现出各种新型的数据库系统.例如:</p><ul><li>数据库技术与分布处理技术相结合,出现了分布式数据库系统;</li><li>数据库技术与并行处理技术相结合,出现了并行数据库系统;</li><li>数据库技术与人工智能技术相结合,出现了知识库系统和主动数据库系统;</li><li>数据库技术与多媒体技术相结合,出现了多媒体数据库系统;</li><li>数据库技术与模糊技术相结合,出现了模糊数据库系统; 等等.</li></ul><ol start="7"><li>请阐述以下数据库系统的主要概念,研究的主要问题及其发展过程:</li></ol><p>分布式数据库系统,并行数据库系统,主动数据库系统,多媒体数据库系统,模糊数据库系统.</p><p>答案要点:</p><p>下面仅仅给出有关概念,它们研究的主要问题及其发展过程请参见教科书《概论》.</p><p>分布式数据库系统:分布式数据库是由一组数据组成的,这组数据分布在计算机网络的不同计算机上,网络中的每个结点具有独立处理的能力(称为场地自治),可以执行局部应用.同时,每个结点也能通过网络通信子系统执行全局应用.</p><p>并行数据库系统:并行数据库系统是在并行机上运行的具有并行处理能力的数据库系统.并行数据库系统是数据库技术与并行计算技术相结合的产物.</p><p>主动数据库系统:主动数据库是相对于传统数据库的被动性而言的.主动数据库能根据数据库的当前状态,主动适时地做出反应,执行某些操作,向用户提供有关信息.主动数据库是传统数据库技术与人工智能技术,面向对象技术相结合的产物.</p><p>多媒体数据库系统:可实现对格式化和非格式化的多媒体数据的存储,管理和查询的数据库系统.</p><p>模糊数据库系统:存储,组织,管理和操作模糊数据的数据库系统.</p><ol start="8"><li>试述数据仓库的产生背景.</li></ol><p>答案要点:</p><ol><li>数据库技术的发展和广泛应用使许多部门,企业积累了大量的原始数据,这些数据是宝贵的资源</li><li>对这些数据的分析和利用可以了解企业运行的情况,发现存在的问题,预测未来的趋势.</li><li>数据库系统作为数据管理的先进技术已经成功用于事务处理.但是它</li></ol><p>对分析处理的支持一直不能令人满意,具体表现在:<br>(1) 分析处理时性能低.<br>(2) 分析的数据对象分散,而且不一致,即缺乏对数据的清洗,集成能力.<br>(3) 事务处理系统不具备动态集成的能力.<br>(4) 系统缺乏对历史数据的有效组织和存储能力,而分析方法必须以大量的历史数据为依托.<br>(5) 在事务处理系统中存储的是细节数据,不适合进行分析处理,而事务处理系统又不具备对数据的综合能力.</p><p>总之,DSS对数据在空间和时间的广度上都有了更高的要求,.而事务处理环境难以满足这些要求.在事务型环境中直接构建分析型应用是一种失败的尝试.数据仓库正是为了构建这种新的分析处理环境而出现的一种数据存储和组织技术.但是数据仓库的主要驱动力并不是过去的缺点,而是市场商业经营行为的改变,市场竞争要求捕获和分析事务级的业务数据.</p><ol start="9"><li>数据仓库数据的基本特征是什么</li></ol><p>答案要点:四个基本特征是:</p><p>· 数据仓库的数据是面向主题的<br>· 数据仓库的数据是集成的<br>· 数据仓库的数据是不可更新的<br>· 数据仓库的数据是随时间不断变化的</p><ol start="10"><li>什么是联机分析处理 什么是数据挖掘</li></ol><p>答案要点:</p><p>联机分析处理OLAP是以海量数据为基础的复杂分析技术.</p><p>OLAP支持各级管理决策人员从不同的角度,快速灵活地对数据仓库中的数据进行复杂查询和多维分析处理,并且能以直观易懂的形式将查询和分析结果提供给决策人员,以方便他们及时掌握企业内外的情况,辅助各级领导进行正确决策,提高企业的竞争力</p><p>数据挖掘是从超大型数据库(VLDB)或数据仓库中发现并提取隐藏在内的模式的过程,这些模式是有效的,新颖的,有潜在使用价值的和易于理解的.目的是帮助决策者寻找数据间潜在的关联,发现经营者被忽略的要素,而这些要素对预测趋势,决策行为也许是十分有用的信息.</p><ol start="11"><li>基于数据库技术的DSS解决方案是什么</li></ol><p>答:</p><p>基于数据库技术的DSS的解决方案是: DW+OLAP+DM DSS的可行方案</p><p>数据仓库,联机分析处理和数据挖掘是作为三种独立的信息处理技术出现的.数据仓库用于数据的存储和组织,OLAP集中于数据的分析,数据挖掘则致力于知识的发现.由于这三种技术内在的联系性和互补性,将它们结合起来是一种新的DSS构架.是DSS有效而可操作的整体解决方案.</p><ol start="12"><li>什么是工程数据库</li></ol><p>答:</p><p>工程数据库是一种能存储和管理各种工程设计图形和工程设计文档,并能为工程设计提供各种服务的数据库.<br>主要应用于CAD&#x2F;CAM,CIM,CASE等工程应用领域.</p><p>工程数据库中,由于传统的数据模型难以满足工程应用的要求,需要运用新的模型技术,如扩展的关系模型,语义模型,面向对象的数据模型.</p><p>工程数据库管理系统的功能与传统数据库管理系统有很大不同.</p><ol start="13"><li>什么是统计数据库</li></ol><p>答:</p><p>统计数据库是一种用来对统计数据进行存储,统计,分析的数据库系统.</p><p>统计数据具有层次型特点,但并不完全是层次型结构.统计数据也有关系型特点,但关系型也不完全满足需要.统计数据具有一些特殊的性质,例如:</p><ol><li>分类属性和统计属性</li><li>多维性</li><li>分类属性的层次结构</li><li>微数据和宏数据之分</li></ol><p>统计数据库中常用的操作有:抽样,邻近搜索,估计与插值,转置,聚集及复杂的分析操作.这些操作不同于关系数据库中传统的查询,增加,删除,修改操作.人们希望能从DMBS一级来支持以上的数据特性和操作.因此,研究和发展了统计数据库技术.</p><p>统计数据库在安全性方面有特殊的要求,要防止某些用户在统计数据库中利用对统计数据(如综合数据)的合法查询推导出该用户无权了解的某一个体的具体数据.</p><ol start="14"><li>什么是空间数据库</li></ol><p>答:</p><p>空间数据库系统是描述,存储和处理空间数据及其属性数据的数据库系统.</p><p>空间数据是用于表示空间物体的位置,形状,大小和分布特征等诸方面信息的数据.</p><p>空间数据的特点是不仅包括物体本身的空间位置及状态信息,还包括表示物体的空间关系(即拓扑关系)的信息.</p><p>空间数据库是随着地理信息系统(GIS)的开发和应用而发展起来的数据库新技术.目前,空间数据库系统不是独立存在的系统,它是和应用紧密结合,大多数作为地理信息系统的基础和核心的形式出现.</p><p>空间数据库的研究涉及计算机科学,地理学,地图制图学,摄影测量与遥感,图像处理等多个学科.空间数据库技术研究的主要内容包括:</p><ol><li>空间数据模型</li><li>空间数据查询语言</li><li>空间数据库管理系统</li></ol><p>等等.</p><h1 id="第十三章-面向对象程数据库系统"><a href="#第十三章-面向对象程数据库系统" class="headerlink" title="第十三章 面向对象程数据库系统"></a>第十三章 面向对象程数据库系统</h1><ol><li>面向对象程序设计的基本思想是什么 它的主要特点是什么</li></ol><p>答案要点:</p><p>面向对象程序设计的基本思想是封装和可扩展性.</p><p>封装的特点:</p><p>面向对象程序设</p><p>计就是把数据结构和数据结构上的操作算法封装在一个对象之中.</p><p>对象是以对象名封装的数据结构和可施加在这些数据上的私有操作.对象的数据结构描述了对象的状态,对象的操作是对象的行为.</p><p>面向对象程序设计中,操作名列在封装对象的界面上,当其他对象要启动它的某个操作时,以操作名发一条消息,该对象接受消息,操作动作起来,完成对私有数据的加工.当一个面向对象的程序运行完毕时,各对象也就达到了各自的终态.输入,输出也由对象自己完成.</p><p>这种全封装的计算实体给软件带来了模块性,安全性等显著优点.因为它基本没有数据耦合,对象间没有因操作而产生的边界效应,出了错可以很快找到原因,所以易于维护和修改.</p><p>可扩展性的特点:</p><p>面向对象程序设计的可扩展性体现在继承性和行为扩展两个方面.<br>因为对象具有一种层次关系.每个对象可以有子对象.子对象可以继承父对象(及其祖先对象)的数据结构和操作,继承的部分就可以重用.<br>另一方面子对象还可以增加新的数据结构和新的操作.新增加的部分就是子对象对父对象发展的部分.</p><p>面向对象程序设计的行为扩展是指可以方便地增加程序代码来扩展对象的行为而不会影响该对象上的其他操作.</p><ol start="2"><li>定义并解释OO模型中以下核心概念: 对象与对象标识,封装,类,类层次.</li></ol><p>答案要点:</p><ol><li>对象与对象标识OID</li></ol><p>现实世界的任一实体被模型化为一个对象,每个对象有一个唯一的标识,称为对象标识.</p><ol start="2"><li>封装</li></ol><p>每一个对象是其状态与行为的封装,其中状态是该对象一系列属性值的集合,而行为是在对象状态上操作的集合,操作也称为方法.<br>3) 类</p><p>共享同样属性和方法集的所有对象构成了一个对象类简称类,一个对象是某一类的一个实例.类的属性的定义域可以是任何类,即可以是基本类也可以是包含属性和方法的一般类,还也可是这个类自身.<br>4) 类层次</p><p>在一个面向对象数据库模式中,可以定义一个类(如C1)的子类(如C2),类C1称为类C2的超类(或父类).子类(如C2)还可以再定义子类(如C3).这样,面向对象数据库模式的一组类形成一个有限的层次结构,称为类层次.</p><p>3.OO模型中对象标识与关系模型中的”码”有什么区别</p><p>答案要点:</p><p>对象标识具有永久持久性.一个对象一经产生系统就给它赋于一个在全系统中唯一的对象标识符,直到它被删除.对象标识是由系统统一分配的,用户不能对对象标识符进行修改.对象标识是稳定的,独立于值的,它不会因为对象中某个值的修改而改变.</p><p>关系模型中的”码”是值标识,不具有永久持久性,只具有程序内持久性.码是由用户建立的,用来区分关系的不同元组.</p><p>4.什么是单继承 什么是多重继承 继承性有什么优点</p><p>答案要点:</p><p>若一个子类只能继承一个超类的特性(包括属性,方法和消息),这种继承称为单继承;若一个子类能继承多个超类的特性,这种继承称为多重继承.</p><p>继承性优点:</p><ol><li>它是建模的有力工具,提供了对现实世界简明而精确的描述.</li><li>它提供了信息重用机制.由于子类可以继承超类的特性,这就可以避免许多重复定义.</li></ol><ol start="5"><li>什么是操作的重载 在OODB中为什么要滞后联编</li></ol><p>答案要点:<br>在OO模型中对于同一个操作,可以按照类的不同,重新定义操作的实现,这称为操作的重载.这样,同一个操作名就与不同的实现方法,与不同的参数相联系.</p><p>为了提供这个功能,OODBMS不能在编译时就把操作名联编到程序上,必须在运行时根据实际请求中的对象类型和操作来选择相应的程序,把操作名与它联编上(即把操作名转换成该程序的地址),这个推迟的转换称为滞后联编.</p><ol start="6"><li>什么是OODB模式演进 为什么面向对象数据库模式的修改要比关系模式的修改复杂得多</li></ol><p>答案要点:</p><p>面向对象数据库模式是类的集合.模式为适应需求的变化会随着时间而变化,这称为模式演进.模式演进包括创建新的类,删除旧的类,修改类的属性和操作等.</p><p>面向对象数据库模式的修改要比关系模式的修改复杂的原因是:</p><ol><li>模式改变频繁<br>使用OODB系统的应用通常需要频繁地改变OODB数据库模式.例如OODB常运用于工程设计环境中,设计环境特征之一就是不断变化.</li><li>模式修改复杂<br>OO模型具有很强的建模能力和丰富的语义,包括类本身的语义,类属性之间和类之间丰富的语义联系,这使得模式修改操作的类型复杂多样.</li><li>OODB中模式演进往往是动态的,使得实现技术更加复杂.</li></ol><ol start="7"><li>什么是对象-关系数据库 它的主要特点是什么 常用的实现方法有哪些</li></ol><p>答案要点:</p><p>对象-关系数据库系统是将关系数据库系统与面向对象数据库系统两方面的特征相结合,不仅支持核心的面向对象数据模型,而且支持传统数据库系统所具有的特征.</p><p>主要特点有:</p><ol><li>具有原来关系数据库的各种特点;</li><li>扩充数据类型;</li><li>支持复杂对象;</li><li>支持继承的概念;</li><li>提供通用的规则系统;</li></ol><p>实现对象-关系数据库系统的方法主要有以下五类.</p><ol><li><p>从头开发对象-关系DBMS.</p></li><li><p>在现有的关系型DBMS基础上进行扩展.扩展方法有两种:<br>a) 对关系型DBMS核心进行扩充,逐渐增加对象特性.<br>b) 不修改现有的关系型DBMS核心,而是在现有关系型DBMS外面加一个包装层.</p></li><li><p>将现有的关系型DBMS与其他厂商的对象-关系型DBMS连接在一起,使现有的关系型DBMS直接而迅速地具有了对象-关系特征.连接方法主要有两种:<br>a) 关系型DBMS使用网关技术与其他厂商的对象-关系型DBMS连接.<br>b) 将对象-关系型引擎与关系型存储管理器结合起来,即以关系型DBMS作为系统的最底层,对象-关系型系统作为上层.</p></li><li><p>将现有的OO型DBMS与其他厂商的对象-关系型DBMS连接在一起,使现有的面向对象型DBMS直接而迅速地具有了对象-关系特征.</p></li><li><p>扩充现有的面向对象的DBMS,使之成为对象-关系型DBMS.</p></li></ol><h1 id="第十四章-分布式数据库系统"><a href="#第十四章-分布式数据库系统" class="headerlink" title="第十四章 分布式数据库系统"></a>第十四章 分布式数据库系统</h1><ol><li>什么样的数据库系统是分布式数据库系统 图14.1的系统配置在什么情况下只能算分散的数据库系统 在什么条件下才是分布式数据库系统</li></ol><p>答案要点:</p><p>分布式数据库是由一组数据组成的,这组数据分布在计算机网络的不同计算机上,网络中的每个结点具有独立处理的能力(称为场地自治),可以执行局部应用.同时,每个结点也能通过网络通信子系统执行全局应用.</p><p>分布式数据库定义的要点:分布性,逻辑整体性,自治性和协作性.</p><p>解析:</p><ol><li>分布性,数据库中的数据不是存储在同一场地上,这就可以和集中式数据库相区别.</li><li>逻辑整体性,这些数据逻辑上是互相联系的,是一个整体,逻辑上如同集中数据库.</li><li>自治性,分布数据库中每个结点上的DBMS具有独立处理的能力(如果没有连入网络,也是一个完整的DBMS).</li><li>协作性,分布数据库中各个结点上的DBMS能相互协调,执行全局应用.</li></ol><p>答案要点:</p><p>《概论》图14.1中,如果用户既可以通过客户机对本地服务器中的数据库执行局部应用,也可以对两个或两个以上结点中的数据库执行全局应用,这样的系统是分布式数据库系统.不支持全局应用的系统不能称为分布式数据库系统,即只是分散的数据库系统.</p><p>(详细说明参见《概论》14.1.1)</p><ol start="2"><li>分布式数据库系统有什么特点</li></ol><p>答案要点:</p><p>分布式数据库系统是在集中式数据库系统技术的基础上发展起来的,但不是简单地把集中式数据库分散地实现,它是具有自己的性质和特征的系统.<br>数据独立性:除了数据的逻辑独立性与物理独立性外,还具有数据分布独立性亦称分布透明性.</p><p>集中与自治相结合的控制结构:各局部的DBMS可以独立地管理局部数据库,具有自治的功能.同时又有集中控制机制,协调各局部DBMS的工作,执行全局应用.</p><p>数据可以适当冗余以提高系统的可靠性,可用性和性能.</p><p>全局的一致性,可串行性和可恢复性.分布式数据库系统中各局部数据库应满足集中式数据库的一致性,并发事务的可串行性和可恢复性.除此以外还应保证数据库的全局一致性,全局并发事务的可串行性和系统的全局可恢复性.</p><p>(详细说明参见《概论》14.1.2).</p><ol start="3"><li>试述研制分布式数据库系统的目的和动机.</li></ol><p>答案要点:研制分布式数据库系统的目的和动机,主要包括技术和组织两方面.</p><p>适应部门分布的组织结构,降低费用;<br>提高系统的可靠性和可用性;<br>充分利用数据库资源,提高数据库的利用率和共享程度;<br>逐步地扩展系统处理能力和系统规模.</p><p>(详细说明参见《概论》14.1.3).</p><ol start="4"><li>试述分布式数据库系统的模式结构.</li></ol><p>答案要点:</p><p>分布式数据库系统的模式结构可以分为两大部分:集中式数据库系统的模式结构和分布式数据库系统增加的模式级别,其中包括:</p><ol><li>全局外模式,它们是全局应用的用户视图,是全局概念模式的子集.</li><li>全局概念模式,它定义分布式数据库中数据的整体逻辑结构,使得数据如同没有分布一样.</li><li>分片模式,定义片段以及全局关系到片段的映象.</li><li>分布模式,定义片段的存放结点.分布模式的映象类型确定了分布式数据库是冗余的还是非冗余的.</li></ol><p>(详细可参考《概论》图14.3分布式数据库系统的模式结构).</p><ol start="5"><li>什么是数据分片 有几种分片方式 数据分片的目的是什么 有什么优点</li></ol><p>答案要点:</p><p>数据分片就是将数据表按照一定条件划分成若干子集,每个子集称为一个片段.<br>分片的方式有多种,水平分片和垂直分片是两种基本的分片方式,混合分片和导出分片是较复杂的分片方式.</p><p>水平分片是指按一定的条件将关系表按行(水平方向)分为若干不相交的子集,每个子集为关系的一个片段.</p><p>垂直分片是指将关系按列(垂直方向)分为若干子集.垂直分片的各个片段都要包含关系的码.这样才能从各个片段重构原来的关系.</p><p>导出分片是指导出水平分片,即水平分片的条件不是本身属性的条件而是其他关系的属性的条件.</p><p>混合分片是指按上述三种分片方式得到的片段继续按另一种方式分片.</p><p>数据分片的优点是:数据不是按照关系而是按片段来存放,有利于更好地根据用户需求来组织数据的分布,也有利于控制数据的冗余度.</p><ol start="6"><li>试述分布透明性的内容.</li></ol><p>答案要点:</p><p>分布透明性包括分片透明性,位置透明性和局部数据模型透明性.</p><p>分片透明性指用户或应用程序只对全局关系进行操作而不必考虑关系的分片.当分片模式改变了,由于全局模式到分片模式的映象,全局模式不变,应用程序不必改写.</p><p>位置透明性指用户或应用程序不必了解片段的存储场地,当存储场地改变了,由于分片模式到分布模式的映象,应用程序不必改变.同时,若片段的重复副本数目改变了,数据的冗余度改变了,用户也不必关心如何保持各副本的一致性,这就是重复副本的透明性.</p><p>局部数据模型透明性指用户或用户程序不必了解局部场地上使用的是哪种数据模型.</p><ol start="7"><li>什么是同构型D-DBMS 什么是异构型D-DBMS</li></ol><p>答案要点:</p><p>D-DBMS的同构和异构可以有三级:硬件级,操作系统级和局部DBMS级.其中最主要的是局部DBMS这一级,因为硬件和操作系统的不同将由通信软件处理和管理.所以,同构型D-DBMS定义为:在分布数据库系统中若每个结点的局部数据库具有相同的DBMS则成为同构型D-DBMS;若各结点的局部数据库具有不同的DBMS,则成为异构型的D-DBMS.</p><p>(详细说明参见《概论》14.2.4)</p><ol start="8"><li>设在《概论》14.2.3节的分布式数据库系统例子中,还有全局关系SC(SNO,CNO,G),它具有两个导出分片SC_A,SC_B,分别存储理学院和文学院学生的选课记录.SC_A存放在场地4,SC_B存放在场地5.今有一个稍复杂的查询,从终端输入一个课程号,查找选修该课程的学生学号和姓名,并把它们显示在屏幕上.请写出具有不同层次分布透明性(类比例子中的三种情况)的应用程序.不必给出细节,只需写出算法思想.</li></ol><p>情况1 若系统具有分片透明性,则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scanf(〃<span class="operator">%</span> s〃,SCnumber); <span class="comment">/*从终端读入课程号到变量SCnumber中 */</span></span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">SELECT</span> Sno,Sname <span class="keyword">INTO</span> :SNO, :NAME</span><br><span class="line"><span class="operator">/</span> <span class="operator">*</span> SNO,NAME为程序变量<span class="operator">*</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">FROM</span> SC,Student <span class="comment">/*在全局关系SC,Student中查找*/</span></span><br><span class="line"><span class="keyword">WHERE</span> SC.Cno <span class="operator">=</span>:SCnumber <span class="keyword">AND</span> SC.Sno<span class="operator">=</span>Student.Sno;</span><br><span class="line">Printf(〃<span class="operator">%</span> s,<span class="operator">%</span> s〃,SNO,NAME); <span class="comment">/*把SNO,NAME输出在屏幕上*/</span></span><br></pre></td></tr></table></figure><p>情况2 若系统具有位置透明性,但不具有分片透明性,则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanf(〃<span class="operator">%</span> s〃,SCnumber);</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">SELECT</span> Sno,Sname <span class="keyword">INTO</span> :SNO, :NAME</span><br><span class="line"><span class="keyword">FROM</span> SC_A,S_A</span><br><span class="line"><span class="keyword">WHERE</span> SC_A.Cno <span class="operator">=</span>:SCnumber <span class="keyword">AND</span> SC_A.Sno<span class="operator">=</span>S_A.Sno;</span><br><span class="line">If(<span class="operator">!</span> FOUND)&#123;</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">SELECT</span> Sno,Sname <span class="keyword">INTO</span> :SNO, :NAME</span><br><span class="line"><span class="keyword">FROM</span> SC_B,S_B</span><br><span class="line"><span class="keyword">WHERE</span> SC_B.Cno <span class="operator">=</span>:SCnumber <span class="keyword">AND</span> SC_B.Sno<span class="operator">=</span>S_B.Sno;</span><br><span class="line">&#125;</span><br><span class="line">Printf(〃<span class="operator">%</span> s,<span class="operator">%</span> s〃,SNO,NAME);</span><br></pre></td></tr></table></figure><p>情况3 若系统只具有局部数据模型透明性,不具有位置透明性(当然也就不具有分片透明性),则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Scanf(〃<span class="operator">%</span> s〃,SCnumber);</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">SELECT</span> Sno,Sname <span class="keyword">INTO</span> :SNO,:NAME</span><br><span class="line"><span class="keyword">FROM</span> SC_A <span class="keyword">AT</span> Site4, S_A <span class="keyword">AT</span> Site1</span><br><span class="line"><span class="comment">/*先在场地4的片段SC_A和场地1的片段S_A中查找*/</span></span><br><span class="line"><span class="keyword">WHERE</span> SC_A.Cno <span class="operator">=</span>:SCnumber <span class="keyword">AND</span> SC_A.Sno<span class="operator">=</span>S_A.Sno;</span><br><span class="line">If(<span class="operator">!</span> FOUND)&#123;</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">SELECT</span> Sno,Sname <span class="keyword">INTO</span> :SNO,:NAME</span><br><span class="line"><span class="keyword">FROM</span> SC_B <span class="keyword">AT</span> Site5,S_B <span class="keyword">AT</span> Site2</span><br><span class="line"><span class="comment">/*再在场地5的片段SC_B和场地2的片段S_B中查找*/</span></span><br><span class="line"><span class="comment">/*也可以在场地5的片段SC_B和场地3的片段S_B中查找*/</span></span><br><span class="line"><span class="keyword">WHERE</span> SC_B.Cno <span class="operator">=</span>:SCnumber <span class="keyword">AND</span> SC_B.Sno<span class="operator">=</span>S_B.Sno;</span><br><span class="line">&#125;</span><br><span class="line">Printf(〃<span class="operator">%</span> s,<span class="operator">%</span> s〃,SNO,NAME);</span><br></pre></td></tr></table></figure><ol start="9"><li>试述下列概念:两段提交协议(2PC);分布事务的原子性;全局死锁.</li></ol><p>答案要点:<br>2PC:2PC把一个分布事务的事务管理分为协调者和参与者.<br>2PC的第一阶段:协调者向所有参与者发出”准备提交”信息.如果某个参与者准备提交,就回答”就绪”信息,否则回答”撤销”信息.参与者在回答前,应把有关信息写入自己的日志中.协调者在发出准备提交信息前也要把有关信息写入自己的日志中.如果在规定时间内协调者收到了所有参与者”就绪”的信息,则将作出提交的决定,否则将作出撤销的决定.</p><p>2PC的第二阶段:协调者将有关决定的信息先写入日志,然后把这个决定发送给的所有的参与者.所有参与者收到命令之后首先往日志中写入”收到提交(或撤销)”决定的信息,并向协调者发送”应答(ACK)”消息,最后执行有关决定.协调者收到所有参与者的应答消息后,一个事务的执行到此结束,有关日志信息可以脱机保存.</p><p>分布事务的原子性:分布事务的原子性就应该是:组成一个全局事务的所有子事务要么一致地全部提交,要么一致地全部滚回.</p><p>全局死锁:全局事务执行时发生的涉及两个以上场地上的死锁.</p><ol start="10"><li>在分布式数据库系统中,对多副本的封锁有几种解决方法</li></ol><p>处理多副本的封锁可采取如下几种方法:</p><ol><li>对写操作,要申请对所有副本的X锁.对于读操作,只要申请对某个副本的S锁.</li><li>无论是写操作还是读操作都要对多数(大于半数)副本申请X锁或S锁.</li><li>规定某个场地上的副本为主副本,所有的读写操作均申请对主副本的封锁.</li></ol><h1 id="第十五章-并行数据库系统"><a href="#第十五章-并行数据库系统" class="headerlink" title="第十五章 并行数据库系统"></a>第十五章 并行数据库系统</h1><ol><li>什么是并行数据库系统</li></ol><p>答案要点:<br>并行数据库系统是在并行机上运行的具有并行处理能力的数据库系统.并行数据库系统是数据库技术与并行计算技术相结合的产物.</p><ol start="2"><li>试述并行数据库系统的研制目标.</li></ol><p>答案要点:</p><p>并行数据库系统该实现如下目标:</p><ol><li>高性能<br>并行数据库系统通过将数据库管理技术与并行处理技术有机结合,发挥多处理机结构的优势,提供比相应的大型机系统更高的性能价格比和可用性.</li><li>高可用性<br>并行数据库系统可通过数据复制来增强数据库的可用性.</li><li>可扩充性<br>系统通过增加处理和存储能力来平滑地扩展性能,应具有线性伸缩比和线性加速比.</li></ol><p>具体说明可参考《概论》15.2.</p><ol start="3"><li>什么是并行数据库系统的伸缩比和加速比</li></ol><p>答案要点:</p><p>线性伸缩比是指当任务扩大N倍,系统处理和存储能力也扩大N倍时系统性能不变.<br>线性伸缩比&#x3D;(小任务在小系统上的运行时间)&#x2F;(大(N倍)任务在大任务上的运行时间)&#x3D;1<br>线性加速比是指当任务不变而系统处理和存储能力扩大N倍时,系统性能也提高N倍.<br>线性加速比&#x3D;(小系统上执行一个任务的时间)&#x2F;(大(N倍)系统上执行同一任务的时间)&#x3D;N</p><ol start="4"><li>并行数据库系统有哪几种体系结构 试比较它们的特点.</li></ol><p>答案要点:<br>从硬件结构来看,根据处理机与磁盘,内存的相互关系可以将并行计算机分为三种基本的体系结构:</p><p>·共享内存结构(SM);<br>·共享磁盘结构(SD);<br>·无共享资源结构(SN).</p><p>此外还有混合结构,即整个系统是Shared_Nothing结构而每个结点是Shared_Memory结构.这种结构综合了SM与SN的优点.</p><ol><li>SM并行结构<br>SM并行结构由多个处理机,一个共享内存(主存储器)和多个磁盘存储器构成.多处理机和共享内存由高速通讯网络连接,每个处理机可直接存取一个或多个磁盘,即所有内存与磁盘为所有处理机共享.</li><li>SD并行结构<br>SD并行结构由多个具有独立内存的处理机和多个磁盘构成.每个处理机都可以读写任何磁盘.</li><li>SN并行结构<br>SN并行结构由多个处理节点构成.每个处理节点具有自己独立的处理机,内存和磁盘存储器.多个处理机结点由高速通信网络连接.</li></ol><ol start="5"><li>并行数据库系统中并行查询优化的必要性和困难何在</li></ol><p>答案要点:</p><p>查询优化始终是数据库管理系统的重要组成部分,查询优化的目标在于提高执行效率.由于并行数据库环境中存在多个处理机,并行查询优化应尽可能地使每个操作并行处理,充分利用系统资源提高并行度来达到提高系统性能的目的.并行查询优化面临的两大困难在于:</p><ol><li>执行计划的搜索空间十分庞大</li><li>执行时的某些系统参数比如CPU数目,内存大小在优化时是未知的.</li></ol><ol start="6"><li>试述数据划分在并行查询处理中的重要性.</li></ol><p>答案要点:</p><p>数据划分是并行查询处理的重要基础.研究和实际表明,数据划分对于并行数据库系统的性能具有很大的影响.</p><p>通过将每个关系的数据划分为小的片段,并把这些小片段均匀地分布在系统的多个磁盘驱动器上可以降低数据的聚集度,使得每个操作能够由多个处理机来承担,从而减少查询的响应时间并提高整个系统的吞吐量.若负载不均,往往会造成多个处理机结点能力的浪费.所以使用正确的数据分布算法以达到负载均衡是并行数据库中数据分布的关键问题.</p><p>7.并行数据库系统中有哪几种常用的数据划分方法</p><p>答案要点:</p><p>划分数据时可以依据一个属性的值,也可以同时依据多个属性的值,前者称为一维数据划分,后者则称为多维数据划分.</p><p>一维数据划分方法相对比较简单,常用的数据划分方法有:</p><p>·轮转法<br>·Hash法<br>·值域划分法</p><p>此外,还有用户定义的划分法,模式划分法,Hybrid_Range划分法等.</p><ol start="8"><li>试述并行数据库系统与分布式数据库系统的区别.</li></ol><p>答案要点:</p><p>分布式数据库系统与并行数据库系统特别是与SN结构的并行数据库系<br>具有很多相似点:</p><ol><li>它们都是用网络连接各个数据处理结点;</li><li>整个网络中的所有结点构成一个逻辑上统一的整体;</li><li>用户可以对各个结点上的数据进行透明存取等等.</li></ol><p>分布式数据库系统和并行数据库系统的应用目标和具体实现方法不同,使得它们具有很大的不同:</p><ol start="4"><li>应用目标不同</li></ol><p>并行数据库系统的目标是充分发挥并行计算机的优势,利用各个处理机结点并行地完成任务,提高系统的整体性能.<br>分布式数据库系统的目标是实现场地自治和数据的全局透明共享,而不要求利用网络中的各个结点来提高系统处理性能.</p><ol start="5"><li>实现方式不同</li></ol><p>在并行数据库系统中各结点间采用高速网络互连,结点间的数据传输代价相对较低,因此当某些结点处于空闲状态时,可以将工作负载过大的结点上的部分任务通过高速网传送给空闲结点处理,从而实现系统的负载平衡.</p><p>在分布式数据库系统中,各结点间一般采用局域网或广域网相连,网络带宽较低,点到点的通信开销较大,因此在查询处理时一般应尽量减少结点间的数据传输量.</p><ol start="6"><li>各结点的地位不同</li></ol><p>在并行数据库系统中,不存在全局应用和局部应用的概念.各结点是非独立的.</p><p>而在分布式数据库系统中,各结点除了能通过网络协同完成全局事务外,更重要的是各结点具有场地自治性.</p><div class="article-footer fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p></div></section></div></article><div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/posts/SQlprocEx.html">SQL 存储过程练习</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/posts/SQLnfs.html">SQL 范式</a></div></section></div><div class="related-wrap md-text" id="comments"><section class="header cmt-title cap theme"><p>快来参与讨论吧~</p></section><section class="body cmt-body waline"><div id="waline_container" class="waline_thread"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div></section></div><footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">VITAN</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p></div></footer><div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right"><div class="widgets"><widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98"><span class="toc-text">一,选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%80%E7%AD%94%E9%A2%98"><span class="toc-text">二,简答题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98-1"><span class="toc-text">一.选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%80%E7%AD%94%E9%A2%98-1"><span class="toc-text">二,简答题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98-2"><span class="toc-text">一,选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%80%E7%AD%94%E9%A2%98-2"><span class="toc-text">二,简答题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98-3"><span class="toc-text">一,选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%80%E7%AD%94%E9%A2%98-3"><span class="toc-text">二,简答题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA"><span class="toc-text">第五章 关系数据理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98-4"><span class="toc-text">一,选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98-5"><span class="toc-text">一,选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%80%E7%AD%94%E9%A2%98-5"><span class="toc-text">二,简答题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98-6"><span class="toc-text">一,选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%80%E7%AD%94%E9%A2%98-6"><span class="toc-text">二,简答题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98-7"><span class="toc-text">一,选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%80%E7%AD%94%E9%A2%98-7"><span class="toc-text">二,简答题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98-8"><span class="toc-text">一,选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%AE%80%E7%AD%94%E9%A2%98"><span class="toc-text">三,简答题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%89%E6%8B%A9%E9%A2%98-9"><span class="toc-text">一,选择题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%AE%80%E7%AD%94%E9%A2%98-8"><span class="toc-text">二,简答题</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget></div></aside><div class="float-panel blur"><button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></button> <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg></button></div></div><div class="scripts"><script defer type="text/javascript">const ctx={date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前"},root:"/",search:{}};if(ctx.search.service="local_search","local_search"==ctx.search.service){let e=Object.assign({},'{"field":"all","path":"/search.json","content":true,"sort":"-date"}');ctx.search[ctx.search.service]=e}const def={avatar:"https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/avatar/round/3442075.svg",cover:"https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/cover/76b86c0226ffd.svg"},deps={jquery:"https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js",marked:"https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js"}</script><script defer type="text/javascript">const utils={css:(e,t,r,o)=>{var a,n=window.document,s=n.createElement("link");if(t)a=t;else{var i=(n.body||n.getElementsByTagName("head")[0]).childNodes;a=i[i.length-1]}var d=n.styleSheets;if(o)for(var l in o)o.hasOwnProperty(l)&&s.setAttribute(l,o[l]);s.rel="stylesheet",s.href=e,s.media="only x",function e(t){if(n.body)return t();setTimeout((function(){e(t)}))}((function(){a.parentNode.insertBefore(s,t?a:a.nextSibling)}));var f=function(e){for(var t=s.href,r=d.length;r--;)if(d[r].href===t)return e();setTimeout((function(){f(e)}))};function u(){s.addEventListener&&s.removeEventListener("load",u),s.media=r||"all"}return s.addEventListener&&s.addEventListener("load",u),s.onloadcssdefined=f,f(u),s},js:(e,t)=>new Promise((r,o)=>{var a=document.createElement("script");if(e.startsWith("/")&&(e=ctx.root+e.substring(1)),a.src=e,t)for(let e of Object.keys(t))a[e]=t[e];else a.async=!0;a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,r())},document.head.appendChild(a)}),jq:e=>{"undefined"==typeof jQuery?utils.js(deps.jquery).then(e):e()},onLoading:e=>{e&&$(e).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>')},onLoadSuccess:e=>{e&&$(e).find(".loading-wrap").remove()},onLoadFailure:e=>{e&&($(e).find(".loading-wrap svg").remove(),$(e).find(".loading-wrap").append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>'),$(e).find(".loading-wrap").addClass("error"))},request:(e,t,r,o)=>{let a=3;utils.onLoading(e),function n(){return new Promise((s,i)=>{let d=0,l=setTimeout(()=>{0===d&&(d=2,l=null,i("请求超时"),0==a&&o())},5e3);fetch(t).then((function(e){if(2!==d&&(clearTimeout(l),s(e),l=null,d=1),e.ok)return e.json();throw new Error("Network response was not ok.")})).then((function(t){a=0,utils.onLoadSuccess(e),r(t)})).catch((function(t){a>0?(a-=1,setTimeout(()=>{n()},5e3)):(utils.onLoadFailure(e),o())}))})}()}}</script><script>const sidebar={leftbar:()=>{l_body&&(l_body.toggleAttribute("leftbar"),l_body.removeAttribute("rightbar"))},rightbar:()=>{l_body&&(l_body.toggleAttribute("rightbar"),l_body.removeAttribute("leftbar"))},dismiss:()=>{l_body&&(l_body.removeAttribute("leftbar"),l_body.removeAttribute("rightbar"))},toggleTOC:()=>{document.querySelector("#data-toc").classList.toggle("collapse")}}</script><script defer src="/js/main.js?v=1.27.0" async></script><script defer type="module">import{init}from"https://unpkg.com/@waline/client@2.14.1/dist/waline.js";function load_comment(){if(!document.getElementById("waline_container"))return;utils.css("https://unpkg.com/@waline/client@2.14.1/dist/waline.css"),utils.css("https://gcore.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline-meta.css");var t=document.getElementById("waline_container").getAttribute("comment_id");t||(t=decodeURI(window.location.pathname));init(Object.assign({js:"https://unpkg.com/@waline/client@2.14.1/dist/waline.js",css:"https://unpkg.com/@waline/client@2.14.1/dist/waline.css",meta_css:"https://gcore.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline-meta.css",serverURL:"https://comment.ivitan.com",commentCount:!0,pageview:!1},{el:"#waline_container",path:t}))}window.addEventListener("DOMContentLoaded",t=>{load_comment()})</script><script defer>window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });</script><script>window.addEventListener("DOMContentLoaded",e=>{ctx.search={path:"/search.json"},utils.js("/js/search/local-search.js",{defer:!0})})</script><script>window.FPConfig={delay:0,ignoreKeywords:[],maxRPS:5,hoverDelay:25}</script><script defer src="https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script><script defer src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js"></script><script>// https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });</script><script>ctx.fancybox={selector:".swiper-slide img",css:"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css",js:"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js"};var selector="[data-fancybox]:not(.error)";ctx.fancybox.selector&&(selector+=", "+ctx.fancybox.selector);var needFancybox=0!==document.querySelectorAll(selector).length;if(!needFancybox){const e=document.getElementsByClassName("ds-memos");null!=e&&e.length>0&&(needFancybox=!0)}needFancybox&&(utils.css(ctx.fancybox.css),utils.js(ctx.fancybox.js,{defer:!0}).then((function(){Fancybox.bind(selector,{hideScrollbar:!1,Thumbs:{autoStart:!1},caption:(e,c)=>c.triggerEl.alt||null})})))</script><script>window.addEventListener("DOMContentLoaded",e=>{const t=document.getElementById("swiper-api");null!=t&&(utils.css("https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css"),utils.js("https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js",{defer:!0}).then((function(){const e=t.getAttribute("effect")||"";new Swiper(".swiper#swiper-api",{slidesPerView:"auto",spaceBetween:8,centeredSlides:!0,effect:e,loop:!0,pagination:{el:".swiper-pagination",clickable:!0},navigation:{nextEl:".swiper-button-next",prevEl:".swiper-button-prev"}})})))})</script><script>document.addEventListener("DOMContentLoaded",(function(){window.codeElements=document.querySelectorAll(".code"),window.codeElements.length>0&&(ctx.copycode={default_text:"Copy",success_text:"Copied",toast:"复制成功"},utils.js("/js/plugins/copycode.js"))}))</script></div></body></html>