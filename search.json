[{"title":"Hexo Github Actions","path":"/posts/GithubActions.html","content":"# Github Actions\n\n## 生成 SSH Key\n```ssh\nssh-keygen -t rsa -b 4096 -C \"emal@gmail.com\"\n```\n\n<!--more-->\n\n## 添加 Key 到 GitHub\n\n### 公钥\n\n仓库 --> Secrets --> Actions --> New repository secert\n\nName: HEXO_DEPLOY_KEY\nValue: id_rsa.pub 的值\n\n## 私钥\n仓库 --> Settings --> Deploy keys --> Add deploy key\n\nName: HEXO_DEPLOY_PUB\nValue: id_rsa  的值\n\n# 使用\n```yaml\nname: Hexo Deploy\n\non:\n  push:\n    branches: \n      - source\n\njobs:\n  build: \n    runs-on: ubuntu-latest \n    name: auto deploy\n    \n    steps:\n    - name: Setup Node.js 12.x\n      uses: actions/setup-node@master\n      with:\n        node-version: \"12.x\"\n\n    - name: Checkout Repository source branch\n      uses: actions/checkout@v2\n      with:\n        ref: source\n\n    - name: Generate Public Files\n      run: |\n        npm i\n        npm install hexo-cli -g\n        hexo clean && hexo generate\n\n    - name: Deploy Hexo\n      uses: peaceiris/actions-gh-pages@v3\n      with:\n        deploy_key: ${{ secrets.HEXO_DEPLOY_KEY }}\n        external_repository: ivitan/ivitan.github.io\n        publish_branch: master\n        publish_dir: ./public\n        commit_message: ${{ github.event.head_commit.message }}\n        user_name: 'Vitan'\n        user_email: 'vitan.me@gmail.com'\n    ```","tags":["Github"]},{"title":"ADB 提取系统 APK","path":"/posts/ADB-APK.html","content":"<!--more-->\n\n## 命令\n```adb\nadb connect ip\nadb shell \n\n# 查找 APK 路径，路径截止到 base.apk\npm list package -f | grep apkName\n\nadb pull APK_PATH Rename.apk\n```","tags":["Linux","Windows"],"categories":["Diary"]},{"title":"一键关闭多用户状态栏头像","path":"/posts/DeleteMutiUser.html","content":"> 一键关闭多用户状态栏头像\n<!--more-->\n# 一键关闭多用户状态栏头像教程\n\n1、打开开发者模式\n2、打开USB调试\n3、勾上禁止权限监控\n4、运行 ADB 命令\n```\nadb shell settings put global user_switcher_enabled 0 \n```","tags":["Android"],"categories":["Coding"]},{"title":"Github 不再支持密码验证解决方案","path":"/posts/Git-Token.html","content":"> remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n> remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.\n\n<!--more-->\n\n## 解决方法\n\n### Token 登录\n若之前记住了密码,则需要删除用户目录下的 `.git-credentials` 文件，则可以重新输入用户名和密码，输入密码时输入 Github 生成的 Token 即可\n\n- Windows\n\n```\nrm -rf C:\\Users\\username\\.git-credentials\n```\n\n- Linux/macOS\n\n```\nrm -rf /home/username/.git-credentials\nrm -rf /Users/username/.git-credentials\n```\n\n## SSH 免密登录\n\n### 生成密钥\n\n- 生成\n\n```\nssh-keygen -t rsa -b 4096 -C \"uesrname@xxx.com\"\n```\n\n- id_rsa.pub 密钥填入 Github 的 SSH keys \n\n- 修改本地项目的地址为 SSH Clone 的地址(三种方法)\n\n1. 修改命令\n\n```\ngit remote origin set-url [url]\n```\n\n2. 先删后加\n\n```\ngit remote rm origin\ngit remote add origin [url]\n```\n\n3. 编辑 .git 中 config","tags":["Linux","Windows"],"categories":["Coding"]},{"title":"如何关闭大部分 WPS 广告","path":"/posts/Anti-WPS-ADs.html","content":"关闭大部分 WPS 广告\n<!--more-->\n# 步骤\n- 打开 WPS 配置工具，点击高级\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesWPS_Peizhi.png)\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesWPS_Setting.png)\n\n- 功能定制中打勾\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesWPS_Plug.png)\n\n- 其他选项中打勾\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesWPS_other.png)\n\n- 右键桌面右下角 WPS 图标，进入同步设置，取消勾选办公小助手\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesWps_settings.png)","tags":["Windows"],"categories":["Diary"]},{"title":"安装 Windows 时 GPT 与 MBR 互换","path":"/posts/GPT-MBR.html","content":"安装 Windows 时 GPT 与 MBR 互换\n<!--more-->\n\n装机启动时在选择磁盘时 Shirt + F10 进入CMD\n\n```\ndiskpart\nlist disk \nselect disk n # n 为想要转换的序号\nclean # 清除数据\nconvert mbr # GPT -> MBR\n\nconvert gpt # MBR -> GPT\n```","tags":["Windows"],"categories":["Diary"]},{"title":"Termux 的 Bintray 库已关闭，解决办法","path":"/posts/TermuxRepo.html","content":"Bintray 库已关闭，如何解决？\n\n<!--more-->\n# 问题\n由于 Bintray 库已关闭，所以安装是提示 403\n\n```\nIgn:2 https://dl.bintray.com/grimler/game-packages-24 games InRelease\nIgn:3 https://dl.bintray.com/grimler/science-packages-24 science InRelease\nErr:4 https://dl.bintray.com/grimler/game-packages-24 games Release\n  403  Forbidden\nErr:5 https://dl.bintray.com/grimler/science-packages-24 science Release\n  403  Forbidden\nGet:1 https://grimler.se/termux-packages-24 stable InRelease [13.1 kB]\nGet:6 https://grimler.se/termux-packages-24 stable/main all Packages [21.6 kB]\nGet:7 https://grimler.se/termux-packages-24 stable/main aarch64 Packages [269 kB]\nReading package lists... Done\nE: The repository 'https://dl.bintray.com/grimler/game-packages-24 games Release' does not have a Release file.\nN: Metadata integrity can't be verified, repository is disabled now.\nN: Possible cause: repository is under maintenance or down (wrong sources.list URL?).\nE: The repository 'https://dl.bintray.com/grimler/science-packages-24 science Release' does not have a Release file.\nN: Metadata integrity can't be verified, repository is disabled now.\nN: Possible cause: repository is under maintenance or down (wrong sources.list URL?).\n```\n\n# 解决办法\n\n## 换源清华\n\n```\ntermux-change-repo\n```\n\n## 更新缓存\n\n```\napt upgrade\npkg upgrade\n```","tags":["Linux","Termux"],"categories":["Diary"]},{"title":"你网站的 Google Adsense 为什么不通过？","path":"/posts/GoogleAdSense.html","content":"> 我们发现，您还有一个 AdSense 帐号。每位用户只能拥有一个帐号。要使用此帐号，请关闭另一个帐号。\n\n<!--more-->\n\n# 失败分析\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesGoogleAdsenseError.png)\n\n1. 网站内容不合规\n2. 提示有另一个账号\n3. ...\n\n## 两个账号原因\n-  Google Play 商店的付款方式，若你注册 Adsense 时又填写了另一个付款方式信息，那么你实际上就有两个了。\n- Google Play 商店锁过非大陆地区，删除付款方式，再在  Adsense 里添加单一付款方式，依旧提示有另一个账号。\n# 解决方法\n\n## 重新注册谷歌账号\n> **此电话号码无法用于进行验证**\n\n大陆地区手机号码需要将浏览器语言设为英文才能接到验证码\n\n## 注册 Adsense\n注册好谷歌账户后，先别登录 Play 商店，直接 Adsense 官网登录，按提示填上大陆地址的付款方式即可.\n\n# 成果\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesAdsenseBingo.png)","tags":["Hexo","Google"],"categories":["Diary"]},{"title":"Kodi 设置中文并添加 IPTV 源","path":"/posts/Kodi.html","content":"Kodi 设置中文并添加 IPTV 源\n<!--more-->\n\n# 下载 Kodi\n\n各平台均可在 [Kodi 官网](https://kodi.tv/download/) 下载\n\n# 设置中文显示\n\n## 设置字体\n\n- 点击齿轮进入设置\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodi_Setting.png)\n\n- 再点击进入 `Interace` --> `Skin` -> `Fonts` 设置成 `Arial baased` 以防止设置成中文后乱码\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodi_Interface.png)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imageskodi_font.png)\n\n## 添加中文\n- 点击 `System` 进入系统设置\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodi_System.png)\n\n- 依次点击 `Add-ons` 和 `Running`\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodin_adfont.png)\n\n- 点击 `Install from repository`\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodi_InFont.png)\n\n- 点击 `Lock and feel`\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imageskodi_lock.png)\n\n- 点击 `Language` 然后找到 `Chinese(simple)`，点击进入后再点击 `Install`\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodi_Language.png)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodi_ChineseSimple.png)\n\n## 应用中文语言\n返回设置界面,进入 `Interface` 后选择 `Regional`，点击 `Language`，选择 `Chinese(simple)`，到此中文\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imageskodi_Settinglang.png)\n\n# 添加 IPTV 源\n## 安装插件\n- 点击设置，再点击 `插件` --> `从库安装` --> `PVR 客户端`\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodi_Plug.png)\n\n- 找到 `PVR IPVTV Simple Client`，点击进入后点击 Install 安装\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodi_PVC.png)\n\n## 下载源\n\n在 https://github.com/biancangming/wtv 下载好放入U盘\n\n## 添加源\n- 点击设置齿轮，然后点击`插件` --> `我的插件` --> `PVR客户端` --> `PVR IPTV Simple Client`，点击设置，进入源设置页面\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKodi_PVRSetting.png)\n\n- 在 `M3U playlist path` 中选择或填写下好的源文件,最后点击确认\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imageskodi_setsource.png)\n\n# 效果展示\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesKidi_show.png)","tags":["Android","TvBox"],"categories":["Diary"]},{"title":"无需 root 解决 android 网络的感叹号","path":"/posts/ADB-NetWork.html","content":"一加 9 Pro 刷了 OxygenOS 后有时连上了WiFi但是无WiFi图标，有时还有感叹号\n<!--more-->\n\n# 解决方法\n\n- 利用 adb ,重启手机依旧生效\n\n```\nadb shell settings put global captive_portal_server www.google.cn/generate_204\n```\n\n## 还原\n\n```\nadb shell settings delete global captive_portal_server\nadb shell settings put global captive_portal_detection_enabled 1\n```","tags":["Linux","Android"],"categories":["Coding"]},{"title":"Adb 修补 boot 刷 Magisk","path":"/posts/AdbMagisk.html","content":"修补 boot 刷 Magisk\n<!--more-->\n\n1. 请确保手机为已[解锁](/posts/Adb.html)状态\n\n2. 下载官方包解压获取 boot.img 放到手机储存空间中，并安装 [Magisk Manager](https://github.com/topjohnwu/Magisk/releases)\n\n3. 安装完成后打开 Magisk --> 点击安装 --> 选择并修补一个文件 --> 选择刚刚的 boot.img\n\n4. 修补后的文件文件在 sdcard/Download/patched_boot.img\n\n5. 将手机重启至 bootloader，连接上电脑，打开 ADB \n\n6. 输入命令 fastboot flash boot patched_boot.img  后重启","tags":["Linux","Windows","Android"],"categories":["Diary"]},{"title":"Python 项目调用 Github Actions 中的 Secrets","path":"/posts/GithubSecret.html","content":"Python 项目调用 Github Actions 中的 Secrets\n\n<!--more-->\n\n## 配置 Secret\n> 设置好名为 `mySecret` 的 Secret \n\n```yml\nname: 'GitHub Actions Demo'\n \non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\njobs:\n  Weather-daily:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 'Checkout'\n        uses: actions/checkout@v2\n      - name: 'Set up Python'\n        uses: actions/setup-python@v1\n        with:\n          python-version: 3.7\n      - name: 'Install requirements'\n        run: | \n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: 'Working'\n        env:\n          apiID: ${{ secrets.APIID }}\n          appSecret: ${{ secrets.APPSECRET }}\n          SCKEY: ${{ secrets.SCKEY }}\n        run: python Demo.py\n```\n\n## Demo\n\n```py\nimport os\n\nmySecret = os.environ['mySecret']\nprint(mySecret)\n```","tags":["Linux","Windows","Python"],"categories":["Coding"]},{"title":"利用 Github Action 自动部署 Hexo","path":"/posts/HexoAction.html","content":"利用 Github Action 自动部署 Hexo。\n<!--more-->\n\n# Secrets\n\n仓库下 Setting -> Secrets -> New repository secret 新建 Secrets\n\n```sh Secret 名\nHEXO_DEPLOY_PRI\n```\n\n# Actions\n\nHexo 目录下新建 .github\\workflows\\deploy.yml\n\n```yml deploy.yml\n# Actions 名称\nname: Hexo Deploy\n\n# 监听分支有提价时执行\non:\n  push:\n    branches: \n      - source\n\n# 系统环境变量\nenv:\n  TZ: Asia/Shanghai\n  GIT_USER: Vitan\n  GIT_EMAIL: vitan.me@gmail.com\n  DEPLOY_REPO: ivitan/ivitan.github.io\n  DEPLOY_BRANCH: master\n  THEME_REPO: ivitan/indigo\n  THEME_BRANCH: master\n\n# 系统环境\njobs:\n  build:\n    name: Setup OS\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        os: [ubuntu-latest]\n        node_version: [12.x]\n\n    steps:\n      - name: Checkout Repository source branch\n        uses: actions/checkout@v2\n        with:\n          ref: source\n\n      - name: Checkout Deploy Repo\n        uses: actions/checkout@v2\n        with:\n          repository: ${{ env.DEPLOY_REPO }}\n          ref: ${{ env.DEPLOY_BRANCH }}\n          path: .deploy_git\n      \n      - name: Checkout Theme Repo\n        uses: actions/checkout@v2\n        with:\n          repository: ${{ env.THEME_REPO }}\n          ref: ${{ env.THEME_BRANCH }}\n          path: themes/indigo\n\n      - name: Setup Node.js ${{ matrix.node_version }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node_version }}\n      \n      - name: Setup Deploy Private Key\n        env:\n          HEXO_DEPLOY_PRI: ${{secrets.HEXO_DEPLOY_PRI}}\n        run: |\n          mkdir -p ~/.ssh/\n          echo \"$HEXO_DEPLOY_PRI\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n\n      - name: Setup Git Infomation\n        run: | \n          git config --global user.name $GIT_USER\n          git config --global user.email $GIT_EMAIL\n\n      - name: Setup Hexo Dependencies\n        run: |\n          sudo timedatectl set-timezone $TZ\n          npm install hexo-cli -g\n          npm install\n          wget https://github.com/ivitan/ivitan.github.io/releases/download/Pin/generator.js -O ./node_modules/hexo-generator-index/lib/generator.js\n\n      - name: Deploy Hexo blog\n        run: |\n          hexo clean\n          hexo generate\n          hexo deploy\n```","tags":["Linux","Windows","Hexo"],"categories":["Coding"]},{"title":"利用 ttyd 在 Web 上共享终端","path":"/posts/TTYD.html","content":"> [ttyd](https://github.com/tsl0922/ttyd) 是用于在 Web 上共享终端的简单命令行工具。\n\n<!--more-->\n\n# 安装\n## Termux\n```\napt install ttyd -y\n```\n## macOS\n\n```\nbrew install ttyd\n```\n\n# 使用\n\n```\nttyd -p 8080 bash\n```\n## 密码登录\n\n```\nsudo ttyd -p 8080 login\n```\n\n即可在浏览器访问 http://ip:8080","tags":["Linux","Termux"],"categories":["Coding"]},{"title":"AAPT 查询 APK 信息","path":"/posts/AAPT.html","content":"个人常用 AAPT 查询 APK 信息命令\n\n<!--more-->\n# AAPT 查询 APK 信息\n\n## 查看签名\n\n```\nkeytool -printcert -jarfile app.apk\n```\n\n## 获取 apk 的详细信息\n\n```\naapt dump badging app-debug.apk\n```\n\n## APK MD5\n\n```\ncertutil -hashfile apk.apk  MD5\n```\n\n## 查看 SHA1\n\n```\ncertutil -hashfile 文件名  SHA1 \n```\n\n## 查看 SHA256\n\n```\ncertutil -hashfile 文件名  SHA256\n```","tags":["Linux","Windows"],"categories":["Coding"]},{"title":"解决 Termux 上 Hexo 无法运行","path":"/posts/Termux-Hexo.html","content":"解决 Hexo \n> zsh:/data/data/com.termux/files/usr/bin/hexo: bad interpreter: /usr/bin/env:no such file or directory\n\n## 方法\n```\ntermux-fix-shebang /data/data/com.termux/files/usr/bin/hexo\n```","tags":["Linux","Termux"],"categories":["Coding"]},{"title":"RaspberryPi Review","path":"/posts/RaspberryReview.html","content":"重新拾起吃灰的 RaspberryPi 3B+ ，无显示器如何玩？\n<!--more-->\n\n# 烧录镜像\n官网下载镜像，并使用烧录工具烧录。\n\n# 设置\n## WiFi\n\n在 `boot` 中新建文件\n\n```conf wps_supplicant.conf\ncountry=CN\nctrl_interface=DIR=/var/run/wpa_supplicant\nupdate_config=1\n\nnetwork={\nssid=\"SSID_Name\"\npsk=\"password\"\nkey_mgmt=WPA-PSK\n}\n```\n\n## SSH\n\n在 `boot` 中新建名为 `ssh` 的无后缀的空白文件。\n\n# 开机获取 IP \n开机后会自动连接预埋的 WiFI。然后就可以使用 Ping Tool 、Fing.app 或者到路由器后台查看树莓派的 IP 啦。然后就可以 SSH 连接树莓派。\n\n```\nssh pi@ip\nraspberry # 初始密码\n```\n\n# 系统相关配置\n\n```\nsudo raspi-config\n```\n## 开启 VNC\n\n选择：“5 Interfacing Options”\n\n## 固定 IP\n\n```conf /etc/dhcpcd.conf\ninterface wlan0\nstatic ip_address=10.1.1.22/24\nstatic routers=10.1.1.1\n```","tags":["Linux","RaspberryPi"],"categories":["Coding"]},{"title":"CentOS 7 部署 Tomcat 8","path":"/posts/Tomcat.html","content":"> CentOS 部署 Tomcat\n\n<!--more-->\n\n# JDK\n\n```sh /usr/vitan\ntar -zxvf jdk-7u79-linux-x64.tar.gz \nln -s /usr/local/jdk1.7.0_79/ /usr/local/jdk\n```\n\n```sh /etc/profile \nJAVA_HOME=/usr/vitan/jdk\nPATH=$JAVA_HOME/bin:$PATH\nCLASSPAtH=.:$JAVA_HOME/lib/tools.jar\nexport PATH JAVA_HOME CLASSPATH\n```\n\nOr\n\n```\nyum install openjdk\n```\n\n## 测试\n```sh\nsource /etc/profile\njava -version\n```\n\n# Tomcat\n## 下载\n```sh\ncd Downloads\nwget wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.50/bin/apache-tomcat-8.5.50.tar.gz\n```\n\n## 安装\n\n```sh\nsudo mkdir /usr/local/tomcat\nsudo tar -zvxf apache-tomcat-8.5.24.tar.gz -C /usr/local/tomcat\nmv /usr/tomcat/apache-tomcat-8.5.24 /usr/local/tomcat8\n\ncd /user/local/tomcat8/bin/\nchmod 500 *\nsh startup.sh # 启动\nsh shutdown.sh # 关闭\n```\n\n## 防火墙发行 8080 端口\n```sh\nsudo firewall-cmd --zone=public --add-port=8080/tcp --permanent\nsudo firewall-cmd --reload\n\nsystemctl stop firewalld.service      # 关闭 firewall\nsystemctl disable firewalld.service   # 禁止 firewall 开机启动\n```\n\n## 测试\n浏览器打开 ip:8080\n\n## Tomcat 目录结构\n\n```\nbin       --启动命令目录\nconf      --配置文件目录\nlib       --库文件目录\nlogs      --日志文件目录\ntemp      --临时缓存文件\nwebapps   --web应用家目录\nwork      --工作缓存目录\n```","tags":["Linux"],"categories":["Coding"]},{"title":"Centos 7 防火墙","path":"/posts/FireWall.html","content":"CentOS 7 防火墙命令\n\n<!--more-->\n\n# 关闭\n```\n# 关闭\nsystemctl stop firewalld.service \n# 禁止开机自启\nsystemctl disable firewalld.service\n\n# 重启\nfirewall-cmd --reload\n```\n\n# 开启端口\n```\nfirewall-cmd --zone=public --add-port=80/tcp --permanent\n```\n\n- -zone # 作用域\n- -add-port=80/tcp # 添加端口，格式为：端口/通讯协议\n- -permanent # 永久生效，没有此参数重启后失效\n\n# 常用\n\n```\n# 查看状态\nfirewall-cmd --state\n# 重新载入配置\nfirewall-cmd --reload\n# 列出支持的zone\nfirewall-cmd --get-zones\n# 列出支持的服务\nfirewall-cmd --get-services\n# 查看ftp服务是否支持，返回yes或者no\nfirewall-cmd --query-service ftp\n# 临时开放ftp服务\nfirewall-cmd --add-service=ftp\n# 永久开放ftp服务\nfirewall-cmd --add-service=ftp --permanent\n# 永久移除ftp服务\nfirewall-cmd --remove-service=ftp --permanent\n# 永久添加80端口 \nfirewall-cmd --add-port=80/tcp --permanent\n# 查看规则\niptables -L -n \n\nfirewall-cmd --help\n```\n\n# 切换为 iptables\n```\nservice firewalld stop\nsystemctl disable firewalld.service\n\nyum install iptables-services -y\nyum install iptables* -y\n```\n## 添加规则\n\n```\nvim /etc/sysconfig/iptables\n\n# 重启\nsystemctl restart iptables.service \n# 开机启动\nsystemctl enable iptables.service \n```","tags":["Linux"],"categories":["Coding"]},{"title":"Windows 配置 Vim","path":"/posts/Vim-Windows.html","content":"Windows 配置美化 Vim.\n\n<!--more-->\n\n![最终效果](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20200615152009.png)\n\n---\n\n# 安装\n## 常规安装\n\n[下载](https://www.vim.org/download.php)\n\n## Scoop 安装\n\n```\nscoop install vim\n```\n\n# 优化\n\n## 安装 vim—plug\n\n[下载](https://github.com/junegunn/vim-plug/releases) 并解压，把 `plug.vim` 文件复制到 D:\\vim\\current\\autoload\\ 目录下\n\n## 配置 Vimrc\n- 打开 Vim 命令模式，输入`:version` 获取 vimrc 路径,如下：\n\n```\nsystem vimrc file: \"$VIM\\vimrc\"\nuser vimrc file: \"$HOME\\_vimrc\"\n2nd user vimrc file: \"$HOME\\vimfiles\\vimrc\"\n3rd user vimrc file: \"$VIM\\_vimrc\"\nuser exrc file: \"$HOME\\_exrc\"\n2nd user exrc file: \"$VIM\\_exrc\"\ndefaults file: \"$VIMRUNTIME\\defaults.vim\"\n```\n\n- 配置\n\n```\nvim \"$HOME\\_vimrc\" \n```\n\n- 我的配置\n\n```vimrc\n\">> 一般设置\nset mouse=a              \" 鼠标可用\nset relativenumber       \" 将行号设置为相对行号\nset wildmenu             \" 命令行补全参数\nfiletype on              \" 设置开启文件类型侦测\nfiletype plugin on       \" 设置加载对应文件类型的插件\nsyntax enable            \" 开启语法高亮功能\nsyntax on                \" 自动语法高亮\nset t_Co=256             \" 开启256色支持\nset cmdheight=2          \" 设置命令行的高度\nset showcmd              \" select模式下显示选中的行数\nset ruler                \" 总是显示光标位置\nset laststatus=2         \" 总是显示状态栏\nset number               \" 开启行号显示\nset cursorline           \" 高亮显示当前行\nset ttimeoutlen=0        \" 设置<ESC>键响应时间\nset virtualedit=block,onemore  \" 允许光标出现在最后一个字符的后面\n \n\">> 搜索设置\nset hlsearch            \" 高亮显示搜索结果\nset incsearch           \" 开启实时搜索功能\nset ignorecase          \" 搜索时大小写不敏感\n \n\">> 编码设置\nset langmenu=zh_CN.UTF-8\nset helplang=cn\nset termencoding=utf-8\nset encoding=utf8\nset fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030\n \n\">> 语法高亮\nsyntax enable\nsyntax on\n \nhi pythonSelf            ctermfg=174 guifg=#6094DB cterm=bold gui=bold\nlet python_highlight_all=1\nsyntax enable\n \n\">> 状态行颜色\nhighlight StatusLine guifg=SlateBlue guibg=Yellow\nhighlight StatusLineNC guifg=Gray guibg=White\n \n\">> 增强模式中的命令行自动完成操作\nset wildmenu\n \n\">> 总是显示状态行\nset laststatus=2\n \n\">> 命令行补全参数\nset wildmenu\n \n\">> 设置tab键空4格\nset tabstop=4\n \n\">> 自动检测文件类型\nfiletype plugin indent on\n \n\">> 开启自动缩进，智能缩进\nset autoindent\nset cindent\nset smartindent\nset shiftwidth=4\n \n\">> 映射光标在窗口间移动的快捷键\nnmap <C-H> <C-W>h\nnmap <C-J> <C-W>j\nnmap <C-K> <C-W>k\nnmap <C-L> <C-W>l\n \n\">> vim-plug\ncall plug#begin('~/.vim/plugged')\nPlug 'vim-airline/vim-airline'\nPlug 'vim-airline/vim-airline-themes'\nPlug 'morhetz/gruvbox'\nPlug 'Yggdroot/indentLine'\nPlug 'mhinz/vim-startify'\nPlug 'scrooloose/nerdtree'\nPlug 'kien/ctrlp.vim'\nPlug 'tpope/vim-fugitive'\nPlug 'scrooloose/syntastic'\nPlug 'junegunn/fzf', { 'do': { -> fzf#install() } }\nPlug 'scrooloose/nerdtree'      \t\" File tree manager\nPlug 'jistr/vim-nerdtree-tabs'      \" enhance nerdtree's tabs\nPlug 'ryanoasis/vim-devicons'       \" add beautiful icons besides files\nPlug 'Xuyuanp/nerdtree-git-plugin'  \" display git status within Nerdtree\nPlug 'tiagofumo/vim-nerdtree-syntax-highlight' \" enhance devicons\ncall plug#end()\n \n\" <Nerdtree>-------------------{\n    \">> Basic settings\n        \"let g:NERDTreeChDirMode = 2  \"Change current folder as root\n        autocmd BufEnter * if (winnr(\"$\") == 1 && exists(\"b:NERDTree\") && b:NERDTree.isTabTree()) |cd %:p:h |endif\n\t\tmap <C-T> :NERDTreeMirror<CR> \"Open Nerdtree    \n\t\tmap <C-T> :NERDTreeToggle<CR> \"Close Nerdtree\n \n    \">> UI settings\n        let NERDTreeQuitOnOpen=1   \" Close NERDtree when files was opened\n        let NERDTreeMinimalUI=1    \" Start NERDTree in minimal UI mode (No help lines)\n        let NERDTreeDirArrows=1    \" Display arrows instead of ascii art in NERDTree\n        let NERDTreeChDirMode=0    \" Change current working directory based on root directory in NERDTree\n        let g:NERDTreeHidden=1     \" Don't show hidden files\n        let NERDTreeWinSize=30     \" Initial NERDTree width\n        let NERDTreeAutoDeleteBuffer = 1  \" Auto delete buffer deleted with NerdTree\n        let NERDTreeShowBookmarks=1   \" Show NERDTree bookmarks\n        let NERDTreeIgnore = ['\\.pyc$', '\\.swp', '\\.swo', '__pycache__']   \" Hide temp files in NERDTree\n        \"let g:NERDTreeShowLineNumbers=1  \" Show Line Number\n    \" Open Nerdtree when there's no file opened\n        \"autocmd vimenter * if !argc()|NERDTree|endif\n    \" Or, auto-open Nerdtree\n        \"autocmd vimenter * NERDTree\n    \" Close NERDTree when there's no other windows\n        autocmd bufenter * if (winnr(\"$\") == 1 && exists(\"b:NERDTree\") && b:NERDTree.isTabTree()) | q | endif\n    \" Customize icons on Nerdtree\n        let g:NERDTreeDirArrowExpandable = '▸'\n        let g:NERDTreeDirArrowCollapsible = '▾'\n \n    \">> NERDTREE-GIT\n        \" Special characters\n    let g:NERDTreeIndicatorMapCustom = { \n        \\ \"Modified\"  : \"✹\",\n        \\ \"Staged\"    : \"✚\",\n        \\ \"Untracked\" : \"✭\",\n        \\ \"Renamed\"   : \"➜\",\n        \\ \"Unmerged\"  : \"═\",\n        \\ \"Deleted\"   : \"✖\",\n        \\ \"Dirty\"     : \"✗\",\n        \\ \"Clean\"     : \"✔︎\",\n        \\ 'Ignored'   : '☒',\n        \\ \"Unknown\"   : \"?\"\n    \\ }\n \n    \">> NERDTree-Tabs\n        let g:nerdtree_tabs_open_on_console_startup=1 \"Auto-open Nerdtree-tabs on VIM enter\n\n    \">> Nerdtree-devicons\n        set guifont=DroidSansMono_Nerd_Font:h11\n\n    \">> Nerdtree-syntax-highlighting\n        let g:NERDTreeDisableFileExtensionHighlight = 1\n        let g:NERDTreeDisableExactMatchHighlight = 1\n        let g:NERDTreeDisablePatternMatchHighlight = 1\n        let g:NERDTreeFileExtensionHighlightFullName = 1\n        let g:NERDTreeExactMatchHighlightFullName = 1\n        let g:NERDTreePatternMatchHighlightFullName = 1\n        let g:NERDTreeHighlightFolders = 1 \" enables folder icon highlighting using exact match\n        let g:NERDTreeHighlightFoldersFullName = 1 \" highlights the folder name\n        let g:NERDTreeExtensionHighlightColor = {} \" this line is needed to avoid error\n\" }\n \n\">> 基本主题配置\nset bg=dark  \"设置背景为黑色\ncolorscheme gruvbox    \"设置主题为 gruvbox\nset guioptions=        \"去掉两边的scrollbar\nset guifont=Monaco:h17 \"设置字体和字的大小\n \n\">> airline settings\nlet g:airline_theme = 'hybrid'\nlet g:airline_powerline_fonts = 1\n \nif !exists('g:airline_symbols')\nlet g:airline_symbols = {}\nendif\n \nlet g:airline_left_sep = ''\nlet g:airline_left_alt_sep = ''\nlet g:airline_right_sep = ''\nlet g:airline_right_alt_sep = ''\nlet g:airline_symbols.branch = ''\nlet g:airline_symbols.readonly = ''\nlet g:airline_symbols.linenr = ''\nlet g:airline#extensions#tabline#enabled = 1\n \n\">> show absolute file path in status line\nlet g:airline_section_c = '%<%F%m %#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'\n \n\">> show tab number in tab line\nlet g:airline#extensions#tabline#tab_nr_type = 1\n \n\">> Enable folding\nset foldmethod=indent\nset foldlevel=99\n \n\">> Enable folding with the spacebar\nnnoremap <space> za\n```","tags":["Windows","Vim"],"categories":["Coding"]},{"title":"Windows 包管理器 Scoop","path":"/posts/Scoop.html","content":"Windows 包管理器 Scoop 的安装使用。\n\n<!--more-->\n# 前提条件\n\n- Windows 7 SP1 + / Windows Server 2008+ [PowerShell 5](https://aka.ms/wmf5download)或更高版本，包括[PowerShell Core](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-6) 和 [.NET Framework 4.5](https://www.microsoft.com/net/download) 或更高版本\n- 必须启用 PowerShell\n\n```\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned-范围CurrentUser\n```\n\n# 默认安装\n默认安装，Scoop 的路径为 C:\\Users\\<user>\\scoop，之后 Scoop 安装的软件也会在此。\n\n- 打开 PowerShell\n\n```\nset-executionpolicy remotesigned -scope currentuser\niex (new-object net.webclient).downloadstring('https://get.scoop.sh')\nscoop help\n```\n\n# 自定义安装\n\n自定义 Scoop 安装的路径,不可以安装了 Scoop 之后再设置。\n\n## 安装到当前用户\n```\n$env:SCOOP='D:\\Applications\\Scoop'\n[Environment]::SetEnvironmentVariable('SCOOP', $env:SCOOP, 'User')\n\nInvoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')\n```\n\n## 全局安装\n```\n$env:SCOOP_GLOBAL='D:\\GlobalScoopApps'\n[Environment]::SetEnvironmentVariable('SCOOP_GLOBAL', $env:SCOOP_GLOBAL, 'Machine')\n\nInvoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')\n```\n\n# 基础命令\n\n|命令|\t动作|\n|:---|:---|\n|scoop search\txx | 搜索软件名\n|scoop install\txx | 安装软件\n|scoop update\txx | 更新软件\n|scoop status\txx | 查看软件状态\n|scoop uninstall\txx |\t卸载软件\n|scoop info\txx | 查看软件详情\n|scoop home\txx | 打开软件主页\n\n- `-g` 为全局，如 scoop update -g xx 更新全局安装的 xx\n\n---\n\n**参考**\n- [Scoop](https://github.com/lukesampson/scoop)","tags":["Windows"],"categories":["Coding"]},{"title":"多设备统一 Git 换行符","path":"/posts/GitLF.html","content":"由于 Linux 系统中使用 0x0A（LF）, windows 系统中使用 0x0D0A（CRLF）作为换行符，导致跨设备时代码无法运行，因此统一换行符就显得很重要。\n<!--more-->\n\n# 配置 Git\n\n```\n# 统一换行符为 LF\ngit config --global core.eol LF\n# 将自动转换关闭,避免转换失败不能不同进行提交\ngit config --global core.autoCRLF false\n# 禁止混用 LF 和 CRLF 两种换行符\ngit config --global core.safeCRLF true\n```\n\n## 参数\n\n- `eol` 设置工作目录中文件的换行符，有三个值 lf, crlf 和 native（默认，同操作系统）\n- autocrlf:\n  - true 检出是转换 CRLF, 提交时转换为 LF\n  - input 检出是不转换，提交时转换为 LF\n  - false 不做转换\n\n- `safecrlf`\n  - true 表示不允许提交时包含不同换行符\n  - warn 则只在有不同换行符时警告\n  - false 则允许提价时有不同换行符存在\n\n# .gitattributes\n\n也可以在项目中添加 .gitattributes\n\n```git  .gitattributes\n* text eol=lf\n* text=auto\n*.txt\t\ttext\n*.jpg\t\t-text\n*.vcproj\ttext eol=crlf\n*.sh\t\ttext eol=lf\n*.py\t\teol=lf\n```\n\n- [了解更多](https://www.bookstack.cn/read/git-doc-zh/docs-39.md)","tags":["Linux","Windows","Git"],"categories":["Coding"]},{"title":"同步 Visual Studio Code 配置","path":"/posts/Sync.html","content":"利用 Gist 和 Setting Sync 同步 Visual Studio Code 设置和扩展。\n<!--more-->\n\n# 安装 Setting Sync\n\n在扩展中搜索 Setting Sync 并安装。\n\n# 配置 Setting Sync\n\n## 新建 Gist\n访问 [Github Tokens](https://github.com/settings/tokens) ,然后点击 Generate new token\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/CreateToken.png)\n\n勾选 Gist\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/Gist.png)\n\n然后复制得到的 Token\n\n## 配置 Setting Sync\nCrtl + P 输入\n\n```\n>sync:Advanced Options\n```\n\n选择 `Sync:编辑扩展本地配置` 打开 Setting Sync 扩展的本地配置文件，在 token 中填入上一步的 Token\n\n```\n\"token\": \"169f0811bf4b00d9cdcvvvvscassdeesvavasd\",\n```\n\n## 配置 Gist\n\n- 创建新的 Gist\n\n访问 https://gist.github.com/ 创建新的 Gist\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/CreatGist.png)\n\n- 得到 Gist ID\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/GistID.png)\n\n## 设置 Setting Sync \n\n- 打开 Setting sync 扩展设置\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/OpenSync.png)\n\n- 填入 Gist ID\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/InputGistID.png)\n\n# 快捷键\n\n- 上传配置\n\n```\nShift + Alt + U\n```\n\n- 下载配置\n\n```\nShift + Alt + D\n```","tags":["Linux","Windows"],"categories":["Coding"]},{"title":"配置 PowerShell 主题","path":"/posts/PowerShell-Theme.html","content":"配置 PowerShell 主题\n\n<!--more-->\n\n# 安装配置 Scoop \n\n> Scoop 第三方 Windows 包管理工具。\n\n```powershell\nset-executionpolicy remotesigned -scope currentuser\niex (new-object net.webclient).downloadstring('https://get.scoop.sh')\nscoop help\n```\n\n- [其他安装方式](/posts/Scoop.html)\n\n## 命令\n\n|命令|\t动作|\n|:---|:---|\n|search\t|搜索软件名\n|install\t|安装软件\n|update\t|更新软件\n|status\t|查看软件状态\n|uninstall|\t卸载软件\n|info\t|查看软件详情\n|home\t|打开软件主页\n\n# 安装 oh-my-posh\n```\nInstall-Module posh-git -Scope CurrentUser \nInstall-Module oh-my-posh -Scope CurrentUser\nInstall-Module -AllowClobber Get-ChildItemColor\n```\n\n# PowerShell 配置文件\n```\n# 新建 PowerShell 配置文件\nif (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }\n\n# 记事本打开配置文件\nnotepad $PROFILE\n```\n\n- 我的配置文件\n\n```$PROFILE\nImport-Module Get-ChildItemColor\n\n$env:PYTHONIOENCODING=\"utf-8\"\n# Remove curl alias\nIf (Test-Path Alias:curl) {Remove-Item Alias:curl}\nIf (Test-Path Alias:curl) {Remove-Item Alias:curl}\n# Remove-Item alias:ls -force\nSet-Alias l Get-ChildItemColor -option AllScope\nSet-Alias ls Get-ChildItemColorFormatWide -option AllScope\n\nfunction GitLogPretty {\n  git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --all\n}\n\nfunction PrettyLS {\n  colorls --light -A\n}\n\nfunction GitStat { git status }\n\nfunction GoBack { Set-Location .. }\n\nfunction GetMyIp { curl -L tool.lu/ip }\nfunction UpdateScoop { scoop update; scoop update * }\n\nfunction Vscode { code .}\n\nfunction HexoServe { hexo clean; hexo g; hexo s}\n\n# Git Commit, Add all and Push — in one step.\nfunction GitAdd{ git add . ; git commit -m \"⚡ ADD: $args\" }\n\nfunction GitCap{ git add . ; git commit -m \"$args\" ; git push }\n\n# NEW.\nfunction GitNew{ gcap \"<F0><9F><93><A6> NEW: $args\" }\n\n# IMPROVE.\nfunction GitImp{ gcap \"👌 IMPROVE: $args\" }\n\n# FIX.\nfunction GitFix{ gcap \"🐛 FIX: $args\" }\n\n# RELEASE.\nfunction GitRlz{ gcap \"🚀 RELEASE: $args\" }\n\n# DOC.\nfunction GitDoc{ gcap\"📖 DOC: $args\" }\n\n# TEST.\nfunction GitTst{ gcap \"✅ TEST: $args\" }\n\nImport-Module posh-git\nImport-Module oh-my-posh\n# $DefaultUser = 'spenc'\n\n# Setup other alias\nSet-Alias open Invoke-Item\nSet-Alias .. GoBack\nSet-Alias glola GitLogPretty\nSet-Alias gst GitStat\nSet-Alias myip GetMyIp\nSet-Alias pls PrettyLS\nSet-Alias suu UpdateScoop\nSet-Alias vs Vscode\nSet-Alias vitan HexoServe\nSet-Alias gadd GitAdd\nSet-Alias gcap GitCap\nSet-Alias gnew GitNew\nSet-Alias gimp GitImp\nSet-Alias gfix GitFix\nSet-Alias grlz grlz\nSet-Alias gdoc GitDoc\nSet-Alias gtst GitTst\n\n# Set theme\nSet-Theme Paradox\n\nSet-PSReadlineKeyHandler -Key Tab -Function MenuComplete\n```\n\n# 更换主题\n```\nSet-Theme <主题名>\n```\n\n## 主题\n\n[查阅](https://github.com/JanDeDobbeleer/oh-my-posh)\n\n# 安装 colortool 配色管理\n```powershel\nscoop install colortool\n```\n\n## 基本命令\n```\n# 查看主题配色\ncolortool -s\n\n# 临时查看\ncolortool <主题名称>\n\n# 定义默认值\ncolortool -d <主题名称>\n```\n\n# 字体\n- [PowerLine Font](https://github.com/powerline/fonts)\n- [Sarasa](https://github.com/be5invis/Sarasa-Gothic/releases)\n- [nerd-fonts](https://github.com/ryanoasis/nerd-fonts/releases)","tags":["Windows"],"categories":["Coding"]},{"title":"Windows 安装 OpenSSH 服务端","path":"/posts/Windows-OpenSSH.html","content":"Windows 安装 OpenSSH 服务端\n<!--more-->\n\n# Windows 10 开启\n在系统设置的 `应用` 中的 `管理可选功能` 安装 OenSSH 客户端 和 OpenSSH 服务器\n\n# Github 下载\n\nhttps://github.com/PowerShell/Win32-OpenSSH/releases\n\n## 安装\n\n解压 OpenSSH，添加 Path 环境变量 `D:\\Program Files\\OpenSSH`，以管理员身份运行 PowerShell\n\n```\ncd D:\\Program Files\\OpenSSH\npowershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1\n```\n\n- 设置服务自动启动并启动服务\n  \n```\nsc config sshd start= auto\nnet start sshd\n```\n\n- 配置服务\n\n```bash C:\\ProgramData\\ssh\\sshd_config\n# 取消注释\nPort 22\nPubkeyAuthentication yes\nPasswordAuthentication no\nPermitEmptyPasswords no\n\n# 注释以下内容\n#Match Group administrators\n#       AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys\n```\n\n- 执行 PowerShell 命令\n\n```\ncd C:\\Progra~1\\OpenSSH\n.\\FixHostFilePermissions.ps1\n.\\FixUserFilePermissions.ps1\n```\n\n- 重启 SSHD 服务\n\n```\nnet stop sshd\nnet sart sshd\n```\n\n## 开启端口\n\n打开 控制面板 -> Windows 防火墙 -> 高级设置 -> 入站规则 -> 新建规则 -> 端口 -> TCP,特定端口 `22` -> 允许连接 -> 下一步\n\n## 将 PowerShell 设为默认 Shell\n```\nNew-ItemProperty -Path \"HKLM:\\SOFTWARE\\OpenSSH\" -Name DefaultShell -Value \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -PropertyType String -Force\n```\n---\n**参考**\n[OpenSSH 服务器配置](https://docs.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_server_configuration)","tags":["Windows","OpenSSH"],"categories":["Coding"]},{"title":"发布自己的 NPM 包","path":"/posts/NpmPackage.html","content":"发布自己的 NPM 包\n\n<!--more-->\n\n# 注册 NPM 账号\n\n在 https://www.npmjs.com/ 注册账户\n\n# 添加本地用户\n\n```\nnpm adduser\nusername:\npassword:\nemail:\n```\n\n检查\n\n```\nnpm whoami\n```\n\n# 配置 package.json\n```\n{\n  \"name\": \"package_name\",\n  \"version\": \"1.8.3\",\n  \"description\": \"Package Descrption.\",\n  \"keywords\": [\n    \"hexo\",\n    \"theme\",\n    \"material design\"\n  ],\n  \"author\": {\n    \"name\": \"Vitan\",\n    \"email\": \"admin@vitan.me\"\n  },\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"url\": \"git+https://github.com/ivitan/Project.git\",\n    \"type\": \"git\"\n  }\n}\n```\n\n# 发布\n```\nnpm publish\n```","tags":["Linux","Windows","Node.Js"],"categories":["Coding"]},{"title":"H3C 交换机常用命令","path":"/posts/H3C.html","content":"H3C 交换机常用命令\n<!--more-->\n\n# 常用命令\n## 用户配置\n```\n<H3C>system-view\n\n# 设置用户分级密码\n[H3C]super password H3C \n\n# 删除用户分级密码\n[H3C]undo super password \n\n# Web网管用户设置,1（缺省）为管理级用户,缺省admin,admin\n[H3C]localuser bigheap 123456 1 \n\n# 删除Web网管用户\n[H3C]undo localuser bigheap \n\n# 只支持0\n[H3C]user-interface aux 0 \n\n# 设置超时为2分50秒,若为0则表示不超时,默认为5分钟\n[H3C-Aux]idle-timeout 2 50 \n\n# 恢复默认值\n[H3C-Aux]undo idle-timeout \n\n# 只支持0和1\n[H3C]user-interface vty 0 \n\n# 设置超时为2分50秒,若为0则表示不超时,默认为5分钟\n[H3C-vty]idle-timeout 2 50 \n\n# 恢复默认值\n[H3C-vty]undo idle-timeout \n\n# 设置telnet密码,必须设置\n[H3C-vty]set authentication password 123456 \n\n# 取消密码\n[H3C-vty]undo set authentication password \n\n# 显示用户\n[H3C]display users \n\n# 显示用户界面状态\n[H3C]display user-interface \n```\n\n## 系统IP配置\n\n```\n[H3C]vlan 20\n[H3C]management-vlan 20\n\n# 创建并进入管理VLAN\n[H3C]interface vlan-interface 20 \n\n#  删除管理VLAN接口\n[H3C]undo interface vlan-interface 20\n\n# 配置管理VLAN接口静态IP地址(缺省为192.168.0.234)\n[H3C-Vlan-interface20]ip address 192.168.1.2 255.255.255.0 \n\n# 删除IP地址\n[H3C-Vlan-interface20]undo ip address\n\n# 指定缺省网关(默认无网关地址)\n[H3C-Vlan-interface20]ip gateway 192.168.1.1 \n[H3C-Vlan-interface20]undo ip gateway\n\n# 关闭接口\n[H3C-Vlan-interface20]shutdown \n\n# 开启\n[H3C-Vlan-interface20]undo shutdown \n\n# 显示管理VLAN接口IP的相关信息\n[H3C]display ip \n\n#  查看管理VLAN的接口信息\n[H3C]display interface vlan-interface 20\n\n# 开启IP调试功能\n<H3C>debugging ip \n<H3C>undo debugging ip\n```\n\n## DHCP客户端配置\n```\n# 管理VLAN接口通过DHCP方式获取IP地址\n[H3C-Vlan-interface20]ip address dhcp-alloc \n\n# 取消\n[H3C-Vlan-interface20]undo ip address dhcp-alloc \n\n# 显示DHCP客户信息\n[H3C]display dhcp \n\n# 开启DHCP调试功能\n<H3C>debugging dhcp-alloc \n\n<H3C>undo debugging dhcp-alloc\n```\n\n## 端口配置\n```\n[H3C]interface Ethernet0/3\n[H3C-Ethernet0/3]shutdown\n\n# 速率,可为10,100,1000和auto(缺省)\n[H3C-Ethernet0/3]speed 100 \n\n# 双工,可为half,full和auto(缺省) 光口和汇聚后不能配置\n[H3C-Ethernet0/3]duplex full \n\n# 开启流控,默认为关闭\n[H3C-Ethernet0/3]flow-control \n\n# 设置抑制广播百分比为20%,可取5,10,20,100,缺省为100\n# 同时组播和未知单播也受此影响\n[H3C-Ethernet0/3]broadcast-suppression 20 \n\n# 内环测试\n[H3C-Ethernet0/3]loopback internal \n\n# 外环测试,需插接自环头,必须为全双工或者自协商模式\n[H3C-Ethernet0/3]loopback external \n\n# 设置链路的类型为trunk,可为access(缺省),trunk\n[H3C-Ethernet0/3]port link-type trunk \n\n# 设置20为该trunk的缺省VLAN,默认为1(trunk线路两端的PVID必须一致)\n[H3C-Ethernet0/3]port trunk pvid vlan 20 \n\n# 将当前access端口加入指定的VLAN\n[H3C-Ethernet0/3]port access vlan 20 \n\n# 允许所有的VLAN通过当前的trunk端口,可多次使用该命令\n[H3C-Ethernet0/3]port trunk permit vlan all \n\n# 设置以太端口为自动监测,normal(缺省)为直通线,across为交叉线\n[H3C-Ethernet0/3]mdi auto \n\n# 将1-4口加入汇聚组,1为主端口,两端需要同时配置,\n# 设置了端口镜像以及端口隔离的端口无法汇聚\n[H3C]link-aggregation Ethernet 0/1 to Ethernet 0/4 \n\n# 删除该汇聚组\n[H3C]undo link-aggregation Ethernet 0/1 \n\n# 配置端口汇聚模式为根据目的MAC地址进行负荷分担,\n# 可选为 ingress,egress和both,缺省为both\n[H3C]link-aggregation mode egress \n\n# 将该端口设置为镜像端口,必须先设置镜像端口,删除时必须先删除被镜像端口,\n# 而且它们不能同在一个端口,该端口不能在汇聚组中,设置新镜像端口时,新取代旧,被镜像不变\n\n[H3C]monitor-port Ethernet 0/2 \n# 将端口3和4设置为被镜像端口,both为同时监控接收和发送的报文,\n# inbound表示仅监控接收的报文,outbound表示仅监控发送的报文\n\n[H3C]mirroring-port Ethernet 0/3 to Ethernet 0/4 both \n[H3C]display mirror\n[H3C]display interface Ethernet 0/3\n\n# 清除所有端口的统计信息\n<H3C>reset counters \n\n# 显示端口汇聚信息\n[H3C]display link-aggregation Ethernet 0/3 \n\n# 诊断该端口的电路状况\n[H3C-Ethernet0/3]virtual-cable-test \n```\n\n## VLAN 配置\n```\n[H3C]vlan 2\n\n# 删除除缺省VLAN外的所有VLAN,缺省VLAN不能被删除\n[H3C]undo vlan all \n\n# 将4到7号端口加入到VLAN2中,此命令只能用来加access端口,\n# 不能用来增加trunk或者hybrid端口\n[H3C-vlan2]port Ethernet 0/4 to Ethernet 0/7 \n\n# 打开VLAN内端口隔离特性,不能二层转发,默认不启用该功能\n[H3C-vlan2]port-isolate enable \n\n# 设置4为VLAN2的隔离上行端口,用于转发二层数据,只能配置一个上行端口,\n# 若为trunk,则建议允许所有VLAN通过,隔离不能与汇聚同时配置\n[H3C-Ethernet0/4]port-isolate uplink-port vlan 2 \n\n# 显示所有VLAN的详细信息\n[H3C]display vlan all \n\n# S1550E支持基于端口的VLAN,通过创建不同的user-group来实现,\n# 一个端口可以属于多个user-group,不属于同一个user-group的端口不能互相通信, \n# 最多支持50个user-group\n\n# 创建user-group 20,默认只存在user-group 1\n[H3C]user-group 20 \n\n# 将4到7号端口加入到VLAN20中,初始时都属于user-group 1中\n[H3C-UserGroup20]port Ethernet 0/4 to Ethernet 0/7 \n\n\n# 显示user-group 20的相关信息\n[H3C]display user-group 20 \n```\n\n# Work 常用\n\n- 进入特权模式\n\n```\nsys\n```\n\n- 进入端口\n\n```\nint e0/0/端口号 \nint e1/0/端口号\n```\n\n- 打开/关闭自动获取mac\n\n```\nmac-address max-mac-count 1\nmac-address max-mac-count 0\n```\n\n- 查找 mac\n  \n```\ndis mac-address | include aebe\n```\n\n- 查看 Vlan 的 arp\n\n```\ndis arp vlan 216\n```\n\n- 查看端口目前 vlan\n\n```\ndis th\n```\n- 关闭/启用端口\n\n```\nshutdown\nun shutdown\n```\n- 查看端口获取mac：\n\n```\ndis mac-address vlan 00\n```\n- mac绑定端口：\n\n```\nmac-address static 0000-0000-0000 vlan 00\n```\n\n- 退出：quit\n- 保存：save\n- 取消：undo\n\n# 命令\n\n- 查看Linux下查看端口状态\n\n```\nnetstat -an|grep -E \"6002|6003\"\n```\n- 显示当前配置\n\n```\ndisplay current-configuration\n```\n- 显示arp信息\n\n```\ndis arp\n```\n- 显示mac列表信息\n\n```\ndis mac-address\n```\n- 显示端口信息\n\n```\ndisplay interface\n```\n- 进入系统视图\n\n```\nsystem-view\n\n```\n-  打开路由器的telnet功能\n\n```\n[H3C]telnet server enable\n```\n- 设置允许同时配置路由器的用户数\n\n```\n[H3C]configure-user count 5\n```\n- 添加本地用户(此处为telnet用户登录时使用的用户名)\n\n```\n[H3C]local-user telnet\n```\n- 设置telnet用户登录时所使用的密码\n\n```\n[H3C-luser-telnet]password simple h3c\n```\n- 设置本地用户的服务类型(此处为telnet)\n\n```\n[H3C-luser-telnet]service-type telnet\n```\n- 设置本地用户的服务级别\n\n```\n[H3C-luser-telnet]level 3\n```\n- 退出本地用户视图\n\n```\n[H3C-luser-telnet]quit\n```\n- 进入用户视图\n\n```\n[H3C]user-interface vty 0 4\n```\n- 选择“scheme”认证方式\n\n```\n[H3C-ui-vty0-4]authentication-mode scheme\n```\n- 进入某个端口\n\n```\n[H3C] interface serial 3/0\n```\n- 为该端口设置ip\n\n```\n[H3C-Serial3/0]ip address 200.1.1.1 255.255.255.0\n```\n- 对该端口进行复位\n\n```\n[H3C-Serial3/0]undo shutdown\n```\n- 添加一条静态路由\n\n```\n[H3C]ip route-static 192.168.1.0 255.255.255.0 192.168.0.1\n```\n- 添加一条默认路由\n\n```\n[H3C]ip route-static 0.0.0.0  0.0.0.0  192.168.0.1\n```\n- 保存配置文件\n\n```\n[H3C]save\n```\n- 查看某端口的状态\n\n```\n[H3C]display interface GigabitEthernet 0/0\n```\n\n- 创建vlan\n\n```\n[H3C]vlan 10\n```\n- 将某个端口加入到vlan中\n\n```\n[H3C-vlan100]port ethernet 0/1\n```\n- 创建vlan虚拟口\n\n```\n[H3C]interface vlan-interface 1\n```\n- 配置ip地址\n\n```\n[H3C-Vlan-interface100]ip address 192.168.1.4  255.255.255.0\n```\n\n- 将端口类型设置为trunk\n\n```    \n[H3C]port  link-type trunk\n```\n\n- 设置trunk口允许所有vlan通过(需要执行save保存)\n\n```\n[H3C]port  trunk permit vlan all \n```\n注意：Trunk 可以收发多个vlan的报文，用于交换机与交换机之间的互连\n\n- 关闭端口\n\n```\n[H3C-GigabitEthernet1/1/1]shutdown\n```\n\n- 设置端口备注\n\n```\n[H3C-Ethernet1/0/15]description 测试数据\n```","tags":["Switch","Network"],"categories":["Coding"]},{"title":"PicGo 使用 JsDeliver CDN 加速","path":"/posts/PicGo.html","content":"PicGo 使用 JsDeliver CDN 加速 Github 图床\n<!--more-->\n# 配置 PicGo\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20200515113912.png)\n\n- 在设定自定义域名上填入 `https://fastly.jsdelivr.net/gh/ivitan/Picture@master`\n  - 其中 `ivitan` 为 Github 账号,`Picture` 为 仓库名,`master` 为分支","tags":["Linux","Windows","Github"],"categories":["Coding"]},{"title":"Git 常用命令参考手册","path":"/posts/GitManual.html","content":"Git 常用命令参考手册\n\n<!--more-->\n\n# 配置相关\n## 配置\n```bash\n# 查看全局配置列表\ngit config -l\n# 查看局部配置列表\ngit config --local --list\n\n# 查看已设置的全局用户名/邮箱\ngit config --global --get user.name\ngit config --global --get user.email\n\n# 设置全局用户名/邮箱\ngit config --global user.name \"Vitan\"\ngit config --global user.email \"example@example.com\"\n\n# 设置本地当前工作区仓库用户名/邮箱\ngit config --local user.name \"Vitan\"\ngit config --local user.email \"example@example.com\"\n\n# 删除配置\ngit config --unset --global user.name\ngit config --unset --global user.email\n\n# 将默认文本编辑器设置为 emacs\ngit config --global core.editor emacs\n\n# 将默认差异化分析工具设置为 vimdiff\ngit config --global merge.tool vimdiff\n```\n\n## 生成SSH_Key\n```bash\n# 1、粘贴以下命令，替换为您的GitHub电子邮件地址\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n\n# 2、当提示“输入要在其中保存密钥的文件”时，按Enter。接受默认文件位置。\n> Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]\n\n# 3、在提示符下，键入一个安全密码。\n> Enter passphrase (empty for no passphrase): [Type a passphrase]\n> Enter same passphrase again: [Type passphrase again]\n```\n\n最后需要将生成的 SSH Key 添加到 `ssh config` 中\n```bash\n# 1、编辑\nvim ~/.ssh/config\n\n# 2、粘贴下面到 config 文件中\nHost *\n  AddKeysToAgent yes\n  UseKeychain yes\n  IdentityFile ~/.ssh/id_rsa\n```\n\n## 初始化仓库\n`git init` 创建一个空的Git仓库或重新初始化一个现有的仓库\n```bash\n# 会在当前目录生成.git\ngit init\n\n# 以安静模式创建，只会打印错误或警告信息\ngit init -q\n\n# 创建一个裸仓库, 通常情况下用不上\ngit init --bare\n```\n\n## 文件状态\n```bash\n# 完整查看文件状态\ngit status\n\n# 以短格式给出输出\ngit status -s\n\n# 忽略子模块\ngit status --ignore-submodules\n```\n\n## 日志\n```bash\n# 查看完整历史提交记录\ngit log\n\n# 查看前N次提交记录 commit message\ngit log -2\n\n# 查看前N次提交记录，包括diff\ngit log -p -2\n\n# 搜索关键词\ngit log -S Java\n\n# 只显示合并日志\ngit log --merges\n\n# 以图形查看日志记录, --oneline 可选\ngit log --graph --oneline\n\n# 列出提交者贡献数量, 只会打印作者和贡献数量\ngit shortlog -sn\n\n# 以提交贡献数量排序并打印出message\ngit shortlog -n\n\n# 采用邮箱格式化的方式进行查看贡献度\ngit shortlog -e\n\n# 查看 README.md 文件的修改历史记录，包括时间、作者以及内容\ngit blame README.md\n```\n\n# 克隆\n```bash\n# https 协议\ngit clone https://github.com/ivitan/git.git\n\n# SSH协议\ngit clone git@github.com:ivitan/git.git\n\n# 克隆某个分支， -b 指定分支名字\ngit clone -b master https://github.com/ivitan/git.git\n\n# 递归克隆，如果项目包含子模块就非常有用\ngit clone --recursive git@github.com:ivitan/git.git\n\n# 克隆深度为1, 不会把历史的记录也克隆，这样可以节省克隆时间\ngit clone --depth=1 https://github.com/ivitan/git.git\n```\n\n# 分支管理\n## 查看分支\n```bash\n# 查看所有分支\ngit branch -a\n\n# 查看本地分支\ngit branch\n\n# 查看远端分支\ngit branch -r\n\n# 查看本地分支所关联的远程分支\ngit branch -vv\n\n# 查看本地 master 分支创建时间\ngit reflog show --date=iso master\n```\n\n## 切换分支\n```bash\n# 2种方法，切换到master分支\ngit checkout master\ngit switch master\n\n# 切换上一个分支\ngit checkout -\n\n# 切换远端分支\ngit checkout -t origin/dev\n```\n\n## 创建分支\n```bash\n# 创建develop本地分支\ngit branch develop\n\n# 创建本地develop分支并切换\ngit checkout -b develop\n\n# 创建远程分支, 实际上创建本地分支然后推送\ngit checkout -b develop\ngit push origin develop\n\n\n# 创建一个空的分支, 不继承父分支，历史记录是空的，一般至少需要执行4步\ngit checkout --orphan develop\n# 这一步可选，如果你真的想创建一个没有任何文件的分支\ngit rm -rf .\n# 添加并提交，否则分支是隐藏的 （执行这一步之前需要注意当前工作区必须保留一个文件，否则无法提交）\ngit add -A && git commit -m \"提交\"\n# 推送到远程\ngit push --set-upstream origin develop\n```\n\n## 删除分支\n```bash\n# 删除本地分支\ngit branch -d <branchName>\n\n# 删除远程分支\ngit push origin :<branchName>\n```\n\n## 重命名分支\n```bash\n# 重命名当前分支, 通常情况下需要执行3步\n# 1、修改分支名称\n# 2、删除远程旧分支\n# 3、将重命名分支推送到远程\ngit branch -m <branchName>\ngit push origin :old_branch\ngit push -u origin new_branch\n\n\n# 重命名指定分支\ngit branch -m old_branch new_branch\n```\n\n# 代码合并\n```bash\n# 两步法, 将 feature/v1.0.0 分支代码合并到 develop\ngit checkout develop\ngit merge feature/v1.0.0\n\n# 或者一步法\ngit merge feature/v1.0.0 develop\n\n# 以安静模式合并, 把develop分支合并到当前分支并不输出任何信息\ngit merge develop -q\n\n# 合并不编辑消息, 跳过交互\ngit merge develop --no-edit\n```\n\n# 暂存\n```bash\n# 暂存所有\ngit add -A\n\n# 暂存某个文件\ngit add ./README.md\n\n# 暂存当前目录所有改动文件\ngit add .\n\n# 暂存一系列文件\ngit add 1.txt 2.txt ...\n```\n\n# 删除\ngit add 的反向操作\n\n```bash\n# 删除1.txt 文件\ngit rm 1.txt\n\n# 删除当前所有文件, 与rm -rf 命令不同的是不会删除 .git 目录\ngit rm -rf .\n\n# 清除当前工作区缓存，但不会删除文件，通常用于修改文件名不生效问题\ngit rm -r --cached .\n```\n\n## 删除远程内容\n-  预览将要删除的文件\n\n```git\ngit rm -r -n --cached file/folder\n\ngit rm -r --cached file/folder\n\ngit commit -m \"Comment\"\ngit push origin master\n```\n\n加上 `-n` 这个参数，执行命令时，不会删除任何文件，而是展示此命令要删除的文件列表预览。\n\n# 提交\n```bash\n# -m 提交的信息\ngit commit -m \"changes log\"\n\n# 只提交某个文件\ngit commit README.md -m \"message\"\n\n# 提交并显示diff变化\ngit commit -v\n\n# 允许提交空消息，通常必须指定 -m 参数\ngit commit --allow-empty-message\n\n# 重写上一次提交信息，确保当前工作区没有改动\ngit commit --amend -m \"新的提交信息\"\n```\n\n# 推送\n```bash\n# 推送内容到主分支\ngit push -u origin master\n\n# 本地分支推送到远程， 本地分支:远程分支\ngit push origin <branchName>:<branchName>\n\n# 简写，默认推送当前分支\ngit push\n\n# 强制推送, -f 是 --force 缩写\ngit push -f\n```\n\n# 拉取最新内容\n```bash\n# 推荐，因为不会做自动合并\ngit fetch origin master\n\n# 相当于git fetch 然后 git merge\ngit pull\n\n# 后面的意思是： 远程分支名:本地分支名\ngit pull origin master:master\n\n# 如果是要与本地当前分支合并，则冒号后面的<本地分支名>可以不写\ngit pull origin master\n```\n\n# 查看文件的改动\n```bash\n# 查看所有文件改动\ngit diff\n\n# 查看具体文件的改动\ngit diff README.md\n\n# 查看某个版本的改动, 后面那一窜是commitId， git log后就能看到\ngit diff d68a1ef2407283516e8e4cb675b434505e39dc54\n\n# 查看某个文件的历史修改记录\ngit log README.md\ngit show d68a1ef2407283516e8e4cb675b434505e39dc54 README.md\n```\n\n# 回滚版本\n```bash\n# 回滚上一个版本\ngit reset --hard HEAD^\n\n# 回滚上两个版本\ngit reset --hard HEAD^^\n\n# 回退到指定版本，git log 就能看到commit id了\ngit reset --hard 'commit id'\n\n# 回滚版本是不保存在 git log，如果想查看使用\ngit reflog\n```\n\n# 撤销\n```bash\n# 撤销当前目录下所有文件的改动\ngit checkout -- .\n\n# 撤销指定文件修改\ngit checkout -- README.md\n\n# 暂存区回到工作区, 指定 ./README.md 文件从暂存区回到工作区\ngit reset HEAD ./README.md\n\n# 撤销commit, 回到工作区, 一般commit id 是前一个\ngit reset <commit_id>\n\n# 撤销commit, 并且把修改同时撤销\ngit reset --hard <commit_id>\n```\n\n# 标签\n```bash\n# 列出本地所有标签\ngit tag\n\n# 列出远程所有标签\ngit ls-remote --tags origin\n\n# 按照特定模式查找标签, `*` 模板搜索\ngit tag -l \"v1.0.0*\"\n\n# 创建带有附注标签\ngit tag -a v1.1.0 -m \"标签描述\"\n\n# 创建轻量标签, 不需要带任何参数\ngit tag v1.1.0\n\n# 后期打标签, 假设之前忘记打标签了，可以通过git log查看commit id\ngit log\ngit tag -a v1.1.0 <commit_id>\n\n# 推送到远程，默认只是本地创建\ngit push origin v1.1.0\n\n# 一次性推送所有标签到远程\ngit push origin --tags\n\n# 删除标签, 你需要再次运行 git push origin v1.1.0 才能删除远程标签\ngit tag -d v1.1.0\n\n# 删除远程标签\ngit push origin --delete v1.1.0\n\n# 检查标签\ngit checkout v1.1.0\n\n# 查看本地某个标签详细信息\ngit show v1.1.0\n```\n\n# Rebase\n`git rebase` 主要作用可以将多个commit记录合并为一条\n\n```bash\n# 操作最近4次提交\ngit rebase -i HEAD~4\n# 或者以 commit_id 进行操作\ngit rebase -i e88835de905ad396f61a0dc8c040a8ac8a34f3f8\n\n\n# 放弃 git rebase 操作\ngit rebase --abort\n\n# 此命令主要用于解决冲突后继续执行\ngit rebase --continue\n```\n\n参考：[git rebase将多次commit合并为一条](https://www.xiejiahe.com/blog/detail/5d550e8553d11b2c3ca05cbe)\n\n\n# GitFlow\nGit Flow 不是内置命令，需要单独安装\n\n## 初始化\n每个仓库都必须初始化一次\n\n```bash\n# 通常直接回车以完成默认设置\ngit flow init\n```\n\n## 功能\n\n```bash\n# 开启新的功能\ngit flow feature start v1.1.0\n\n# 推送到远程, 在团队协作中这一步少不了\ngit flow feature publish v1.1.0\n\n# 完成功能, 会将当前分支合并到 develop 然后删除分支，回到 develop\ngit flow feature finish v1.1.0\n```\n\n\n## 打补丁\n\nhotfix 是针对 `master` 进行打补丁的\n\n```bash\n# 开启新的 hotfix\ngit flow hotfix start v1.1.0_hotifx\n\n# 推送到远程\ngit flow hotfix publish v1.1.0_hotifx\n\n# 完成新的hotfix, 将当前分支合并到 master 和 develop，然后删除分支，回到 develop\ngit flow hotfix finish v1.1.0_hotifx\n```\n\n## 发布\n\n```bash\n# 开启新的 release\ngit flow release start v1.1.0\n\n# 推送到远程\ngit flow release publish v1.1.0\n\n# 完成, 将当前分支合并到 master 和 develop，删除当前分支然后回到 develop\ngit flow release finish v1.1.0\n```\n\n## Git flow schema\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/git-flow.png)\n\n\n# 子模块\n具体使用还可以看这里 [git submodule子模块使用教程](https://www.xiejiahe.com/blog/detail/5dbceefc0bb52b1c88c30853)\n```bash\n# 添加子模块\ngit submodule add https://github.com/ivitan/git.git\n\n# 更新，有2种方法\n# 一步到位\ngit submodule update --remote\n# 或者进入到子模块项目再拉取\ngit pull\n\n# 修复子模块分支指向 detached head\ngit submodule foreach -q --recursive 'git checkout $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)'\n\n# 删除子模块 common 为子模块名称，一般删除需要三部\ngit submodule deinit <common>\n# 清除子模块缓存\ngit rm --cached common\n# 提交代码并推送\ngit commit -am \"Remove a submodule\" && git push\n```\n\n# 帮助\n```bash\n# 详细打印所有git命令\ngit help\n\n# 打印所有git命令, 此命令不会有详细信息，更清晰一些\ngit help -a\n\n# 列出所有可配置的变量\ngit help -c\n```\n\n# 清空commit历史\n假设当前分支是 `develop`\n\n```bash\n# 1、新建一个新分支\ngit checkout --orphan new_branch\n# 2、暂存所有文件并提交\ngit add -A && git commit -m \"First commit\"\n# 3、删除本地 develop 分支\ngit branch -D develop\n# 4、再将 new_branch 分支重命名为 develop\ngit branch -m develop\n# 5、强制将 develop 分支推送到远程\ngit push -f origin develop\n```\n\n# 其他\n```bash\n# 查看git版本\ngit --version\n\n# 查看远程仓库地址\ngit remote -v\n\n# 记住提交账号密码\ngit config --global credential.helper store\n\n# 清除git已保存的用户名和密码\n# windows\ngit credential-manager uninstall\n# mac linux\ngit config --global credential.helper \"\"\n# 或者\ngit config --global --unset credential.helper\n\n# 清除本地git缓存\ngit rm -r --cached .\n```\n\n# Git 思维导图\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/Gitmap.jpg)\n\n---\n**Via**\n- [git-manual](https://github.com/xjh22222228/git-manual)","tags":["Linux","Windows","Git"],"categories":["Coding"]},{"title":"Windows Shortcuts","path":"/posts/WindowsShortcut.html","content":"Windows 的常用快捷键\n\n<!--more-->\n# Ctrl\n|快捷键|功能|\n|:---|:---|\n|Ctrl + C |复制\n|Ctrl + V |粘贴\n|Ctrl + X |剪切\n|Ctrl + Z |撤销\n|Ctrl + A |全选\n|Ctrl + D |删除\n|Ctrl + Y |恢复\n|Ctrl + R |刷新（F5）\n|Ctrl + F4 |关闭应用或浏览器标签页\n\n# Alt\n|快捷键|功能|\n|:---|:---|\nAlt + F4 | 直接关闭应用\nAlt + Tab | 在打开的应用间切换\nAlt + Enter | 显示所选项目的属性\nAlt + Esc | 按项目打开顺序循环浏览\nAlt + 空格键 | 打开活动窗口的快捷菜单\n\n# Windows\n|快捷键|功能|\n|:---|:---|\nWindows + A |  打开操作中心\nWindows + D  | 显示和隐藏桌面\nWindows + E |  文件资源管理器\nWindows + F |  打开反馈中心\nWindows + G  | 游戏栏\nWindows + I  | 打开设置\nWindows + K  | 打开连接\nWindows + L |  锁屏\nWindows + M  | 最小化所有窗口\nWindows + Shift + M  | 还原桌面上的最小化窗口\nWindows + P |  投屏，选择演示显示模式\nWindows + Q  | 打开搜索\nWindows + R  | 打开“运行”对话框\nWindows + S |  打开搜索\nWindows + T |  循环浏览任务栏上的应用\nWindows + U  | 打开轻松使用设置中心\nWindows + V |  打开剪切板\nWindows + W |  打开 Ink 工作区\nWindows + X |  打开快速链接菜单\nWindows + 空格键  | 切换输入语言和键盘布局\nWindows + 句点 (.)  | 打开表情符号面板\nWindows + 逗号 (,) |  临时速览桌面\nWindows + 号 (+)  | 打开放大镜\nWindows + 数字 |  打开桌面，然后启动固定到任务栏的应用（位于数字所指明的位置）。如果应用已处于运行状态，则切换至该应用，例如应用商店：Windows + 1；新版 Edge 浏览器：Windows + 2；Chrome 浏览器：Windows + 6，以此类推。）\n\n# 虚拟桌面\n|快捷键|功能|\n|:---|:---|\nWindows + Tab  | 打开任务视图\nWindows + Ctrl + D  | 添加虚拟桌面\nWindows + Ctrl + F4  | 关闭虚拟桌面。\n\n# 其它\n|快捷键|功能|\n|:---|:---|\nF2   | 重命名\nCtrl + Shift + Esc   | 打开任务管理器（Ctrl + Alt + Del）\nWindows + PrtScn   | 全屏幕截图\nWindows + Shift + S   | 打开截图和草图\ngetmac  |  获取Mac地址\nmstsc  |  远程连接\nWindows最后一次正确配置  | 开机F8\n\n# 常用快捷命令\n|命令|功能|\n|:---|:---|\nncpa.cpl  | 网络连接\nlusrmgr  | 打开用户组管理\nwinver  | 检查Windows版本\nwmimgmt.msc  | 打开Windows管理体系结构(WMI)\nwupdmgr | Windows更新程序\nwscript  | Windows脚本宿主设置\nwrite  | 写字板\nwinmsd  | 系统信息\nwiaacmgr  | 扫描仪和照相机向导\nwinchat  | XwinverP自带局域网聊天\nmem  | 显示内存使用情况\nMsconfig  | 系统配置实用程序\nmplayer2  | 简易widnows media player\nmspaint  | 画图板\nmstsc  | 远程桌面连接\nmplayer2  | 媒体播放机\nmagnify  | 放大镜实用程序\nmmc  | 打开控制台\nmobsync  | 同步命令\ndxdiag  | 检查DirectX信息\ndrwtsn32  | 系统医生\ndevmgmt.msc  | 设备管理器\ndfrg.msc  | 磁盘碎片整理程序\ndiskmgmt.msc  | 磁盘管理实用程序\ndcomcnfg  | 打开系统组件服务\nddeshare  | 打开DDE共享设置\ndvdplay  | DVD播放器\nnet stop messenger  | 停止信使服务\nnet start messenger  | 开始信使服务\nnotepad  | 打开记事本\nnslookup  | 网络管理的工具向导\nntbackup  | 系统备份和还原\nnarrator  | 屏幕“讲述人”\nntmsmgr.msc  | 移动存储管理器\nntmsoprq.msc  | 移动存储管理员操作请求\nnetstat -an  | (TC)命令检查接口\nsyncapp  | 创建一个公文包\nsysedit  | 系统配置编辑器\nsigverif  | 文件签名验证程序\nsndrec32  | 录音机\nshrpubw  | 创建共享文件夹\nsecpol.msc  | 本地安全策略\nsyskey  | 系统加密，一旦加密就不能解开，保护Windows xp系统的双重密码\nservices.msc  | 本地服务设置\nSndvol32  | 音量控制程序\nsfc.exe  | 系统文件检查器\nsfc /scannow  | Windows文件保护\ntsshutdn  | 60秒倒计时关机命令\ntourstart  | xp简介（安装完成后出现的漫游xp程序）\ntaskmgr  | 任务管理器\neventvwr  | 事件查看器\neudcedit  | 造字程序\nexplorer  | 打开资源管理器\npackager  | 对象包装程序\nperfmon.msc  | 计算机性能监测程序\nprogman  | 程序管理器\nregedit.exe  | 注册表\nrsop.msc  | 组策略结果集\nregedt32  | 注册表编辑器\nrononce -p  | 15秒关机\nregsvr32 /u *.dll  | 停止dll文件运行\nregsvr32 /u zipfldr.dll  | 取消ZIP支持\ncmd.exe  | CMD命令提示符\nchkdsk.exe  | Chkdsk磁盘检查\ncertmgr.msc  | 证书管理实用程序\ncalc  | 启动计算器\ncharmap  | 启动字符映射表\ncliconfg  | SQL SERVER 客户端网络实用程序\nClipbrd  | 剪贴板查看器\nconf  | 启动netmeeting\ncompmgmt.msc  | 计算机管理\ncleanmgr  | 垃圾整理\nciadv.msc  | 索引服务程序\nosk  | 打开屏幕键盘\nodbcad32  | -ODBC数据源管理器\noobe/msoobe /a  | 检查XP是否激活\nlusrmgr.msc  | 本机用户和组\nlogoff  | 注销命令\niexpress  | 木马捆绑工具，系统自带\nNslookup  | IP地址侦测器\nfsmgmt.msc  | 共享文件夹管理器\nutilman  | 辅助工具管理器\ngpedit.msc  | 组策略","tags":["Windows"],"categories":["Diary"]},{"title":"更换 Npm 源","path":"/posts/NpmMirror.html","content":"> Npm 换源\n<!--more-->\n\n# 临时源\n```node\nnpm --registry https://registry.npm.taobao.org install express\n```\n\n# 永久源\n```node\nnpm config set registry https://registry.npm.taobao.org\n```\n\n# cnpm\n```node\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n# 官方镜像\n```node\nnpm config set registry https://registry.npmjs.org/\n```\n\n# 查看源地址\n```node\nnpm config get registry\n```","tags":["Linux","Windows","Node.Js"],"categories":["Coding"]},{"title":"Highlight.Js Markdown 对照表","path":"/posts/HighlightJs.html","content":"> HighlightJs显示语言的完整列表\n\n<!--more-->\n\n用法\n\n```\n    ```key\n    code\n    ``` \n```\n\n\n| 语言               | key              \n| :-----------------------| :---------------------\n| 1C                      | 1c                     \n| ABNF                    | abnf                   \n| Access logs             | accesslog              \n| Ada                     | ada                    \n| ARM assembler           | armasm, arm            \n| AVR assembler           | avrasm                 \n| ActionScript            | actionscript, as       \n| Alan                    | alan, i   \n| AngelScript             | angelscript, asc       \n| Apache                  | apache, apacheconf     \n| AppleScript             | applescript, osascript \n| Arcade                  | arcade                 \n| AsciiDoc                | asciidoc, adoc         \n| AspectJ                 | aspectj                \n| AutoHotkey              | autohotkey             \n| AutoIt                  | autoit                 \n| Awk                     | awk, mawk, nawk, gawk  \n| Axapta                  | axapta                 \n| Bash                    | bash, sh, zsh          \n| Basic                   | basic                  \n| BNF                     | bnf                    \n| Brainfuck               | brainfuck, bf          \n| C#                      | cs, csharp             \n| C++                     | cpp, c, cc, h, c++, h++, hpp\n| C/AL                    | cal                    \n| Cache Object Script     | cos, cls               \n| CMake                   | cmake, cmake.in        \n| Coq                     | coq                    \n| CSP                     | csp                    \n| CSS                     | css                    \n| Cap’n Proto             | capnproto, capnp       \n| Clojure                 | clojure, clj           \n| CoffeeScript            | coffeescript, coffee, cson, iced\n| Crmsh                   | crmsh, crm, pcmk       \n| Crystal                 | crystal, cr            \n| Cypher (Neo4j)          | cypher\n| D                       | d                      \n| DNS Zone file           | dns, zone, bind        \n| DOS                     | dos, bat, cmd          \n| Dart                    | dart                   \n| Delphi                  | delphi, dpr, dfm, pas, pascal, freepascal, lazarus, lpr, lfm\n| Diff                    | diff, patch            \n| Django                  | django, jinja          \n| Dockerfile              | dockerfile, docker     \n| dsconfig                | dsconfig               \n| DTS (Device Tree)       | dts                    \n| Dust                    | dust, dst              \n| Dylan                   | dylan\n| EBNF                    | ebnf                   \n| Elixir                  | elixir                 \n| Elm                     | elm                    \n| Erlang                  | erlang, erl            \n| Excel                   | excel, xls, xlsx       \n| Extempore               | extempore, xtlang, xtm\n| F#                      | fsharp, fs             \n| FIX                     | fix                    \n| Fortran                 | fortran, f90, f95      \n| G-Code                  | gcode, nc              \n| Gams                    | gams, gms              \n| GAUSS                   | gauss, gss             \n| GDScript                | godot, gdscript\n| Gherkin                 | gherkin                \n| GN for Ninja            | gn, gni\n| Go                      | go, golang             \n| Grammatical Framework   | gf                     \n| Golo                    | golo, gololang         \n| Gradle                  | gradle                 \n| Groovy                  | groovy                 \n| HTML, XML               | xml, html, xhtml, rss, atom, xjb, xsd, xsl, plist, svg\n| HTTP                    | http, https            \n| Haml                    | haml                   \n| Handlebars              | handlebars, hbs, html.hbs, html.handlebars\n| Haskell                 | haskell, hs            \n| Haxe                    | haxe, hx               \n| Hy                      | hy, hylang             \n| Ini, TOML               | ini, toml              \n| Inform7                 | inform7, i7            \n| IRPF90                  | irpf90                 \n| JSON                    | json                   \n| Java                    | java, jsp              \n| JavaScript              | javascript, js, jsx    \n| Kotlin                  | kotlin, kt             \n| Leaf                    | leaf                   \n| Lasso                   | lasso, ls, lassoscript \n| Less                    | less                   \n| LDIF                    | ldif                   \n| Lisp                    | lisp                   \n| LiveCode Server         | livecodeserver         \n| LiveScript              | livescript, ls         \n| Lua                     | lua                    \n| Makefile                | makefile, mk, mak      \n| Markdown                | markdown, md, mkdown, mkd\n| Mathematica             | mathematica, mma, wl   \n| Matlab                  | matlab                 \n| Maxima                  | maxima                 \n| Maya Embedded Language  | mel                    \n| Mercury                 | mercury                \n| mIRC Scripting Language | mirc, mrc\n| Mizar                   | mizar                  \n| Mojolicious             | mojolicious            \n| Monkey                  | monkey                 \n| Moonscript              | moonscript, moon       \n| N1QL                    | n1ql                   \n| NSIS                    | nsis                   \n| Nginx                   | nginx, nginxconf       \n| Nimrod                  | nimrod, nim            \n| Nix                     | nix                    \n| OCaml                   | ocaml, ml              \n| Objective C             | objectivec, mm, objc, obj-c\n| OpenGL Shading Language | glsl                   \n| OpenSCAD                | openscad, scad         \n| Oracle Rules Language   | ruleslanguage          \n| Oxygene                 | oxygene                \n| PF                      | pf, pf.conf            \n| PHP                     | php, php3, php4, php5, php6, php7\n| Parser3                 | parser3                \n| Perl                    | perl, pl, pm           \n| Plaintext: no highlight | plaintext              \n| Pony                    | pony                   \n| PostgreSQL & PL/pgSQL   | pgsql, postgres, postgresql\n| PowerShell              | powershell, ps, ps1    \n| Processing              | processing             \n| Prolog                  | prolog                 \n| Properties              | properties             \n| Protocol Buffers        | protobuf               \n| Puppet                  | puppet, pp             \n| Python                  | python, py, gyp        \n| Python profiler results | profile                \n| Q                       | k, kdb                 \n| QML                     | qml                    \n| R                       | r                      \n| Razor CSHTML            | cshtml, razor, razor-cshtml\n| ReasonML                | reasonml, re           \n| RenderMan RIB           | rib                    \n| RenderMan RSL           | rsl                    \n| Roboconf                | graph, instances       \n| Robot Framework         | robot, rf   \n| RPM spec files          | rpm-specfile, rpm, spec, rpm-spec, specfile \n| Ruby                    | ruby, rb, gemspec, podspec, thor, irb | |\n| Rust                    | rust, rs               \n| SAS                     | SAS, sas               \n| SCSS                    | scss                   \n| SQL                     | sql                    \n| STEP Part 21            | p21, step, stp         \n| Scala                   | scala                  \n| Scheme                  | scheme                 \n| Scilab                  | scilab, sci            \n| Shape Expressions       | shexc             \n| Shell                   | shell, console         \n| Smali                   | smali                  \n| Smalltalk               | smalltalk, st          \n| Solidity                | solidity, sol        \n| Stan                    | stan, stanfuncs        \n| Stata                   | stata                  \n| Structured Text         | iecst, scl, stl, structured-text \n| Stylus                  | stylus, styl           \n| SubUnit                 | subunit                \n| Supercollider           | supercollider, sc     \n| Swift                   | swift                  \n| Tcl                     | tcl, tk                \n| Terraform (HCL)         | terraform, tf, hcl     \n| Test Anything Protocol  | tap                    \n| TeX                     | tex                    \n| Thrift                  | thrift                 \n| TP                      | tp                     \n| Twig                    | twig, craftcms         \n| TypeScript              | typescript, ts         \n| VB.Net                  | vbnet, vb              \n| VBScript                | vbscript, vbs          \n| VHDL                    | vhdl                   \n| Vala                    | vala                   \n| Verilog                 | verilog, v             \n| Vim Script              | vim                    \n| x86 Assembly            | x86asm                 \n| XL                      | xl, tao                \n| XQuery                  | xquery, xpath, xq      \n| YAML                    | yml, yaml              \n| Zephir                  | zephir, zep            \n\n---\n\n- [官方文档](https://github.com/highlightjs/highlight.js/tree/9-18-stable)","tags":["Linux","Windows"],"categories":["Coding"]},{"title":"Vim NerdTree 插件","path":"/posts/NerdTree.html","content":"> [NERDTree](https://github.com/preservim/nerdtree) 是 Vim 编辑器的文件系统浏览器。使用此插件，用户可以直观地浏览复杂的目录层次结构，快速打开文件以进行读取或编辑，以及执行基本的文件系统操作。\n\n<!--more--->\n\n# Plug 安装\n```vim\ncall plug#begin('~/.vim/plugged')\nPlug 'scrooloose/nerdtree'          \" File tree manager\nPlug 'jistr/vim-nerdtree-tabs'      \" enhance nerdtree's tabs\nPlug 'ryanoasis/vim-devicons'       \" add beautiful icons besides files\nPlug 'Xuyuanp/nerdtree-git-plugin'  \" display git status within Nerdtree\nPlug 'tiagofumo/vim-nerdtree-syntax-highlight' \" enhance devicons\ncall plug#end()\n```\n\n# 配置\n```vim ~/.vimrc\n\" <Nerdtree>-------------------{\n    \">> Basic settings\n        let g:NERDTreeChDirMode = 2  \"Change current folder as root\n        autocmd BufEnter * if (winnr(\"$\") == 1 && exists(\"b:NERDTree\") && b:NERDTree.isTabTree()) |cd %:p:h |endif\n\n    \">> UI settings\n        let NERDTreeQuitOnOpen=1   \" Close NERDtree when files was opened\n        let NERDTreeMinimalUI=1    \" Start NERDTree in minimal UI mode (No help lines)\n        let NERDTreeDirArrows=1    \" Display arrows instead of ascii art in NERDTree\n        let NERDTreeChDirMode=2    \" Change current working directory based on root directory in NERDTree\n        let g:NERDTreeHidden=1     \" Don't show hidden files\n        let NERDTreeWinSize=30     \" Initial NERDTree width\n        let NERDTreeAutoDeleteBuffer = 1  \" Auto delete buffer deleted with NerdTree\n        \"let NERDTreeShowBookmarks=0   \" Show NERDTree bookmarks\n        let NERDTreeIgnore = ['\\.pyc$', '\\.swp', '\\.swo', '__pycache__']   \" Hide temp files in NERDTree\n        \"let g:NERDTreeShowLineNumbers=1  \" Show Line Number\n    \" Open Nerdtree when there's no file opened\n        \"autocmd vimenter * if !argc()|NERDTree|endif\n    \" Or, auto-open Nerdtree\n        \"autocmd vimenter * NERDTree\n    \" Close NERDTree when there's no other windows\n        autocmd bufenter * if (winnr(\"$\") == 1 && exists(\"b:NERDTree\") && b:NERDTree.isTabTree()) | q | endif\n    \" Customize icons on Nerdtree\n        let g:NERDTreeDirArrowExpandable = '▸'\n        let g:NERDTreeDirArrowCollapsible = '▾'\n\n    \">> NERDTREE-GIT\n        \" Special characters\n    let g:NERDTreeIndicatorMapCustom = { \n        \\ \"Modified\"  : \"✹\",\n        \\ \"Staged\"    : \"✚\",\n        \\ \"Untracked\" : \"✭\",\n        \\ \"Renamed\"   : \"➜\",\n        \\ \"Unmerged\"  : \"═\",\n        \\ \"Deleted\"   : \"✖\",\n        \\ \"Dirty\"     : \"✗\",\n        \\ \"Clean\"     : \"✔︎\",\n        \\ 'Ignored'   : '☒',\n        \\ \"Unknown\"   : \"?\"\n    \\ }\n\n    \">> NERDTree-Tabs\n        \"let g:nerdtree_tabs_open_on_console_startup=1 \"Auto-open Nerdtree-tabs on VIM enter\n    \">> Nerdtree-devicons\n        \"set guifont=DroidSansMono_Nerd_Font:h11\n    \">> Nerdtree-syntax-highlighting\n        \"let g:NERDTreeDisableFileExtensionHighlight = 1\n        \"let g:NERDTreeDisableExactMatchHighlight = 1\n        \"let g:NERDTreeDisablePatternMatchHighlight = 1\n        \"let g:NERDTreeFileExtensionHighlightFullName = 1\n        \"let g:NERDTreeExactMatchHighlightFullName = 1\n        \"let g:NERDTreePatternMatchHighlightFullName = 1\n        \"let g:NERDTreeHighlightFolders = 1 \" enables folder icon highlighting using exact match\n        \"let g:NERDTreeHighlightFoldersFullName = 1 \" highlights the folder name\n        \"let g:NERDTreeExtensionHighlightColor = {} \" this line is needed to avoid error\n\" }\n```\n\n# 快捷键\n输入 `:NERDTreeToggle` 打开文件树。快捷键来映射,在vimrc中加入：\n```vim\nmap <F3> :NERDTreeMirror<CR>\nmap <F3> :NERDTreeToggle<CR>\n```\n\n## 切换工作台和目录\n```vim\nctrl + w + h    光标 focus 左侧树形目录\nctrl + w + l    光标 focus 右侧文件显示窗口\nctrl + w + w    光标自动在左右侧窗口切换\nctrl + w + r    移动当前窗口的布局位置\n\no       在已有窗口中打开文件、目录或书签，并跳到该窗口\ngo      在已有窗口 中打开文件、目录或书签，但不跳到该窗口\nt       在新 Tab 中打开选中文件/书签，并跳到新 Tab\nT       在新 Tab 中打开选中文件/书签，但不跳到新 Tab\ni       split 一个新窗口打开选中文件，并跳到该窗口\ngi      split 一个新窗口打开选中文件，但不跳到该窗口\ns       vsplit 一个新窗口打开选中文件，并跳到该窗口\ngs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口\n!       执行当前文件\nO       递归打开选中 结点下的所有目录\nm    文件操作：复制、删除、移动等\n```\n## 切换标签页\n```vim\n:tabnew [++opt选项] ［＋cmd］ 文件      建立对指定文件新的tab\n:tabc   关闭当前的 tab\n:tabo   关闭所有其他的 tab\n:tabs   查看所有打开的 tab\n:tabp   前一个 tab\n:tabn   后一个 tab\n\n标准模式下：\ngT      前一个 tab\ngt      后一个 tab\n```","tags":["Linux","Windows","Android","Vim"],"categories":["Coding"]},{"title":"Git 版本回退","path":"/posts/GitReset.html","content":"> Git 版本回退\n\n# 本地替换为远程\n```git\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```\n<!--more-->\n\n# 撤销\n```git\n# 撤销所有的已经add的文件:\ngit reset HEAD .\n\n# 撤销某个文件或文件夹\ngit reset HEAD -filename\n\n# 回退到上个版本\ngit reset --hard HEAD^ \n\n# 退到/进到 指定commit_id\ngit reset --hard commit_id\n```\n\n- 文件被修改了，但未执行git add操作（working tree内撤销）\n\n```git\ngit checkout fileName\ngit checkout .\n```\n\n- 同时对多个文件执行了git add操作，但本次只想提交其中一部分文件\n\n```git\ngit add *\ngit status\ngit reset HEAD <filename>\n```\n- 文件执行了git add操作，但想撤销对其的修改（index内回滚）\n\n```git\n# 取消暂存\ngit reset HEAD fileName\n# 撤销修改\ngit checkout fileName\n```\n\n- 修改的文件已被git commit，但想再次修改不再产生新的Commit\n\n```git\n# 修改最后一次提交 \ngit add sample.txt\ngit commit --amend -m\"说明\"\n```\n\n- 已在本地进行了多次git commit操作，现在想撤销到其中某次Commit\n\n```git\ngit reset [--hard|soft|mixed|merge|keep] [commit|HEAD]\n```","tags":["Linux","Windows","Git"],"categories":["Coding"]},{"title":"Pixel 2 XL 开启 Diag","path":"/posts/PixelDiag.html","content":"> Pixel 2 XL 开启 Diag 破解电信 VoLTE\n\n# 开启端口\n1. 安装 Diag Magisk 并输入模块\n2. 刷入 Pixel_2_Diag_Port.zip\n3. 刷入 VoEnabler-v1.4.zip\n4. 连接电脑，输入以下命令开启 Diag 端口 \n\n<!--more-->\n\n```shell\ncd D:\\adb\nadb devices\nadb shell\nsu\nsetenforce 0\nsetprop sys.usb.configfs 1 && setprop sys.usb.config diag,serial_cdev,rmnet_gsi,adb\n```\n- su命令需要在手机端 Magisk 确认 root 授权，成功会在设备管理器的端口中看到高通 9091\n\n# 电信 VoLTE\n- 其他运营商的配置文件方法一样\n\n1. 安装 QPST\n2. 打开 QPST 的 PDC 选择 9091 端口\n3. 点击Load加载运营商配置文件mcfg_sw.mbn，建议使用commerci/hvolte_o/mcfg_sw.mbn，\n4. 加载出运营商配置文件后，右击该配置，指配到 sub0，最后点激活 active，将会不重启直接开启 VoLTE 模式\n\n# 所需工具\n[提取码: j3sc](https://pan.baidu.com/s/1gDZMKuqvrMsAg7zEjKr5sw )","tags":["Windows","Android"],"categories":["Coding"]},{"title":"安装 Google USB Driver","path":"/posts/UsbDriver.html","content":"> Google USB Driver 是针对 Google 设备执行 adb 调试的驱动。安装可解决 bootloader 下 waiting for any device\n\n# 下载\n- [Windows latest_usb_driver_windows.zip](https://dl-ssl.google.com//android/repository/latest_usb_driver_windows.zip)\n\n# 安装\n设备管理器 -> 便携设备 -> 属性 -> 驱动程序 -> 更新驱动程序 -> 选择解压好的文件夹","tags":["Linux","Windows"],"categories":["Diary"]},{"title":"Cmder 配置","path":"/posts/Cmder.html","content":"> Cmder 是 Windows出色的终端。它不仅支持 Linux 命令，并且因为并采用了 Monokai 配色方案，最重要的是能自定义布局。\n\n<!--more-->\n\n# 配置\n## 基本配置\n- 系统环境变量\n\n```\nCMDER_HOME\nD:\\Program Files\\cmder\n```\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20200405132003.png)\n\n- 在 PATH 添加 `%CMDER_HOME%`\n\n## 右键菜单\n- 添加\n\n```\nCmder.exe /REGISTER ALL\n```\n\n- 删除\n\n```\nCmder.exe /UNREGISTER ALL\n```\n\n## 使用 Bash\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/cmder_bash.png)\n\n\n## 别名\n### Bash\nBash 配置文件的加载顺序是:\n```\n$CMDER_ROOT/config/profile.d/*.sh\n$CMDER_ROOT/config/user-profile.sh\n$HOME/.bashrc\n```\n\n### CMD \n```bat %CMDER_ROOT%\\config\\user-aliases.cmd \nls=ls --show-control-chars -F --color $*\npwd=cd\nclear=cls\n```\n\n### PowerShell\n直接使用 PowerShell 的 alias 命令添加或在下面的文件中添加\n\n```\n'CMDER_ROOT\\config\\profile.d\\*.ps1'\n'CMDER_ROOT\\config\\user-profile.ps1'\n```\n\n## 配置文件\n```bash D:\\Program Files\\cmder\\vendor\\git-for-windows\\etc\\bash.bashrc\n# 别名\nalias vs=\"code .\"\nalias e.='explorer .'\nalias cp='cp -i'\nalias mv='mv -i'\nalias rm='rm -i'\nalias ls='ls -F --color=auto'\nalias ll='ls -al'\nalias grep='grep --color=auto'\nalias la='ls -a'\nalias l.='ls -d .* --color=tty'\nalias vitan='hexo clean && hexo g && hexo s'\n\n# Git Commit, Add all and Push — in one step.\nfunction ad() {\n    git add . && git commit -m \"$*\"\n}\n\nfunction gadd() {\n    ad \"⚡ ADD: $@\"\n}\n\nfunction gcap() {\n    git add . && git commit -m \"$*\" && git push\n}\n\n# NEW.\nfunction gnew() {\n    gcap \"📦 NEW: $@\"\n}\n\n# IMPROVE.\nfunction gimp() {\n    gcap \"👌 IMPROVE: $@\"\n}\n\n# FIX.\nfunction gfix() {\n    gcap \"🐛 FIX: $@\"\n}\n\n# RELEASE.\nfunction grlz() {\n    gcap \"🚀 RELEASE: $@\"\n}\n\n# DOC.\nfunction gdoc() {\n    gcap \"📖 DOC: $@\"\n}\n\n# TEST.\nfunction gtst() {\n    gcap \"✅ TEST: $@\"\n}\n```\n\n# 设置 VS Code\n## 添加环境变量\n变量名 `CMDER_ROOT` 变量值 `D:\\Program Files\\cmder`\n\n## VS Code 配置\n\n```sh setting.json\n\"terminal.integrated.shell.windows\": \"cmd.exe\",\n\"terminal.integrated.shellArgs.windows\": [\n    \"/k\",\n    \"D:\\\\Program Files\\\\cmder\\\\vendor\\\\init.bat\"\n]\n```","tags":["Linux","Windows","Batch"],"categories":["Coding"]},{"title":"Termux Config Shell","path":"/posts/TermuxConfig.html","content":"> 写的一个 Termux 配置脚本，配置开发环境、美化等...\n\n## via curl\n```bash\napt install curl\nbash -c \"$(curl -fsSL https://raw.githubusercontent.com/ivitan/Shell/master/Termux/Termux.sh)\"\n```\n\n## via wget\n```bash\napt install wget\nbash -c \"$(wget -O- https://raw.githubusercontent.com/ivitan/Shell/master/Termux/Termux.sh)\"\n```","tags":["Linux","Windows"],"categories":["Coding"]},{"title":"配置 WNMP 环境","path":"/posts/WNMP.html","content":"> WNMP 一键安装\n\n# 仓库\nhttps://github.com/ivitan/wnmp\n\n# WNMP 下载\n- [Nginx](http://nginx.org/en/download.html)\n- [PHP](http://windows.php.net/download/ )\n- [MySQL](http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.17-winx64.zip)\n\n<!--more-->\n\n# Nignx\n1. 解压 Nignx 到 D:\\WNMP\\Nignx\n2. 运行 D:\\WNMP\\Nignx 下的 nginx.exe\n3. 打开浏览器访问 http://localhost 或 http://127.0.0.1\n\n![nginx.png](https://i.loli.net/2019/12/23/TuIFyje98l4qXvi.png)\n\n4. 配置\n\n```nginxconf D:\\WNMP\\Nignx\\nginx.cof\n#user  nobody;\nworker_processes  auto;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    #default_type  application/octet-stream;\n    \n\n    autoindex on;\n    autoindex_exact_size off;\n    autoindex_localtime on;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #access_log  logs/access.log  main;\n    sendfile        on;\n    #tcp_nopush     on;\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n    #gzip  on;\n\tinclude vhost/*.conf;\n}\n```\n\n```nginxconf D:\\WNMP\\Nignx\\conf\\vhost\\default.cof\nserver {\n    listen 80;\n    server_name localhost;\n    root www/;\n    location / {\n        index index.php index.html index.htm;\n        try_files $uri $uri/ /index.php?$query_string;\n    }\n    location ~ \\.php$ {\n        fastcgi_pass 127.0.0.1:9000;\n        fastcgi_index index.php;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        include fastcgi_params;\n    }\n    access_log logs/access.log main;\n}\n```\n\n## 常用命令\n```nginx\nnginx -s stop\t快速关闭 Nginx\nnginx -s quit\t优雅的关闭 Nginx\nnginx -s reload 更改配置，使用新配置启动新工作进程，正常关闭旧工作进程\nnginx -s reopen 重新打开日志文件\n```\n# MySQL\n## 配置\n```ini %mysql%\\my.ini\n[mysqld]\ncharacter-set-server=utf8\n#绑定IPv4和3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir=D:/WNMP/mysql\n# 设置mysql数据库的数据的存放目录\ndatadir=D:/WNMP/mysql/data\n# 允许最大连接数\nmax_connections=2000\n# skip_grant_tables\n[mysql]\ndefault-character-set=utf8\n[mysql.server]\ndefault-character-set=utf8\n[mysql_safe]\ndefault-character-set=utf8\n[client]\ndefault-character-set=utf8\n```\n## 安装\n```bash %mysql%\\bin\nmysqld.exe -install \n```\n提示：Service successfully installed. 表示安装成功.\n\n### 初始化 MySQL 数据\n创建一个具有空密码的root用户\n```sql\nmysqld --initialize-insecure --user=mysql \n```\n- 最后的参数 --user=mysql 在 windows 也可以不用添加\n- 但在 unix 等系统下好像很重要。 \n- 执行命令后系统会自动生成相应的 data 目录，并自动创建好空密码的 root 用户。\n\n## 启动mysql服务\n```bat\nnet start mysql\n```\n## 进行密码设定\n可执行如下命令：\n```sql\nmysqladmin -u root -p password NewPassword\n\npassword: # OldPassword\n```\n- 在输入旧密码（或没改过密码的就直接回车）\n- 系统很久没响应，然后报错（10060）。 原因：mysql没有通过windows防火墙 解决方法：将 D:\\mysql\\bin\\mysqld.exe 添加到windows防火墙允许通过的应用中。\n\n# PHP\n1. 解压 PHP 到 D:\\WNMP\\PHP\n2. 修改配置，将 D:\\WNMP\\PHP\\php.ini-development 改为 php.ini,取消下面注释\n\n```yml D:\\WNMP\\PHP\\php.ini\n;extension=mysql\n;extension=mysqli\n;enable_dl = Off，改为 enable_dl = On\n;fastcgi.impersonate = 1\n;extension=curl\n;extension=gd2\n;extension=mbstring\n;extension=mysqli\n;extension=mysql\n```\n\n去 `;` 再修改\n\n```yml\n;extension_dir = \"ext\" 改为 extension_dir = \"D:\\wnmp\\php\\ext\"\n;date.timezone = 改为date.timezone = Asia/Shanghai\n;cgi.force_redirect = 1 改为cgi.force_redirect = 0\n;cgi.rfc2616_headers = 0 改为 cgi.rfc2616_headers = 1\n```\n3. 配置 PHP，使其能与 Nginx 配合，取消下面的注释\n\n```yml\n;cgi.fix_pathinfo=1\n```\n\n4. 启动PHP\n\n```bat\nD:\\WNMP\\php\\php-cli.exe -b 127.0.1.1:9000 -c D:\\WNMP\\php\\php.ini\n```\n\n## php.ini 配置\nhttps://github.com/ivitan/wnmp/blob/master/php/php-7.2.25/php.ini\n\n# 脚本\n## 环境变量\n环境变量Path里面增加 MySQL、Nginx、PHP 执行文件的路径\n```bat\n;D:\\wnmp\\mysql\\bin;D:\\wnmp\\nginx;D:\\wnmp\\php;\n```\n## 启动 WNMP\n```bat stat.bat\n@echo off\nset base_path=%cd%\nset nginx_path=%base_path%\\nginx\nset php7_path=%base_path%\\php\\php-7.2.25\nset mysql_path=%base_path%\\mySql\n\necho Starting PHP7 FastCGI...\nRunHiddenConsole %php7_path%\\php-cgi.exe -b 127.0.0.1:9000 -c %php7_path%\\php.ini\n\necho Starting Nginx...\nRunHiddenConsole %nginx_path%\\nginx.exe -c %nginx_path%\\conf\\nginx.conf\n\necho Starting MySql...\nRunHiddenConsole %mysql_path%\\bin\\mysqld --defaults-file=%mysql_path%\\my.ini --port=3306\n\necho please open http://127.0.0.1 ...\nping -n 3 127.0.0.1 > nul\nstart chrome  \"dev.vitan.me\"\nexit\n```\n\n## 重启 WNMP\n```bat\n@echo off\necho Stopping Nginx...\ntaskkill /F /IM nginx.exe > nul\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho Stopping Mysql...\ntaskkill /F /IM mysqld.exe > nul\n\nset base_path=%cd%\nset nginx_path=%base_path%\\nginx\nset php7_path=%base_path%\\php\\php-7.2.25\nset mysql_path=%base_path%\\mysql\n\necho Starting PHP7 FastCGI...\nRunHiddenConsole %php7_path%\\php-cgi.exe -b 127.0.0.1:9000 -c %php7_path%\\php.ini\n\necho Starting Nginx...\nRunHiddenConsole %nginx_path%\\nginx.exe -c %nginx_path%\\conf\\nginx.conf\n\necho Starting MySql...\nRunHiddenConsole %mysql_path%\\bin\\mysqld --defaults-file=%mysql_path%\\my.ini --port=3306\necho please open http://127.0.0.1 ...\nping -n 3 127.0.0.1 > nul\nstart chrome  \"dev.vitan.me\"\nexit\n```\n\n## 关闭 WNMP\n```bat\n@echo off\nset base_path=%cd%\nset nginx_path=%base_path%\\nginx\nset php7_path=%base_path%\\php\\php-7.2.25\nset mysql_path=%base_path%\\mySql\n\necho Starting PHP7 FastCGI...\nRunHiddenConsole %php7_path%\\php-cgi.exe -b 127.0.0.1:9000 -c %php7_path%\\php.ini\n\necho Starting Nginx...\nRunHiddenConsole %nginx_path%\\nginx.exe -c %nginx_path%\\conf\\nginx.conf\n\necho Starting MySql...\nRunHiddenConsole %mysql_path%\\bin\\mysqld --defaults-file=%mysql_path%\\my.ini --port=3306\n\necho please open http://127.0.0.1 ...\nping -n 3 127.0.0.1 > nul\nstart chrome  \"design.vitan.me\"\nexit\n```\n\n# 整体测试\n- 测试 PHP\n\n```php D:\\WNMP\\www\n<?php\nphpinfo();\n?>\n```\n浏览器访问 http://localhost/phpinfo.php\n\n- 测试 Mysql\n\n```php D:\\WNMP\\www\n<?php\nif (mysqli_connect(\"localhost\", \"root\", \"root\")) {\n    echo \"Mysql connect successful！\";\n} else {\n    echo \"Mysql connect error...\";\n}\n?>\n```","tags":["Windows","Web","PHP"],"categories":["Coding"]},{"title":"Batch 计划任务","path":"/posts/WinTask.html","content":"> Batch 计划任务\n\n# 语法\n```cmd\nSCHTASKS /Create [/S system [/U username [/P [password]]]]\n[/RU username [/RP password]] /SC schedule [/MO modifier] [/D day]\n[/M months] [/I idletime] /TN taskname /TR taskrun [/ST starttime]\n[/RI interval] [ {/ET endtime | /DU duration} [/K] [/XML xmlfile] [/V1]]\n[/SD startdate] [/ED enddate] [/IT | /NP] [/Z] [/F] [/HRESULT] [/?]\n```\n<!--more-->\n\n描述:允许管理员在本地或远程系统上创建计划任务。\n\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc minute [/mo {1 - 1439}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]]\n```\n\n# 参数列表\n|参数|含义|\n|:---|:---|\n|`/S  system `|指定要连接到的远程系统。如果省略这个系统参数，默认是本地系统。\n|`/U  username ` | 指定应在其中执行 SchTasks.exe 的用户上下文。\n| `/P  [password]` |指定给定用户上下文的密码。如果省略则提示输入。\n| `/RU  username`  |    指定任务在其下运行的“运行方式”用户,帐户(用户上下文)。对于系统帐户，有效值是 \"\"、\"NT AUTHORITY\\SYSTEM\" 或\"SYSTEM\"。对于 v2 任务，\"NT AUTHORITY\\LOCALSERVICE\"和 \"NT AUTHORITY\\NETWORKSERVICE\"以及常见的 SID 对这三个也都可用。\n|`/RP  [password] ` |  指定“运行方式”用户的密码。要提示输入密码，值必须是 \"*\" 或无。系统帐户会忽略该密码。必须和 /RU 或 /XML 开关一起使用。\n|`/RU/XML /SC schedule` | 指定计划频率。有效计划任务:  MINUTE、 HOURLY、DAILY、WEEKLY、 MONTHLY, ONCE, ONSTART, ONLOGON, ONIDLE, ONEVENT.\n|`/MO  modifier` | 改进计划类型以允许更好地控制计划重复周期。有效值列于下面“修改者”部分中。\n|` /D    days` |  指定该周内运行任务的日期。有效值:MON、TUE、WED、THU、FRI、SAT、SUN和对 MONTHLY 计划的 1 - 31(某月中的日期)。通配符“*”指定所有日期。\n| `/M    months` |  指定一年内的某月。默认是该月的第一天。有效值: JAN、FEB、MAR、APR、MAY、JUN、JUL、 AUG、SEP、OCT、NOV  和 DEC。通配符 “*” 指定所有的月。\n|`/I    idletime` |    指定运行一个已计划的 ONIDLE 任务之前要等待的空闲时间。有效值范围: 1 到 999 分钟。\n|`/TN   taskname` |    以路径\\名称形式指定对此计划任务进行唯一标识的字符串。\n|`/TR   taskrun`  |    指定在这个计划时间运行的程序的路径和文件名。例如: C:\\windows\\system32\\calc.exe\n|`/ST   starttime`|    指定运行任务的开始时间。时间格式为 HH:mm (24 小时时间)，例如 14:30 表示 2:30 PM。如果未指定 /ST，则默认值为当前时间。/SC ONCE 必需有此选项。\n|`/RI   interval` |    用分钟指定重复间隔。这不适用于计划类型: MINUTE、HOURLY、ONSTART, ONLOGON, ONIDLE, ONEVENT.有效范围: 1 - 599940 分钟。如果已指定 /ET 或 /DU，则其默认值为10 分钟。\n| `/ET   endtime ` |    指定运行任务的结束时间。时间格式为 HH:mm (24 小时时间)，例如，14:50 表示 2:50 PM。这不适用于计划类型: ONSTART、ONLOGON, ONIDLE, ONEVENT.\n| `/DU   duration `  |  指定运行任务的持续时间。 时间格式为 HH:mm。这不适用于 /ET 和 计划类型: ONSTART, ONLOGON, ONIDLE, ONEVENT.对于 /V1 任务，如果已指定 /RI，则持续时间默认值为1 小时。\n|`/K `  | 在结束时间或持续时间终止任务。这不适用于计划类型: ONSTART、ONLOGON, ONIDLE, ONEVENT.必须指定 /ET 或 /DU。\n|`/SD   startdate`  |  指定运行任务的第一个日期。格式为 yyyy/mm/dd。默认值为当前日期。这不适用于计划类型: ONCE、ONSTART, ONLOGON, ONIDLE, ONEVENT.\n| `/ED   enddate `  |   指定此任务运行的最后一天的日期。格式是 yyyy/mm/dd。这不适用于计划类型:ONCE、ONSTART、ONLOGON、ONIDLE。\n|`/EC   ChannelName` | 为 OnEvent 触发器指定事件通道。\n|`/IT` |  仅有在 /RU 用户当前已登录且作业正在运行时才可以交互式运行任务。此任务只有在用户已登录的情况下才运行。\n|`/NP `  |不储存任何密码。任务以给定用户的身份非交互的方式运行。只有本地资源可用。\n|`/Z ` |  标记在最终运行完任务后删除任务。\n|`/XML  xmlfile`  | 从文件的指定任务 XML 中创建任务。可以组合使用 /RU 和 /RP 开关，或者在任务 XML 已包含主体时单独使用 /RP。\n|`/V1 ` |  创建 Vista 以前的平台可以看见的任务。不兼容 /XML。\n| `/F` |   如果指定的任务已经存在，则强制创建任务并抑制警告。\n|`/RL   level ` | 为作业设置运行级别。有效值为 LIMITED 和 HIGHEST。默认值为 LIMITED。\n|`/DELAY delaytime ` | 指定触发触发器后延迟任务运行的等待时间。时间格式为mmmm:ss。此选项仅对计划类型ONSTART, ONLOGON, ONEVENT.\n|`/HRESULT ` |  为获得更出色的故障诊断能力，处理退出代码将采用 HRESULT 格式。\n| `/?` | 显示此帮助消息。\n\n修改者: 按计划类型的 /MO 开关的有效值:\n\n|参数|有效值|\n|:---|:---|\n|MINUTE|  1 到 1439 分钟|\n|HOURLY|  1 - 23 小时|\n|DAILY|  1 到 365 天|\n|WEEKLY|  1 到 52 周|\n|ONCE| 无修改者|\n|ONSTART|无修改者|\n|ONLOGON| 无修改者|\n|ONIDLE| 无修改者|\n|MONTHLY| 1 到 12，或FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY|\n|ONEVENT|  XPath 事件查询字符串|\n\n## 示例\n1. 在远程机器 \"ABC\" 上创建计划任务 \"doc\"， \"runasuser\" 用户下运行 notepad.exe。\n\n```cmd\nSCHTASKS /Create /S ABC /U user /P password \n/RU runasuser /RP runaspassword /SC HOURLY /TN doc /TR notepad\n```\n\n2. 远程机器 \"ABC\" 上创建计划任务 \"accountant\"， 在指定的开始日期和结束日期之间的开始时间和结束时间内，每隔五分钟运行 calc.exe。\n\n```cmd\nSCHTASKS /Create /S ABC /U domain\\user /P password \n/SC MINUTE /MO 5 /TN accountant /TR calc.exe /ST 12:00 \n/ET 14:00 /SD 06/06/2006 /ED 06/06/2006 /RU runasuser /RP userpassword\n```\n\n3. 创建计划任务 \"gametime\"，在每月的第一个星期天运行“空当接龙”。\n\n```cmd\nSCHTASKS /Create /SC MONTHLY /MO first /D SUN \n/TN gametime /TR c:\\windows\\system32\\freecell\n```\n\n4. 在远程机器 \"ABC\" 创建计划任务 \"report\"，每个星期运行 notepad.exe。\n\n```cmd\nSCHTASKS /Create /S ABC /U user /P password /RU runasuser\n/RP runaspassword /SC WEEKLY /TN report /TR notepad.exe\n```\n\n5. 在远程机器 \"ABC\" 创建计划任务 \"logtracker\"，每隔五分钟从指定的开始时间到无结束时间，运行 notepad.exe。将提示输入 /RP 密码。\n\n```cmd\nSCHTASKS /Create /S ABC /U domain\\user /P password /SC MINUTE\n/MO 5 /TN logtracker\n/TR c:\\windows\\system32\\notepad.exe /ST 18:30\n/RU runasuser /RP\n```\n\n6. 创建计划任务 \"gaming\"，每天从 12:00 点开始到14:00 点自动结束，运行 freecell.exe。\n\n```cmd\nSCHTASKS /Create /SC DAILY /TN gaming /TR c:\\freecell /ST 12:00\n/ET 14:00 /K\n```\n\n7. 创建计划任务“EventLog”以开始运行 wevtvwr.msc只要在“系统”通道中发布事件 101\n\n```cmd\nSCHTASKS /Create /TN EventLog /TR wevtvwr.msc /SC ONEVENT\n/EC System /MO *[System/EventID=101]\n```\n\n8. 文件路径中可以加入空格，但需要加上两组引号，一组引号用于 CMD.EXE，另一组用于 SchTasks.exe。用于 CMD的外部引号必须是一对双引号；内部引号可以是一对单引号或一对转义双引号:\n\n```cmd\nSCHTASKS /Create\n/tr \"'c:\\program files\\internet explorer\\iexplorer.exe'\n\\\"c:\\log data\\today.xml\\\"\" ...\n```\n\n9. 令计划安全脚本 Sec.vbs 每 20 分钟运行一次。由于命令没有包含起始日期或时间，任务在命令完成 20 分钟后启动，此后每当系统运行它就每 20 分钟运行一次。请注意，安全脚本源文件位于远程计算机上，但任务在本地计算机上计划并执行。\n\n```cmd\nschtasks /create /sc minute /mo 20 /tn \"Security Script\" /tr \\\\central\\data\\scripts\\sec.vbs\n```\n\n# 其他实例     \n转载自:https://blog.csdn.net/lionzl/article/details/40896893\n## schtasks create hourly\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc hourly [/mo {1 - 365}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]]\n```\n计划命令在每小时过五分的时候运行。\n\n1. 下面的命令将计划 MyApp 程序从午夜过后五分钟起每小时运行一次。因为忽略了 /mo 参数，命令使用了小时计划的默认值，即每 (1) 小时。如果该命令在 12:05 A.M 之后生成，程序将在第二天才会运行。\n\n```cmd\nschtasks /create /sc hourly /st 00:05:00 /tn \"My App\" /tr c:\\apps\\myapp.exe\n```\n\n计划命令每五小时运行一次\n\n下面的命令计划 MyApp 程序从 2001 年 3 月的第一天起每五小时运行一次。它使用 /mo 参数来指定间隔时间，使用 /sd 参数来指定起始日期。由于命令没有指定起始时间，当前时间被用作起始时间。\n\n```cmd\nschtasks /create /sc hourly /mo 5 /sd 03/01/2001 /tn \"My App\" /tr c:\\apps\\myapp.exe\n```\n\n## schtasks create daily\n\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc daily [/mo {1 - 365}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]]\n```\n\n计划任务每天运行一次\n\n下面的范例计划 MyApp 程序在每天的 8:00 A.M. 运行一次，直到 2001 年 12 月 31 日结束。由于它忽略了 /mo 参数，所以使用默认间隔 1 来每天运行命令。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc daily /st 08:00:00 /ed 12/31/2001\n```\n\n计划任务每隔一天运行一次\n\n下面的范例计划 MyApp 程序从 2001 年 12 月 31 日起每隔一天在 1:00 P.M. (13:00) 运行。命令使用 /mo 参数来指定两 (2) 天的间隔。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc daily /mo 2 /st 13:00:00 /sd 12/31/2001\n```\n\n## schtasks create weekly\n\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc weekly [/d {MON - SUN | *}] [/mo {1 - 52}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]]\n```\n\n计划任务每六周运行一次\n\n下面的命令计划 MyApp 程序在远程计算机上每六周运行一次。该命令使用 /mo 参数来指定间隔。它也使用 /s 参数来指定远程计算机，使用 /ru 参数来计划任务以用户的 Administrator 帐户权限运行。因为忽略了 /rp 参数，SchTasks.exe 会提示用户输入 Administrator 帐户密码。\n\n另外，因为命令是远程运行的，所以命令中所有的路径，包括到 MyApp.exe 的路径，都是指向远程计算机上的路径。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc weekly /mo 6 /s Server16 /ru Admin01\n```\n\n\n计划任务每隔一周在周五运行\n\n下面的命令计划任务每隔一周在周五运行。它使用 /mo 参数来指定两周的间隔，使用 /d 参数来指定是一周内的哪一天。如计划任务在每个周五运行，要忽略 /mo 参数或将其设置为 1。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc weekly /mo 2 /d FRI\n```\n\n## schtasks create monthly\n### 常规月计划语法\n\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc monthly [/mo {FIRST | SECOND | THIRD | FOURTH | LAST | LASTDAY] [/d {MON - SUN | 1 - 31}] [/m {JAN - DEC[,JAN - DEC...] | *}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] \n```\n\n- 指定周的语法\n\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc monthly /mo {FIRST | SECOND | THIRD | FOURTH | LAST} /d {MON - SUN} [/m {JAN - DEC[,JAN - DEC...] | *}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] \n```\n\n- Lastday 语法\n\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc monthly /mo LASTDAY /m {JAN - DEC[,JAN - DEC...] | *} [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] \n```\n\n- 指定日期的语法\n\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc monthly /d {1 - 31} [/m {JAN - DEC[,JAN - DEC...] | *}] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]] \n```\n\n#### 计划任务在每月的第一天运行\n\n下面的命令计划 MyApp 程序在每月的第一天运行。因为默认修饰符是 none（即：没有修饰符），默认天是第一天，默认的月份是每个月，所以该命令不需要任何其它的参数。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly\n```\n\n#### 计划任务在每月的最后一天运行\n\n下面的命令计划 MyApp 程序在每月的最后一天运行。它使用 /mo 参数指定在每月的最后一天运行程序，使用通配符 (*) 与 /m 参数表明在每月的最后一天运行程序。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /mo lastday /m *\n```\n\n#### 计划任务每三个月运行一次\n\n下面的命令计划 MyApp 程序每三个月运行一次。.它使用 /mo 参数来指定间隔。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /mo 3\n```\n\n#### 计划任务在每月的第二个周日运行\n\n下面的命令计划 MyApp 程序在每月的第二个周日运行。它使用 /mo 参数指定是每月的第二周，使用 /d 参数指定天。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /mo SECOND /d SUN\n```\n\n#### 计划任务在五月和六月的第 15 天运行。\n\n下面的命令计划 MyApp 程序在五月 15 日和六月 15 日的 3:00 PM (15:00) 运行。它使用 /d 参数来指定日期，使用 /m 参数指定月份。它也使用 /st 参数来指定开始时间。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /d 15 /m MAY,JUN /st 15:00:00\n```\n\n## schtasks create once\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc once /st StartTime /sd StartDate [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]]\n```\n\n### 计划任务运行一次\n\n下面的命令计划 MyApp 程序在 2002 年 1 月 1 日午夜运行一次。它使用 /ru 参数指定以用户的 Administrator 帐户权限运行任务，使用 /rp 参数为 Administrator 帐户提供密码。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc once /st 00:00:00 /sd 01/01/2002 /ru Admin23 /rp p@ssworD1\n```\n\n## schtasks create onstart\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc onstart [/sd StartDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]]\n```\n### 计划任务在每次系统启动的时候运行\n\n下面的命令计划 MyApp 程序在每次系统启动的时候运行，起始日期是 2001 年 3 月 15 日。\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc onstart /sd 03/15/2001\n```\n\n## schtasks create onlogon\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc onlogon [/sd StartDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]]\n```\n\n### 计划任务在用户登录到远程计算机的时候运行\n\n下面的命令计划批处理文件在用户（任何用户）每次登录到远程计算机上的时候运行。它使用 /s 参数指定远程计算机。因为命令是远程的，所以命令中所有的路径，包括批处理文件的路径，都指定为远程计算机上的路径。\n\n```cmd\nschtasks /create /tn \"Start Web Site\" /tr c:\\myiis\\webstart.bat /sc onlogon /s Server23\n```\n\n## schtasks create onidle\n```cmd\nschtasks /create /tn TaskName /tr TaskRun /sc onidle /iIdleTime [/sd StartDate] [/s computer [/u [domain\\]user /p password]] [/ru {[Domain\\]User | \"System\"} [/rp Password]]\n```\n### 计划某项任务在计算机空闲的时候运行\n\n下面的命令计划 MyApp 程序在计算机空闲的时候运行。它使用必需的 /i 参数指定在启动任务之前计算机必需持续空闲十分钟。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc onidle /i 10\n```\n\n### 创建以 System 权限运行的任务\n\n下面的命令计划 MyApp 程序以 NT Authority\\System 帐户权限运行。在这个范例中，任务计划在每月的第一天运行，但对于以系统权限运行的任务可以使用所有的计划类型。\n\n该命令使用 /ru \"System\" 参数指定系统安全上下文。因为系统任务不需要密码，所以忽略了 /rp 参数。\n\n```cmd\nschtasks /create /tn \"My App\" /tr c:\\apps\\myapp.exe /sc monthly /d 1 /ru \"System\"\n```\n\n作为响应，SchTasks.exe 显示一个信息性消息和一个成功消息。它不提示输入密码。信息：此任务将被创建于用户名下 (\"NT AUTHORITY\\SYSTEM\")。 成功：计划任务 \"My App\" 已成功创建。 \n\n### 创建运行多个程序的任务\n\n每个任务只能运行一个程序。但是可以创建一个运行多个程序的批处理文件，然后计划一个任务来运行该批处理文件。下面的过程说明了这个方法：\n\n1. 创建一个启动要运行程序的批处理文件。\n\n在这个范例中创建了一个启动“事件查看器”(Eventvwr.exe) 和“系统监视器”(Perfmon.exe) 的批处理文件。\n* 启动文本编辑器，例如“记事本”。\n* 键入每个程序的名称和指向可执行文件的完全合格的路径。在这种情况下，文件包含有下列语句。\n\n```cmd MyApp.bat\nC:\\Windows\\System32\\Eventvwr.exe\nC:\\Windows\\System32\\Perfmon.exe\n```\n2. 使用 SchTasks.exe 创建一个运行 MyApps.bat 的任务。\n\n下面的命令创建了 Monitor 任务，每当有人登录它就运行。它使用 /tn 参数命名任务，使用 /tr 参数运行 MyApps.bat。它使用 /sc 参数来指明 OnLogon 计划类型，使用 /ru 参数指定 Administrator 帐户。\n```cmd\nchtasks /create /tn Monitor /tr C:\\MyApps.bat /sc onlogon /ru Reskit\\Administrator\n```\n该命令的结果是，每当用户登录到计算机，任务就启动“事件查看器”和“系统监视器”。\n\n### 更改计划任务\n\n更改一个或多个下列任务属性。\n\n* 任务运行的程序 (/tr)。\n* 任务运行的用户帐户 (/ru)。\n* 用户帐户的密码 (/rp)。\n\n语法\n```cmd\nschtasks /change /tn TaskName [/s computer [/u [domain\\]user /p password]] [/tr TaskRun] [/ru [Domain\\]User | \"System\"] [/rp Password]\n```\n\n|参数|含义|\n|:---|:---|\n|`/tn TaskName`| 标识要更改的任务。输入任务名|\n|`/s Computer`| 指定远程计算机的名称或 IP 地址（带有或者没有反斜杠）。默认值是本地计算机|\n|`/u [domain\\]user`| 使用特定用户帐户的权限运行命令。默认情况下，使用已登录到运行 SchTasks 的计算机上的用户的权限运行命令|\n| `/p password`| 指定在 /u 参数中指定的用户帐户的密码。如果使用 /u 参数，则需要该参数|\n| `/tr TaskRun`| 更改任务运行的程序。输入可执行文件、脚本文件或批处理文件的完全合格的路径和文件名。如果忽略了路径，SchTasks.exe 假定文件在 Systemroot\\System32 目录下指定的程序替换任务最初运行的程序|\n| `/ru [Domain\\]User \"System\"`| 更改用于任务的用户帐户。 [domain\\]User  指定用户帐户\"System\" or \" 指定为操作系统所使用的 NT Authority\\System 帐户。在更改用户帐户的时候，必须也要更改用户密码。如果命令带有 /ru 参数，但没有 /rp 参数，SchTasks.exe 提示要求输入新的密码而且不显示键入的文本。任务以不需要密码的 NT Authority\\System 帐户权限运行，SchTasks.exe 不会提示输入密码|\n|`/p Password`| 更改用于任务的帐户密码。输入新的密码|\n| `/?` |在命令提示符显示帮助|\n\n注释\n\n* XOX /tn 和 /s 参数标识该任务。/tr、/ru 和 /rp 参数指定可以更改的任务属性。\n* 使用 change 操作的命令必须至少更改一个任务属性。\n* NT Authority\\System 帐户没有交互式登录权限。用户看不到以系统权限运行的程序，不能与其交互。\n\n### 更改任务运行的程序\n\n下面的命令将 Virus Check 任务运行的程序由 VirusCheck.exe 更改为 VirusCheck2.exe。此命令使用 /tn 参数标识任务，使用 /tr 参数指定任务的新程序。（不能更改任务名称。）\n\n```cmd\nschtasks /change /tn \"Virus Check\" /tr C:\\VirusCheck2.exe\n```","tags":["Windows","Batch"],"categories":["Coding"]},{"title":"Batch","path":"/posts/Batch.html","content":"> Batch 批量处理相关。# %~dp0[获取当前路径]1. %~dp0 “d”为Drive的缩写，即为驱动器，磁盘、“p”为Path缩写，即为路径，目录2. cd %~dp0 ：进入批处理所在目录3. cd %~dp0bin\\ ：进入批处理所在目录的bin目录```batREM 作用：以管理员身份安装Apached:cd %~dp0bin\\httpd.exe -k install -n \"Apache24\"```以管理员身份运行 示例.bat ，执行结果如下：```batC:\\Windows\\system32>d:D:\\>cd D:\\Server\\Apache24\\bin\\D:\\Server\\Apache24\\bin>httpd.exe -k install -n \"Apache24\"```# 常用命令%cd%[执行的路径]当前执行的路径，并非目标文件的路径taskill```battaskkill /f /im notepad.exe [终止进程]taskkill /?打开帮助```获取命令帮助 xxx /?遇到记不清楚的命令，但记得名字，就可以键入 命令名 空格 /?就会有详细的该命令的帮助了，比如：ping /? , cd /?查看内置命令帮助信息```batver /?cmd /?set /?rem /?if /?echo /?goto /?for /?shift /?call /?```其他常用的命令```battype /?find /?findstr /?copy /?```# 基础语法1. 批处理文件是一个“.bat”结尾的文本文件，这个文件的每一行都是一条DOS命令。可以使用任何文本文件编辑工具创建和修改。2. 批处理是一种简单的程序，可以用 if 和 goto 来控制流程，也可以使用 for 循环。3. 批处理的编程能力远不如C语言等编程语言，也十分不规范。4. 每个编写好的批处理文件都相当于一个DOS的外部命令，把它所在的目录放到DOS搜索路径(path)中，即可在任意位置运行。5. C:\\AUTOEXEC.BAT 是每次系统启动时都会自动运行的，可以将每次启动时都要运行的命令放入该文件中。6. 大小写不敏感(命令符忽略大小写)7. 批处理的文件扩展名为 .bat 或 .cmd。8. 在命令提示下键入批处理文件的名称，或者双击该批处理文件，系统就会调用Cmd.exe来运行该文件。 # 参数系统参数```bat%SystemRoot% ===> C:\\WINDOWS (%windir% 同样)%ProgramFiles% ===> C:\\Program Files%USERPROFILE% ===> C:\\Documents and Settings\\Administrator (子目录有“桌面”,“开始菜单”,“收藏夹”等)%APPDATA% ===> C:\\Documents and Settings\\Administrator\\Application Data%TEMP% ===> C:\\DOCUME~1\\ADMINI~1\\LOCALS~1\\Temp (%TEM% 同样)%APPDATA% ===> C:\\Documents and Settings\\Administrator\\Application Data%OS% ===> Windows_NT (系统)%Path% ===> %SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem (原本的设置)%HOMEDRIVE% ===> C: (系统盘)%HOMEPATH% ===> \\Documents and Settings\\AdministratorREM 枚举当前的环境变量setlocal enabledelayedexpansionFOR /F \"usebackq delims==\" %%i IN (`set`) DO @echo %%i !%%i!``` 传递参数给批处理文件%[1-9]表示参数，参数是指在运行批处理文件时在文件名后加的以空格(或者Tab)分隔的字符串。变量可以从%0到%9，%0表示批处理命令本身，其它参数字符串用 %1 到 %9 顺序表示。```batREM 执行同目录下的“test2.bat”文件，并输入两个参数call test2.bat \"hello\" \"haha\"```在“test2.bat”文件里写:```batecho %1 (打印: \"hello\")echo %2 (打印: \"haha\")echo %0 (打印: test2.bat)echo %19 (打印: \"hello\"9)```# 批处理基本命令help 命令/? 命令，语法： 命令 /?可显示此命令的帮助信息```batREM 把 type 命令的帮助信息写入到tmp.txt文件里type /? >>tmp.txt ``````bathelp type (显示跟“type /?”一样)``` Echo 命令语法: ```batecho [{onoff}] [message]ECHO [ON  OFF] 打开回显或关闭回显功能。ECHO 显示当前回显设置。ECHO [message] 显示信息。echo off 表示在此语句后所有运行的命令都不显示命令行本身；默认是on，on时会显示如： C:\\文件夹路径>命令行。```在实际应用中我们会把这条命令和重定向符号( 也称为管道符号，一般用 > >> ^ )结合来实现输入一些命令到特定格式的文件中。```bat echo offREM 显示出“hello world”echo hello world echo Windows Registry Editor Version 5.00 > c:\\setupreg.reg REM 追加内容进 setupreg.reg 这个文件echo \"SourcePath\"=\"D:\\\\Win2003\\\\\" >> c:\\setupreg.reg ``` @ 命令表示不显示@后面的命令@ 与 echo off 相象，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行(只能影响当前行)。```bat@echo off REM 此语句常用于开头，表示不显示所有的命令行信息，包括此句@echo please wait a minite...@format X: /q/u/autoset```format 这个命令是不可以使用/y这个参数的，可喜的是微软留了个autoset这个参数给我们，效果和/y是一样的。 Goto 命令语法：goto label (label是参数，指定所要转向的批处理程序中的行。)指定跳转到标签行，找到标签行后，程序将处理从下一行开始的命令。label标签的名字可以随便起，但是最好是有意义的，字母前必须加个冒号“:”来表示这个字母是标签。goto命令就是根据这个冒号来寻找下一步跳到到那里。经常与 if 配合使用，根据不同的条件来执行不同的命令组。Rem 命令语法：Rem Message...(小技巧：用::代替rem)注释命令，在C语言中相当与/*...*/,它并不会被执行，只是起一个注释的作用，便于别人阅读和自己日后修改。```bat@Rem Here is the description.``` Pause 命令会暂停批处理的执行并在屏幕上显示Press any key to continue...的提示，等待用户按任意键后继续```bat@echo off:begincopy a:*.* d:\\backecho Please put a new disk into driver Apausegoto begin```在这个例子中，驱动器 A 中磁盘上的所有文件均复制到d:\\back中。显示的信息提示您将另一张磁盘放入驱动器 A 时，pause 命令会使程序挂起，以便您更换磁盘，然后按任意键再次复制。 Call 命令语法: ```batcall [[Drive:][Path] FileName [BatchParameters]] [:label [arguments]]```参数: `[Drive:][Path] FileName` 指定要调用的批处理程序的位置和名称。filename 参数必须具有 `.bat` 或 `.cmd` 扩展名。调用另一个批处理程序，并且不终止父批处理程序。如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令。call 命令接受用作调用目标的标签。如果在脚本或批处理文件外使用 Call，它将不会在命令行起作用。```batREM 调用指定目录下的 test2.bat，且输入3个参数给他call=\"%cd%\\test2.bat\" haha kkk aaaREM 调用同目录下的 test2.bat，且输入2个参数给他call test2.bat arg1 arg2 ```注：可以调用自身(死循环、递归)Start 命令调用外部程序，所有的 DOS命令 和 命令行程序 都可以由 start命令 来调用。常用参数：- MIN 开始时窗口最小化- SEPARATE 在分开的空间内开始 16 位 Windows 程序- HIGH 在 HIGH 优先级类别开始应用程序- REALTIME 在 REALTIME 优先级类别开始应用程序- WAIT 启动应用程序并等候它结束- parameters 这些为传送到命令/程序的参数```batREM 调用同目录下的 test2.bat，且输入2个参数给他，且本窗口最小化start /MIN test2.bat arg1 arg2REM 文件路径名有空格时e:\\\"program files\"\\qq.exe```If 命令if 表示将判断是否符合规定的条件，从而决定执行不同的命令。有三种格式:语法: ```batif [not] \"参数\" == \"字符串\" 待执行的命令```参数如果等于(not表示不等，下同)指定的字符串，则条件成立，运行命令，否则运行下一句。(注意是两个等号)```batif \"%1\" == \"a\" format a:if {%1} == {} goto noparms```If exist语法: if [not] exist [路径\\]文件名 待执行的命令如果有指定的文件，则条件成立，运行命令，否则运行下一句。```batREM 存在这文件，则编辑它，用很难看的系统编辑器if exist config.sys edit config.sysREM 如果存在这文件，则显示它的内容if exist config.sys type config.sys ```If errorlevel number语法: if [not] errorlevel <数字> 待执行的命令如果程序返回值等于指定的数字，则条件成立，运行命令，否则运行下一句。(返回值必须按照从大到小的顺序排列)```bat@echo offXCOPY F:\\test.bat D:\\IF ERRORLEVEL 1 (ECHO 文件拷贝失败) Else IF ERRORLEVEL 0 ECHO 成功拷贝文件pause```很多DOS程序在运行结束后会返回一个数字值用来表示程序运行的结果(或者状态)，称为错误码errorlevel或称返回码。常见的返回码为0、1。通过if errorlevel命令可以判断程序的返回值，根据不同的返回值来决定执行不同的命令。Else语法： if 条件 (成立时执行的命令) else (不成立时执行的命令)如果是多个条件，建议适当使用括号把各条件包起来，以免出错。```batif 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) else (echo comment3 )REM 如果 else 的语句需要换行，if 执行的行尾需用“^”连接，并且 if 执行的动作需用(括起来)，否则报错if 1 == 0 ( echo comment1 ) else if 1==0 ( echo comment2 ) ^else (echo comment3 )```比较运算符:```batEQU - 等于 (一般使用“==”)NEQ - 不等于 (没有 “!=”,改用“ if not 1==1 ”的写法)LSS - 小于LEQ - 小于或等于GTR - 大于GEQ - 大于或等于``` Choice 命令choice 使用此命令可以让用户输入一个字符(用于选择)，从而根据用户的选择返回不同的 errorlevel，然后配合 if errorlevel 选择运行不同的命令。注意：choice命令为DOS或者Windows系统提供的外部命令，不同版本的choice命令语法会稍有不同，请用choice /?查看用法。choice 使用此命令可以让用户输入一个字符，从而运行不同的命令。使用时应该加/c:参数，c:后应写提示可输入的字符，之间无空格。它的返回码为1234……```batchoice /c:dme defrag,mem,end```将显示: defrag,mem,end[D,M,E]?```batchoice /c:dme defrag,mem,endif errorlevel 3 goto defrag (应先判断数值最高的错误码)if errorlevel 2 goto memif errotlevel 1 goto end```For 命令for 命令是一个比较复杂的命令，主要用于参数在指定的范围内循环执行命令。```batfor {%variable  %%variable} in (set) do command [command-parameters]```- `%variable` 指定一个单一字母可替换的参数。变量名称是区分大小写的，所以 %i 不同于 %I,在批处理文件中使用 FOR 命令时，指定变量建议用 %%variable而不要用 %variable- `set` 指定一个或一组文件。可以使用通配符- `command` 指定对每个文件执行的命令- `command-parameters` 为特定命令指定参数或命令行开关。如果命令扩展名被启用，额外的 FOR 命令格式会受到支持a.```batFOR /D %variable IN (set) DO command [command-parameters]```如果集里面包含通配符，则指定与目录名匹配，而不与文件名匹配。b.```batFOR /R [[drive:]path] %variable IN (set) DO command [command-parameters]```检查以 [drive:]path 为根的目录树，指向每个目录中的FOR 语句。如果在 /R 后没有指定目录，则使用当前目录。如果集仅为一个单点(.)字符，则枚举该目录树。c.```batFOR /L %variable IN (start,step,end) DO command [command-parameters]```该集表示以增量形式从开始到结束的一个数字序列。如：(1,1,5) 将产生序列 1 2 3 4 5； 而(5,-1,1) 将产生序列 (5 4 3 2 1)。d.有或者没有 usebackq 选项:```batFOR /F [\"options\"] %variable IN (file-set) DO commandFOR /F [\"options\"] %variable IN (\"string\") DO commandFOR /F [\"options\"] %variable IN (command) DO command```参数\"options\"为:1. eol=c - 指一个行注释字符的结尾(就一个,如“;”)2. skip=n - 指在文件开始时忽略的行数。3. delims=xxx - 指分隔符集。这个替换了空格和跳格键的默认分隔符集。4. tokens=x,y,m-n - 指每行的哪一个符号被传递到每个迭代的 for 本身。这会导致额外变量名称的分配。5. m-n格式为一个范围。通过 nth 符号指定 mth。如果符号字符串中的最后一个字符星号，那么额外的变量将在最后一个符号解析之后分配并接受行的保留文本。usebackq - 指定新语法已在下类情况中使用:在作为命令执行一个后引号的字符串并且一个单引号字符为文字字符串命令并允许在 filenameset中使用双引号扩起文件名称。1. 显示当前目录下所有以bat或者txt为扩展名的文件名```batfor %%c in (*.bat *.txt) do (echo %%c)```a. 显示当前目录下所有包含有 e 或者 i 的目录名```batfor /D %%a in (*e* *i*) do echo %%a```b. 显示 E盘test目录 下所有以bat或者txt为扩展名的文件名。```batfor /R E:\\test %%b in (*.txt *.bat) do echo %%bfor /r %%c in (*) do (echo %%c) :: 遍历当前目录下所有文件```c. 如下命令行将产生序列 1 2 3 4 5```batfor /L %%c in (1,1,5) do echo %%c```d. 以下两句，显示当前的年月日和时间```batFor /f \"tokens=1-3 delims=-/. \" %%j In ('Date /T') do echo %%j年%%k月%%l日For /f \"tokens=1,2 delims=: \" %%j In ('TIME /T') do echo %%j时%%k分```e. 把记事本中的内容每一行前面去掉8个字符```batsetlocal enabledelayedexpansionfor /f %%i in (zhidian.txt) do (set atmp=%%iset atmp=!atmp:~8!if {!atmp!}=={} ( echo.) else echo !atmp!)REM 读取记事本里的内容(使用 delims 是为了把一行显示全,否则会以空格为分隔符)for /f \"delims=\" %%a in (zhidian.txt) do echo.%%a```continue 和 break利用 goto 实现程序中常用的 continue 和 break 命令, 其实非常简单1. `continue` 在 for 循环的最后一行写上一个标签，跳转到这位置即可2. `break` 在 for 循环的外面的下一句写上一个标签，跳转到这位置即可```batfor /F [\"options\"] %variable IN (command) DO (... do command ...if ... goto continueif ... goto break... do command ...:continue):break``` # 其它命令ping 命令测试网络联接状况以及信息包发送和接收状况。但是不能够测试端口。```batping IP地址或主机名 [-t] [-a] [-n count] [-l size]```参数含义：- -t 不停地向目标主机发送数据；- -a 以IP地址格式来显示目标主机的网络地址；- -n count 指定要Ping多少次，具体次数由count来指定；- -l size 指定发送到目标主机的数据包的大小。```batREM 不停的测试192.168.0.1，按ctrl+c停止ping 192.168.0.1 -t ()REM ping一下所有的局域网电脑for /L %%a in (0,1,255) do ping 192.168.0.%%a -n 1 >> tmp.txt```telnet 命令测试端口使用 telnet IP地址或主机名 端口，使用tcp协议的```battelnet 192.168.0.1 80 (测试192.168.0.1的80端口)```color 命令设置背景及字体颜色 ```batcolor bf```b 是指定背景色的十六进制数字； f 指定前景颜色(即字体颜色)。颜色值: 0:黑色 1:蓝色 2:绿色 3:湖蓝 4:红色 5:紫色 6:** 7:白色8:灰色 9:淡蓝 A:淡绿 B:浅绿 C:淡红 D:淡紫 E:淡黄 F:亮白如果没有给定任何参数，该命令会将颜色还原到 CMD.EXE 启动时的颜色。如果两参数一样，视为无效输入。只有一个参数时，设置字体。random 命令产生随机数(正整数0~)exit 命令结束程序。即时是被调用的程序，结束后也不会返回原程序shutdown命令```batREM关机shutdown -s ```# 字符串处理分割字符串，以查看时间为例%源字符串:~起始值,截取长度% (起始值从0开始；截取长度是可选的，如果省略逗号和截取长度，将会从起始值截取到结尾；截取长度如果是负数，表示截取到倒数第几个。)1. `%time%` 显示如：\"11:04:23.03\" (完整的时间\"hh:mm:ss.tt\")2. `%time:~0,5%` 显示\"hh:mm\"(即\"11:04\")，其中0表示从右向左移位操作的个数，5表示从左向右移位操作的个数3. `%time:~0,8%` 显示标准时间格式\"hh:mm:ss\"(即\"11:04:23\"，前8个字符串)4. `%time:~3,-3%` 显示\"mm:ss\"(即从第4个开始,截去最后3个的字符串)5. `%time:~3%` 显示\"04:23.03\"(即去掉前4个字符串)6. `%time:~-3%` 显示\".tt\"(即最后3个字符串)上面的字串分割格式，也可以用于其它地方，如目录路径：\"%cd:~0,10%\"替换字符串```batset a=\"abcd1234\"echo %a% 显示：\"abcd1234\"set a=%a:1=kk% 替换“1”为“kk”echo %a% 显示：\"abcdkk234\"```字符串合并由于没有直接的字符串合并函数，只能用笨方法了。```batset str1=%str1%%str2% (合并 str1 和 str2)```计算字符串长度没有现成的函数。如下程序利用 goto形成循环，不断将字符串截短1，并记录截短的次数，到字符串变成空时的次数即长度。```batset testStr=This is a test stringREM 将 testStr 复制到str，str 是个临时字符串set str=%testStr%REM 标签，用于goto跳转:next1REM 判断str是不是空，如果不是则执行下边的语句if not \"%str%\"==\"\" (REM 算术运算，使num的值自增1，相当于num++或者++num语句set /a num+=1REM 截取字符串，每次截短1set \"str=%str:~1%\"REM 跳转到next1标签: 这里利用goto和标签，构成循环结构goto next1)REM 当以上循环结构执行完毕时，会执行下边的语句echo testStr=%testStr%echo testStr的长度为：%num%```截取字符串时，需要传递参数直接 echo %args:~%num%,-5% 没办法想要的字符串，需要如下两步```batsetlocal enabledelayedexpansionecho !args:~%num%,-5!``` # 注册表操作备份注册表- 将[HKEY_LOCAL_MACHINE ... Run]的内容，备份到“c:\\windows\\1.reg”```batreg export HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run c:\\windows\\1.regreg export HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run c:\\windows\\2.reg```修改/添加注册表内容- 一般的添加或修改```batreg add \"HKCU\\Environment\" /v Java_Home /t reg_sz /d \"D:\\Java\\jdk1.6.0_07\" /f```上句解析：“HKCU”是“HKEY_CURRENT_USER”的缩写，不用缩写用全称也可以；添加名称为“Java_Home”的变量；类型为“reg_sz”，另一种常见类型是“reg_dword”；值为 D:\\Java\\jdk1.6.0_07；使用变量```batset SoftWareHome=HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft\\Javareg add \"%SoftWareHome%Web Start\\1.6.0_07\" /v Home /t reg_sz /d \"%cd%\\jre1.6.0_07\\bin\" /f```注册表的名称有空格，或者数据用特殊符号时```batreg add \"%SoftWareHome2%\\HelpCommands\" /v \"01:Online Documentation\" /t reg_sz /d \"\\\"%cd%\\Documentation\\Index.htm\\\"\" /fREM 传入值为(值用双引号括起来的)：\"D:\\ProgramFiles\\1.work_soft\\Sybase\\PowerDesigner_12\\Documentation\\Index.htm\"reg add \"%SoftWareHome2%\\Paths\" /v ReportTemplates /t reg_sz /d \"%cd%\\Resource Files\\Report Templates\\\\\" /f传入值为(“\\”结尾的)： E:\\Holemar\\1.notes\\90. Windows\\Resource Files\\Report Templates\\```增加空的内容```batreg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Shared Tools\\MSConfig\\startupreg\\IMJPMIG8.1\"```添加或修改默认值```batreg add \"%vpath%InstallPath\" /ve /t reg_sz /d \"%cd%\" /f```这里用“/ve”来代替一般修改时的“/v 变量名”,即可修改默认值了删除注册表的内容双引号里面的是注册表的目录，下面两句将删除这目录下的所有信息```batreg delete \"HKEY_CURRENT_USER\\Software\\RealVNC\" /freg delete \"HKEY_LOCAL_MACHINE\\SOFTWARE\\RealVNC\" /f```双引号里面的是注册表的目录，下面一句将删除这目录下指定的某个信息```batreg delete \"HKEY_LOCAL_MACHINE\\Software\\RealVNC\" /v VNC_Server /f```注册表的常用位置系统启动项：```bat[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run][HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run]example: REG ADD HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v VNC_Server /t REG_SZ /d \"%cd%\\VNC_Server.bat\" /f```系统环境变量：```bat[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment]```当前用户的环境变量：```bat[HKEY_CURRENT_USER\\Environment]```刷新注册表修改注册表之后，结束并重新加载explorer.exe进程，可刷新注册表，令其生效```battaskkill /f /im explorer.exe >nulstart \"\" \"explorer.exe\"``` # 系统服务停止/启动```batREM 停止服务NET STOP 服务名REM 启动服务NET Start 服务名``` 设置启动类型```batREM 自动： SC CONFIG 服务名 START= autoREM 手动： SC CONFIG 服务名 START= demandREM 已禁用：SC CONFIG 服务名 START= disabled```附：“START= ”等号后面必须要有一个空格。(start还有boot,system两个值)```batREM 打印机加载项，设置成手动，默认自动SC CONFIG Spooler START= demand```查看系统服务：```batstart %SystemRoot%\\system32\\services.msc /s``` # setlocal与变量延迟在没有开启变量延迟的情况下，某条命令行中的变量改变，必须到下一条命令才能体现。另外例如for命令等，其后用一对圆括号闭合的所有语句也当作一行。```batset a=4set a=5 & echo %a%```结果：4也可以对这种机制加以利用，如下的变量交换```batset var1=abcset var2=123echo 交换前： var1=%var1% var2=%var2%set var1=%var2%& set var2=%var1%echo 交换后： var1=%var1% var2=%var2%```- 启动批处理文件中环境变量的本地化。本地化将持续到出现匹配的 endlocal 命令或者到达批处理文件结尾为止。语法:```batsetlocal {enableextension  disableextensions} {enabledelayedexpansion  disabledelayedexpansion}```1. `enableextension` 启用命令扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。2. `disableextensions` 禁用命令扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。3. `enabledelayedexpansion` 启用延迟的环境变量扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。4. `disabledelayedexpansion` 禁用延迟的环境变量扩展，直到出现匹配的 endlocal 命令，无论 setlocal 命令之前的设置如何。 - 为了能够感知环境变量的动态变化，批处理设计了变量延迟。简单来说，在读取了一条完整的语句之后，不立即对该行的变量赋值，而会在某个单条语句执行之前再进行赋值，也就是说“延迟”了对变量的赋值。```batsetlocal enabledelayedexpansionset a=4set a=5 & echo !a!```结果： 5变量延迟的启动语句是“setlocal enabledelayedexpansion”，并且变量要用一对叹号“!!”括起来由于启动了变量延迟，所以批处理能够感知到动态变化，即不是先给该行变量赋值，而是在运行过程中给变量赋值，因此此时a的值就是5了另外，启动变量延迟，“%”的变量还是不变```batsetlocal enabledelayedexpansionfor /l %%i in (1,1,5) do (set a=%%iecho !a!)```结果，打印从1到5；如果不变量延迟，一个变量也没有打印 # 文件处理删除- 删除一个文件或多个文件```batdel /s /q /f d:\\test\\a.bat```将直接删除d:\\test\\a.bat，没有任务提示```batdel temp\\* /q /f /s```将直接删除 本目录的 temp 目录的所有文件，没有任务提示删除文件的时候可以使用“*”作通配符- 删除一个空目录```batrd /q /s d:\\test\\log```将直接删除d:\\test\\log目录，如果log目录里面有文件将无法删除- 删除一个非空目录 (必须指定目录名称)```batrmdir /q /s d:\\test\\logs```必须指定目录名称，不能使用通配符1. `/S` 除目录本身外，还将删除指定目录下的所有子目录2. `/Q` 安静模式，带 /S 删除目录树时不要求确认无论里面是否有文件或文件夹将全部直接删除创建目录```batMKDIR [drive:]pathMD [drive:]path```路径有空格时，可以用双引号括起来，也可以用 &nbsp; 替代# 实践部分1. 调用其他程序时，对文件的大小写不敏感，文件后缀也可忽略,如：`start LeapFTP.exe` 与 `start leapftp` 效果一样，都是运行“LeapFTP.exe”文件。每行的开头的字符串会自动查找程序来运行，还可用双引号引起来(文件名或目录名含空格时必须用),如：\"D:\\Program Files\\Leap FTP.exe\" \"LeapFTP.exe\" 可正常运行文件，start \"\" \"LeapFTP.exe\" 也可以正常运行文件(注意，第一个参数是窗口显示的标题)3. `copy C:\\test\\*.* D:\\back` (复制C盘test文件夹的所有文件(不包括文件夹及子文件夹里的东西)到D盘的back文件夹)4. `dir c:\\*.* > a.txt` (将c盘文件列表写入 a.txt 中)5. `>` 生成文件并写入内容(如果有这文件则覆盖)，` >>` 文件里追加内容6. `md d:\\aa` (创建文件夹)7. 在命令末尾加上 `>NUL 2>NUL`，表示隐蔽返回信息。8. 等待用户输入：set /p 变量名=屏幕显示信息```batset /p pass=请输入密码:```9. 让用户按回车退出,小技巧(替代pause)，文件的最后一句：```batset /p tmp=操作结束，请按回车键退出...```10. 设置标题： `title JDK安装`11. 设置屏幕显示颜色，如绿色: `color 0a`12. 清屏： `cls`13. 查看自己的IP```batfor /f \"tokens=15\" %%i in ('ipconfig ^ find /i \"ip address\"') do set ip=%%iecho %ip% (这时的 %ip% 就是自己的IP地址)```14. 修改文件的更新日期```batcopy 文件名+,,>nul (修改为当前时间，如果要修改为指定时间，先修改系统时间，再改回系统时间)```15. 修改文件的后缀名```batren C:\\test\\*.jpg *.JPGfor /r %%c in (*.jpg) do (ren %%c *.JPG) :: 修改当前目录下的所有文件的后缀名，包括子目录的```16. 修改文件的文件名```batrename test.jpg test2.JPGrename *.jpg *.888.JPG```17. 查看DNS、IP、Mac等```batREM Win08winipcfgIpconfig /allNSLOOKUP```18. 查看IP上的共享资源，就可以```batnet view 192.168.10.8```19. 共享A. 查看你机器的共享资源: ```batnet share```B. 手工删除共享```batnet share 共享资源名称$ /d```注意$后有空格。C. 增加一个共享：```batnet share mymovie=e:\\downloads\\movie /users:3```mymovie 共享成功。 同时限制链接用户数为3人。20. 打开某网站```batstart iexplore.exe http://www.baidu.com``` # 实例1. 生成 reg 文件，运行它，再删除它```batecho \"更改windows安装文件的路径\"echo Windows Registry Editor Version 5.00 > c:\\setupreg.regecho [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup] >> c:\\setupreg.regecho \"ServicePackSourcePath\"=\"D:\\\\Win2003\\\\\" >> c:\\setupreg.regecho \"SourcePath\"=\"D:\\\\Win2003\\\\\" >> c:\\setupreg.regREM 写入注册表regedit /S c:\\setupreg.regREM 删除注册表文件del c:\\setupreg.reg``` 2. 调用了exe文件,结束后没有关闭，解决方法:用start命令运行文件，如```batstart LeapFTP.exe 192.168.0.100```3. 设置系统环境变量```batREM 有这个环境变量，则不需再设置，直接结束if not \"%JAVA_HOME%\" == \"\" exitREM 设置环境变量的地址set inputJavaHome=%cd%\\jdk1.6.0_07REM 设置环境变量，也可以设置当前用户的变量set EnvironmentHome=HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environmentecho 正在设置环境变量，请稍候......reg add \"%EnvironmentHome%\" /v JAVA_HOME /t reg_sz /d \"%inputJavaHome%\" /freg add \"%EnvironmentHome%\" /v ClassPath /t reg_sz /d \".;%%JAVA_HOME%%\\lib\" /freg add \"%EnvironmentHome%\" /v Path /t reg_sz /d \"%%JAVA_HOME%%\\bin;%Path%\" /f]REM 刷新，令环境变量生效taskkill /f /im explorer.exe >nulstart \"\" \"explorer.exe\"```4. 隐藏某目录的所有文件及文件夹```batcd /d 要隐藏的目录(如：D:)for /f \"usebackq delims=\" %%A in (`dir /a /b`) do (attrib \"%%A\" -r +h -s)``` 5. 在批处理中使用密码。密码为admin，输入正确，跳转到next1 ，若输入密码错误3次，则锁屏。```bat@echo offset num=0:11set /p pass=请输入密码:if \"%pass%\"==\"admin\" goto next1set /a num=%num% + 1if %num%==3 goto no1goto 11:no1%windir%\\system32\\rundll32.exe user32.dll,LockWorkStationgoto 11:next1echo 密码正确，执行下面的程式pause``` 6. 清空回收站(未成功)```bat@echo offdel /f /s /q c:\\recycler\\*.*del /f /s /q %systemdrive%\\recycled\\*.*REM 新屏幕taskkill /f /im explorer.exe >nulstart \"\" \"explorer.exe\"``` 7. 让系统断断续续地鸣叫```bat@echo off:beginREM 发出鸣叫(“”实际就是ASCII码值为7的特殊字符（蜂鸣键beep）echoREM 让程序暂停一小阵子ping -n 1 -l 1 127.1>nulgoto :begin```8. 将 FAT 卷转换成 NTFS利用“CONVERT.exe”进行,解析如下：```batCONVERT volume /FS:NTFS [/V] [/CvtArea:filename] [/NoSecurity] [/X]```- `volume` 指定驱动器号(后面跟一个冒号)、装载点或卷名- `/FS:NTFS` 指定要被转换成 NTFS 的卷- `/V` 指定 Convert 应该用详述模式运行- `/CvtArea:filename `将根目录中的一个接续文件指定为NTFS 系统文件的占位符- `/NoSecurity` 指定每个人都可以访问转换的文件和目录的安全设置- `/X` 如果必要，先强行卸载卷。该卷的所有打开的句柄则无效 ```bat@ ECHO OFF@ ECHO.@ ECHO. 说 明@ ECHO --------------------------------------------------------------------------@ ECHO NTFS是一种磁盘格式。该格式能存放大于4G的单个文件(如高清电影文件)，并可对@ ECHO 文件夹进行加密，但有个缺点是DOS下无法访问。建议D盘及其后的盘使用NTFS格式，@ ECHO C盘如非必要可以不转换，FAT32与NTFS这两种格式的读写速度几乎是没有差别的。@ ECHO --------------------------------------------------------------------------@ ECHO.convert c: /fs:ntfsREM D盘也转成 NTFSconvert d: /fs:ntfs```9. 获取我的文档```batSET SF=\"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\"FOR /F \"tokens=2,*\" %%I IN ('REG QUERY %SF% /v Personal 2^>NUL^FIND /I \"Personal\"') DO SET \"myDoc=%%~J\"REM 复制文件到我的文档XCOPY /D /E /R /Y /C \"%cd%\\test.txt\" \"%myDoc%\\test\\\"```10 获取当前目录路径```batcd ./set CURR_PATH=%cd%```11. IF-ERRORLEVEL```bat@ECHO OFFXCOPY C:\\AUTOEXEC.BAT D:IF ERRORLEVEL 1 ECHO 文件拷贝失败IF ERRORLEVEL 0 ECHO 成功拷贝文件```如果文件拷贝成功，屏幕就会显示“成功拷贝文件”，否则就会显示“文件拷贝失败”。`IF ERRORLEVEL` 是用来测试它的上一个DOS命令的返回值的，注意只是上一个命令的返回值，而且返回值必须依照从大到小次序顺序判断。因此下面的批处理文件是错误的：---```bat@echo off //不显示shell的命令。Setlocal //环境改变只适用于这个文件。%OS% //为当前的操作系统。Rem //注释一行文本。Goto 标签 //改变执行顺序，去标签位置.：标签 //定义一个标签。Set 变量名=值 //定义变量Not //取反Netstat –na //显示当前被点用的端口.%0 %1 %2 //用于表示批处理文件的参数0为命令,共1-9个参数。Shift //用于向前一个参数，原1变0，原2变1.每调用一次shift向前一移动一位。Call //调用其他批处理文件或命令。Start 命令 参数 //指示出在另一个窗口中开始运行命令。```---- 自动设置Java环境变量```bat@echo offIF EXIST %1\\bin\\java.exe (rem 如输入正确的 Java2SDK 安装目录，开始设置环境变量@setx JAVA_HOME %1@setx path %path%;%JAVA_HOME%\\bin@setx classpath %classpath%;.@setx classpath %classpath%;%JAVA_HOME%\\lib\\tools.jar@setx classpath %classpath%;%JAVA_HOME%\\lib\\dt.jar@setx classpath %classpath%;%JAVA_HOME%\\jre\\lib\\rt.jar@echo on@echo Java 2 SDK 环境参数设置完毕，正常退出。) ELSE (IF \"%1\"==\"\" (rem 如没有提供安装目录，提示之后退出@echo on@echo 没有提供 Java2SDK 的安装目录,不做任何设置，现在退出环境变量设置。) ELSE (rem 如果提供非空的安装目录但没有bin\\java.exe，则指定的目录为错误的目录@echo on@echo 非法的 Java2SDK 的安装目录,不做任何设置，现在退出环境变量设置。))```---本文部分内容转载自：http://m18333611647.blog.163.com/blog/static/225533041201422111365439/","tags":["Windows","Batch"],"categories":["Coding"]},{"title":"如何高效寻找开源项目","path":"/posts/OpenSourceSearch.html","content":"Github 中高效寻找搜索开源项目\n\n# in:name\n搜索时使用 `in:name` 可以搜索名字包含的内容\n```\nin:name vue\n```\n\n ## 搜索过滤\n - Stars 数\n\n```bash\n #匹配start书大于1000\n in:name vue stasr>1000\n```\n<!--more-->\n- Forks 数\n\n```bash\n #匹配Forkt书大于1000\n in:name vue forks>1000\n```\n\n## 条件并行使用\n```bash\n #匹配Forkt书大于1000\n in:name vue stars>1000 forks>1000\n```\n\n# in:description\n在描述中搜索\n```bzsh\nin:description 前端\n```\n\n## language\n```bash\nin:description 前端 language:vue\n```\n\n## pushed\n更新时间\n```bash\nin:description 前端 language:vue pushed >2019-10-01\n```\n\n## 条件并行使用\n```bash\nin:description 爬虫  language:python star>1000  pushed >2019-10-01\n```\n\n# in:readme\n在 READMME 中搜索\n```bash\nin:readme security stars>1000\n```","tags":["Git","Github"],"categories":["Coding"]},{"title":"CMD","path":"/posts/CMD.html","content":"> CMD 基础,转载自:[可可西](https://www.cnblogs.com/kekec/p/3662125.html)\n\n# 基础命令\n```cmd\n# 中断命令\nCrtl + z  \n```\n<!--more-->\n# 文件/目录\n##  cd\n|命令|含义|\n|:---|:---|\n|cd |显示当前目录|\n|cd .. | 上一级目录|\n|cd /d d:  |  进入上次D盘所在的目录|\n|cd /d d:\\   | 进入d盘根目录|\n|cd d: |显示上次d盘所在的目录|\n|cd /d d:\\data| 进入d:\\data目录|\n\n##  md\n```cmd\n# e盘新建file目录\nmd e:\\file \n\nmd movie film\nmd d:\\test\\movie \n```\n\n## pushd/popd\n使用栈来维护当前目录\n```cmd\npushd e:\\file # 当前目录切换到e:\\file\npopd # 将刚才保存的e:\\file弹栈，并设置为当前目录\n```\n\n## dir\n```cmd\n # 显示当前目录中的子文件夹与文件\n dir \n\n# 只显示当前目录中的子文件夹与文件的文件名\ndir /b \n\n# 分页显示当前目录中的子文件夹与文件\ndir /p  \n\n# 显示当前目录中的子文件夹\ndir /ad\n\n# 显示当前目录中的文件\ndir /a-d \n\n #/ 显示c:\\test目录中的内容\ndir c:\\test \n\n # 显示当前目录中keys.txt的信息\ndir keys.txt\n\n#/ 递归显示当前目录中的内容\ndir /S   \n\n# 显示当前目录下以key开头的文件和文件夹的信息\ndir key*  \n\n# 只显示当前目录中隐藏的文件和目录，并按照文件大小从小到大排序\ndir /AH /OS  \n```\n\n## tree 显示目录结构\n```cmd\n# 显示目录结构\ntree d:\\file \n\n```\n## ren 文件或目录重命名\n```cmd\nren 1.txt 1.bat\nren c:\\test test_01\nren Logs.txt Logs-%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%.txt\n```\n\n## rd 删除目录\n```cmd\nrd movie\nrd /s /q d:\\test  # 使用安静模式删除\n```\n\n## move 移动\n```cmd\nmove *.png png\nmove /Y *.png test\nmove 1.png d:\\png\\2.png # 移动并重命名\nmove test d:\\new # d:\\new不存在则移动并重命名\n```\n\n## del 删除\n```cmd\ndel test\ndel /f test\n\n# 删除当前目录下的test文件夹中所有文件及d:\\test2中所有doc文件（含只读文件；递归子目录下的文件；删除前不确认）\ndel /f /s /q test d:\\test2\\*.doc \n\n# 删除当前目录下所有只读文件\ndel /ar *.*\n\n# 删除当前目录下除系统文件以外的所有文件\ndel /a-s *.*  \n```\n- /ar、/ah、/as、/aa 分别表示删除只读、隐藏、系统、存档文件\n- /a-r、/a-h、/a-s、/a-a 分别表示删除除只读、隐藏、系统、存档以外的文件\n\n## replace 替换\n```cmd\n# 替换为d:\\png中的1.png\nreplace d:\\1.png d:\\png\n```\n\n## attrib  查看或修改文件或目录的属性\n```cmd\n # 查看当前目录下1.txt的属性\nattrib 1.txt  \n\n# 去掉1.txt的只读属性\nattrib -R 1.txt \n\n# 隐藏movie文件夹\nattrib +H movie  \n```\n- A：存档  R：只读  S：系统  H：隐藏\n\n## assoc 设置'文件扩展名'关联到的'文件类型'\n```cmd \n# 显示所有'文件扩展名'关联\nassoc\n\n# 显示.txt代表的'文件类型'，结果显示.txt=txtfile\nassoc .txt \n\n#显示.doc代表的'文件类型'，结果显示.doc=Word.Document.8\nassoc .doc \n\n# 显示.exe代表的'文件类型'，结果显示.exe=exefile\nassoc .exe\n\n# 恢复.txt的正确关联\nassoc .txt=txtfile  \n```\n\n## forfiles 递归目录执行命令\n```cmd\n#在当前目录下查找含有.svn的文件或目录（递归子目录），并对该目录执行指定版本号svn更新\nforfiles /p . /m .svn /s /c \"cmd /c svn up -r12005\" \n\n# 在c:\\myfiles目录下查找含有.svn的文件或目录（递归子目录），并对该目录执行指定版本号svn更新\nforfiles /p c:\\myfiles /m .svn /s /c \"cmd /c svn up -r12005\" \n```\n\n##  文件查看\n- type 显示文本文件内容\n\n```cmd \n#显示c盘中11.txt的文本内容\ntype c:\\11.txt \n\n# 显示当前目录下conf.ini的文本内容\ntype conf.ini   \n\n# 分页显示c盘中11.txt的文本内容\ntype c:\\11.txt | more  \n```\n- more 逐屏的显示文本文件内容\n\n```cmd\nmore con.txt\n# Space:下一屏 q:退出\n```\n\n# 拷贝\n## copy 拷贝文件\n```cmd\ncopy test.txt d:\\txt\ncopy movie d:\\\ncopy /Y test.txt d:\\txt\n\n# 将当前目录下的art_2.7z.开头的所有文件（按照名称升序排序）依次合并生成art_2.7z\ncopy /B art_2.7z.* art_2.7z   \n\n# 将当前目录下的art_2.7z.001、art_2.7z.002文件合并生成art_2.7z\ncopy /B art_2.7z.001+art_2.7z.002 art_2.7z\n```\n\n## xcopy\n```cmd  \n# 将c:\\bat\\hai中的所有内容拷贝到d:\\hello中  注意：需要在hello后加上\\  表示hello为一个目录，否则xcopy会询问hello是F，还是D\nxcopy c:\\bat\\hai d:\\hello\\ /y /h /e /f /c \n\n# 将c:\\bat\\hai中的2019年11月3日后更改的文件拷贝到d:\\hello中\nxcopy c:\\bat\\hai d:\\hello\\ /d:11-03-2019\n```\n\n## robocopy\n```cmd\n# 将当前目录下Plugins中所有内容（排除名为Intermediate和Binaries的文件夹）保留目录结构拷贝到当前目录下的PluginsDest中（PluginsDest不存在会自动创建）\nrobocopy .\\Plugins .\\PluginsDest /MIR /xd Intermediate Binaries  \n\n# 将c:\\test中所有内容（排除名为UE4Editor-SGame-Win64-DebugGame.dll和pdb后缀的文件）保留目录结构拷贝到d:\\test2中（d:\\test2不存在会自动创建）\nrobocopy c:\\test d:\\test2 /MIR /xd Intermediate /xf UE4Editor-SGame-Win64-DebugGame.dll *.pdb\n```\n\n# mklink 符号链接\n```cmd \n#  创建D盘Users目录链接到C盘，并命名为Users\nmklink /j \"C:\\Users\" \"D:\\Users\"  \n```\n- mklink [[/d] | [/h] | [/j]] Link Target\n1. /d 创建目录符号链接。黙认为文件符号链接。\n2.  /h　　 创建硬链接，而不是符号链接。\n3.  /j　　　创建目录联接。\n4.  Link　　指定新的符号链接名称。\n5.  Target　指定新链接引用的路径(相对或绝对)。\n\n# 注册表命令\n|参数|含义|\n|:---|:---|\n|KeyName [\\Machine]FullKey|Machine为远程机器的机器名 - 忽略默认到当前机器。远程机器上只有 HKLM 和 HKU。FullKey ROOTKEY+SubKey。ROOTKEY [ HKLM \\| HKCU\\| HKCR\\| HKU \\|  HKCC ]。SubKey 所选ROOTKEY下注册表项的完整名|\n|/v       | 所选项之下要添加的值名\n|/ve     | 为注册表项添加空白值名<无名称>\n|/t        |RegKey 数据类型: [ REG_SZ \\| REG_MULTI_SZ \\| REG_DWORD_BIG_ENDIAN\\| REG_DWORD\\| REG_BINARY\\|  REG_DWORD_LITTLE_ENDIAN\\| REG_NONE \\| REG_EXPAND_SZ ]如果忽略，则采用 REG_SZ|\n|/s        |指定一个在 REG_MULTI_SZ 数据字符串中, 用作分隔符的字符；如果忽略，则将\"\"用作分隔符|\n|/d        |要分配给添加的注册表ValueName的数据|\n|/f        |不提示，强行改写现有注册表项|\n\n```cmd\n# 强制添加一条开机启动c:\\tools\\myapp.exe程序的注册表项\nreg add \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v MyApp /t REG_SZ /d \"c:\\tools\\myapp.exe\" /f  \n\n# 解决32位xp打开ioa后，弹出的框关不掉问题\nreg add \"HKLM\\SOFTWARE\\ScmClient\" /v AgreementConfirmed /t REG_SZ /d 1 /f  \n\n# 强制添加一条加速关闭应用程序的注册表项\nreg add \"HKCU\\ControlPanel\\Desktop\" /v WaitToKIllAppTimeOut /t REG_SZ /d 10000 /f \n\n # 将JdkPath_h4127442381设置为空\nreg add \"hkcu\\software\\Unity Technologies\\Unity Editor 4.x\" /v JdkPath_h4127442381 /t REG_SZ /f\n\n# 强制添加windbg打开dump文件到右键菜单的注册表项（不指明/v，键值将写入默认值名中）\nreg add \"HKCR\\*\\shell\\WinDbg\\command\" /t REG_SZ /d \"\\\"D:\\Program Files (x86)\\windbg\\windbg.exe\\\" -z \\\"%1\\\" \" /f    \n\n# 强制添加winhex到右键菜单的注册表项（不指明/v，键值将写入默认值名中）\nreg add \"HKCR\\*\\shell\\WinHex\\command\" /t REG_SZ /d \"\\\"D:\\software-setup\\system\\winhex\\winhex.exe\\\"  \\\"%1\\\" \" /f \n\n#为IE设置代理：http://txp-01.tencent.com/proxy.pac\nreg add \"hkcu\\software\\microsoft\\windows\\currentversion\\internet settings\" /v AutoConfigURL /t REG_SZ /d \"http://txp-01.tencent.com/proxy.pac\" /f  \n\n # 关闭IE代理服务器选项\nreg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\" /v ProxyEnable /t REG_DWORD /d 0 /f \n\n# 为Procmon.exe工具（Process Monitor为其属性面板上的描述名）添加License同意\nreg add \"hkcu\\software\\Sysinternals\\Process Monitor\" /v EulaAccepted /t REG_DWORD /d 1 /f  \n\n#强制删除值名的MyApp的注册表项\nreg delete \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v MyApp /f  \n\n# 强制删除让任务栏里的任务管理器为灰色的注册表项\nreg delete \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe\" /f  \n\n# 删除http代理\nreg delete HKEY_CURRENT_USER\\Environment /v HTTP_proxy /f  \n\n # 删除https代理\nreg delete HKEY_CURRENT_USER\\Environment /v HTTPS_proxy /f \n\n # 强制复制winmine下所有的子项与值到winminebk中\nreg copy \"hkcu\\software\\microsoft\\winmine\" \"hkcu\\software\\microsoft\\winminebk\" /s /f \n\n # 导出winmine下所有的子项与值到\nreg export \"hkcu\\software\\microsoft\\winmine\" c:\\regbak\\winmine.reg c:\\regbak\\winmine.reg文件中\n\n# 导入c:\\regbak\\winmine.reg文件到注册表中\nreg import c:\\regbak\\winmine.reg  \n\n#查询ie的安装路径\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE\" /s   \n\n# 查询.dsw默认值\nreg query HKCR\\.dsw /ve  \n\n# 查询QQGame安装路径\nreg query HKEY_CURRENT_USER\\Software\\Tencent\\QQGame\\SYS /v GameDirectory  \n```\n- 注册表中%1 %2 %3 %4的含义：--  %1表示文件列表，%2表示默认打印机，%3表示驱动器，%4表示端口\n\n# 命令顺序\n## @#@\n```cmd\ncd /d d:\\src&work.exe /o c:\\result.txt # 先将当前工作目录切换到d:\\src下，然后执行work.exe /o c:\\result.txt命令\n```\n## &&\n&&  顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令\n```cmd\n# 如果找到了\"ok\"字样，就显示\"成功\"，找不到就不显示\nfind \"ok\" c:\\test.txt && echo 成功\n```\n## ||\n||   顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令\n```cmd\n# 如果找不到\"ok\"字样，就显示\"不成功\"，找到了就不显示\nfind \"ok\" c:\\test.txt || echo 不成功  \n```\n## |\n```cmd\ndir *.* /s/a | find /c \".exe\"\ndir *.* /s/a 2>&1 | find /c \".exe\" \n```\n\n# 重定向\n## >\n将当前命令输出以覆盖的方式重定向\n```cmd\ntasklist > p1.txt\ntasklist 1> p1.txt  # 等同于：tasklist > p1.txt\n\n #输出结果（stdout）打印在屏幕上，错误信息（stderr）以覆盖的方式重定向到p1.txt中（注：bin目录不存在时，会输出错误信息）\ndir bin 2> p1.txt \n\n # 将错误信息（stderr）重定向到输出结果（stdout），然后将输出结果（stdout）以覆盖的方式重定向到p1.txt中（注：bin目录不存在时，会输出错误信息）\ndir bin > p1.txt 2>&1 \n\n # 将输出结果（stdout）重定向到错误信息（stderr），然后将错误信息（stderr）以覆盖的方式重定向到p1.txt中（注：bin目录不存在时，会输出错误信息） 注：与上条命令结果一致\ndir bin 2> p1.txt 1>&2 \n\n# 屏幕上不打印tasklist的输出结果（stdout），错误信息（stderr）仍会打印\ntasklist >nul   \n\n# 屏幕上不打印命令的错误信息（stderr），输出结果（stdout）仍会打印（注：bin目录不存在时，会输出错误信息）\ndir bin 2>nul  \n\n#  将命令的错误信息（stderr）重定向到输出结果（stdout），然后不打印输出结果（stdout）【屏幕上错误信息（stderr）和输出结果（stdout）都不打印】（注：bin目录不存在时，会输出错误信息）\ndir bin >nul 2>&1  \n\n  # 将命令的输出结果（stdout）重定向到错误信息（stderr），然后不打印错误信息（stderr）【屏幕上错误信息（stderr）和输出结果（stdout）都不打印】（注：bin目录不存在时，会输出错误信息）\ndir bin 2>nul 1>&2 \n```\n\n## >>\n将当前命令输出以追加的方式重定向\n```cmd \n# 将tasklist的输出结果（stdout）以追加的方式重定向到p2.txt文件中（注：tasklist的输出结果就不会打印到屏幕上了）\ntasklist >> p2.txt\n \ntasklist 1>> p2.txt  # 等同于：tasklist >> p2.txt\n\n# 输出结果（stdout）打印在屏幕上，错误信息（stderr）以追加的方式重定向到p2.txt中（注：bin目录不存在时，会输出错误信息）\ndir bin 2>> p2.txt \n\n# 将错误信息（stderr）重定向到输出结果（stdout），然后将输出结果（stdout）以追加的方式重定向到p2.txt中（注：bin目录不存在时，会输出错误信息）\ndir bin >> p2.txt 2>&1 \n\n# 将输出结果（stdout）重定向到错误信息（stderr），然后将错误信息（stderr）以追加的方式重定向到p2.txt中（注：bin目录不存在时，会输出错误信息） 注：与上条命令结果一致\ndir bin 2>> p2.txt 1>&2\n```\n\n## <\n 从文件中获得输入信息，而不是从屏幕上，一般用于date time label等需要等待输入的命令\n ```cmd\n date <temp.txt  // temp.txt中的内容为2005-05-01\n ```\n ## @\n @   命令修饰符  在执行命令前，不打印出该命令的内容\n```cmd\n@cd /d d:\\me   // 执行该命令时，不打印出命令的内容：cd /d d:/me\n```\n## ,    \n在某些特殊的情况下可以用来代替空格使用\n```cmd\ndir,c:\\   // 相当于：dir c:\\\n```\n\n## ;\n当命令相同的时候,可以将不同的目标用;隔离开来但执行效果不变。如执行过程中发生错误则只返回错误报告但程序还是会继续执行\n```cmd\ndir c:\\;d:\\;e:\\   // 相当于顺序执行：dir c:\\    dir d:\\     dir e:\\\n```\n\n# 时间日期\n## time\n```cmd\ntime  # 显示或设置当前时间\n\ntime /t  # 显示当前时间\n\ntime   # 设置新的当前时间（格式：hh:mm:ss），直接回车则表示放弃设置\n```\n## date\n```cmd\ndate /t  # 显示当前日期\n\ndate  # 设置新的当前日期（格式：YYYY/MM/DD），直接回车则表示放弃设置\n```\n\n# BAT\n## 显示\n```cmd\ncls  # 清除屏幕\nver  # 显示当前windows系统的版本号\nwinver  # 弹框显示当前windows系统信息\nhostname  # 显示当前机器名\nvol  # 显示当前分区的卷标\nlabel  # 显示当前分区的卷标，同时提示输入新卷标\nlabel c:system  # 设置c盘的卷标为system\n```\n## echo\n```cmd\n # 输出一个\"回车换行\"，空白行\necho. \n\n# 后续所有命令在执行前，不打印出命令的内容\necho off \n\n# 后续所有命令在执行前，打印出命令的内容\necho on   \n\n#/ 输出123到终端屏幕\necho 123 \n\n# 输出Hello World!!!到终端屏幕\necho \"Hello World!!!\"   \n\n#每个命令运行结束，可以用这个命令行格式查看返回码；默认值为0，一般命令执行出错会设errorlevel为1\necho %errorlevel%   \n\n# 输出test的字符串到当前目录中的p1.txt文件中（以覆盖的方式）\necho test > p1.txt \n```\n\n```cmd\n# 显示变量p代表的字符串，即aa1bb1aa2bb2\necho %p%\n\n#显示变量p中第6个字符以后的所有字符，即aa2bb2\necho %p:~6% \n\n# 显示第6个字符以后的3个字符，即aa2\necho %p:~6,3% \n\n# 显示最后面的2个字符，即b2\necho %p:~-2%\n\n# 显示除了最后2个字符以外的其它字符，即aa1bb1aa2b\necho %p:~0,-2%\n\n# 用c替换变量p中所有的aa，即显示c1bb1c2bb2\necho %p:aa=c%\n\n# 将变量p中的所有aa字符串置换为空，即显示1bb12bb2\necho %p:aa=% \n\necho %p:*bb=c%\n# 第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2\n```\n\n## set\n```cmd\n# 显示当前用户所有的环境变量\nset  \n\n# 查看path的环境变量值（准确的说是查看以path开头的环境变量）\nset path \n\n#清空path变量\nset path=   \n\n# 将path变量设置为d:\\execute（注：修改的path只会影响当前回话，也不会存储到系统配置中去；当前cmd窗口关闭，新设置的path也就不存在了\nset path=d:\\execute ）\n\n# 在path变量中添加d:\\execute（注：修改的path只会影响当前回话，也不会存储到系统配置中去；当前cmd窗口关闭，新设置的path也就不存在了）\nset path=%path%;d:\\execute  \n\n# 设置变量p，并赋值为aa1bb1aa2bb2\nset p=aa1bb1aa2bb2 \n```\n\n```cmd\n# 设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2\nset p=%p:*bb=c% \n\n# 设置p为数值型变量，值为39\nset /a p=39 \n\n# 支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3\nset /a p=39/10 \n\n # 用 /a 参数时，在 = 后面的变量可以不加%直接引用\nset /a p=p/10\n\n# &运算要加引号。其它支持的运算符参见set/?\nset /a p=\"1&0\"\n```\n\n## path\n```cmd\n# 显示当前path变量的值\npath \n\n# 清除所有搜索路径设置并指示cmd.exe只在当前目录中搜索\npath ;\n\n#将d:\\xxx路径添加到path中\npath d:\\xxx;%PATH% \n```\n```cmd\ntitle 正在做命令行测试  # 修改当前cmd窗口的标题栏文字为正在做命令行测试\n\nprompt orz:   # 将命令提示符修改为orz:\n\nprint 1.txt  #使用设置好的打印机来打印1.txt文本文件\n\ncall ff.bat   # 调用执行ff.bat脚本（ff.bat脚本执行完原脚本才会往下执行）\n\nexit # 退出当前CMD实例\npause # 暂停批处理程序，并显示出：请按任意键继续....\n```\n\n## start\n```cmd\nstart  # 运行某程序或命令\n\n# 最大化的方式启动记事本\nstart /max notepad.exe\n\n # 最小化的方式启动计算器\nstart /min calc.exe \n\n# 最小化的方式启动Proxifier代理工具\nstart /min \"\" d:\\Proxifier.exe  \n\n# 启动一个cmd实例窗口，并运行tasklist\nstart  tasklist \n\n# 调用资源管理器打开f盘\nstart explorer f:\\  \n\n# 启动ie并打开www.qq.com网址\nstrat iexplore \"www.qq.com\" \n\n#启动开始执行ff.bat（启动ff.bat脚本后，原脚本继续执行，不会等ff.bat脚本执行完）\nstart ff.bat  \n```\n\n## color\n设置当前cmd窗口背景色和前景色（前景色即为字体的颜色）\n```cmd\ncolor 02 # 将背景色设为黑色，将字体设为绿色\n```\n\n|代码| 颜色|代码| 颜色|\n|:---|:---|:---|:---|\n|0 | 黑色 |8 | 灰色|\n|1 | 蓝色 |9 | 淡蓝色|\n|2 | 绿色 |A | 淡绿色|\n|3 | 浅绿色| B | 淡浅绿色|\n|4 |红色 |C | 淡红色|\n|5 | 紫色| D | 淡紫色|\n|6 | 黄色|E | 淡黄色|\n|7 | 白色|F | 亮白色|\n\n-  设置DOS窗口颜色为9f，大小：200行 60列（若屏幕缓冲区大小的宽度w<200或高度h<60,最终DOS的窗口就会为w行，h列）\n\n```cmd\nmode con cols=200 lines=60 & color 9f   \n```\n\n## chcp  字符编码\n936 -- GBK(一般情况下为默认编码)\n437 -- 美国英语\n65001 -- utf-8\n1200 -- utf-16\n1201 -- utf-16(Big-Endian)\n12000 -- utf-32\n12001 -- utf-32(Big-Endian)\n\n```cmd \n# 设置当前命令行环境编码为GBK  执行完该命令后还需要将字体设置为点阵字体，才能真正将编码环境切成utf8\nchcp  936 \n\n# 设置当前命令行环境编码为utf8  执行完该命令后还需要将字体设置为Lucida Console，才能真正将编码环境切成utf8\nchcp  65001  \n```\n\n## wmic 查看进程信息\n```cmd\n# 查看名为\"buyticket.exe\"所有进程命令行，exe全路径，PID及线程数\nwmic process where Caption=\"buyticket.exe\" get commandline,ExecutablePath,ProcessId,ThreadCount /value\n\n# 查看名为\"buyticket.exe\"所有进程的exe全路径及当前打开的句柄数\nwmic process where Caption=\"buyticket.exe\" get ExecutablePath,HandleCount /value  \n\n# 查看名为\"buyticket.exe\"所有进程的exe全路径、当前虚拟地址空间占用及物理内存工作集\nwmic process where Caption=\"buyticket.exe\" get ExecutablePath,VirtualSize,WorkingSetSize /value   \n```\n\n## shutdown \n```cmd\n#关闭计算机\nshutdown /s  \n\n# 一小时后，关闭本地计算机\nshutdown /s /t 3600\n\n# 终止系统关闭\nshutdown /a \n\n# 关闭并重启本地计算\nshutdown /r 机\n\n# 关闭并重启ip为192.168.1.166的计算机\nshutdown /m 192.168.1.166 /r \n```\n```cmd\n# 关闭并重启计算机，重启后重新启动所有注册的应用程序\nshutdown /g  \n\n# 注销本地计算机\nshutdown /l  \n\n# 休眠本地计算机（强制正在运行的应用程序关闭，不前台警告用户）\nshutdown /h /f \n\n # 关闭计算机\nshutdown /s\n```\n\n## regsvr32  注册或反注册com组件\n```cmd\n# 以无声的方式注册clock.ocx组件\nregsvr32 /s clock.ocx  \n\n# 卸载myCommon.dll组件\n regsvr32 /u myCommon.dll\n```\n\n## format  格式化磁盘\n```cmd\n# 以ntfs类型格式化J盘 【类型有:FAT、FAT32、exFAT、NTFS或UDF】\nformat J: /FS:ntfs   \n\n#  以fat32类型快速格式化J盘\nformat J: /FS:fat32 /Q \n```\n## chkfsk 检查磁盘并显示状态报告\n```\nchkdsk /f D:   # 检查磁盘D并显示状态报告；加参数/f表示同时会修复磁盘上的错误\n```\n\n## subset\nsubst   磁盘映射  -- 磁盘映射信息都保存在注册表以下键值中：HKEY_CURRENT_USER\\Network\n\n```cmd \n# 显示目前所有的映射\nsubst \n\n# 将\\\\com\\software共享映射为本地z盘\nsubst z: \\\\com\\software \n\n# 将e:\\src映射为本地y盘\nsubst y: e:\\src \n\n# 删除z盘映射\nsubst z: /d  \n```\n\n## cmdkey  \n 凭据Credential（保存的用户名和密码）\n```cmd\n# 列出可用的凭据\ncmdkey /list  \n\n# 列出指定目标的凭据\ncmdkey /list:10.12.190.82  \n\n# 列出指定目标的凭据\ncmdkey /list:Domain:target=10.12.190.82  \n\n# 若target为10.12.190.82的凭据不存在，则添加；否则就将10.12.190.82凭据的用户名修改为LiLei，密码修改为123456\ncmdkey /add:Domain:target=10.12.190.82 /user:LiLei /pass:123456  \n\n# 删除指定目标的凭据\ncmdkey /delete:Domain:target=10.12.190.82 \n```\n\n## cscript  执行vbs脚本\n```cmd\n# 执行mac.vbs脚本，显示本机mac地址\ncscript /Nologo mac.vbs  \n```\n\n```vbs mac.vbs\nDim mc,mo\nSet mc=GetObject(\"Winmgmts:\").InstancesOf(\"Win32_NetworkAdapterConfiguration\")\nFor Each mo In mc\nIf mo.IPEnabled=True Then\nMsgBox \"本机网卡MAC地址是: \" & mo.MacAddress\nExit For\nEnd If\nNext\n```\n\n## powercfg  设置电源方案\n```cmd\n# 列出当前用户环境中的所有电源方案的GUID以及当前使用的是哪一个电源方案\npowercfg -list   \n\n# 查询GUID为8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c的电源方案的详细内容\npowercfg -query 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c \n\n# 设置禁止休眠\npowercfg -h off\n```\n```cmd\n#  设置硬盘从不关闭\npowercfg -change -disk-timeout-dc 0\npowercfg -change -disk-timeout-ac 0\n\n#  设置显示器从不关闭\npowercfg -change -monitor-timeout-dc 0\npowercfg -change -monitor-timeout-ac 0\n\n# 设置从不进入待机\npowercfg -change -standby-timeout-dc 0\npowercfg -change -standby-timeout-ac 0\n\n#  设置从不进入休眠\npowercfg -change -hibernate-timeout-dc 0\npowercfg -change -hibernate-timeout-ac 0\n```\n1. dc代表直流电源 即使用电池供电；ac代表交流电源 即直接连接电源\n2. 后面数字为时间，单位为分钟；设置为0表示从不\n\n## netsh advfirewall  设置防火墙\nwindows防火墙规则顺序：阻止规则的优先级高于允许规则\n\n```cmd\n#将防火墙当前的所有配置导出到d:\\test\\advfirewall.pol文件\nnetsh advfirewall export \"d:\\test\\advfirewall.pol\"  \n# 将d:\\test\\advfirewall.pol文件中规则导入到防火墙中\nnetsh advfirewall import \"d:\\test\\advfirewall.pol\"  \n# 将防火墙还原为默认策略\nnetsh advfirewall reset\n\n# 关闭所有类型网络的防火墙（域网络【Domain】、家庭或工作的专用网络【Private】、公用网络都关闭【Public】）\nnetsh advfirewall set allprofiles state off\n\nnetsh advfirewall set allprofiles state on  # 开启所有类型网络的防火墙\n\n#关闭当前类型网络的防火墙\nnetsh advfirewall set currentprofile state off \n\n# 开启当前类型网络的防火墙\nnetsh advfirewall set currentprofile state on \n\n# 开启域网络的防火墙\nnetsh advfirewall set domainprofile state on \n\n # 关闭域网络的防火墙\nnetsh advfirewall set domainprofile state off\n\n# 开启家庭或工作的专用网络的防火墙\nnetsh advfirewall set privateprofile state on \n\n# 关闭家庭或工作的专用网络的防火墙\nnetsh advfirewall set privateprofile state off  \n\n# 开启公用网络的防火墙\nnetsh advfirewall set publicprofile state on \n\n # 关闭公用网络的防火墙\nnetsh advfirewall set publicprofile state off \n\n#显示所有规则\nnetsh advfirewall firewall show rule name=all  \n\n# 显示名为foxmail的所有规则\nnetsh advfirewall firewall show rule name=foxmail   \n# 开启ping回显\nnetsh advfirewall firewall set rule name=\"文件和打印机共享(回显请求 - ICMPv4-In)\" new enable=yes \n\n#  删除所有名为NiZhanBrowser的规则\nnetsh advfirewall firewall delete rule name=NiZhanBrowser \n\n# 删除所有名为NiZhanBrowser的入站规则\nnetsh advfirewall firewall delete rule name=NiZhanBrowser dir=in\n\n# 删除所有名为NiZhanBrowser且操作为阻止的规则\nnetsh advfirewall firewall delete rule name=NiZhanBrowser action=block \n\n# 添加名为TCP-In-8888入站规则：允许TCP端口8888\nnetsh advfirewall firewall add rule name=TCP-In-8888 protocol=TCP localport=8888 dir=in action=allow  \n\n# 添加名为TCP-In-8888入站规则：阻止TCP端口8888\nnetsh advfirewall firewall add rule name=TCP-In-8888 protocol=TCP localport=8888 dir=in action=block  \n\n# 添加名为TCP-In-8888出站规则：允许TCP端口8888\nnetsh advfirewall firewall add rule name=TCP-In-8888 protocol=TCP localport=8888 dir=out action=allow  \n\n# 添加名为TCP-In-8888出站规则：阻止TCP端口8888\nnetsh advfirewall firewall add rule name=TCP-In-8888 protocol=TCP localport=8888 dir=out action=block  \n\n#  添加名为test1入站规则：允许TCP端口8888、远程IP地址在10.96.208.0/23,10.96.154.0/23区间、远程Port在1024-2048,2050-65535\nnetsh advfirewall firewall add rule name=test1 protocol=TCP localport=8888 remoteip=10.96.208.0/23,10.96.154.0/23 remoteport=1024-2048,2050-65535 dir=in action=allow \n\n# 添加名为test2入站规则：允许TCP端口8888、本地IP地址在10.46.50.32、本地Port在3702\nnetsh advfirewall firewall add rule name=test2 protocol=TCP localport=8888 localip=10.46.50.32 localport=3702 dir=in action=allow \n\n# 添加名为test3入站规则：允许TCP端口8888、程序路径为：D:\\tools\\test3.exe\nnetsh advfirewall firewall add rule name=test2 protocol=TCP localport=8888 program=\"D:\\tools\\test3.exe\" dir=in action=allow \n\n```\n注：netsh advfirewall firewall add rule ?可用来查看帮助信息\n\n## schtasks  任务计划\n```cmd\n# 以较为详细易于阅读的格式显示本机所有任务计划信息\nschtasks /query /fo LIST /v  \n\n # 创建一个名为Soda Build的任务计划：该任务计划每20分钟执行一下d:\\check.vbs脚本\nschtasks /create /sc minute /mo 20 /tn \"Soda Build\" /tr d:\\check.vbs \n\n# 强制创建一个名为Soda Build的任务计划（不进行确认）：该任务计划每天凌晨2点06分执行一下D:\\updateall.bat脚本\nschtasks /create /tn \"Soda Build\" /tr D:\\updateall.bat /sc daily /st 02:06 /f \n\n# 强制删除Soda Build名称的任务计划（不进行确认）\nschtasks /delete /tn \"Soda Build\" /f \n\n#将名为Soda Build的任务计划的执行脚本修改为d:\\check2.vbs\nschtasks /change /tn \"Soda Build\" /tr d:\\check2.vbs \n\n#执行名为Soda Build的任务计划\nschtasks /run /tn \"Soda Build\" \n\n#终止执行名为Soda Build的任务计划\nschtasks /end /tn \"Soda Build\" \n```\n\n## net\n```cmd\n# 查看已经启动的服务\nnet start \n\n# 开启任务计划服务\nnet start \"Task Scheduler\"   \n\n# 不询问，直接关闭任务计划服务\nnet stop \"Task Scheduler\" /y \n\n# 开启dns缓存服务\nnet start dnscache \n\n# 不询问，直接关闭dns缓存服务\nnet stop dnscache /y  \n\n# 开启Remote Desktop Services服务\nnet start TermService  \n\n# 不询问，直接关闭Remote Desktop Services服务\nnet stop TermService /y  \n\n# 查看当前用户下的共享目录\nnet share  \n\n#  取消名为workFile的共享状态\nnet share workFile /delete \n\n# 将c:\\360Downloads设为共享，并取名为xxx\nnet share xxx=c:\\360Downloads   \n\n# 开启ipc$共享\nnet share ipc$ \n\n# 删除ipc$共享\nnet share ipc$ /del \n\n# 删除c盘共享\nnet share c$ /del \n\n# 建立192.168.1.166的ipc空链接\nnet use \\\\192.168.1.166\\ipc$ \" \" /user:\" \"\n\n# 直接登陆后建立192.168.1.166的ipc非空链接（用户名为administrator 密码为123456）\nnet use \\\\192.168.1.166\\ipc$ \"123456\" /user:\"administrator\"  \n\n# 直接登陆后映射192.168.1.166的c盘到本地为h盘（用户名为administrator 密码为123456）\nnet use h: \\\\192.168.1.166\\c$ \"123456\" /user:\"administrator\"   \n\n# 登陆后映射192.168.1.166的c盘到本地为h盘\nnet use h: \\\\192.168.1.166\\c$   \n\n# 删除ipc链接\nnet use \\\\192.168.1.166\\ipc$ /del  \n\n# 删除本地的h盘的映射\nnet use h: /del \n\n# 查看本地局域网内开启了哪些共享\nnet view \n\n# 查看192.168.1.166的机器上在局域网内开启了哪些共享\nnet view \\\\192.168.1.166 \n\n# 查看本地机器的日期及时间\nnet time \\\\127.0.0.1  \n\n# 查看本地机器的日期及时间\nnet time \\\\localhost   \n\n# 查看192.168.1.166机器的日期及时间\nnet time \\\\192.168.1.166  \n\n# 设置本地计算机时间与192.168.1.166主机的时间同步，加上参数/yes可取消确认信息\nnet time \\\\192.168.1.166 /set \n\n# 查看当前机器上的用户\nnet user  \n\n# 查看当前机器上的Administrator用户的信息\nnet user Administrator  \n\n# 启用Guest用户\nnet user Guest /active:yes  \n\n# 新建一个名为dev，密码为123456的用户\nnet user dev 123456 /add   \n\n# 把名为dev的用户添加到管理员用户组中，使其具有管理员权限\nnet localgroup administrators dev /add  \n\n# 删除名为dev的用户\nnet user dev /del  \n```\n\n##  进程操作\n```cmd\n# 显示当前运行的进程信息（可查看PID）\ntasklist  \n\n#结束指定的进程\ntaskkill  \n\n# 结束名为notepad.exe的进程\ntaskkill /im notepad.exe \n\n#  结束pid为1230、1241和1253的进程以及由它们启动起来的子进程\ntaskkill /pid 1230 /pid 1241 /pid 1253 /t \n\n# 强制结束有名为cmd.exe的进程以及由它启动起来的子进程\ntaskkill /f /im cmd.exe /t  \n```\n\n# 网络\n```cmd\n#  测试与baidu服务器的连接情况\nping baidu.com   \n\n# 测试机器名为chen-pc0的连接情况\nping chen-pc0   \n\n # 测试与ip为220.181.111.86的连接情况\nping 220.181.111.86  \n\n# 向qq.com发送10次65500字节的ping\nping -l 65500 -n 10 qq.com  \n\n# 对当前主机执行6次ping操作（花费时间为5s）\nping -n 6 127.0.0.1 \n\n # 不断地测试baidu服务器的连接情况   【Ctrl+Pause Break：查看ping的统计信息；Ctrl+C：终止当前任务】\nping -t baidu.com \n```\n\n```cmd \n# 查看本地ip地址等详细信息\nipconfig /all\n\n# 显示本地dns缓存的内容\nipconfig /displaydns \n\n# 清除本地dns缓存的内容\nipconfig /flushdns\n\n# 获取www.cnblogs.com的域名解析\nnslookup www.cnblogs.com \n\n# 打印出www.cnblogs.com的域名解析所有记录\nnslookup -d www.cnblogs.com\n\n# 查看开启了哪些端口\nnetstat -a   \n\n # 查看端口的网络连接情况\nnetstat -n \n\n# 查看正在进行的工作\nnetstat -v   \n\n# 查看tcp协议的使用情况\nnetstat -p tcp  \n\n# 查看本机到达182.140.167.44的路由路径\ntracert 182.140.167.44  \n\n#显示出IP路由\nroute print  \n```\n\n# arp\narp   显示和修改地址解析协议(ARP)使用的“IP到mac”的地址转换表\n```cmd\n# 显示arp缓存表\narp -a  \n```\nat  计划任务（必须保证“Task Scheduler”服务启动   net start \"task scheduler\"）\n```cmd\n# 查看所有的计划任务\nat \n\n# 停止所有任务计划（不需要确认）\nat /delete /yes \n\n# 开启id为1的计划任\nat 1 \n\n# 停止id为1的计划任务（不需要确认）\nat 1 /delete /yes  \n\n# 到12:42 ，电脑会出现“ 系统关机 ”对话框，并默认 30 秒延时自动关机\nat 12:42 shutdown –s –t30   \n\n# 如果命令不是exe文件，必须在命令前加上cmd /c\nat cmd /c dir > c:\\test.out  \n\n# 在每周六早上6点，电脑定时启动task.bat批处理文件\nat 6:00AM /every:Saturday task.bat  \n\n# 到12:00时，关闭名为chen的计算机\nat \\\\chen 12:00 shutdown /r   \n\n# 到12:00时，关闭ip为192.168.1.166的计算机\nat \\\\192.168.1.166 12:00 shutdown /r \n```\n\n#  文本处理 \n```cmd\n# 编辑config.ini文件（会进入edit字符编辑器；按alt，可以选择对应的菜单） win7 x64下没有该命令\nedit config.ini  \n```\nfind  文件中搜索字符串\n```cmd\n# 在1.txt文件中忽略大小写查找pid字符串，并带行号显示查找后的结果\nfind /N /I \"pid\" 1.txt \n\n# 只显示在1.txt文件中查找到exe字符串的次数\nfind /C \"exe\" 1.txt  \n\n# 显示未包含1.txt文件中未包含exe字符串的行\nfind /V \"exe\" 1.txt\n\nfindstr  文件中搜索字符串\n\n# 在1.txt文件中搜索hello或world\nfindstr \"hello world\" 1.txt  # 在1.txt文件中搜索hello或world\n\n# 在1.txt文件中搜索hello world\nfindstr /c:\"hello world\" 1.txt \n\n# 在1.txt文件中搜索hello world，并在每行结果前打印出1.txt:   注：findstr只有在2个及以上文件中搜索字符串时才会打印出每个文件的文件名，nul表示一个空文件\nfindstr /c:\"hello world\" 1.txt nul  # 在1.txt文件中搜索hello world，并在每行结果前打印出1.txt:   注：findstr只有在2个及以上文件中搜索字符串时才会打印出每个文件的文件名，nul表示一个空文件\n\n# 不区分大小写，在当前目录和所有子目录中的所有文件中的hello\nfindstr /s /i \"Hello\" *.*   # 不区分大小写，在当前目录和所有子目录中的所有文件中的hello\n\n# 在1.txt中搜索以1个数字+1个小写字母开头子串的行\nfindstr  \"^[0-9][a-z]\" 1.txt  # 在1.txt中搜索以1个数字+1个小写字母开头子串的行\n```\n\n# 控制台命令窗口中一些技巧\n在文件夹空白处按住Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”\n命令参数的路径：要使用反斜杠`\\`，不要使用正斜杠'/'   如：del d:\\test2\\file\\my.txt\n命令参数的路径：若存在空格，应使用双引号将路径引起来  如：del \"d:\\program files\\file\\my.txt\"\n\n文件及目录名中不能包含下列任何字符：`\\ / : * ? \" < > |`\n\n`rem`   在批处理文件中添加注解，其后的命令不会被执行，但会回显\n`::` 也可以起到rem的注释作用，且不会有回显\n任何以冒号: 开头的字符行, 在批处理中都被视作标号（label）, 而直接忽略其后的所有内容\n有效标号：冒号后紧跟一个以字母数字开头的字符串，goto语句可以识别\n无效标号：冒号后紧跟一个非字母数字的一个特殊符号，goto无法识别的标号，可以起到注释作用，::常被用作注释符号","tags":["Windows","Batch"],"categories":["Coding"]},{"title":"HCNA NOTE","path":"/posts/HCNA_Note.html","content":"HCNA 学习笔记\n\n# 网络整体架构\n## 企业网络\n企业网络：包括小型办公室、教育、政府、银行等行业或机构\n\n- 企业网络远程互联：\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/wangluo.jpg)\n\n总公司与分公司使用广域网链路(WAN)互联\n<!--more-->\n### 企业网络基本架构\n\n1. 小型企业：通常采用扁平网络结构，扩展能力低。\n2. 大型企业：通常采用层次化结构以支撑网络的扩展和用户的增长。 \n\n- 结构图(左小右大)\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/iwljgt.png)\n\n# 网络基本管理及模拟器使用\n## 常用的传输介质\n双绞线、光纤、Radio(蓝牙等)、同轴电缆(几乎淘汰)\n\n### 双绞线(8芯)\n有多种类型，不同类型传输速度不同和，超5类、6类最常用。RJ-45水晶头\n\n`568A标准` 白绿，绿，白橙，蓝，白蓝，橙，白棕，棕\n`568B标准` 白橙，橙，白绿，蓝，白蓝，绿，白棕，棕\n\n`交叉线` 一头采用568A标准，一头采用568B标准\n`平行线/直通线` 两头采用同样的标准，同为568A标准或568B标准\n\n相同设备使用交叉线，不同设备使用直通线，现在很多设备都有自适应。\n\n### 光纤\n`单模光纤(S)` 颜色多为黄色，连接头多为蓝色或绿色，只能传输一种模式的广。不存在模间色散，适用于长距离高速传输。\n`多模光纤(M)` 线缆颜色千兆多位橙色、万兆多为水蓝色，连接头多位灰白色，允许不同模式的光在一根光纤上传输，由于模间色散较大而导致信号脉冲展宽严重，因此主要用于局域网的短距离传输。\n\n- 区别\n\n主要在传输距离，单模长距离，多模短距离。单模和多模差异在传输距离。洲际的传输使用的是 `光缆`，不是光纤\n\n- 常用光纤连接器\n\nST，FC，SC，LC连接器。连接器有帽子，要拿掉才能连接\n\n### 串口电缆\n网络通信中常用和推荐的串口电缆标准为 RS-232，但传输速率有限仅为6米。\nRS-422和RS-485的传输距离可达1200米。接头常用V.35(80年代淘汰)，但仍在帧中继、ATM等传统网络上使用。\nV.24为RS-232标准的欧洲版，RS-232本身没有定义接头标准，RS-232逐渐被FireWire，USB等取代。新产品和设备已经普遍使用USB标准。\n\n## ENSP 模拟器\n关闭Windows防火墙，不要装各种管家。\n尽量少运行软件，可能会干扰 virtunal-box。\n重新注册要关闭ENSP，个人文件夹下的.VirtualBox彻底删除。注册完毕之后关闭ENSP然后再开启。\n\n## 冲突域\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/cty.jpg)\n\n- 应用场景\n\n多点接入网络(MA),如交换机(Switch)\n\n- 冲突域与半双工搭配\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20200517124923.png)\n\n`单工` 简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。\n`半双工` 比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。\n`全双工` 比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。\n\n- 共同点\n\n半双工和全双工都支持双向数据传输。\n \n> 共享式网络中，不同的主机同时发送数据时，就会产生信号冲突的问题，解决方法一般是：采用`载波侦听多路访问/冲突检测技术(CAMA/CD)` 的基本工作过程如下\n\n1. 终端设备不同地检测共享网路的状态。如果线路空闲，则可以发送数据，线路不空闲，则等待一段时间后据徐检测(延时时间由退避算法决定)。\n2. 如有另一个设备同时发送数据，两个设备发送的数据会产生冲突。\n3. 终端设备检测到冲突之后，马上停止发送自己的数据，并发送特俗阻塞信息，以强化冲突信号，使线路上的其他站点能够尽早检测冲突。\n4. 终端设备检测到冲突后，等待一段时间后再将进行数据发送(延时时间由退避算法决定)。\n\nCSMA/CD 的工作原理：先听后发，边发边听，冲突停发，随机延迟后重发。\n\nQ: 用串行线路能否构建MA网络\nA: 肯定可以\n\nNBMA(非广播多路访问)：物理架构(ATM、帧中继网络)----NMBMA(网络设计)---VPN(DSVPN)。\n\n## 熟悉以及远程管理设备的实验\n```bash\nsystem-view\ninterface GigabitEnternet0/0/0/0 # 进入接口\nip address 10.1.1.1 255.255.255.0\n```\n\n常用命令\n\n```bash\nsysname R1 # 修改设备名字\nip address 10.1.1.1.7 # 配置IP地址\nip address mask  10.1.1.1.7 24 # 配置IP地址和掩码\ndiaplay this # 显示当前模式\ndis ip int bri # 查看接口开启情况\nundo shutdown # \nq # 退出\n\nuser-interface # 用户接口\nuser-interface ？ # 查看帮助\n\nuser-interface vty 0 4 # 开启虚拟终端管理\nset authentication password cipher pass # 设置认证密码为pass\n\ntalent 10.1.1.1 # 远程管理设备，不能进入system-view\n\ndiaplay ip routting0table # 查看路由表\n```\n\n# 网络各种分层结构\n## 网络分层基础\n\n> 网络的层次化不要以设备最为标准，要以协议作为分层的标准。\n\n### OSI(开放式系统互联模型) 七层模型\n\n1. `应用层` 为应用程序提供网络服务\n2. `表示层` 数据格式化，加密、解密，如：jpg，gif\n3. `会话层` 建立、维护、管理会话连接,系统(Linux,iOS,Android)在此\n4. `传输层` 建立、维护、管理端到端连接，单位：段(segment)，TCP/UDP连个协议\n5. `网络层` IP寻址和路由选择,单位：包，有200多个协议\n6. `数据链路层` 控制网络层与物理层之间的通讯，单位：帧(frame)\n7. `物理层` 比特流传输，单位：比特(bit)\n\n\n- 应用层、表示层、会话层：单位统称为：协议数据单元(PDU),`物理层` 在TCP/IP中被称为 `互联网层` (Internet Protocal)\n\n### TCP/IP(工业标准)\n1. 应用层 (TELNET、FTP、SMTP)\n2. 传输层 (TCP、UDP)\n3. 互联网层 (IP、ICMP),路由\n4. 网络接口层 (PPP)，交换\n\n## 数据封装\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/shujufengzhuang.png)\n\n每一层都有一个头部\n\n## TCP与UDP的概念相互的区别及优劣\n1. TCP面向连接，UDP面向无链接\n2. TCP面向报文，UDP面向字节流\n3. TCP提供可靠传输服务（数据顺序、正确性），UDP传输不可靠\n4. TCP协议传输速度慢，UDP协议传输速度快\n5. TCP协议对系统资源要求多（头部开销大），UDP协议要求少*\n\n## VRP 的操作\n管理vlan(虚拟局域网)\n```bash SW1\nsystem-view\nsysname SW1\ninterface vlanif 1\nip address 10.1.1.1 24\ndisplay this\n```\n```bash SW2\nsystem-view\nsysname SW2\ninterface vlan 1\nip address 10.1.1.2 24\n```\nENSP自带了网络报文解析器。右键设备-数据抓包\n\n# Ehternet基础\n> 网络中传输数据时需要定义并遵循一些标准，以太网是根据IEEE802.3 标准来管理和控制数据帧的。了解IEEE802.3标准是充分理解以太网中链路层通讯的标准。\n\n- IEEE 是局域网标准\n\n## 以太网帧\n以太网(最流行，最常用，效率最高)，它的数据链路层基于MAC地址进行帧的传输。\nPR：\nFR(MA网络)：帧中继靠的是DLCI\nPPP(ppp网络)、HDLC(ppp网络)：什么都不靠\n\n## 以太网MAC地址\n以太网的MAC地址(Media Access Control Address)：\n由两部分组成:前24位的供应商代码、后24位的序列号。供应商代码由IEEE管理和分配。\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/MacAddress.png)\n\nOUI：厂商序号\n\n### MAC分类\n单一的源段发送到单一的目的端，每个主机接口由一个MAC地址唯一标识，MAC地址的OUI中第一字节第8个比特表示地址类型，对于主机MAC地址这个比特固定为0如，表示目的的MAC地址为此MAC地址的帧都是发送到某个唯一的端。在冲突域中，所有主机都能收到源主机发送的单播帧，但其他主机发现目的地址与本地MAC地址不一致后会丢弃收到的帧，只有真正的目的主机才会接收并处理收到的帧\n\n`单播MAC`(1 V 1)：01001100 第一字节的最后一位：0\n`组播MAC`(1 V n): 00000001 第一字节的最后一位：1\n`广播MAC`(1 V all): F1111111 第一字节的最后一位：1\n\n01005E:经典的组播MAC\n\n## 以太网封装格式\n以太网两种最常用的以太网封装格式：以太2型和802.3\n\n80年代初：DIX v2，1983年：提出IEEE8.2.3\n\n类型的位置除了IP(0800)还有ARP(0806),PPPoE,MP,IPv6c\n\n两种协议的主要区别在于：\n\nEnternetII格式中包含一个Type字段，标识以太网帧处理完成值后将被发送到哪个上层协议进行处理。IEEE802.3格式同样的位置是长度字段。\n\n以太网帧中的Type字段为0X0800，表示该帧的网络层协议为IP协议。\n\n不同的Type字段值可以用来区别这两种帧的类型:\n\n`EnternetII格式`: Length/Type >= 1536(0x0600)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20200517125147.png)\n\n`IEEE802.3格式`: Length/Type <= 1500(0x05DC)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20200517125222.png)\n\n以太网帧中还包括源和目的的MAC地址，分别代表发送者和接受者的MAC，此外还有帧校验序列字段，用于检验传输过程中的完整性。\n\n# 以太网IP地址网络基础和FTP\n## IP编制\n### IP编制组成\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/ndLwcGxUgrkJhCq.png)\n\n1. IP 地址分为网络部分和主机部分\n2. IP 地址由32个二进制位组成，通常用点分十进制形式表示。\n\n- IP报文头部\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/R1GazuNob9qBnwY.png)\n\nTyep[Data] 的 1500 包括IP报头\n\n\n## 以太网IPv4基础和分类\n`/8 `：代表掩码，作用：区分网络和主机，代表8个连续的1(255.0.0.0)\n`127.0.0.0/8` ：网络(主机位全为0)\n`127.255.255.255/8` ：广播地址(主机全为1)\n\n每个网段上有两个特俗地址不能分配给主机或网络设备。(除网络地址和广播地址外的其他IP地址可以作为网络设备的IP地址)\n1. IP地址主机位全为0(而不是无端一定为0)，表示一个网段。\n\n2. 该网段中的广播地址，目的地址为广播地址的报文会被该网段中的所有网络设备接受，广播地址的主机位全为1.\n\n## 网络的进制\n二进制，十进制，十六进制(MAC)\n\n## IPv4地址分类\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20200517125412.png)\n\n### 地址范围\nA类：1.0.0.1 - 126.255.255.254\nB类：128.1.0.1 - 191.255.255.254\nC类：192.0.1.1 - 223.255.255.254\nD类：224.0.0.0 - 239.255.255.255\nE类：240.0.0.1 - 255.255.255.254\n\n- NET: ABCDE的有类网络\n- subset：即子网(一个大的网络划分成小的网络)\n\n10.2.8.3/24 可以容纳的主机：2^8-2\n\n### IP地址类型\n互联网标准：RFC \n\n- 私有地址\n\n1. 10.0.0.0~10.255.255.255\n2. 127.16.0.0~127.31.55.255\n3. 192.168.0.0~192.158.255.255\n\n- 特俗地址\n\n1. 127.0.0.0~127.255.255.255, 127.0.0.1主机环回地址\n2. 0.0.0.0\n3. 255.255.2555.255(本地广播地址，是0.0.0.0的广播地址)\n\n## 子网掩码(subset mask)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/YGBtav3hmNwMCDi.png)\n\n- 默认子网掩码\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/s25D4BLpFRfkITJ.png)\n\nA类：8位\nB类：16位\nC类：24位\n\n## 地址规划\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/xzUOeirdFZqsyjh.png)\n\n- 举例\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/iNvgm3yKU5ehRZn.png)\n\n由子网掩码可知：172.10.1.7/16，所以网络地址为：172.16.0.0(主机位全为0)，主机数：2^16,可用主机数: 2^16-2\n\n例子：10.1.8.3/24的网络是什么？第一个可用主机是？最后一个可用主机？可用主机是多少？\n10.1.8.0，10.1.8.1，10.1.8.254，$2^8$-2=254\n\n- 变长子网掩码\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/ScY1AUKshDLRvx4.png)\n\n192.168.1.7/25\n\n## 有类IP编址的缺陷\n在设计网络时使用有类IP地址会造成地址的浪费。\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/Sv8LD5ZQUioz7lw.png)\n\n## 划分子网方法\n1. 根据需要的子网数目来确定子网位数，但是要确保每个子网可用的IP地址数目大于等于本机数。\n优点：简单\n缺点：每个子网的实际主机数不同，但分配的IP地址数目相同，可能浪费IP地址\n\n2. 根据每个子网的主机数目来确定主机数位，然后确定子网数位。\n优点：比较充分地利用IP地址\n缺点：复杂\n\n## 计算\n### 科学但麻烦的方法\n要转换二进制\n二进制:1代表网络，0代表主机。\n\n1. 子网的数目 = $2^x$ (x代表子网位数)\n2. 可用主机数目 = $2^y$-2 (y代表主机位数)\n3. 主机位为全1的地址时广播地址=下个子网号-1\n4. 主机位全为0的地址是网络地址。 \n\n- 利用子网数目计算子网掩码\n\n> 把B类地址172.16.0.0划分成30个子网络，它的子网掩码是多少？\n\n将子网络数目30转换成二进制表示11110\n统计一下这个二进制的数共有5位\n注意：当二进制数中只有一个1的时候，所统计的位数需要减1（例如：10000要统计为4位）\n将B类地址的子网掩码255.255.0.0主机地址部分的前5位变成1\n这就得到了所要的子网掩码（11111111.11111111.11111000.00000000）255.255.248.0。\n\n- 利用主机数目计算子网掩码\n\n> 把B类地址172.16.0.0划分成若干子网络，每个子网络能容纳500台主机，它的子网掩码是多少？\n\n把500转换成二进制表示111110100\n统计一下这个二进制的数共有9位\n将子网掩码255.255.255.255从后向前的9位变成0\n这就得到了所要的子网掩码（11111111.11111111.11111110.00000000）255.255.254.0。\n\n- 利用子网掩码计算最大有效子网数\n\n> A类IP地址，子网掩码为255.224.0.0，它所能划分的最大有效子网数是多少？\n\n将子网掩码转换成二进制表示11111111.11100000.00000000.00000000\n统计一下它的网络位共有11位\nA类地址网络位的基础数是8，二者之间的位数差是3\n最大有效子网数就是$2^3$，即最多可以划分8个子网络。\n\n- 利用子网掩码计算最大可用主机数\n\n> A类IP地址，子网掩码为255.252.0.0，将它划分成若干子网络，每个子网络中可用主机数有多少？\n\n将子网掩码转换成二进制表示11111111.11111100.00000000.00000000\n统计一下它的主机位共有18位\n最大可用主机数就是 2^18-2（除去全是0的网络地址和全是1广播地址），即每个子网络最多有262142台主机可用。\n\n- 利用子网掩码确定子网络的起止地址\n\n> B类IP地址172.16.0.0，子网掩码为255.255.192.0，它所能划分的子网络起止地址是多少？\n\n- 利用子网掩码计算，最多可以划分4个子网络\n\n> 利用子网掩码计算，每个子网络可容纳16384台主机（包括网络地址和广播地址）\n\n用16384除以256（网段内包括网络地址和广播地址的全部主机数），结果是64\n具体划分网络起止方法如下：\n172.16.0.0～172.16.63.255\n172.16.64.0～172.16.127.255\n172.16.128.0～172.16.191.255\n172.16.192.0～172.16.255.255\n\n[参考来源](http://blog.sina.com.cn/s/blog_5753d0930101fxdf.html)\n\n## 快速但需要检验的方法\n快的方式(Block):几个主机位,算B类地址比较麻烦.\n\n- 例子\n\n132.56.45.7/30,网络位，主机位多少？\n\n30转成二进制：1111，1100，后两位的0的块：$2^2$,一块最多4个主机(0-3,4-7,8-11)\n\n## CIDR 无类域间路由\ncidrreport.org\n无间路由(Classless Inter Domain Routing):由RFC1871定义。突破传统的地址分类边界，将路由表中的若干条线路汇聚成一条路由，减少了路由表的规模，提高了路由的可扩展性。\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/xD3bcuXPFsLTiSZ.png)\n\n图中：转成二进制：\n10.24.0000，0000.0\n10.24.0000，0001.0\n10.24.0000，0010.0\n10.24.0000，0011.0\n\n转二进制部分只有后两位不一样。把网络往前推（子网是Mask边长汇总是Mask变短),原来是24，变短就是22.\n\n## 网关(Gateway)\n用来转发来自不同网段之间的数据包。\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/6y7Jc51WoUZINP8.png)\n\n## 实施FTP\n- 文件传输\n\nFTP：文件传输协议 (华为居多)，基于TCP，两个端口号,控制端口一般为21，而数据端口不一定是20，和FTP的应用模式有关，如果是主动模式，应该为20，如果为被动模式，由服务器端和客户端协商而定。\nTFTP：简单文件传输协议 (思科居多)，基于UDP\n\n1. 网络连通性\n\n```bash SW1\ninterface vlanf1\nip address 10.1.1.1 255.255.255.0\n```\n```bash SW2\ninterface vlanf1\nip address 10.1.1.2 255.255.255.0\n```\n测试连通性\n```bash\nping 10.1.1.1.2\n```\n\n2. 开启FTP服务\n\n```bash\nftp server enable\ndiaplay ftp-servver # 查看状态\n```\n\n3. 实施FTP\n\n开启3A（认证，授权，统计）\n\n```bash SW1\naaa\nlocal-user Endar password simple userName # 增加用户名和密码\nlocal-user Endar level 15 # 设置最高的访问权限，0-15级\nlocal-user Endar ftp-directory flash: # 共享所有目录，后面可以指定其他\nlocal-user Endar server-type ftp # 设置用户服务用于ftp协议\nsave Endar.zip # 保持配置文件\nsss\n\n客户端测试\n\n```bash SW2\nftp 10.1.1.1 # 后输入用户名、密码\ndir # 查考目录\nget Endar.zip # 获取文件\nq # 退出\n```\n\n# 以太网IP头部概述和VRP相关讲解\n一公司四个部门，5、25、27、15人，规划每个部门vlan，给固定长度掩码：192.168.1.0/27，192.168.1.32/27，192.168.1.64/27，192.168.1.96/27\n\n## IP包头的重要字段\n## VRP基础(应用)\n\n\n# VRP(通用路由平台)的FTP应用\n可以Web、Cli登录\n常用密码：Admin@huawei\n## 设备初始化启动\nbios 自检\n内存检测\ncopy 数据(VRP包拷贝)\n解压缩到内存\nCTRL + B 停止自动启动(后可以初始密码)\n \n## 命令行视图\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/RLPUMe4njqVylga.png)\n\n- 用户视图\n\n清除、display、保存\n\n- 系统视图(system-view)\n\n以中括号显示。可以display，但不能清除、保存\n配置系统参数\n\n- 接口视图\n\n- 协议视图\n\nOSPF、BGP、is-is\n```bash\nsystem-view\nospf # 进入 osp 协议设置\nbgp # 将进入 bgp协议设置\n```\n\n## 命令行功能\n|命令|解释|\n|:--------|:-------|\n|CTRL + A | 光标移动到当前目录行最前端|\n|CTRL + E | 光标移动到当前目录行最末端|\n|CTRL + C | 停止当前命令的运行|\n|CTRL + Z | 回到用户视图|\n|CTRL + ] | 终止当前连接或切换连接|\n|Backspace | 删除光标左边的第一个字符|\n|⬅ Or CTRL + B | 光标左移一位|\n|➡ Or CRTL + F | 光标右移一位|\n|TAB     |输入一个不完整的命令按TAB进行补全|\n\n## 命令行在线帮助\n- 部分帮助\n\n```bash\n<Huawei>d?\n<Huawei>display h?\n```\n\n- 完全帮助\n\n```bash\n<Huawei>?\n<Huawei>dislay?\n```\n\n## 命令等级\n|用户等级|命令等级|名称|\n|:--------|:-------|:-------|\n|0|0|访问级|\n|1|0 and 1|监控级|\n|2|0，1 and 2|配置级|\n|3-15|0，1，2 and 3|管理级|\n\n允许某管理员保存系统配置，则可以将save命令的级别提高到4级，并定义只有该管理员有4级权限。就可以在不影响其他用户的情况下，实现命令的使用控制。\n\n```bash\nsystem-view\ncommand-privileage level 2 view user save\n```\n\n## 用户界面\nVTY接口最大可配范围：0~4\n\n|用户界面类型|编号|\n|:--------|:-------|\n|Console|0|\n|VTY|0~4|\n\n```bash R1\nsystem-view\nuser-intetface vty 0 4\nset authentication password clipher pass\n```\n```bash R2\ntalnet 12.1.1.1\n```\n```bash R1\ndiaplay users # 查看用户\nuser privilege level 2 # 设置用户登陆权限\n```\n\n`user-interface maximum-vty number` 可以配置同时登陆到设备的VTY类型用户界面的最大个数，如最大登录用户数设为0，则任何用户都不能通过Telnet或者SSH登陆到路由器。\n\n- 配置用户界面命令\n\n|命令|功能|\n|:--------|:-------|\n|idle-tineout|设置超时时间默认十分钟|\n|screen-length|设置指定终端屏幕的临时显示行数(0不显示)|\n|history-command max-size|设置历史命令缓冲区的大小|\n\n```bash\nsystem-view\nuser-interface console 0\nhistoty-command max-size 20\nindle-timeout 1 30 # 1分20秒(最好不要改))\n```\n```bash\nsystem-view\nuser-interface console 0\nscreen-length 512 # 最大行数512\n```\n\n## CTR 快捷键\n|命令|解释|\n|:--------|:-------|\n|CTRL + TAB|到达后一标签|\n|CTRL + SHIFT + TAB|前一标签|\n|ALT + 数字|直接到达某标签|\n\n## 配置标题消息\n```bash\n# 配置在用户登录前显示的标题信息\nheader login information \"Welcome to huawei certification\"\n\n# 配置在用户登陆后显示的标题信息\nheader shell information \"Please dont't reboot this devices\"\n```\n`dis current-configuration | ? ` \n`dis current-configuration | include header ` 显示包含 header 的命令有哪些 \n\n# 文件系统管理\n## 基本命令\n|命令|功能|\n|:--------|:-------|\n|pwd|查看当前目录|\n|dir|显示当前目录下的文件信息|\n|more|查看文本文件的具体内容|\n|cd|修改当前用户当前界面的工作目录|\n|mkdir|创建新目录|\n|rmdir|删除目录|\n|copy|复制文件|\n|move|移动文件|\n|rename|村民们文件|\n|delete / unreserved|删除/永久删除文件|\n|undelete|恢复删除的文件|\n|reset recycle-bin|彻底删除回收站的文件|\n|save|保存配置，要在用户模式下|\n\n## 配置文件管理\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/B7dYZRDnW2tQmc6.png)\n\n- 配置文件查询\n\n|命令|功能|\n|:--------|:-------|\n|diaplay curremt-contiguration|显示当前配置文件|\n|diaplay saved-configuration|显示保存的配置文件|\n\n```bash\nsave Endar.zip # 保存配置\n\n# 查看当前配置\ndiaplay current-configuration\n\n# 显示保存的配置文件\ndiaplay saved-configuration\n```\n\n- 系统启动文件查查\n\n|命令|功能|\n|:--------|:-------|\n|display startup|查看系统启动参数|\n\n- 系统启动配置文件修改\n\n`startuo ?` :\n1. path # 加载补丁\n2. save-configuration # 加载下次的配置\n3. system-software # 加载下次启动的软件\n\n```bash\n# 配置系统下次启动时使用的配置文件\nstartup save-configuration Ender.zip\ndis startup\n```\n\n- 比较当前配置和保存的配置\n\n```bash\ncompare configuration\n```\n\n- 配置文件重装\n\n```bash\n# 清楚下次启动时加载的配置文件\nreset save-contiguration\n```\n\n- 设置环回地址\n\n```bash\nsystem-view\ninterface loopback 0\nip address 10.1.1.1 32\n```\n\n## 存储设备\nSDRAM、Flash、NVRAM、SD Card、USB\n\n```bash\n# 显示存储设备信息\ndiaplay version\n```\n\n- 存储设备修复\n\n```bash\nfixdisk flash:\n\nfixdisk ad1:\n```","tags":["Linux"],"categories":["Coding"]},{"title":"LAMP","path":"/posts/LAMP.html","content":"> Linux 编译安装 LAMP \n\n# Apache\n# 准备\n编译工具&开发包\n```shell\nyum -y install make gcc openssl\n```\n依赖包\n\n|包|描述|\n|:---|:---|\n|[httpd](https://httpd.apache.org/)|Apache 主程序包|\n|[apr](https://apr.apache.org/download.cgi)|Apache 依赖包|\n|[apr-util](https://apr.apache.org/download.cgi)|Apache 依赖包|\n|[pcre](https://ftp.pcre.org/pub/pcre/)|Apache 依赖包|\n\n<!--more-->\n## Install\n\n- apr\n\n```shell\ntar zxvf apr-1.5.2.tar.gz\ncd apr-1.5.2\n./configure --prefix=/usr/local/apr\nmake && make install\n```\n\n- apr-util\n\n```shell\ntar zxvf apr-util-1.5.4.tar.gz\ncd apr-tuil-1.5.4\n./configure --prefix=/usr/local/apr-util/\\\n--with-apr=/usr/local/apr/bin/apr-1-config\nmake && make install\n```\n\n- pcre\n\n```shell\nunzip -o pcre-8.38.zip\ncd pcre-8.38\n./cofigure --prefix=/usr/local/pcre\nmake && make install\n```\n\n- Apache\n\n```shell\ntar zxvf httpd-2.4.18.tar.gz -C /usr/local/src/\ncd /usr/local/src/httpd-2.4.18/\n./configure --prefix=/usr/local/apache2 \\\n--enable-so \\\n--enable-ssl \\\n--with-apr=/usr/local/apr/ \\\n--with-apr-util=/usr/local/apr-util/ \\\n--with-pcre=/usr/local/pcre/\n```\n注:\n--enable-so # 支持动态加载模块哦\n--enable-rewrite # 支持网站地址重写\n--with-apr=/usr/local/apr # 关联 apr\n\n### 配置文件\n```shell\nls /usr/local/apache2/conf/httpd.conf\n```\n### 网站根目录\n```shell\nls /usr/local/apache2/htdocs/\n```\n### 生成启动脚本\n```shell\ncp /usr/local/apache2/bin/apachectl  /etc/init.d/\nchmod +x /etc/init.d/apachectl\n```\n\nvim /etc/init.d/apachectl\n\n```shell  apachectl\n# chkconfig: 2345 64 36\n# descroption:  apache service\n```\n\n## 将服务添加到系统启动列表\n```shell\nchkconfig --add apachectl\nchkconfig apachectl on\nchkconfig --list apachectl \nservice apachectl start\n```\n\n# MySQL\n## Download\n[boost](https://sourceforge.net/projects/boost/files/latest/download)\n[MySQL](https://dev.mysql.com/downloads/mysql/)\n\n```shell\nyum -y remove boost\nyum -y remove mysql\n```\n## Install\n### 添加用户和组\n```shell\ngroupadd mysql\nuseradd -M -s /sbin/nologin -r -g mysql mysql\n```\n### 创建安装目录和数据存放目录\n```shell\nmkdir /server\nmount /dev/sdb2 /server/\n\n# 开机自动挂载\necho \"/dev/sdb2 /server ext4 defaults 0 0\" >> /etc/fstab\n```\n\n### 安装\n```shell\nmkdir -p /server/mysql/data\ntar -zxvf boost_1_59_0.tar.gz\nmv booboost_1_59_0 boost\ntar -zxvf mysql-5.7.11.tar.gz\n\ncd mysql-5.7.11\n cmake . \\\n-DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\\n-DSYSCONFDIR=/server/mysql/data \\\n-DSYCONFDIR=/etc \\\n-DWITH_MYISAM_STORAGE_ENGINE=1 \\\n-DWITH_INNOBASE_STORAGE_ENGINE=1 \\\n-DWITH_MEMORY_STORAGE_ENGINE=1 \\\n-DWITH_READLINE=1 \\\n-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \\\n-DMYSQL_TCP_PORT=3306 \\\n-DENABLED_LOCAL_INFILE=1 \\\n-DWITH_PARTITION_STORAGE_ENGINE=1 \\\n-DEXTRA_CHARSETS=all \\\n-DDEFAULT_CHARSET=utf8 \\\n-DDEFAULT_COLLATION=utf8_general_ci \\\n-DDOWNLOAD_BOOST=1 \\\nDWITH_BOOST=/server/boost\n```\n\n安装\n\n```shell\nmake -j 4 # 多核心安装\n# 查看核心数\ngrep processor /proc.cpuinfo | wc -l\n\nmake install\n```\n\n修改目录权限\n```shell\nchown -R mysql:mysql /server/mysql/\n```\n\n生成配置文件\n\n```shell\nmv /etc/my.cnf{,.bak}\ncp /server/mysql/support-files/my-default.cnf /etc/my.cnf\n```\n\n生成服务启动脚本\n\n```shell\ncp /server/mysql/support-files/mysql.server /etc/init.d/mysqld\nchkcongig mysqld on\nchkconfig --list mysqld\n```\n\n初始化数据库\n\n```shell\n/server/mysqk/bin/mysqld --initialize-insecure --user=mysql --basedir=/server/mysql --datadir=/server/mydql/data\n```\n\n启动服务\n\n```shell\nserver mysqld start\n```\n\n添加 path 路径\n1. 方法一\n\n```shell vim /etc/profile\nexport MYSQL_HOME=/server/mysql\nexport PATH=$PATH:$MYSQL_HOMW/bin\n```\n使修改生效\n```shell\nsource /etc/profile\n```\n2. 方法二\n```shell\nln -s /server/mysql/bin/* /user/local/bin\n```\n\n修改密码\n1. 方法一\n\n```shell\nmysqladmin -u roor password \"123456\"\n```\n\n2. 方法二\n\n```shell\nmysql\nset password=password('123456');\n```\n\n# PHP\n## 安装依赖包\n```shell\nyum -y install php-mcrypt libmcrypt libmcrypt-devel autoconf freetype gd libmcrypt libpng libpng-devel libjpeg libxml2 libxml2-devel zlib curl curl-devel\n```\n## Install\n```shell\ntar  zxvf php-7.05.tar.gz\n```\n### 编译\n```shell\ncd php-7.05\n./configure --prefix=/server/php7/ \\\n--with-apx2=/use/local/apache2/bin/apxs \\\n--enable-mbstring \\\n--with-curl \\\n--with-gd \\\n--enable-fpm \\\n--enab;e-musqld \\\n--with-pdo-mysql=mysqld \\\n--with-config-file-path=/server/php7/etc/ \\\n--with-mysqli=mysqlnd \\\n--with-mysql-socl=/server/mysql/mysql.sock\n```\n\n### 安装\n```shell \nmake -j 4\nmake install\n```\n\n生成配置文件\n```shell\ncp php.ini-production /server/php7/etc/php.int\n```\n添加 Apache 支持\n```shell\nvim /usr/local/apache2/cong/httpd.conf\n\nAddtype application/x-httpd=php .php .phtml\n```\n\n创建测试页面\n```shell\ncd /usr/local/apache2/htdocs/\necho \"\n<?php phpinfo();\n?>\n```","tags":["Linux","Web"],"categories":["Linux"]},{"title":"解决Python pip 速度慢","path":"/posts/PipInstall.html","content":"解决 Python 安装库时速度慢或者超时问题\n\n\n# 设置超时时间\n```python\npip --default-timeout=1000 install jieba\n```\n\n# -i 指定源\n```python\npip install wordcloud -i https://pypi.tuna.tsinghua.edu.cn/simple/\n```\n<!--more-->\n# 更改默认设置\n```python ~/.pip/pip.conf\n[global]\nindex-url = http://mirrors.aliyun.com/pypi/simple/\n[install]\ntrusted-host=mirrors.aliyun.com\n```","tags":["Linux","Python"],"categories":["Coding"]},{"title":"Matplotlib 中文乱码","path":"/posts/MatplotlibZh.html","content":"Linux 解决 matplotlib 中文乱码问题\n<!--more-->\n\n# 安装字体\n- 安装中文字体，例如 SimHei\n\n- 检测本机中文字体\n\n```python\nfrom matplotlib.font_manager import FontManager\nimport subprocess\n\nfm = FontManager()\nmat_fonts = set(f.name for f in fm.ttflist)\n#print(mat_fonts)\noutput = subprocess.check_output('fc-list :lang=zh -f \"%{family}\\n\"', shell=True)\n#print( '*' * 10, '系统可用的中文字体', '*' * 10)\n#print (output)\nzh_fonts = set(f.split(',', 1)[0] for f in output.decode('utf-8').split('\\n'))\navailable = mat_fonts & zh_fonts\nprint ('*' * 10, '可用的字体', '*' * 10)\nfor f in available:\n     print (f)\n```\n\n# 配置字体\n- 复制字体\n\n```bash\nsudo cp font.ttf /usr/share/fonts\nsudo cp font.ttf /usr/lib/python3.7/site-packages/matplotlib/mpl-data/fonts\n```\n\n# 配置\n```baah /usr/lib/python3.7/site-packages/matplotlib/mpl-data\nsudo nvim matplotlibrc\n```\n\n- matplotlibrc\n\n```bash\nfont.family     : sans-serif                                           \nfont.serif▏     : serif     \n\nfont.serif         : SimHei,Source Code Pro,DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia\nfont.sans-serif    : SimHei,Source Code Pro,DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica\n```\n\n# 清楚缓存\n```bash\nrm -rf ~/.cache/matplotlib\n```\n\n# 使用\n```bash\n# 中文乱码的处理\nfrom pylab import mpl\nmpl.rcParams['font.sans-serif'] = ['Source Code Pro'] # 指定默认字体\nmpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题\n```\n\n\n---\n**参考资料**\n- [Linux下解决matplotlib中文乱码的方法](https://segmentfault.com/a/1190000000621721)","tags":["Linux","ArchLinux","Python"],"categories":["Diary"]},{"title":"Linux Wine 调整分辨率","path":"/posts/Wine-dpi.html","content":"Linux Wine 调整分辨率\n<!--more-->\n\n# 终端输入\n- 应用设置\n\n```bash\nenv WINEPREFIX=\"$HOME/.deepinwine/Deepin-WeChat\" winecfg\n```\n\n- 全局设置\n\n```bash\nwinecfg\n```\n\n# 设置分辨率\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/wine-dpi.png)","tags":["Linux","Wine"],"categories":["Linux"]},{"title":"Xpath 升格用法","path":"/posts/Xpath.html","content":"xpath 升格用法\n<!--more-->\n\n# 匹配当前节点下所有子节点 `.//`\n```python\nxpath('//div//') # div 当前节点\n```\n- `//` 标签下的所有标签\n\n# 匹配某标签的属性值 `/@属性名称`\n```python\n# 获取 input value\nxpath('//input/@value')\n```\n\n# 匹配多个路径 `|`\n```python\nxpath('//div/text() | //div/div/text()')\n```\n\n# 按属性匹配 `@`\n```python\n# 获取所有id=\"test\"的所有文本内容\nxpath('//*[@id=\"test\"]//text()')\n```\n\n# 匹配不包含某个属性的标签 `not`\n```python\n# 多用于表格中匹配中不包含表头信息的数据\nxpath('//table/tr[not(@class=\"tbhead\")]')\n```\n\n# 匹配包含多个属性的标签 `and`\n```python\n# 匹配所有的tr中不包含 tbhead 属性 和包含 head 的tr标签\nxpath('//table/tr[not(@class=\"tbhead\") and @class=\"head\"]')\n```\n\n# 匹配包含不同属性的名称相同的标签 `or`\n```python\n# 匹配包含class=\"speedbar\" 或者 class=\"content-wrap\" 的标签\nxpath（'//div[@class=\"speedbar\" or @class=\"content-wrap\"]'）\n```\n\n# 将对象还原为字符串 `etree.tostring（）`\n```python\n# 将匹配到的对象，作为etree.tostring（）的参数即可，  注： 返回字符串\nsObj = xml.xpath('//*[@id=\"test\"]')[0]# 使用xpath定位一个节点\nsStr = etree.tostring(sObj)\n```\n\n# 按轴(Axes)匹配\n## 选取当前节点的所有子元素 `child`\n```python\n# 获取div下的tr的标签\nxpath('//div[@id=\"testid\"]/child::tr/td/text()')\n# 感觉这种方法鸡肋， 也可以实现\nxpath('//div[@id=\"testid\"]//tr/td') \n```\n\n## 选取当前节点的所有属性 `attribute`\n```python\n# 获取div标签所有的属性值\nxpath('//div/attribute::*') \n# 感觉这种方法鸡肋，//div/@* 同样能实现\n```\n\n## ancestor：父辈元素 / ancestor-or-self：父辈元素及当前元素\n```python\n# 获取父辈元素的div的所有属性值， 在不好定位的情况下，通过孩子标签定位，这种方法可以用\nxpath('//div[@id=\"test\"]/ancestor::div/@*')\nxpath('//div[@id=\"test\"]/ancestor-or-self::div/@*')\n```\n\n## descendant：后代 / descendant-or-self：后代及当前节点本身\n```python\n# 获取孩子元素的div的所有属性值，感觉鸡肋\nxpath('//div[@id=\"test\"]/descendant::div/@*')\nxpath('//div[@id=\"test\"]/descendant-or-self::div/@*')\n```\n\n## 选取当前节点的所有命名空间节点 `namespace`\n```python\nxpath('//div[@id=\"test\"]/namespace::*')\n```\n\n## 定位 `position`\n```python\n# 和通过下标定位一样， 方法鸡肋\nxpath('//*[@id=\"test\"]/ol/li[position()=2]/text()')\n```\n\n# Xpath 函数\n## 统计数量 `count`\n```python\n# 统计符合要求节点的数量,返回字符串\nxpath('count(//tr[@info])')\n```\n\n## 字符串拼接 `concat`\n```python\n# 统计出来的两个内容的字符串进行“ + ”处理,返回字符串\nxpath('concat(//li[@id=\"one\"]/text(),//li[@id=\"three\"]/text())')\n```\n\n## 解析当前节点下的字符 `string`\n```python\n# string()直解析匹配的第一个标签的值，  注： 返回字符串\nxpath('string(//tr)') \n```\n\n## 获取当前节点的节点名称 `local-name`\n```python\n# 返回当前属性的节点名称，  注： 返回字符串\nxpath('local-name(//*[@id=\"test\"])')\n```\n\n## 以指定的字符开头 `starts-with`\n```python\n# starts-with定位属性值以8开头的li元素\nxpath('//tr[starts-with(@code,\"one\")]/text()')\n```\n\n## 小于 `<`\n```python\n# 匹配所有tr标签属性info小于200的内容\nxpath('//tr[@info<200]/text()')\n```\n\n## 根据指定的文本内容选择\n```python\n# 指定的文本内容可以是文本内容的部分， 也可以是全部\nxpath('//div[2]/ul/li[contains(text(), \"指定的文本内容\")]/span/text()'\n```\n\n--- \n**Via**\n- [作者:董小贱](https://www.jianshu.com/p/4fef4142b33f)","tags":["Linux","WebCrawler","Python"],"categories":["Coding"]},{"title":"Hexo SEO 优化","path":"/posts/HexoSEO.html","content":"Hexo SEO 优化\n<!--more-->\n\n# 添加站点地图\n## 安装插件\n```bash\nnpm install hexo-generator-sitemap --save\nnpm install hexo-generator-baidu-sitemap --save\n```\n\n## 配置\n```bash _config.yml\n#hexo sitemap\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: bdmap.xml\n```\n\n# 添加 robots\n站点 source 下添加 `robots.txt`\n```bash robots.txt\nUser-agent: *\nAllow: /\nAllow: /archives/\nAllow: /categories/\nAllow: /tags/\nAllow: /about/\n\nDisallow: /vendors/\nDisallow: /js/\nDisallow: /css/\nDisallow: /fonts/\nDisallow: /vendors/\nDisallow: /fancybox/\n\nSitemap: https://vitan.me/sitemap.xml\nSitemap: https://vitan.me/bdmap.xml\n```\n\n# 添加到 Google\n- 在 [Google Search Console](https://search.google.com/search-console) 添加站点地图\n- 在 [百度](https://ziyuan.baidu.com/linksubmit/index) 添加站点地图","tags":["Hexo"],"categories":["Diary"]},{"title":"撤销 Google AdSense","path":"/posts/DeleteGoogleAdSense.html","content":"# AdSense 账户\n## 撤销原因\n更换了邮箱之后重新申请了一个，但是提示有多个 AdSense 账户\n\n<!--more-->\n## 常规撤销\n登录 [Google AdSense](https://www.google.com/adsense/) 点击菜单->账号->撤销账号\n\n- 个人情况\n我遇到的情况比较特俗，AdSense 页面的 `账号` 按钮不可点击，为灰色。\n\n## 摸索的方法\n1. 在 [Google 账号](https://myaccount.google.com) 的 `数据和个性化` -> `下载数据、删除数据或为数据制定方案` -> `删除某项服务或您的帐号` 关闭自己的 Google 付款资料\n2. 可以发现 AdSense 页面中的 `账号` 按钮变为可点击了，撤销成功！","tags":["Hexo","Google"],"categories":["Diary"]},{"title":"RaspberryPi 搭建 Gogs Git 服务","path":"/posts/GogsOnPi.html","content":"树莓派搭建 Gogs Git 服务\n<!--more-->\n# 安装 MySQL\n```bash\nsudo apt install mariadb-server mariadb-client \n```\n配置\n```bash\nsudo vi /etc/mysql/mariadb.conf.d/50-server.cnf \n注释掉 \nbind-address = 127.0.0.1\n```\n\n- 修改 root 密码\n\n```bash\nsudo mysqladmin -u root -p password \n```\n\n- 新建 gogs 数据库\n\n```bash\nmysql -h127.0.0.1 -uroot -p123456\ncreate database gogs;\n```\n\n- 重启 MySQL\n\n```bash\nsudo service mysql restart\n```\n# golang\n```bash\nsudo apt install golang -y\n```\n\n# [gogs](https://gogs.io/)\n```bash\nwget https://cdn.gogs.io/0.11.79/gogs_0.11.79_raspi2_armv6.zip\n```\n解压\n```bash\ntar -xzvf gogs_0.11.79_raspi2_armv6.zip\n```\n\n安装\n```bash\ncd 解压后的目录\n./gogs web\n```\n\n配置\n- 浏览器打开 `http://ip:3000`\n\n![](https://raw.githubusercontent.com/ivitan/Picture/master/20190731144809.png)\n\n后台运行\n```bash\nnohup ./gogs web > nohup.out 2>&1 &\n```\n# [Frp](https://diannaobos.com/frp/) 内网穿透\n下载安装\n```bash\nwget https://github.com/fatedier/frp/releases/download/v0.27.1/frp_0.27.1_linux_386.tar.gz\n  \n# 解压安装\ntar -zxvf frp_0.27.1_linux_386.tar.gz\n```\n\n配置\n```bash\ncd frp_0.27.1_linux_386\nvim frps.ini\n```\n```bash\n[common]\nserver_addr = gogs.vitan.me\nserver_port = 8000\ntoken = \n\n[gogs]\ntype =http\nprivilege_mode = true\nlocal_ip = localhost\nlocah_port = 3000\n\ncustom_domain = gogs.vitan.me\n```\n启动\n```bash\n./frps -c ./frps.ini\n```\n- 配置好服务器端后,可以在浏览中(http://IP:8000/static/#/) 打开 frp 的控制台\n\n---\n**参考**\n- [gogs](https://gogs.io/docs/installation/install_from_binary)\n- [Frp](https://diannaobos.com/frp/)","tags":["Linux","Git","RaspberryPi"],"categories":["Diary"]},{"title":"Termux 局域网共享文件","path":"/posts/Termux-Httpd.html","content":"Android 跨设备局域网共享文件\n<!--more-->\n# http-server\n安装\n```bash\npkg install nodejs-lts\nnpm install http-server -g\n```\n\n启动服务\n```bash\nhttp-server\n```\n\n## 同一局域网\n同一局域网下浏览器登录启动服务后的提示的 ip 即可访问手机的文件，相反电脑同理。","tags":["Linux","Android","Termux"],"categories":["Diary"]},{"title":"Shell","path":"/posts/Shell.html","content":"Shell 总结\n<!--more-->\n# 变量替换和测试\n## 变量替换\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720191523.png)\n\n## 变量测试\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720191707.png)\n\n# 字符串处理\n## 计算字符串长度\n方法一\n```sh\n${#string}\n```\n\n方法二\n```sh\nexpr length \"$string\"\n```\n  - string 有空格，则必须加双引号\n\n## 子串\n获取子串在字符串中的索引位置\n\n```sh\nexpr index $string $substring\n```\n\n抽取子串\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720192503.png)\n\n## 总结\n计算字符串长度\n```sh\nvar1=\"This is a app\"\nlen=${#$var1}\nlen=`expr length \"$var1\"`\n```\n\n子串索引\n```sh\nvar1=\"quicstart is a app\"\nind=`expr index \"$var1\" start`\n```\n\n子串长度\n```sh\nvar1=\"quicstart is a app\"\nind=`expr match \"$$var1\" app`\n```\n\n抽取字符串中的子串\n```sh\nvar1=\"quicstart is a app\"\nsubstr1=${var1:10}\nsubstr2=${var1:10:6}\nsubstr1=${var1:-5}\nsubstr1=${var1:-10:4}\n```\n  - expr 索引1开始,${string:position}从0开始\n\n实例\n```sh\n  #! /bin/bash\n  string=\"Bigdata process framework is Hadoop,Hadoop is an open source project\"\n\n  function print_tips\n  {\n      echo \"***********************\"\n      echo \"(1) 打印string长度\"\n      echo \"(2) 删除字符串中所有Hadoop\"\n      echo \"(3) 替换第一个Hadoop为Mapreduce\"\n      echo \"(4) 替换全部Hadoop为Mapreduce\"\n      echo \"**********************\"\n    }\n\n  function len_of_string\n  {\n    echo \"${#string}\"\n  }\n\n  function del_hadoop\n  {\n    echo \"${string/Hadoop/}\"\n  }\n\n  function rep_hadoop_mapreduce_first\n  {\n    echo \"${string/Hadoop/Mapreduce}\" \n  }\n\n  function rep_hadoop_mapreduce_all\n  {\n    echo \"${string//Hadoop/Mapreduce}\" \n  }\n\n  while true\n  do \n    echo \"【string=$string】\"\n    echo\n    print_tips\n    read -p \"Pls input your choice(1|2|3|4|q|Q):\" choice\n    case $choice in\n          1)  len_of_string\n              ;;\n          2)  del_hadoop\n              ;;\n          3)  rep_hadoop_mapreduce_first\n              ;;\n          4)  rep_hadoop_mapreduce_all\n              ;;\n          q|Q)  exit\n                ;;\n          *)\n              echo \"Error,input only in {1|2|3|4|q|Q}\"\n              ;;\n          esac\n  done\n```\n\n# 命令替换\n语法格式\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720194539.png)\n\n## 例题\n获取系统所有用户并输出\n```sh\ncat /etc/passwd | cut -d “:” -^C #分割的第一个\ncat /etc/passwd | cut -d “:” -f 1 #分段\n```\n\n```sh\n#! /bin/bash\n# 判断进程是否存在，否则启动\nnginx_process_num=$(ps -ef | grep nginx | grep -v grep | wc -l)\n\nif [ $nginx_process_num -eq 0 ];then\n    systemctl start nginx\nfi\n```\n\n## 总结\n`\\`\\`` 和 `$()`\n1. ``和$()是等价的，但初学推荐$()\n2. $(())用于进行整数运算，包括加减乘除\n3. $(((100 + 30) / 12))\n\n# 有类型变量\n## declare 和 typeset 命令\n两者关系:两者等价，都是用来定义变量类型\n\n## declare参数表\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720195605.png)\n\n```sh\n# 声明整数型变量\ndeclare -i ab #声明整数型变量\nab=56 #改变变量内容\necho $ab #显示变量内容\n56\n\n# 改变变量属性\ndeclare -i ef #声明整数型变量\nef=1  #变量赋值（整数值）\necho $ef #显示变量内容\n1\nef=\"wer\" #变量赋值（文本值）\necho $ef \n0\n\ndeclare +i ef #取消变量属性\nef=\"wer\"\necho $ef\nwer\n\n# 设置变量只读\ndeclare -r ab #设置变量为只读\nab=88 #改变变量内容\necho $ab #显示变量内容\n56\n\n# 声明数组变量\ndeclare -a cd='([0]=\"a\" [1]=\"b\" [2]=\"c\")' #声明数组变量\necho ${cd[1]}\nb #显示变量内容\n\necho ${cd[@]} #显示整个数组变量内容\na b c\n```\n  - `declare -x` 声明为环境变量，可在脚本中直接使用\n\n## 取消声明的变量\n```sh\ndeclare +r\ndeclare +i\ndeclare +a\ndeclare +X\n```\n\n# 数学运算\n语法格式\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720200443.png)\n\nexpr操作符对照表\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720200649.png)\n\n## 例子\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720201000.png)\n\n# Bash运算之bc\n## bc 操作\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720201134.png)\n```sh\nscale=2 #精确到小数点后两位\necho “20+22” | bc\necho “scale=3;23+33” | bc\n```\n\n# 函数\n## 函数定义和使用\nLinux Shell中的函数和大多数编程语言中的函数一样，将相似的任务或代码封装到函数中，供其他地方调用\n\n语法一\n```sh\n  name()\n  {\n    command1\n    command2\n    ....\n    commandn\n  }\n```\n\n语法二\n```sh\n  function name\n  {\n    command1\n    command2\n    ....\n    commandn\n  }\n```\n\n## 如何调用\n1. 直接使用函数名调用，可以将其想象成 Shell 中的一条命令\n2. 函数内部可以直接使用函数 $1,$2...$n\n3. 调用函数：function_name $1 $2\n\n## 例题\n```sh\n  #!/bin/bash\n  # 判断进程是否存在，否则启动\n\n  #脚本名含有nginx会返回0\n  # echo $$ 运行脚本产生的进程id\n  this_pid=$$\n\n  while true\n  do\n  ps -eff | grep nginx | grep -v grep | grep -v $this_pid &> /dev/null\n\n  if [ $? -eq 0];then\n      echo \"Nignx is running well\"\n      sleepp 3\n  else \n      systemctl start nginx\n      echo \"Nginx is down,start it..\"\n  fi\n  done\n```\n\n判断进程\n```sh\nnetstat -tnlp | grep :80\ncurl localhost/index.html\n```\n\n# 向函数传递参数\n## shell传参\n```sh\n  function name\n  {\n    echo \"Hello $1\"\n    echo \"Hello $2\"\n  }\n```\n\n## 函数返回值\n1. return\n2. echo\n\n### reutrn 返回值\n1. 只能返回1-255的整数\n2. 通常智能用来供其他地方调用获取状态，因此仅返回0（成功)，1(失败)\n\n### echo 返回值\n1. 可以返回任何字符串结果\n2. 通常用于返回数据，如一个字符串值或列表值\n\n# 局部变量全局变量\n## 全局变量\n1. 不做特殊处理，shell 中变量为全局变量\n2. 大型脚本程序慎用\n\n\n## 局部变量\n1. 定义时，使用local关键字\n2. 函数内外如果存在同名变量，册函数内部变量覆盖外部变量\n\n## 函数库\n- 为什么要定义函数库\n1. 经常使用的重复代码封装成函数文件\n2. 一般不直接执行，而是由其他脚本调用\n\n实例\n```sh 库文件\n  function add\n  {\n      echo \"`expr $1 + $2`\"\n  }\n\n  function reduce\n  {\n      echo \"`expr $1 - $2`\"\n  }\n\n  function multiple\n  {\n      echo \"`expr $1 \\* $2`\"\n  }\n\n  function diveid\n  {\n      echo \"`expr $1 / $2`\"\n  }\n\n  function sys_load\n  {\n      echo \"Memory Info\"\n      free -m\n      echo\n\n      echo \"Disk Usage\"\n      echo\n      df -h \n  }\n```\n```sh \n#!/bin/bash\n. /home/vitan/workplace/Shell/learn/function/base_function\nadd 122 3\nreduce 9 3\nmultiple 22 11\ndiveid 12 3\nsys_load\n```\n\n### 注意事项\n1. 库文件名的后缀是任意的，但一般用 `.lib`\n2. 库文件通常没有可执行权限\n3. 库文件无需和脚本在同级目录，只需在脚本中引时指定\n4. 第一行一般使用 `#!/bin/bash/echo` ，输出警告信息，避免用户执行\n\n# 文件查找之find命令\nfind [路径][选项][操作]\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190720205155.png)\n\n## 实例\n1. 查找 /etc 目录下 conf 结尾的文件\n```sh\nfing /etc -name '.conf'\n```\n2. 查找当前目录下文件名为 aa 的文件，不区分大小写\n```sh\nfind . -name aa\n```\n3. 查找文件属主为 hdfs 的所有文件\n```sh\nfind . -user hdfs\n```\n4. 查找文件属组为 yarn 的所有文件\n```sh\nfind . -group yarm\n```\n---\n\n## 选项\n1. -type\n  - f 文件 find . -type f\n  - d 目录 dind . -type d\n  - c 字符设备文件 dind . -type c\n  - b 块设备文件 dind . -type b\n  - l 链接文件 dind . -type l\n  - p 管道文件 dind . -type p\n\n2. -size\n  - -n 大小小于n的文件\n  - +n 大小大于n的文件\n  - n 大小等于n的文件\n    \n  ```sh\n  # 小于10000字节的文件\n  find /etc -size -10000c\n  # 大于1M的文件\n  find /etc -size +1M\n  ```\n\n3. -mtime\n   - -n n天以内修改的文件\n   - +n n天以外修改的文件\n   - n 正好n天修改的文件\n\n  ```sh\n  #查找/etc下5天内修改的conf结尾的文件\n  find /etc -mtime -5 -name '*.conf'       \n  # 查找10天之前修改且属主为root的文件\n  find /etc -mtime +10 -user root\n  ```\n\n4. -mmin\n   - -n n分种内修改的文件\n   - +n n分钟外修改的文件\n\n  ```sh\n  # 30分钟前修改的文件\n  find /etc -mmin +30\n  # 30分钟内修改的目录\n  find /etc -mmin -3o -type d\n  ```\n\n5. -mindepth n\n   - 表示从n级子目录开始搜索\n\n  ```sh\n  find /etc -mindepth 3\n  ```\n\n6. -maxdepth n\n   - 表示最多搜索n-1级子目录\n\n  ```sh\n  find /etc -maxdepth 3 -name '*.conf'\n  find ./etc -type f -name '.*conf' -size +10k -maxdepth 2\n  find . -type f -nogroup\n  ```\n\n7. -perm\n   - find .perm 644\n  \n8. -prune \n    - 通常和-path一起用，用于将特定目录排除在搜索条件之外\n\n  ```sh\n  # 查找当前目录下所有普通文件，排除test目录\n  find . -path ./etc -prune -o -type f\n  # 查找当前目录下所有普通文件，但排除etc和opt目录\n  find . -path ./etc -prune -o -path ./opt -prune -o -type f\n  # 当前目录所有普通文件，排除etc和opt目录，但属主为hdfs\n  find . -path ./etc -prune -o -path ./opt -prune -o -type -f -a -user hdfs\n  # 当前目录所有普通文件，排除etc和opt目录，但属主为hdfs,文件大小大于\n  find . -path ./etc -prune -o -path ./opt -prune -o -type -f -a -user hdfs -a -size +2M\n  ```\n\n9. -newer file1\n```sh\nfind /etc -newer a\n```\n+ 操作\n  ```sh\n  # 搜索/etc下的文件非目录，以conf结尾，大于19k，然后删除\n  find ./etc -type -f -name '*.conf' -size +10k -exec rm -rf {} \\;\n\n  find /var/log/ -name '*.log' -mtime +7 -exec rm -rf {} \\;\n  find /etc -size +10k -type -f -name '*.conf' -exec cp {} /root/conf/ \\;\n  ```\n  - -print 打印输出\n  - -exec 对搜索的文件执行特定的操作\n  - -ok 和exec功能一样，但每次操作都会给用户提示\n  \n+ 逻辑运算符\n  - -a 与\n  - -o 或\n  - -not|! 非\n\n# find locate whereis和 which 总结及使用场景分析\n## locate\n1. 文件查找命令，所属软件包mlocate\n2. 不同于find命令是在整块磁盘中搜索，locate在数据库文件中查找\n3. find默认全部匹配，locate默认部分匹配\n\n- updatedb命令\n  1. 用于更新/var/lib/mlocate/mlocate.db\n  2. 所使用配置文件/etc/update.conf\n  3. 该命令在后台cron计划任务定期执行\n\n## whereis选项和含义\n- -b 只返回二进制文件\n- -m 只返回帮助文档文件\n- -s 只返回源码文件\n\n## which\n- 仅查找二进制程序文件\n- 选项\n  - -b 只返回二进制文件\n\n## 各命令使用场景推荐\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721094218.png)\n\n\n# grep和egrep\n## grep\n语法\n1. grep [option] [pattern] [file1,file2...]\n2. command | grep [option] [pattern]\n\ngrep参数\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721094721.png)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721094812.png)\n  - grep -E “python | PYTHON” file\n\n## egrep\negrep语法\n```sh\negrep(选项)(查找模式)(文件名1，文件名2，……)\n```\n# sed\nsed(Stream Editor)，流编辑器，对标准输出或文件逐行进行处理\n\n## 语法\n1. stdot | sed [option] \"pattern command\"\n2. sed [option] \"pattern command\" file\n\n## 选项\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721095810.png)\n\n```sh\n  sed ‘p’ sed.tet # p打印出来\n  sed -n‘p’ sed.tet\n  # 不加参数，原行也会再打印一次\n  sed ‘/python/p’sed.txt  #查找行\n  sed -n‘/python/p’sed.txt  #查找行\n  # 多个匹配条件\n  sed -n -e ‘/python/p’ -e ‘/PYTHON/p’ sed.txt\n  #文件中的\n  Vim edit.sed\n  /python/p\n  Sed -n -f edit.sed sed.txt\n  Sed -n -r‘/python|PYTHON/p’ sed.txt #使用扩展正则表达式\n  # 修改\n  sed -n ‘s/love/like/g’ sed.txt # love替换为like\n  sed -i‘s/love/like/g’ sed.txt #修改源文件\n```\n\n## sed 的 pattern 详解\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721100028.png)\n\n```sh\n  # 打印file的17行\n  sed -n \"17p\" file\n  # 打印10到20行\n  sed -n \"10,20p\" file\n  # 打印第10行开始，往后加5行的内容\n  sed -n \"10,+5p\" file\n  # 以root开头的行\n  sed -n \"/^root/p\" file\n  # 打印第一个匹配到ftp开头的行\n  sed -n \"/^root/,/^ftp/p\" file\n  # 打印第四行开始，到以hdgs开头的\n  sed -n \"4,/^hdfs/p\" file\n  # 匹配root的行，直到第10行结束\n  sed -n \"/root/,10p\" file\n```\n\n## sed 中的编辑命令\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721100852.png)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721100931.png)\n\n```\n  sed -i‘1d/ sed.txt # 删除第一行\n  sed -i ‘1,3d’sed.txt # 删除1-3行\n  sed -i ‘/\\/sbin\\/nologin/d’passwd # 把不可登录的账号删除\n  sed -i ‘/^mail,/^ftp/d’pssswd #mail到ftp\n  文本追加\n  sed -i ‘/\\/bin\\/bash/a This is user which can login to system’pssswd # 行后追加\n  sed -i ‘/^hdfs/,/&yarn/i AAAAAA’ pssswd # 行间追加\n  sed -i ‘/root/r list’ passwd #把list内容追加root行后面\n  sed -n‘/\\/bin\\/bash/w /tmp/user_login.txt’passwd #保存\n\n  sed -i ‘s/\\/bin\\/bash/\\/BIN\\/BASH/g’passwd # 小写的替换为大写\n  sed -i ‘a/root/ROOT/’passwd # 替换第一个root为大写\n  sed -i ‘a/root/ROOT/2’passwd # 替换前两个个root为大写\n  sed -i ‘s/hadoop/HADOOP/ig’str.txt #不区分大小写\n  sed -n ‘/\\/sbin\\/nologin/=’passwd # 查看行号,不显示内容\n\n  sed -i ‘s/had..p/hadoops/g’ sed.txt #.任意一个字符\n  sed -i ‘s/had..p/&s/g’ sed.txt #hadXXp后面加s，反向引用\n  sed -i ‘s\\/(had..ps\\)\\/1O/g’ sed.txt #后加O\n  sed -i ‘s/\\(had\\)...../\\1doop/g’sed.txt # had后面替换\n```\n\n## 反向引用\n- 是什么\n1. &和\\1 引用模式匹配到的整个串\n\n```sh\n# file中寻找1开头的后跟两任意字符以e结尾的字符\nsed \"s/1..e/&r/g\" file\nsed \"s/\\(1...e\\)/\\1r/g\" file # 使用\\1代表搜寻到的字符串\n```\n- 上面两种方法实现一样的功能，分别使用&和\\1代表搜寻到的整个字符串\n- 区别在于&只能表示匹配到的完整字符串，只能引用整个字符串，而\\1可以使用()对匹配到的\n- 要替换匹配的字符串的一部分，name必须使用\\1，不能使用&\n\n## sed 引用变量\n- 注意\n1. 匹配模式中存在变量，则建议使用双引号\n2. sed中需要引入自定义变量时，如外面使用单引号，则自定义变量必须使用单引号\n\n## 用 sed 查询特定内容\n查询命令\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721102519.png)\n\n实例\n```sh\n# 打印/etc/passwd中的第20行内容\nsed -n \"20p\" /etc/passwd\n\nsed -n \"8,15p\" /etc/passwd\nsed -n \"8,+5p\" /etc/passwd\nsed -n '/^hdfs/p' /etc/passwd\nsed -n '^root/,/^hdfs/p' /etc/passwd\nsed -n '8,/\\sbin\\/nologin/p' /etc/passwd\nsed -n '\\bin\\/bash/,5p' /etc/passwd\n```\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721103230.png)\n\n```sh\n  #!/bin/bash\n  FILE_NAME=/root/my.cnf\n\n  function get_all_segments\n  {\n      echo \"`sed -n '/\\[.*\\]/p' $FILE_NAME | sed -e 's/\\[//g' -e 's/\\]//g'`\"\n  }\n\n  function count_items_in_segment\n  {\n      items=`sed -n '/\\['$1'\\]/,/\\[.*\\]/p' $FILE_NAME | grep -v \"^#\" | grep -v ^$ | grep -v \"\\[.*\\]\"`\n      index=0\n      for item in $items\n      do\n          index=`expr $index +1`\n      done\n      echo $index\n  }\n\n  number=0\n  for segment in `get_all_segments`\n  do\n      num=`expr $number + 1`\n      items_count=`coubt_items_in_segment $segment`\n      echo \"$number: $segment $items_count\"\n  done\n```\n\n## sed 删除特定内容\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721103352.png)\n\n```sh\nsed -i '15d' passwd\nsed -i '8,14d' passwd\nsed -i '/\\sbin\\/nologin/d' passwd\nsed -i '/^mail/,/^yarn/d' passwd\nsed -i '/\\sbin\\/nologin/,13d' passwd\nsed -i '5,/^ftp/d' passwd\n# yarn开头到最后\nsed -i '/^yarn/,$' /etc/passwd\n```\n\n- 1. 删除配置文件中所有的注释行和空行\n- 2. 在配置文件中所有不以#开头的行前面加×符合，主要以#开头的行不添加\n\n```sh\nsed -i ‘/^#/d;/^$/d’ nginx.conf #删除注释\nsed -i ‘/[:blank:]*#/d’ nginx.conf #删除空行\nsed -i ‘/^[^#]/\\*&/g’nginx.conf  #非井号开头\n```\n\n## sed 修改文件内容\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721104309.png)\n\n实例\n```sh\n  #修改第一行的root为ROOT\n  sed -i '1s/root/ROOT/' passwd\n  #修改5到10行中所有的/sbin/nologin为/bin/bash\n  sed -i '5,10s/\\/sbin\\/nologin/\\bin\\/bash/g' passed\n  #修改匹配到/sbin/nologin的行，将匹配到行中的login改为LOGIN\n  sed -i '/\\sbin\\/nologin/s/login/LOGIN/g' passwd\n  #修改以root开头的行，到15行中的所有行，修改行中的nologin为SPARK\n  sed -i '/^root/,15s/nologin/SPARK/g' passwd\n  #从15行开始到匹配以yarn开头的所有行，修改行中的bin为BIN\n  sed -i '15,/^yarn/s/bin/BIN/g' passwd\n  \n  sed -i 's/[0-9]*//g' file.txt\n```\n\n## sed 追加文本内容\n- 语法\n1. a\n```sh\n# 第十行后追加\"Add lind behind\"\nsed -i '10a Add lind behind' passwd\n# 第10到20行，每一行后面都追加\"Test line behind\"\nsed -i '10,20a Test line behind' passws\n# 匹配到/bin/bash的行后面追加\"insert line for /bin/bash behind\"\nsed -i '/\\bin\\/bash/a insert line for /bin/bash behind' passws\n```\n2. i\n```sh\n# 匹配yarn开头的行，在匹配航后面追加\"Add lind behind\"\nsed -i 'yarn/i Add lind behind' passwd\n# 每一行前面都追加“insert line before every line\"\nsed -i 'i insert line before every line' passwd\n```\n3. r\n```sh\n#将/etc/fstab文件的内容追加到passwd的第20行后面\nsed -i '20r /etc/fstab' passwd\n#将/etc/inittab文件内容追加到passwd文件匹配/bin/bash行后面\nsed -i '/\\bin\\/bash/r /etc/inittab' passwd\n#将/etc/vconsol.conf文件内容追加到passwd文件中特定行的后面，匹配以ftp开头的行后面\nsed -i /^ftp/,18r /etc.vconsole.conf’ pssswd\n```\n4. w\n```sh\n# 将passwd文件匹配到/bin/bash的行追加到/tmp/sed.txt文件中\nsed -i '/\\bin\\/bash/w /tmp/sed.txt' passwd\n# 将passwd文件从10行还是到匹配到hsfs开头的所有行内容追加到/tmp/sed-1.txt\nsed -i '10,/^hsfs/w /tmp/sed-1.txt' passwd\n```\n\n# awk\n## awk 的工作模式\n1. awk 为一个文本处理工具，通常用于处理数据并产生结果报告。\n2. 命名是由三个创始人姓氏首字母组成\n  \n## 语法\n```awk\nawk 'BEGIN{}pattern{commands}END{}' file_name\n\nstandard outpu | awk 'BEGIN{}pattern{commands}END{}' file_name\n```\n\n- 语法格式说明\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721124926.png)\n  \n## awk 内置变量\n内置变量对照表\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721125045.png)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721130039.png)\n\n```awk\nawk '{print $0}END{}' /etc/passwd\n# 指定分隔符，输出第一个(既所有用户名)\nawk 'BEGIN{FS=\":\"}{print $1}' /etc/passwd\n# 默认空格为分割符\nawk '{print $1' list.txt\n\n# NF每一个行字段个数（number Filed）\nawk '{print NF}' list.txt # 返回字段个数\n\n# NR(Number Row)\nawk '{print NR}' list.txt /etc/passwd # 返回行号\n\n# FNR(File Number Row)对每一个文件单独计数\nawk '{print FNR}' list.txt /etc/passwd\n\n# FS(File Separator)\nawk 'BEGIN{FS=\"|\"}{print $2}' list.txt #指定分割符|\n\n# RS(Row Separator) 行分隔符\nawk 'BEGIN{FS=\"|\";RS=\"--\"}{print $2}' list.txt\n\n# ORS(Output Row Separatot) 输出行分割符\nawk 'BEGIN{FS=\"|\";RS=\"--\"；ORS=\"&\"}{print $2}' list.txt\n\nawk 'BEGIN{FS=\"|\";RS=\"--\"；ORS=\"&\";OFS=\":\"}{print $2，$3}' list.txt\n\nawk '{print FILENAME}' list.txt #对每一行输出文件名\n\nawk '{print ARGC}' list.txt # 输出行参数个数\n\nawk 'BEGIN{FS=\":\"}{print $NF}' /etc/passwd # 输出行最大自的断\n```\n\n## awk 格式化输出\nprintf(默认不带分隔符) 语法\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721134349.png)\n\n修饰符\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721134554.png)\n\n实例\n```awk\n# 不加任何修饰输出 \nawk 'BEGIN{FS=\":\"}{printf $1}' /etc/passwd\n# 换行输出\nawk 'BEGIN{FS=\":\"}{printf \"%s\\n\",$1}' /etc/passwd\n\n# 输出两个变量\nawk 'BEGIN{FS=\":\"}{printf \"%s%s\\n\",$1,$7}' /etc/passwd\n\n# 第一个第二个变量长度20(默认右对齐)\nawk 'BEGIN{FS=\":\"}{printf \"%20s %20s\\n\",$1,$7}' /etc/passwd\n\n# 第一个第二个变量长度20(左对齐)\nawk 'BEGIN{FS=\":\"}{printf \"%-20s %-20s\\n\",$1,$7}' /etc/passwd\n```\n```awk\n# 以字符串格式打印/etc/passwd中的第七个字段，以\":\"为分隔符\nawk 'BEGIN{FS=\":\"}{printf \"%s\\n\",$7}' /etc/passwd\n# 以10进制格式打印/etc/passwd中的第3个字段，以\":\"为分隔符\nawk 'BEGIN{FS=\":\"} {printf \"%d\\n\",$3}' /etc/passwd #不指定位数默认左对齐（指定位数右对齐 %-d)\n  \n# 浮点数\nawk 'BEGIN{FS=\":\"} {printf \"%o.3f\\n\",$3}' /etc/passwd \n\n# 16进制\nawk 'BEGIN{FS=\":\"} {printf \"%x\\n\",$3}' /etc/passwd \n\n# 8进制\nawk 'BEGIN{FS=\":\"} {printf \"%o\\n\",$3}' /etc/passwd\n\n# 科学计数法\nawk 'BEGIN{FS=\":\"} {printf \"%e\\n\",$3}' /etc/passwd\n```\n\n## awk模式匹配的两种用法\n- 语法\n1. RegExp 含义：按正则表达式匹配\n2. 关系运算 含义：按关系运算匹配\n\n实例\n\n- RegExp\n\n```awk\n# 匹配/etc/passwd文件中含有root字符串的所有行\nawk 'BEGIN{FS=\":\"}/root/{print $0}' /etc/passwd\n\n#匹配/etc/passwd中yarn开头的所有行\nawk 'BEGIN{FS=\":\"}/^yarn/{print $0}' /etc/passwd\n```\n\n- (运算符)关系运算\n  - 关系运算符：<,><=,>=,==,!=,\\~(匹配正则表达式),!\\~\n\n  ```awk\n  # 以：为分隔符，匹配第3个字段小于50的所有行信息\n  awk 'BEGIN{FS=\":\"}$3<50{print $0}' /etc/pssswd\n\n  awk 'BEGIN{FS=\":\"}$7==\"/bin/bash\"{print $0}' /etc/pssswd\n\n  awk 'BEGIN{FS=\":\"}$7!=\"/bin/bash\"{print $0}' /etc/pssswd\n\n  # 第三个字符包含3个以上数字的所有行信息\n  awk 'BEGIN{FS=\":\"}$3~/[0-9]{3,}/{print $0}' /etc/passwd # {3,}重复3次\n\n  awk 'BEGIN{FS=\":\"}$0~/\\sbin\\/nologin/{print $0}' /etc/passwd \n  ```\n\n  - 布尔运算:||(或),&&(与),!(非)\n\n  ```awk\n  # 以：为分隔符，匹配文件中包含hdfs或者yarn的所有行信息\n  awk 'BEGIN{FS=\":\"}$1==\"hdfs\" || $1==\"yarn\" {print $0}' /etc/passwd\n\n  # 第三字段小于50且第四字段大于50的所有行信息\n  awk 'BEGIN{FS=\":\"}$3<50 && $4>50 {print $0}' /etc/passwd\n\n  awk 'BEGIN{FS=\":\"}$3<50 && $7~/\\bin\\/bash/ {print $0}' /etc/passwd\n  ```\n## awk 动作中的表达式用法\n算术运算符\n\n|运算符|含义|\n|:---|:---|\n|+|加|\n|-|减|\n|*|乘|\n|/|除|\n|%|模|\n|^或**|乘方|\n|++X|再返回X变量之前，X变量加1|\n|X++|再返回X变量之后，X变量加1|\n\n\n- 实例\n\n```awk\nawk 'BEGIN{var=20;var1=\"hello\";print var,var1}'\n  \nawk 'BEGIN{num1=20;num2+=num1;print num2,num2}'\n\nawk 'BEGIN{num1=20;num2+=num1;print num2+num2}'\n\nawk 'BEGIN{num1=20;num2=30;printf \"%0.2f\\n\",num1/num2}'\n\nawk 'BEGIN{x=2;y=x++;print x,y}'\n\nawk 'BEGIN{x=2;y=x--;print x,y}'\n```\n```awk\n# 计算文件中空白行数量\nawk '/^$/{sumx=0;sum++}END{print sum}' /etc/services\n  \n# 计算课程的平均分\nawk '{total=S2+$3+$5+$5;AVG=total/4;printf \"%-8s,%-5d%-5d%-5d%-8d%0.2f\\n\",$1,$2,$3,$4.$5,AVG}' stu.txt\n\nawk 'BEGIN{printf \"%-8s%-8s%-8s%-8s%-8s%s\\n\",\"姓名\",\"语文\",\"数学\",\"英语\",\"物理\",\"平均分\"}{total=$2+$3+$4+$5;AVG=total/4;printf \"%-8s%-8d%-8d%-8d%-8d%0.2f\\n\",$1,$2,$3,$4.$5,AVG}' stu.txt\n```\n\n## awk 动作中的条件及循环语句\n- 条件语句\n\n```awk\nif(条件表达式)\n  动作1\nelse if(条件表达式)\n  动作2\nelse\n  动作3\n```\n\n- 实例\n\n```awk\n# 以：为分隔符只打印第3个字段的数值在50-100范围内的行信息\nawk 'BEFIN{FS=\":\"}{if($3>50 && $3<100>) print $0}' /etc/passwd\nawk 'BEFIN{FS=\":\"}{if($3>50 || $3<100>) print $0}' /etc/passwd\n\n# 小于50的UID\nawk 'BEGIN{FS=\":\"}{if($3<50) printf \"%-10s%-5d\\n\",\"小于50的UID:\",$3}' /etc/passwd\n  \nawk 'BEGIN{FS=\":\"}{if($3<50) printf \"%-10s%-10s%-5d\\n\",\"小于50的UID:\",$1,$3}' /etc/passwd\n\nawk 'BEGIN{FS=\":\"}{if($3<50) printf \"%-10s%-10s%-5d\\n\",\"小于50的UID:\",$1,$3}' /etc/passwd\n```\n\n- vim scripts.awk\n\n```awk\nBEGIN{\n    FS=\":\"\n}\n{\n    f($3<50)\n  {\n    printf \"%-30s%-20s%-5d\\n\",\"小于50的UID\",$1,$3\n  }\n  else if($3>50 && $3<100)\n  {\n    printf \"%-30s%-20s%-5d\\n\",\"大于50且小于100的UID\",$1,$3\n  }\n  else\n  {\n    printf \"%-30s%-20s%-5d\\n\",\"大于100的UID\",$1,$3\n  }\n}\n```\n\n- 使用\n\n```awk\nawk -f scripts.awk /etc/passed\n```\n\n- 循环语句\n\n1. do while 循环\n\n```awk\ndo while\n  do \n      动作\n  while(条件表达式)\n```\n\n2. for 循环\n\n```awk\nfor (初始化计数器;测试计数器;计数器变更)\n  动作\n```\n\n实例\n- 1+2+...100的和\n\n1. while\n\n```awk\n  BEGIN{\n      while(i<=100)\n      {\n        sum+=1\n      }\n      print sum\n  }\n```\n  - awk -f while.wak\n\n- for\n\n```awk\n  BEGIN{\n    for(i0;i<=100;i++)\n    {\n      sum+=1\n    }\n    print sum\n  }\n```\n  - awk -f for.awk\n\n3. do while\n\n```awk\n  BEGIN{\n    do\n    {\n      sum+=1\n      i++\n    }while(i<=100)\n    print sum\n  }\n```\n  - awk -f do_while.awk\n  \n- 计算每个同学平均分，仅显示大于90\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721185930.png)\n\n```awk student.awk\n  BEGIN{\n    printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Chinese\",\"English\",\"Math\",\"Physical\",\"Average\"\n  }\n  {\n    total=$2+$3+$4+$5\n    avg=total/4\n    if(avg>90)\n    {\n      printf \"%-10s%-10d%-10d%-10d%-10d%-0.2f\\n\",$1,$2,$3,$4,$5,avg\n    }\n  }\n```\n\n- 计算平均分大于90的各科总分\n\n```awk student.awk\n  BEGIN{\n      printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Chinese\",\"English\",\"Math\",\"Physical\",\"Average\"\n  }\n  {\n    total=$2+$3+$4+$5\n    avg=total/4\n    if(avg>90)\n    {\n      printf \"%-10s%-10d%-10d%-10d%-10d%-0.2f\\n\",$1,$2,$3,$4,$5,avg\n      score_chinese+=$2\n      score_english+=$3\n      score_math+=$4\n      score_physical+=$5\n    }\n  }\n  END{\n    printf \"%-10s%-10d%-10d%-10d%-10d\\n\",\"\",score_chinese,score_english,score_math,score_physical\n  }\n```\n## awk 中的字符串函数\n字符串函数对照表\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721191406.png)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190721191743.png)\n\n例子\n1. 以:为分隔符，返回文件中每行中的字段长度\n\n```awk 1.awk\n  # NF 字段个数\n  BEGIN{\n    FS=\":\"\n  }\n  {\n    i=1\n    while(i<=NF)\n    { \n      if(i==NF)\n        printf \"%d\",length($i)\n      else\n        printf \"%d:\",length($i)\n      i++\n    }\n    print \"\"\n  } \n```\n\n2. 搜索字符串\"I have a dream\"中出现\"ea\"子串的位置\n\n```awk \n# 方法1\nawk 'BEGIN{str=\"I have a dream\";location=index(str,\"ea\");print location}'\n\n#方法2\nawk 'BEGIN{str=\"I have a dream\";location=match(str,\"ea\");print location}'\n```\n\n3. 将字符串\"Hadoop is a bigdata Framework\"全部转为小写\n\n```awk\nawk 'BEGIN{str=\"Hadoop is a bigdata Framework\";print tolower(str)}'\n```\n\n4. 上一题转为大写\n\n```awk\nawk 'BEGIN{str=\"Hadoop is a bigdata Framework\";print toupper(str)}'\n```\n\n5. 将字符串\"Hadoop Kafka Spark Storm”按空格为分隔符，分割每一部分保存到数组arr中\n\n```awk\nawk 'BEGIN{str=\"Hadoop Kafka Spark Storm\";split(str,arr,\" \");print arr[0]}'\n\n# 遍历(awk 下标从1开始)\nawk 'BEGIN{str=\"Hadoop Kafka Spark Storm\";split(str,arr,\" \");for(a in arr) print arr[a]}'\n```\n\n6. 搜索字符串\"Tranction 2345 start:select * from master\"第一个数字出现的位置\n\n```sh\nawk 'BEGIN{str=\"Tranction 2345 start:select * from master\";location=match(str,/[0-9]/);print location}'\n```\n  - 正则表达式要用 `//` 引起来\n\n7. 截图字符串”transaction start”的子串，条件从第4个字符开始，截取5为\n\n```sh\nawk 'BEGIN{str=\"transaction start\";print substr(str,4,5)}'\n```\n\n8. 替换\"Tranction 243 start，Event ID：9002\"中第一个匹配到的数字为$符号\n\n```sh\nawk 'BEGIN{str=\"Tranction 243 start，Event ID：9002\";count=sub(/[0-9]+/,\"$\",str);print count,str}'\n  \n# gsu所有\nawk 'BEGIN{str=\"Tranction 243 start，Event ID：9002\";count=gsub(/[0-9]+/,\"$\",str);print count,str}'\n```\n\n## awk中的常用选项\n|选项|解释|\n|:---|:---|\n|-v|参数传递|\n|-f|指定脚本文件|\n|-F|指定分隔符|\n|-V|查看awk的版本号|\n\n实例\n- -v 把外部变量引入\n\n```sh 终端中\nnum1=20\nvar=\"Hello World\"\nawk -v num2=\"$num1\" -v var1=\"$var\" 'BEGIN{print num2,var1}'\n```\n\n- -f 引入文件\n\n```sh\nawk -f student.awk /etc/passws\n```\n- -F\n\n```sh\nawk -F \":\" '{print $7}' /etc/passwd\nawk -F : '{print $7}' /etc/passwd\n# 等价于\nawk 'BEGIN{FS=\":\"}{print $7}' /etc/passwd\n```\n\n## Shell 数组的用法\n\n- array=(\"Mike\",\"Bell\",\"Hellen\")\n  - 下面的 `井` 为 `#`\n\n|解释|代码|\n|:--|:--|\n|打印元素| echo ${井array[2]}|\n|打印元素个数 |echo ${井array[@]} / echo ${井array[*]}|\n|打印元素长度 |echo ${井array[3]}| \n|给元素赋值  |array[3]=\"LI\"|\n|删除元素 |unset array[2];unset array|\n|分片访问 |echo ${井array[@]:1:3}|\n|元素内容替换 | \\${array[@]/e/E} #只替换第一个e;${array[@]//e/E}替换全部e|\n\n- 数组遍历 \n\n```sh\nfor a in array\ndo \n   echo $a\ndone\n```\n\n## awk 数组用法\n- awk中使用数组时，不仅可以使用数字作为数组下标，也可以使用字符串作为数组下标\n\n1. 统计主机上所有TCP连接状态，按照每个TCP状态分类\n\n```sh\nnetstat -an | grep tcp | awk '{arrary[$6]++}END{for(a in arrary) print a,arrary[a]}'\n```\n\n2. 计算横向数总和，计算纵向数据总和\n\n```sh 数据\nAllen 80 90 96 98\nMike  93 98 92 91\nZhang 78 76 87 92\nJerry 86 89 68 92\nHan   85 95 75 90\nLi    78 88 98 100\n```\n```sh stu.awk\n  BEGIN{\n    printf \"%-10s%-10s%-10s%-10s%-10s%-10s\\n\",\"Name\",\"Chinese\",\"Math\",\"English\",\"Physical\",\"Total\"\n  }\n  {\n    total=$2+$3+$4+$5\n    yuwen_sum+=$2\n    math_sum+=$3\n    english_sum+=$4\n    physical_sum+=$5\n    printf \"%-10s%-10d%-10d%-10d%-10d%-10d\\n\",$1,$2,$3,$4,$5,total\n  }\n  END{\n    printf \"%-10s%-10d%-10d%-10d%-10d\\n\",\"\",yuwen_sum,math_sum,english_sum,physical_sum\n  }\n```\n\n## awk 处理数据例子\n生成随机数据\n```sh\n  #!/bin/bash\n  function create_random()\n  {\n    min=$1\n    max=$(($2-$min+1))\n    num=$(date +%s%N)\n    echo $(($num%$max+$min))\n  }\n\n  INDEX=1\n\n  while true\n  do\n    for user in Allen Mike Jerry Tracy Hanmeimei Lilei\n    do\n      COUNT=$RANDOM\n      NUM1=`create_random 1 $COUNT`\n      NUM2=`expr $COUNT - $NUM1`\n      echo \"`date '+%y-%m-%d %H:%M:%S'` $INDEX Batches: user $user insert $COUNT records into databases:product table:datail,insert $NUM1 records successfully,failed $NUM2 records\" >> ./db.log.`date +%Y%m%d`\n      INDEX=`expr $INSEX + 1`\n    done\n  done\n```\n\n1. 统计每个用户分别插入多少record \n\n```sh tesst.awk\n  BEGIN{\n    printf \"%-10s%-10s\\n\",\"User\",\"Total Records\"\n  }\n  {\n    USER[$6]+=$8\n  }\n  END{\n    for(u in USER)\n      printf \"%-20s%-20d\\n\",u,USER[u]\n  }\n```\n\n2. 统计每个用户分别插入成功和失败各多少record\n\n```sh 2.awk\n  BEGIN{\n    printf \"%-10s%-20s%-20s\\n\",\"User,\"Success_Records\",\"Filed_records\"\n  }\n  {\n    SUCCESS[$6]+=$14\n    FAILED[$6]+=$17\n  }\n  END{\n    for(u in SUCCESS)\n      printf \"%-10s%-20d%-20d\\n\",u,SUCCESS[u],FAILED[u]\n  }\n```\n\n3. 将例子1,2结合，一起输出每个用户分别插入多少条数据，成功失败各多少条\n\n```sh 3.awk\n    BEGIN{\n      printf \"%-30s%-30s%-30s%-30s\\n\",\"Name\",\"total records\",\"success records\",\"failed records\"\n  }\n  {\n      TOTAL_RECORDS[$6]+=$8\n      SUCCESS[$6]+=$14\n      FAILED[$6]+=$17\n  }\n  END{\n      for(u in TOTAL_RECORDS)\n          printf \"%-30s%-30d%-30d%-30d\\n\",u,TOTAL_RECORDS[u],SUCCESS[u],FAILED[u]\n  }\n```\n\n4. 在例子3的基础上，加上结尾，统计全部插入记录数，成功记录数，失败记录数\n\n- 方法一\n\n```sh 3.awk\nBEGIN{\n    printf \"%-30s%-30s%-30s%-30s\\n\",\"Name\",\"total records\",\"success records\",\"failed records\"\n}\n{\n    TOTAL_RECORDS[$6]+=$8\n    SUCCESS[$6]+=$14\n    FAILED[$6]+=$17\n}\nEND{\n    for(u in TOTAL_RECORDS)\n    {\n        # 在统计出的结果数组中进行累加\n        records_sum+=TOTAL_RECORDS[u]\n        success_sum+=SUCCESS[u]\n        failed_sum+=FAILED[u]\n        printf \"%-30s%-30d%-30d%-30d\\n\",u,TOTAL_RECORDS[u],SUCCESS[u],FAILED[u]\n    }\n  \n    printf \"%-30s%-30d%-30d%-30d\\n\",\"\",records_sum,success_sum,failed_sum\n}\n```\n\n- 方法二\n\n```sh\n  BEGIN{\n      printf \"%-30s%-30s%-30s%-30s\\n\",\"Name\",\"total records\",\"success records\",\"failed records\"\n  }\n  \n  {\n      RECORDS[$6]+=$8\n      SUCCESS[$6]+=$14\n      FAILED[$6]+=$17\n      \n      # 在原始数据中进行汇总计算\n      records_sum+=$8\n      success_sum+=$14\n      failed_sum+=$17   \n  }\n  \n  END{\n      for(u in RECORDS)\n          printf \"%-30s%-30d%-30d%-30d\\n\",u,RECORDS[u],SUCCESS[u],FAILED[u]\n  \n      printf \"%-30s%-30d%-30d%-30d\\n\",\"total\",records_sum,success_sum,failed_sum\n  }\n```\n\n5. 查找丢失数据的现象，也就是成功+失败的记录数不等于一共插入的记录数，找出这些数据并显示行号和对应行的日志信息\n\n```sh\nawk '{if($8!=$14+$17) print NR,$0}' db.log.20190722\n```","tags":["Linux","Shell","Bash"],"categories":["Coding"]},{"title":"斐讯 N1 盒子降级刷机","path":"/posts/N1Box.html","content":"斐讯 N1 盒子降级刷机\n<!--more-->\n# 降级\n- 打开 ADB,点击官方固件的 `版本号` 4 次\n\n## 重启至 Bootloader\n- 先下载 [ADB](https://dl.google.com/android/repository/platform-tools-latest-windows.zip)\n- 连接设备并进入 fastboot\n```bash\ncd adb\nadb connect ip:5555\nadb shell reboot fastboot\n```\n\n## 刷入降级\n- 双公头 USB 数据线与电脑连接，务必连接至靠近 HDMI 接口的那个 USB 接口\n```bash\nfastboot devices #查看是否识别到设备\nfastboot flash boot boot.img\nfastboot flash bootloader bootloader.img\nfastboot flash recovery recovery.img\nfastboot reboot\n```\n\n# 刷入 [w大固件](https://www.right.com.cn/forum/thread-338759-1-1.html)\n\n- 先安装 [Usb Burning Tool](https://androidmtk.com/download-amlogic-usb-burning-tool)\n- 打开设备管理器 ==> `操作` ==>`添加过时硬件` ==> 下一步 ==> 选择 `安装我手动从列表选择的硬件` ==> 下一步 ==> 选择 `libusb-win32 Usb Devices` ==> 下一步 ==> 选择 `WorldCup Device` ==> 下一步 ==> 下一步 \n- 打开 Usb Burining Tool,去除勾选右边烧录配置的 `擦除flash` 和 `擦除bootloader`\n- [w大固件](https://www.right.com.cn/forum/thread-338759-1-1.html)","tags":["Linux","Android","TvBox"],"categories":["Diary"]},{"title":"Grub 双系统选项、美化","path":"/posts/Grub.html","content":"添加 Win10 菜单到 Grub\n<!--more-->\n# 安装 os-prober\n```bash\nsudo pacman -S os-prober \n```\n\n# 扫面并添加到菜单\n```bash\nsudo grub-mkconfig -o /boot/grub/grub.cfg\n```\n# 美化\n下载主题 [Gnome-Look](https://www.gnome-look.org/browse/cat/109/ord/latest/)\n\n## 配置\n有的主题有安装脚本，运行即可\n\n```bash\nsudo cp -r 主题包名 /boot/grub/themes/  \nsudo vim /etc/grub.d/00_header\n```\n```bash 上一步添加如下内容\nGRUB_THEME=\"/boot/grub/themes/主题包名/theme.txt\"\nGRUB_GFXMODE=\"1920x1080x32\"\n```\n\n## 更新配置\n```bash\nsudo grub-mkconfig -o /boot/grub/grub.cfg\n```\n\n# 效果\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/Grub.png)","tags":["Linux","Windows"],"categories":["Diary"]},{"title":"Git 更换设备后怎么做","path":"/posts/Git-Change.html","content":"Git 更换设备后怎么做\n<!--more-->\n# 旧仓库\n```bash\ngit init 仓库名字\n# 建立远程连接\ngit remote add origin https://github.com/user/repo.git    \n#获取远程更新\ngit fetch origin  \n# 把更新的内容合并到本地分支\ngit merge origin/master \n# 加入差异的文件,就是本地修改的文件\ngit add . \ngit commit -m \"Commit message\" \ngit push origin master\n```\n\n# 新仓库\n```bash\ngit init()\ngit remote add origin https://github.com/user/repo.git\ngit add .\ngit commit -m \"Commit message\"\npush origin master\n```\n\n# 建议\n- 拉取时推荐\n\n```bash\ngit fetch origin master\ngit merge origin/master\n```\n- 不推荐\n\n```bash\ngit pull\n```","tags":["Linux","Git"],"categories":["Diary"]},{"title":"ArchLinux Docker","path":"/posts/Docker.html","content":"ArchLinux 安装 Docker\n<!--more-->\n# 安装\n```bash\nsudo pacman -S docker\n```\n\nstart server\n```bash\nsystemctl restart docker \n```\n\n# 镜像\n```bash\ndocker pull ubuntu:18.04\ndocker pull centos # latest\ndicker pull centos:6\n```\n\n# 运行\n```bash\nsudo docker run -i -t centos /bin/bash\n```\n- -it, -i：交互式操作， -t 终端","tags":["Linux","Docker"],"categories":["Coding"]},{"title":"Vim 集锦","path":"/posts/Vim-Mooc.html","content":"Vim 重新学习笔记\n<!--more-->\n# 三个模式\n## Insert 编辑模式\n```bash\na i o # 进入编辑模式\nESc # 进入 normal 模式\n```\n\n- i (insert)\n- a (append)\n- o (oppen a line below)\n\n## Command 模式\n```bash\n:wq # 保存退出\n:vs # vertical split 横向分频\n:sp # 纵向分频\n:% s/foo/bar/g # 全局替换\n:h option-list # 查找所有设置选项\n```\n\n## Visual (可视)模式\n```bash\nv # 进入 visual 模式\nV # 选择行\nctrl v # 进行快选择\n```\n\n# 如何快速纠错\na/i/o 进入插入模式\n\n```bash\nctrl h # 删除上一个字符\nctrl w # 删除上一个单词\nctrl u # 删除当前行\n```\n\n快速切换 Insert 和 Normal\n\n```bash\nctrl c / ctrl [ # 代替 Esc\ngi # 快速跳转到你最后一次编辑的地方并进入插入模式\n```\n\n使用 hjkl 移动\n\n```bash \nh # 左\nj # 下\nk # 上\nl # 右\n```\n\n# 在单词之间飞舞\n```bash \nw/W # 移到下一 word/WORD 开头\ne/E # 下一个 word/WORD 尾\nb/B # 回到上一个word/WORD 开头\n```\n- word 指以非空白符分割的单词\n- WORD 以空白符分割的单词\n\n行间搜索移动\n\n```bash\nf{char} # 移到 char 字符上\nt # 移到 char 前一个字符\nF # 反过来搜索前面的字符\n```\n- ; 该行下一个\n- , 该行上一个\n\n水平移动\n\n```bash\n0 # 移到行首第一个字符\n^ # 第一个非空白字符\n$ # 移到行尾\ng_ # 移到行尾非空白字符\n```\n\n垂直移到\n\n```bash\n() # 在句子间移动\n{} # 在段落间移到\n```\n- 插件 easy-motion\n\n页面移动\n\n```bash\ngg、G # 文件开头/结尾\nctrl o # 快速返回\n\nH/M/L # 跳到屏幕开头(Head)中间(Middle)结尾(Lower)\nctrl u # 上翻页\nctrl f # 下翻页\nzz # 把屏幕置为中间\n```\n# 增删查改\n增\n\n```bash\na/i/o\nA/I/O\n```\n\n快速删除\n\n```bash normal 模式下\nx # 快速删一个字符\nd # 删除\ndaw # 删除一个单词\n```\n- d x 可以搭配数字执行多次\n\n快速修改\n\n```bash\nr(replace) c(change) s(substitute) # 常用\n```\n- normal 下 r 可以替换一个字符，s 替换并进入插入模式\n- 使用 c 配合文本对象可以快速进行修改\n\n查询\n\n```bash\n/ # 前向搜索\n? # 反向搜索\n```\n- n/N 跳转上一个或者上一个匹配\n- * 或者 # 进行当前单词的前向和后向匹配\n\n# 替换命令\nsubstitute\n\n```bash\n:[range]s[ubsitite]/{pattern}/{string}/[flags]\n```\n- range 范围(:10,20),10-20行,% 全部\n- pattern 要替换的模式\n- string 是替换后的文本\n\n## 替换标志位\nFlags 常用标志\n\n```bash\ng(global) # 全局\nc(confirm) # 表示确认，可以确认或拒绝修改\nn(number) # 报告匹配到的次数而不替换，可以用来匹配次数\n```\n- :1,6 s/self// 查询1-6行有几个 self\n- :% s/\\<quack\\>/jiao/g 替换所有 quack 为 jiao\n\n# Buffer Windows Tab\n文件操作相关\n\n1. Buffer 是打开的一个文件的内存缓冲区\n2. 窗口是 Buffer 可视化的分割区域\n3. Tab 可以组织窗口为一个工作区\n\n## 在 Buffer 之间切换\n1. 使用 :ls 列举当前缓冲区，后 :b n跳转到第 n 个\n2. :bpre :bnext :bfirst :blast\n3. 或者 :b buffer_name 加上 tab 补全来跳转\n\n## Windows 窗口\n1. <ctrl w>s 水平分割\n2. <ctrl w>v 垂直分割\n3. 或者 :sp :vs\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/window.png)\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/tab.png)\n\n# 宏(macro)\n可以看做一系列命令合集\n\n## How\n1. q 录制、技术录制\n2. q{register} 选择要保存的寄存器，把录制的命令保存其中\n3. @{register} 回放寄存器中的一系列命令\n\n```bash\nq I\" A\"\n\nVG # 全选\n: I\"\n:t # 重复上一命令\n:A\"\n```\n\n# 常见的补全\n|命令|补全类型|\n|:---|:---|\n|ctrl n |普通关键字|\n|ctrl x/n|当前缓冲区关键字|\n|ctrl x/i|包含文件关键字|\n|ctrl x/J|标签文件关键字|\n|ctrl x/k|字典查找|\n|ctrl x/l|整行补全|\n|ctrl x/f|文件名补全|\n|ctrl x/o|全能(Omni)补全|\n\n  ---\n\n## 最常用\n1. ctrl n 和 ctrl p 补全单词\n2. ctrl x 和 ctrl f 补全文件名\n3. ctrl x 和 ctrl o 补全代码 \n\n# 更换配色\n```bash\n:colorscheme # 显示当前主题配色\n:colorscheme <ctrl+d> # 显示所有配色\n:colorscheme 配色名 # 修改配色\n```\n\n# 映射\n## 基本映射\n- normal 模式下(leadser键即 `,` )\n1. map 可以实现映射，`:map -x` 然后按下 - 就会删除一个字符\n2. `:map <space> viw` 按下空格键时选中整个单词\n3. `:map <c-d> dd` 删除\n  - 消除映射 `unmap -`\n  - `imap <c-d> <Esc>ddi` insert 模式映射 ctrl+d 删除一行\n    \n- 模式映射映射\n\n1. 用 namap/vmap/imap 定义映射只在normal/visual/insert分别有效\n  - `:vmap \\U` 把 visusal 模式下选中的文本大小(u/U转换大小写)\n\n## 递归与非递归映射\n*map 系列有递归风险,如果安装了一个插件，插件映射了同一个按键的不同行为，有冲突就会有一个失效。\n\n非递归映射\n1. *map 对应的 nnoremap/vnoremao/inoremap\n2. 任何时候都建议使用非递归映射\n\n示例\n\n```vim\nlet mapleader = \",\"\ninoremap <leader>w <Esc>:w<cr> # 插入模式保存\ninoremap jj <Esc> # 使用jj直接进入 normal\n# 使用 leader+w 直接保存\ninoremap <leader>w <Esc>:w<cr>\nnoremap <leader>w :w<cr>\n\n# 切换 Buffer\nnnoremap <slient> [b :bprevious<CR>\nnnoremap <slient> [n :bnext<CR>\n\n# 分屏\nnoremap <C-h> <C-w>h\nnoremap <C-j> <C-w>j\nnoremap <C-k> <C-w>k\nnoremap <C-l> <C-w>l\n\n# json 格式化\ncomr FormatJSON %!python3 -m json.tool\n\n# sudo to write\ncnoremap w!! w !sudo tee % >/dev/null\n```\n\n# 插件\n## 常见的插件管理器\nvim-plug,Vundle,Pathogen,Deim \n\n## [vim-plug](https://github.com/junegunn/vim-plug)\n- 安装 vim-plug\n\n```bash\ncurl -fLo ~/.vim/autoload/plug.vim --create-dirs \\\nhttps://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\n```\n\n## 安装插件\n```bash .vimrc\ncall plug#begin('~/.vim/plugged')\nPlug 'mhinz/vim-startify' # 插件\n\" Initialize plugin system\ncall plug#end()\n```\n- `source ~/.vimrc` 并 `:PlugInstall`\n\n## vim 美观插件\n- 外观\n\n1. 修改启动界面: [vim-startify](https://github.com/mhinz/vim-startify)\n2. 状态栏美化：[vim-airline](https://github.com/vim-airline)\n3. 增加但代码缩进线条：[indentline](https://github.com/yggdroot/indentline)\n\n- 配色方案\n\n1. [vim-hybird](https://github.com/w0ng/vim-hybird)\n2. [solarized](https://github.com/altercation/vim-colors-solarized)\n3. [grubbox](https://github.com/morhetz/gruvbox)\n\n## 插件推荐网站\n[vimawesome](https://vimawesome.com)\n\n## 文件目录和搜索插件\n\n- 文件目录 [nerdtree](https://github.com/scrooloose/nerdtree)\n\n```vim\n\" 查找文件所在位置\nnnoremap <leader>v :NERDTreeFind<cr>\n\" 切换设置\nnnoremap <leader>g :NERDTreeToggle<cr>\n```\n\n- 模糊搜索器 [ctrip.vim](https://github.com/ctrlpvim/ctrlp.vim)\n\n```vimrc\nlet g:ctrlp_map = '<c-p>'\nlet g:ctrlp_cmd = 'CtrlP'\n```\n  - Crtl + P 后输入要搜索的内容\n\n- 模糊搜索[fzf.vim](https://github.com/junegunn/fzf.vim)\n\n```bash \nFiles . # 搜索当前目录\n:Ag content # 搜索字符串\n```\n\n- 快速跳转位置插件 [vim-easymotion](https://github.com/easymotion/vim-easymotion)\n\n映射\n\n```bash\nunmap ss <Plus>(easymotion-s2)\n```\n\n- 修改成对内容 [vim-surround](https://github.com/tpope/vim-surround)\n\n```bash\nds # delete a surrounding\ncs # change a surrounding\nys # you add a surrounding\n```\n\n- 替换　[far.vim](https://github.com/brooth/far.vim)\n\n```bash\nvim duck.go gua.py\n:Far [替换] [替换成的] **/*.py\n```\n\n## 代码\n### 浏览代码\n[targbar](https://github.com/majutsushi/tagbar)\n\n```bash vimrc\nnonormal <leader>t :TagbarToggle<CR>\n```\n[vim-interestingwords](https://github.com/lfv89/vim-interestingwords) 可以高亮单词\n\n### 补全\n补全插件\n\n1. [deoplete.nvim](https://github.com/shougo/deoplete.nvim) 多语言，模糊搜索\n2. [coc.vim](https://github.com/neoclide/coc.nvim) 多语言插件支持\n\n快速注释\n\n[vim-commentary](https://github.com/tpope/vim-commentary) `gc` 注释或取消注释\n\n## 格式化与静态检查\n格式化\n\n[Neoformat](https://github.com/sbdchd/neoformat) 需要安装对应语言的格式化库，python的autopep8,js的prettier等\n\n静态检查Lint\n\nneomake、[ale](https://github.com/w0rp/ale) 需要安装对应语言的 lint 库如 eslint/pylint/golint\n\n## Python 相关\n[Python-mode](https://github.com/python-mode/python-mode) 具有基本的补全，跳转，重构，格式化功能\n```bash .vimer\n\" Python-mode\nlet g:pymode_python =  'python3'\nlet g:pymode_trim_whitespaces = 1\nlet g:pymode_doc = 1\nlet g:pymode_doc_bind = 'k'\nlet g:pymode_rope_goto_definition_bind = \"<C-J>\"\nlet g:pymode_lint = `\nlet g:pymode_lint_checkers = ['pyflakers','pep8','mccabe','plylint']\nlet g:pymode_options_max_line_length = 120\n```\n\n## Git\n[Fugitive](https://github.com/tppope/vim-fugitive)\n\n- 命令 `:Gedit`,`:Gdiff`,`:Gblame`,`:Gcommit` 等\n\n[vim-gitgutter](https://github.com/airblade/vim-gitgutter) 显示文件变动\n\n[gv.vim](https://github.com/junegunn/gv.vim) `:GV` 查看提交记录\n\n---\n**学习视频**\n- [玩转Vim 从放弃到爱不释手](https://www.imooc.com/learn/1129)","tags":["Linux","Windows","Vim"],"categories":["Coding"]},{"title":"Cat 追加与覆盖","path":"/posts/CatEOF.html","content":"Cat  追加与覆盖\n<!--more-->\n# 追加\n- cat <<EOF>>\n\n```bash\n#!/bin/bash\ncat << EOF >> cat.txt\nvitan.me\nEOF\n```\n\n- cat >>\n\n```bash\n#!/bin/bash\ncat >> cat.txt << EOF\nvitan.me\nEOF\n```\n\n# 覆盖\n- cat <<EOF>>\n\n```bash\n#!/bin/bash\ncat << EOF > cat.txt\nvitan.me\nEOF\n```\n\n- cat >>\n\n```bash\n#!/bin/bash\ncat > cat.txt << EOF\nvitan.me\nEOF\n```\n\n# 使用变量\n- Warnning\n追加和覆盖若要使用变量必须加 `\\` 如 **`\\$var`**","tags":["Linux","Shell"],"categories":["Linux"]},{"title":"Terminal Socks5 Proxy","path":"/posts/CurlSocks5.html","content":"Some Socks5 Proxy setting\n<!--more-->\n# Git\n```bash\ngit config --global http.proxy socks5://127.0.0.1:1080\ngit config --global https.proxy socks5://127.0.0.1:1080\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n# Curl\n```bash .curlrc\necho 'socks5 = \"127.0.0.1:1080\"' >> ~/.curlrc\n```\n\n- ALL_PROXY\n\n```bash\nexport ALL_PROXY=socks5://127.0.0.1:1080\n```\n\n# Wget\n```bash EVN Config\nxport http_proxy=http://127.0.0.1:1080\nxport http_proxy=httpS://127.0.0.1:1080\n```\n\n## .wgetrc\n```bash ~/.wgetrc\nhttps_proxy = http://127.0.0.1:8087/\nhttp_proxy = http://127.0.0.1:8087/\nftp_proxy = http://127.0.0.1:8087/\n\n# If you do not want to use proxy at all, set this to off.\nuse_proxy = on\n```\n-e\n\n```bash\nwget -c -r -np -k -L -p -e \"http_proxy=http://127.0.0.1:1080\" url\n```\n\n# Pip\n```bash\nsudo pacman -S proxychains\n```\n- vim /etc/proxychains.conf\n\n```bash /etc/proxychains.conf\n[ProxyList]\nsocks5  127.0.0.1 1080\n```\n\n- usage\n\n```bash\nproxychains pip install <package_name>\n```\n\n---\n**参考**\n- [为wget使用代理](https://my.oschina.net/u/2306127/blog/791258)","tags":["Linux"],"categories":["Linux"]},{"title":"CentOS DNS","path":"/posts/Linux-DNS.html","content":"CentOS DNS \n<!--more-->\n# Bind\nInstall\n\n```bash\nyum install bind bind bind-chroot -y\n```\n\nStart Service\n\n```bash\nservice named start\nsystemctl name start # CentOs 7\nsystemctl enable named-chroot\n```\n\n# Bind 配置\n```bash named.conf\nvim /var/named/chroot/etc/named.conf\n```\n```bash /var/named/chroot/etc/named.conf\noptions {\n        listen-on port 53 { any; };# 监听任何ip对53端口的请求\n        listen-on-v6 port 53 { ::1; };\n        directory       \"/var/named\";\n        dump-file       \"/var/named/data/cache_dump.db\";\n        statistics-file \"/var/named/data/named_stats.txt\";\n        memstatistics-file \"/var/named/data/named_mem_stats.txt\";\n        allow-query     { any; }; # 接收任何来源查询dns记录\n        recursion yes;\n\n        dnssec-enable yes;\n        dnssec-validation yes;\n\n        /* Path to ISC DLV key */\n        bindkeys-file \"/etc/named.iscdlv.key\";\n\n         managed-keys-directory \"/var/named/dynamic\";\n};\n\n//以下用于限定 bind 服务器的日志参数\nlogging {\n        channel default_debug {\n                file \"data/named.run\";\n                severity dynamic;\n        };\n};\n\n//用于指定根服务器的配置信息，一般不能改动\nzone \".\" IN {\n        type hint;\n        file \"named.ca\";\n};\n\ninclude \"/etc/named.zones\"; //指定住配置文件，按实际改动\ninclude \"/etc/named.root.key\";\n```\n\n## 配置主配置文件\n```bash\ncd /var/named/chroot/etc/\ncp -p named.rfc1912.zones named.zones\nvim named.zones\n```\n```bash /var/named/chroot/etc/named.zones\nzone \"vitan.me\" IN {\n        type master;\n        file \"vitan.me.zone\";\n        allow-update { none; };\n};\n\nzone \"197.28.149.in-addr.arpa\" IN {\n        type master;\n        file \"149.28.197.zone\";\n        allow-update { none; };\n};\n```\n\n## 区域配置文件\n- 正向解析域\n\n```bash\ncd /var/named/chroot/var/named\ncp -p named.localhost vitan.me.zone\nvim vitan.me.zone\n```\n```bash /var/named/chroot/var/named/vitan.me.zone\n$TTL 1D\n@       IN SOA  www.vitan.me. mail.vitan.me. (\n                2007101100      ; serial\n                1D      ; refresh # 主从刷新时间\n                1H      ; retry # 主从通讯失败后重试间隔\n                1W      ; expire # 缓存过期时间\n                3H )    ; minimum # 没有TTL定义时的最小生存周期\n\n@       IN      NS              www.vitan.me.\n@       IN      MX      10      www.vitan.me.\nwww     IN      A               149.28.197.1\nmail    IN      A               149.28.197.1\nwww1    IN      CNAME           www.vitan.me.\n```\n\n- 反向向解析域\n\n```bash\ncd /var/named/chroot/var/named\ncp -p named.loopback 149.28.197.zone\nvim /var/named/chroot/var/named/149.28.197zone\n```\n```bash /var/named/chroot/var/named/149.28.197.zone\n$TTL 1D\n@       IN SOA  www.vitan.me. mail.vitan.me. (\n                2007101100      ; serial\n                1D      ; refresh # 主从刷新时间\n                1H      ; retry # 主从通讯失败后重试间隔\n                1W      ; expire # 缓存过期时间\n                3H )    ; minimum # 没有TTL定义时的最小生存周期\n\n@       IN      NS              www.vitan.me.\n@       IN      MX      10      www.vitan.me.\nwww     IN      A               149.28.197.1\nmail    IN      A               149.28.197.1\nwww1    IN      CNAME           www.vitan.me.\n```\n\n# 重启 DNS 服务\n```bash\nservice named restart/reload\nsystemctl named restart # CentOs 7\n```\n\n# 客户端配置与测试\n\n- 以便能使用 nslookup dig 和 host\n\n```bash\nyum install bind-utils -y\n```\n\n```bash /etc/resolv.conf\nvim /etc/resolv.conf\n```\n```bash /etc/resolv.conf\nsearch vitan.me\nnameserver 149.28.197.1\n```\n\n# Test\n```bash\ndig www.vitan.me\nnslookup www.vitan.me\n```","tags":["Linux"],"categories":["Linux"]},{"title":"CentOS  DHCP","path":"/posts/Linux-DHCP.html","content":"CentOS DHCP\n<!--more-->\n# 安装\n```bash\nyum update\nyum install dhcp -y\n```\n\n# 修改 ip\n```bash\nvim /etc/sysconfig/network-scripts/ifcfg-eth2\n```\n```bash\nDEVICE=\"eth2\"\nBOOTPROTO=static\nHWADDR=\"00:0D:29:G1:2D:3B\"\nNM_CONTROLLED=\"yes\"\nONBOOT=\"yes\"\nBOOTPROTO=\"none\"\nIPADDR=192.168.22.11\nNETMASK=255.255.255.0\nGATEWAY=192.168.22.1 \n```\n\n- 重启网络\n\n```bash\nservice network restart\nsystemctl network restart\n```\n\n# 服务端配置\n\n- 路径 \n\n```bash dhcpd.conf\n/etc/dhcp/dhcpd.conf\n```\n\n- 复制 dhcpd.conf.samplle\n\n```bash\ncp -p /usr/share/doc/dhcp-6.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf\n```\n\n- 配置文件设置\n\n``` bash /etc/dhcp/dhcpd.conf\nddns-update-style interim;// dhcp 服务器和dns 服务器的动态信息更新模式     \nignore client-updates;       \ndefault-lease-time           259200; #预设租约为 3 天\nmax-lease-time               518400; # 最大租约为 6 天\n\nsubnet 192.168.22.0 netmask 255.255.255.0 {\n      option routers                  192.168.22.254;#预设路由\n      option subnet-mask              255.255.255.0;\n      option domain-search            \"vitan.me\"; # 给予一个领域名\n      option domain-name-servers      192.168.22.1;\n      option time-offset              -18000; #时区\n      range   192.168.1.10   192.168.1.100;\n\n      # 关于固定的 IP \n      host win7 {\n        hardware ethernet    08:00:27:11:EB:C2; #客户端网卡 MAC\n        fixed-address        192.168.100.30;    #给予固定的 IP\n    }\n}\n\n```\n\n- 启动\n\n```bash\nservice dhcpd start\nsystemctl start dhcp #CentOs 7\ndhcpd # 检测错误\nchkconfig --levels 235 dhcpd on # 开机启动\n```\n\n# 客户端配置\n```bash ifcfg.eth2\n  vim /etc/sysconfig/network-scripts/ifcfg-eth2\n```\n```bash \n  DEVICE=\"eth2\"\n  BOOTPROTO=dhcp\n  HWADDR=\"00:0D:29:G1:2D:3B\"\n  NM_CONTROLLED=\"yes\"\n  ONBOOT=\"yes\"\n  BOOTPROTO=\"none\"\n  IPADDR=192.168.22.100\n  NETMASK=255.255.255.0\n  GATEWAY=192.168.22.1 \n```\n\n- 重启网络\n\n```bash\nifdown eth2\nifup eth2\n\nservice network restart\n```\n\n# 查看租约情况\n```bash\ncat /var/pib/dhcpd/dhcpd.leases\n```","tags":["Linux"],"categories":["Linux"]},{"title":"Vim 增删查改、翻页和寄存器","path":"/posts/vimcopyppaste.html","content":"> Vim 增删查改、复制捏贴、翻页和寄存器。\n> Vim 里剪切 (cut) 复制(copy) 粘贴(psate) 分别对应 delete/yank/put\n<!--more-->\n\n# 复制粘贴\n## Normal 模式下\n\n- yp dp vp\n\n```sh\ny # 复制(yank)\np # 粘贴(put)\nd # 剪贴\nvp # v(visual) 命令选中要复制的地方，后 p\n```\n\n- 配合文本对象\n\n```sh\nyyiw # 复制一个单词\nyy   # 复制一行\ndd   # 删除一行\no    # 下一行\nV    # 快选两行\nv    #　选择文本\n```\n\n## Insert 模式下\n\n- 保留复制内容的缩进\n\n1. vimrc 设置了自动缩进 `:set autoindent` 会使复制的代码缩进错乱\n\n```vim\n:set paste \n:set nopaste # 取消\n```\n\n# 增删查改翻页移动\n## 增删查改\n增（大写相反）\n```bash\na# append 当前字母后面插入\ni # insert 当前字母前面插入\no # open a line 向下打开新一行\n```\n\n删\n```bash\nd  # 删除\ndw # 删除单词\ndiw # delete inner word 删除不包含空格的一个单词\ndaw # delete around word\ndd # 删除一行\nx # 删除一个字符\n```\n\n改\n```bash \nc\nciw # Change inner word\nct  # 括号里面的内容（修改到右边括号）\nci” # 删除双引号里的内容\n```\n\n查\n```bash\nfs # 查找当前行第一个出现的 s ，使用 ； 查找下一个\nFs # 往回查\n/word # 查找所以单词 word\n?word #往回查\n```\n# 移动翻页\n移动\n```bash\nhjkl # 上下左右\nw # word 移动单词\nb #back word 往回移动单词\n:18 # 移动到18行\n18G # 移动到14行\n0 # 回到开头\n$ # 行尾\ngg # 文件开头\nG # 文件结尾\nCtrl o # 返回刚刚的位置\n```\n\n翻页\n```bash\nctrl + f # forward\nctrl + u # upward\n```\n\n# Vim 寄存器\n使用 d 删除或者 y 复制的内容都放在了 \"无名寄存器\"\n\n- 调换两字符\n\n```vim\nx  # 删除一个字符放到无名寄存器\np  # 粘贴\n```\n\n## 寄存器(register)\n`\"{register}` 可以指定寄存器，不指定默认使用无名寄存器，`\"\"` 表示\n\n## 无名寄存器\n```vim\n\"ayiw # 复制一个单词到寄存器 a \n\"bdd  # 删除当前行到寄存器 b\n\n\"a p  # 粘贴寄存器 a 的内容\n\"b p  # 粘贴寄存器 b 的内容\n```\n\n## 其他寄存器\n- ”a-z 有名寄存器\n  - \"0 复制专业寄存器（y复制的文本会拷到复制及长期0）\n  - \"+ 系统剪切板 （可以再复制前加上 \"+ 复制到系统剪切板）\n    - `:set cliboard=unnamed` 可直接复制系统剪切板内容\n  - ”% 当前文件名\n  - \". 上次插入的文本\n\n\n## 查看寄存器内容\n```vim\n:reg a # 查看 a 寄存器内容\n:reg b # 查看 b 寄存器内容\n```\n\n## 查看是否支持 clipboard\n```vim\n:echo has('clipboard')\n```\n- 1 为支持","tags":["Linux","Vim"],"categories":["Coding"]},{"title":"Git Clone Error","path":"/posts/GitSOCKS4.html","content":"> Failed to receive SOCKS4 connect request ack.\n<!--more-->\n# 解决方法\n```git\ngit config --global http.proxy 'socks5://127.0.0.1:1080' \ngit config --global https.proxy 'socks5://127.0.0.1:1080' \n```\n\n> error: RPC failed; curl 18 transfer closed with outstanding read data remaining\n\n# 解决方法\n\n- 1. --depth 1\n\n```shell\n# 关闭压缩\ngit config --global core.compression 0\n# 部分克隆\ngit clone --depth 1 http://github.com/large-repository \ncd large-repository\n# 进入新目录并检索其余的克隆\ngit fetch --unshallow\n\n# 或者\ngit fetch --depth=2147483647\n# 做一个定期拉\ngit pull --all\n```\n- 2. 切换使用 ssh(git clone username@mydomain.com:my_group/my_repository.git) \n- 3. 增加缓冲区大小\n\n```shell\ngit config --global http.postBuffer 524288000\n```\n\n---\n**参考**\n- [stackoverflow](https://stackoverflow.com/questions/38618885/error-rpc-failed-curl-transfer-closed-with-outstanding-read-data-remaining)","tags":["Linux","Termux","Git"],"categories":["Diary"]},{"title":"Hexo Post 模板","path":"/posts/Hexo-Post.html","content":"> 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件.\n<!--more-->\n```bash\nhexo new photo \"My Gallery\"\n```\n\n在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，可以在模版中使用的变量：\n\n- layout 文章的布局，可以取值post（默认值）或page，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。\n- title 文章的标题\n- date 创建日期，文件的创建日期\n- updated 修改日期，文件的修改日期\n- comments 是否开启评论，默认值true\n- tags 标签\n- categories 分类\n- permalink url中的名字，默认值文件名\n\n# 模板\n```bash\ntitle: {{ title }}\ndate: {{ date }}\ntags:\n- Linux\ncategories:\n- notes\nauthor:\n- Vitan\n- /images/Hexo.svg\n```","tags":["Hexo"],"categories":["Diary"]},{"title":"spyder","path":"/posts/spyder.html","content":"spyder3 No module named 'PyQt5.QtWebKitWidgets'\n<!--more-->\n解决 Spyder3 无法启动\n```python\nsudo pip install pyqt5==5.11.2\n```\n\n---\n**相关 issue**\n- [6990](https://github.com/spyder-ide/spyder/issues/6990)","tags":["Linux","ArchLinux","Ubuntu","Python"],"categories":["Coding","Python"]},{"title":"Linus Wine","path":"/posts/wine.html","content":"Linux Wine\n<!--more-->\nArchLinux\n```shell\nsudo pacman -S wine wine_gecko wine-mono winetricks\n```\n\n字体乱码\n```shell\ntouch zh.reg\n```\n\n- 内容\n\n```shell\nREGEDIT4\n\n  [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink]\n  \"Lucida Sans Unicode\"=\"wqy-microhei.ttc\"\n  \"Microsoft Sans Serif\"=\"wqy-microhei.ttc\"\n  \"Microsoft YaHei\"=\"SourceHanSansCN-Medium.otf\"\n  \"MS Sans Serif\"=\"wqy-microhei.ttc\"\n  \"Tahoma\"=\"wqy-microhei.ttc\"\n  \"Tahoma Bold\"=\"wqy-microhei.ttc\"\n  \"SimSun\"=\"wqy-microhei.ttc\"\n  \"Arial\"=\"wqy-microhei.ttc\"\n  \"Arial Black\"=\"wqy-microhei.ttc\"\n  \"宋体\"=\"SourceHanSansCN-Medium.otf\"\n  \"新细宋体\"=\"SourceHanSansCN-Medium.otf\"\n```\n\n- Run\n\n```shell\negedit zh.reg\n```","tags":["Linux","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Git Pull 覆盖本地文件","path":"/posts/GitPull.html","content":"放弃对于本地的项目中修改，Git pull强制覆盖\n<!--more-->\n```git\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```","tags":["Linux","ArchLinux","Git","Ununtu"],"categories":["Diary"]},{"title":"Termux ADB","path":"/posts/Termux-ADB.html","content":"Termux ADB\n<!--more-->\n## 下载 arm 版 ADB\n[Download](https://github.com/ivitan/Shell/releases/download/Adb/adb.zip)\n\n## Installation\n\n1. 解压后 `mv arm/adb $PREFIX/bin`\n2. 添加权限 `chmod +x $PREFIX/bin/adb`\n\n\n## Usage\n\n1. 远程连接设备（已开启USB网络调试）\n\n```sh\nadb connect ip\n```\n## ADB\n[ADB 与 Fastboot 常用命令](/posts/Adb.html)","tags":["ADB","Termux"],"categories":["Diary"]},{"title":"jQuery Selector","path":"/posts/jQuerySelector.html","content":"jQuery 选择器\n<!--more-->\n#元素选择器\n```js\n// id 选择器\n$(\"#myELement\")\n\n// 元素选择器\n$(\"div\")\n$(\"span\")\n$(\"button\")\n...\n\n// .class 选择\n$(\".myClass\")\n\n// 通配符选择(选取所有元素)\n$(\"*\")\n```\n\n# 层叠选择器\n```js\n    //所有form元素中的input元素 \n    $(\"form input\") \n\n    //id值为main的所有的子元素\n    $(\"#main > *\")   \n\n    /*所有的label元素的下一个input元素节点，\n    返回的是label标签后面直接跟一个input标签的所有input标签元素 */       \n    $(\"label + input\") \n\n    //同胞选择器，返回id为prev的标签元素的所有的属于同一个父元素的div标签\n    $(\"#prev ~ div\")       \n```\n\n# 基本过滤选择器\n```js\n//所有tr元素的第一个\n$(\"tr:first\")\n\n//所有tr元素的最后一个 s\n$(\"tr:last\") \n\n//过滤掉：checked的选择器的所有的input元素 \n$(\"input:not(:checked) + span\")  \n\n//所有的tr元素的第1，3，5... ...个元素 \n(\"tr:odd\") \n\n//所有的td元素中序号为2的那个td元素\n$(\"td:eq(2)\") \n\n//td元素中序号大于4的所有td元素 \n$(\"td:gt(4)\")   \n\ntd元素中序号小于4的所有的td元素     \n$(\"td:ll(4)\")   \n\n//所有标题元素（h1 - h6）\n$(\":header\") \n\n$(\"div:animated\") \n```\n\n# 内容过滤选择器\n```js\n//所有div中含有John文本的元素\n$(\"div:contains('John')\")\n\n//所有的为空（也不包括文本节点）的td元素的数组 \n$(\"td:empty\")        \n\n//所有含有p标签的div元素   \n$(\"div:has(p)\")      \n\n//所有的以td为父节点的元素数组 \n$(\"td:parent\")        \n```\n\n# 可视化过滤选择器\n```js\n//所有的被hidden的div元素 \n$(\"div:hidden\")  \n\n//所有的可视化的div元素    \n$(\"div:visible\")\n```\n\n# 属性过滤选择器\n```js\n//含有id属性的div元素 \n$(\"div[id]\")\n\n//name属性等于'newsletter'的input元素 \n$(\"input[name='newsletter']\")\n    \n//name属性不等于'newsletter'的input元素 \n$(\"input[name!='newsletter']\")\n    \n//name属性以'news'开头的input元素 \n$(\"input[name^='news']\") \n\n// name属性以'news'结尾的input元素 \n$(\"input[name$='news']\")   \n\n//name属性包含'news'的input元素     \n$(\"input[name*='man']\")          \n    \n//可以使用多个属性进行联合选择，得到所有的含有id属性并且属性以man结尾的元素 \n$(\"input[id][name$='man']\")    \n```\n\n# 子元素过滤选择器\n```js\n$(\"ul li:nth-child(2)\"),$(\"ul li:nth-child(odd)\"),$(\"ul li:nth-child(3n + 1)\") \n\n//返回所有的div元素的第一个子节点的数组\n$(\"div span:first-child\")   \n\n//返回所有的div元素的最后一个节点的数组 \n$(\"div span:last-child\") \n\n//返回所有的div中只有唯一一个子节点的所有子节点的数组 \n$(\"div button:only-child\")       \n```\n\n# 表单元素选择器： \n```js\n//所有的表单输入元素，包括input, textarea, select 和 button \n$(\":input\")  \n    \n//所有的text input元素 \n$(\":text\")                     \n\n//所有的password input元素 \n$(\":password\")           \n\n//所有的radio input元素\n$(\":radio\")                    \n\n//所有的checkbox input元素\n$(\":checkbox\")             \n\n//所有的submit input元素 \n$(\":submit\")               \n\n// 所有的image input元素 \n$(\":image\")                \n\n//所有的reset input元素 \n$(\":reset\")                   \n\n//所有的button input元素 \n$(\":button\")                \n\n// 所有的file input元素 \n$(\":file\")                    \n\n// 所有类型为hidden的input元素或表单的隐藏域 \n$(\":hidden\")              \n```\n\n# 表单元素过滤选择器\n```js \n//所有的可操作的表单元素 \n$(\":enabled\")             \n\n//所有的不可操作的表单元素 \n$(\":disabled\")            \n\n//所有的被checked的表单元素\n$(\":checked\")             \n\n//所有的select 的子元素中被selected的元素 \n$(\"select option:selected\") \n```\n```jquery\n//选取一个 name 为”S_03_22″的input text框的上一个td的text值\n$(”input[@ name =S_03_22]“).parent().prev().text() \n    \n//名字以”S_”开始，并且不是以”_R”结尾的\n$(”input[@ name ^='S_']“).not(”[@ name $='_R']“) \n    \n//一个名为 radio_01的radio所选的值\n$(”input[@ name =radio_01][@checked]“).val(); \n```\n```jquery\n//查找A元素下面的所有子节点，包括非直接子节点\n$(\"A B\") \n\n//查找A元素下面的直接子节点\n$(\"A>B\") \n\n//查找A元素后面的兄弟节点，包括非直接子节点\n$(\"A+B\") \n\n//查找A元素后面的兄弟节点，不包括非直接子节点\n$(\"A~B\")  \n```","tags":["HTML","CSS","jQuery"],"categories":["Coding","Web"]},{"title":"Git Commit Emoji","path":"/posts/GitEmoji.html","content":"Git Commit Emoji\n<!--more-->\n# Emoji\nemoji                                   | emoji 代码                   | commit 说明\n:--------                               | :--------                    | :--------\n:tada: (庆祝)                           | `:tada:`                     | 初次提交\n:sparkles: (火花)                       | `:sparkles:`                 | 引入新功能\n:bookmark: (书签)                       | `:bookmark:`                 | 发行/版本标签\n:bug: (bug)                             | `:bug:`                      | 修复 bug\n:ambulance: (急救车)                    | `:ambulance:`                | 重要补丁\n:globe_with_meridians: (地球)           | `:globe_with_meridians:`     | 国际化与本地化\n:lipstick: (口红)                       | `:lipstick:`                 | 更新 UI 和样式文件\n:clapper: (场记板)                      | `:clapper:`                  | 更新演示/示例\n:rotating_light: (警车灯)               | `:rotating_light:`           | 移除 linter 警告\n:wrench: (扳手)                         | `:wrench:`                   | 修改配置文件\n:heavy_plus_sign: (加号)                | `:heavy_plus_sign:`          | 增加一个依赖\n:heavy_minus_sign: (减号)               | `:heavy_minus_sign:`         | 减少一个依赖\n:arrow_up: (上升箭头)                   | `:arrow_up:`                 | 升级依赖\n:arrow_down: (下降箭头)                 | `:arrow_down:`               | 降级依赖\n:zap: (闪电)<br>:racehorse: (赛马)      | `:zap:`<br>`:racehorse:`      | 提升性能\n:chart_with_upwards_trend: (上升趋势图) | `:chart_with_upwards_trend:` | 添加分析或跟踪代码\n:rocket: (火箭)                         | `:rocket:`                   | 部署功能\n:white_check_mark: (白色复选框)         | `:white_check_mark:`         | 增加测试\n:memo: (备忘录)                         | `:memo:`                     | 撰写文档\n:hammer: (锤子)                         | `:hammer:`                   | 重大重构\n:art: (调色板)                          | `:art:`                      | 改进代码结构/代码格式\n:fire: (火焰)                           | `:fire:`                     | 移除代码或文件\n:pencil2: (铅笔)                        | `:pencil2:`                  | 修复 typo\n:construction: (施工)                   | `:construction:`               | 工作进行中\n:construction_worker: (工人)            | `:construction_worker:`      | 添加 CI 构建系统\n:green_heart: (绿心)                    | `:green_heart:`              | 修复 CI 构建问题\n:lock: (锁)                             | `:lock:`                     | 修复安全问题\n:whale: (鲸鱼)                          | `:whale:`                    | Docker 相关工作\n:apple: (苹果)                          | `:apple:`                    | 修复 macOS 下的问题\n:penguin: (企鹅)                        | `:penguin:`                  | 修复 Linux 下的问题\n:checkered_flag: (旗帜)                 | `:checked_flag:`             | 修复 Windows 下的问题\n\n---\n**Via**\n- [Git-commit-emoji](https://github.com/liuchengxu/git-commit-emoji-cn/blob/master/README.md)\n\n# Emoji-Log\n## 配置\n\n```bash .bash/.zshrc\n    #.# Better Git Logs.\n    ### Using EMOJI-LOG (https://github.com/ahmadawais/Emoji-Log).\n    # Git Commit, Add all and Push — in one step.\n    function gcap() {\n        git add . && git commit -m \"$*\" && git push\n    }\n    # NEW.\n    function gnew() {\n        gcap \"📦 NEW: $@\"\n    }\n    # IMPROVE.\n    function gimp() {\n        gcap \"👌 IMPROVE: $@\"\n    }\n    # FIX.\n    function gfix() {\n        gcap \"🐛 FIX: $@\"\n    }\n    # RELEASE.\n    function grlz() {\n        gcap \"🚀 RELEASE: $@\"\n    }\n    # DOC.\n    function gdoc() {\n        gcap \"📖 DOC: $@\"\n    }\n    # TEST.\n    function gtst() {\n        gcap \"✅ TEST: $@\"\n    }\n```\n\n## 别名到 ~/.gitconfig\n```bash\n    # Git Commit, Add all and Push — in one step.\n    cap = \"!f() { git add .; git commit -m \\\"$@\\\"; git push; }; f\"\n    # NEW.\n    new = \"!f() { git cap \\\"📦 NEW: $@\\\"; }; f\"\n    # IMPROVE.\n    imp = \"!f() { git cap \\\"👌 IMPROVE: $@\\\"; }; f\"\n    # FIX.\n    fix = \"!f() { git cap \\\"🐛 FIX: $@\\\"; }; f\"\n    # RELEASE.\n    rlz = \"!f() { git cap \\\"🚀 RELEASE: $@\\\"; }; f\"\n    # DOC.\n    doc = \"!f() { git cap \\\"📖 DOC: $@\\\"; }; f\"\n    # TEST.\n    tst = \"!f() { git cap \\\"✅ TEST: $@\\\"; }; f\"\n```\n\n# gitmoji-cli\n## install\n```bash\nnpm i -g gitmoji-cli\n```\n## usage\n```bash\ngitmoji --help\ngitmoji -c\n```\n\n---\n\n**Via**\n- [OpenSource.com](https://opensource.com/article/19/2/emoji-log-git-commit-messages)\n- [gitmoji-cli](https://github.com/carloscuesta/gitmoji-cli)","tags":["Linux","Termux","Git"],"categories":["Diary"]},{"title":"ArchLinux NTFS","path":"/posts/ArchNtfs.html","content":"解决 ArchLInux 无法挂载 NTFS 的U盘和硬盘\n<!--more-->\n\n## 方法\n```bash\nsudo pacman -Syu \nsudo pacman -S ntfs-3g \n```","tags":["Linux","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Hexo 同时部署到 Github Coding","path":"/posts/HexoGithubCoding.html","content":"Hexo 同时部署到 Github Coding\n<!--more-->\n## 添加 SSH 公钥\n1. Github Coding添加同一个 SSH 公钥\n2. Github Coding 都部署好相关的仓库\n\n## 设置 _config.yml\n ```yaml _config.yml\ndeploy:\ntype: git\nrepository: \n    github: ssh://git@github.com/ivitan/ivitan.github.io,master\n    coding: git@git.coding.net:Vitan/vitan.coding.me.git,master\nbranch: master\n```","tags":["Linux","Termux","Hexo"],"categories":["Diary"]},{"title":"数据分析(是否出险)","path":"/posts/Spyder-1.html","content":"以下是相关分析步骤与过程\n1. 将Hw4文件导入\n2. 使用auto_ins作如下分析\n  - 1、首先对loss重新编码为1/0，有数值为1，命名为loss_flag\n  - 2、对loss_flag列进行描述分析（计数计频次）\n  - 3、分析是否出险和年龄、驾龄、性别、婚姻状态等变量之间的关系\n\n<!--more-->\n\n# 导入数据\nHw4文件导入\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\nimport seaborn as sns\nimport os\n\nos.chdir('/home/vitan/Python/Python/HW4')\n# 将auto_ins.csv读取进来,命名为auto\nauto = pd.read_csv('auto_ins.csv',encoding='gbk')\n```\n# 数据处理\n\n-  定义codeMy(x)函数，其作用是对auto里的loss重新编码为1/0，有数值为1，命名为loss_flag\n\n```python\ndef codeMy(x):\n    if x > 0:\n        return 1\n    else:\n        return 0\n     ```\n    - 对auto里的loss重新编码为1/0，有数值为1，命名为loss_flag\n    ```python\n    auto.loss_flag = auto.Loss.map(codeMy)\n    ```\n    - 应用匿名函数的方法对loss重新编码为1/0，有数值为1，命名为loss_flag1\n    ```python\n    auto[\"loss_flag1\"]= auto.Loss.map(lambda x:1 if x > 0 else 0)\n```\n\n# 画图\n## 分析\n- 对loss_flag列进行描述分析（计数计频次）\n\n```python\nauto.loss_flag.value_counts()\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1g0n5e60z7gj20ao06wwec.jpg)\n\n- 对loss_flag出险情况进行百分比统计\n\n```python\nauto.loss_flag.value_counts()/auto.loss_flag.count()\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1g0n5ev4yt8j20ao06wwec.jpg)\n\n- 绘制是否出险柱形图\n\n```python\nauto.loss_flag.value_counts().plot(kind=\"bar\")\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1g0n5u8ajf7j20aj06vjr7.jpg)\n\n- 分析是否出险和年龄、驾龄、性别、婚姻状态等变量之间的关系\n\n```python\n#设置画布fig\nfig = plt.figure()\n#将画布设计成1行2列结构，增加第一个子图层ax1\nax1 = fig.add_subplot(1,2,1)\n#将画布设计成1行2列结构，增加第二个子图层ax2\nax2 = fig.add_subplot(1,2,2)\n#是否出险和年龄关系：绘制箱形图（盒须图），分析出险和年龄的关系\nsns.boxplot(x=\"loss_flag\",y=\"Age\",data=auto,ax =ax1)\n\n#是否出险和驾龄：绘制箱形图（盒须图），分析出险和驾龄的关系\nsns.boxplot(x=\"loss_flag\",y=\"exp\",data=auto,ax =ax2)\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1g0n5mv40ebj20aq07faa2.jpg)\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1g0n5nop9tvj20aq07faa2.jpg)\n\n- 是否出险和性别：绘制面积堆积柱形图，分析出险和性别的关系\n\n```python\nfrom stack2dim import *\nstack2dim(auto,\"Gender\",\"loss_flag\")\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1g0n5odvgqgj20ar07at8m.jpg)\n    \n- 是否出险和婚姻状态：绘制面积堆积柱形图，分析出险和婚姻的关系\n\n```python\nstack2dim(auto,\"Marital\",\"loss_flag\")\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1g0n5ppeo0yj20ar07awee.jpg)","tags":["Python"],"categories":["Coding","Python"]},{"title":"常用算法","path":"/posts/PythonAlgorithm.html","content":"Python 排序\n<!--more-->\n## 冒泡排序\n```python\ndef bubble_sort(li):\nfor i in range(len(li)-1): # i表示第几趟\n    for j in range(len(li)-i-1): # j表示图中的箭头\n        if li[j] > li[j+1]:\n            li[j], li[j+1] = li[j+1], li[j]\n```\n冒泡排序(优化)\n```python\ndef bubble_sort_1(li):\nfor i in range(len(li)-1): # i表示第几趟\n    exchange = False\n    for j in range(len(li)-i-1): # j表示图中的箭头\n        if li[j] > li[j+1]:\n            li[j], li[j+1] = li[j+1], li[j]\n            exchange = True\n    if not exchange:\n        return\n```\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/maopao.gif)\n\n## 选择排序\n```python\ndef select(li):\nfor i in range(len(li)):\n    # 第i趟开始时 无序区：li[i:]\n    # 找无序区最小值，保存最小值的位置\n    min_index = i\n    for j in range(i + 1, len(li)):\n        if li[j] < li[min_index]:\n            min_index = j\n    li[min_index], li[i] = li[i], li[min_index]\n\n```\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/xuanze.gif)\n\n## 插入排序\n```python\ndef insert_sort(li):\nfor i in range(1, len(li)): # i是摸到的牌的下标\n    tmp = li[i]     # tmp是摸到牌的值\n    # 方法一\n    j = i - 1 # j是手里最后一张牌的下标    li[j]是手里最后一张牌的值\n    while j >= 0 and li[j] > tmp:   # 两个终止条件：j小于0表示tmp是最小的 顺序不要乱 \n        li[j+1] = li[j]\n        j -= 1\n    # 方法二\n    # for j in range(i-1, -1, -1):\n    #     if li[j] > tmp:\n    #         li[j+1] = li[j]\n    #     else:\n    #         break\n    li[j+1] = tmp   #将摸到的牌 插入到 往前挪过之后的 j 的后一位\n```\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/charu.gif\n)\n\n ##  快速排序\n```python\ndef quick_sort(lists, left, right):\n    # 快速排序\n    if left >= right:\n        return lists\n    key = lists[left]\n    low = left\n    high = right\n    while left < right:\n        while left < right and lists[right] >= key:\n            right -= 1\n        lists[left] = lists[right]\n        while left < right and lists[left] <= key:\n            left += 1\n        lists[right] = lists[left]\n    lists[right] = key\n    quick_sort(lists, low, left - 1)\n    quick_sort(lists, left + 1, high)\n    return lists\n```\n```python\ndef part(li, left, right):  # 列表,最左索引,最右索引\n    tmp = li[left]  # 先找个临时变量把第一个元素存起来\n    while left < right:  # 当最左小于最右\n        while left < right and li[right] >= tmp:  # 当最左<最右 且 最右边的值大于等于临时变量\n            right -= 1  # 最右 往左 挪 1 个单位长度\n        li[left] = li[right]  # 都不满足:把挪完之后的最右的值 赋值给 最左的值(即最右的值小于临时变量时,这个值挪到当前最左的值)\n        while left < right and li[left] <= tmp:  # 当最左<最右 且 最左边的值小于等于临时变量\n            left += 1  # 最左 往右 挪 1 个单位长度\n        li[right] = li[left]  # 都不满足:把挪完之后的最左的值 赋值给 最右的值(即最左的值大于临时变量时,这个值挪到当前最右的值)\n    li[left] = tmp  # 当前最左最右的值相等时,把这个值赋给临时变量\n    return left  # 返回当前临时变量的索引\n\ndef quick(li, left, right):\n   if left < right:  # 如果左索引<右索引\n       mid = part(li, left, right)  # 调用part进行分区 返回一个索引赋给mid\n       quick(li, left, mid - 1)  # 递归调用quick 直到left=mid-1\n       quick(li, mid + 1, right)  # 递归调用quick 直到mid+1=right\n\nli = list(range(1000))\nimport random\nrandom.shuffle(li)\nprint(li)\n\nquick(li, 0, len(li) - 1)\nprint(li)\n```\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/kuaisu.gif)\n\n## 堆排序\n```python\ndef sift(li, low, high):\n   tmp = li[low]\n   i = low\n   j = 2 * i + 1\n   while j <= high: # 退出条件2：当前i位置是叶子结点，j位置超过了high\n       # j 指向更大的孩子\n       if j + 1 <= high and li[j+1] > li[j]:\n           j = j + 1 # 如果右孩子存在并且更大，j指向右孩子\n       if tmp < li[j]:\n           li[i] = li[j]\n           i = j\n           j = 2 * i + 1\n       else:       # 退出条件1：tmp的值大于两个孩子的值\n           break\n   li[i] = tmp\n\n@cal_time\ndef heap_sort(li):\n   # 1. 建堆\n   n = len(li)\n   for i in range(n//2-1, -1, -1):\n       # i 是建堆时要调整的子树的根的下标\n       sift(li, i, n-1)\n   # 2.挨个出数\n   for i in range(n-1, -1, -1): #i表示当前的high值 也表示棋子的位置\n       li[i], li[0] = li[0], li[i]\n       # 现在堆的范围 0~i-1\n       sift(li, 0, i-1)\n```\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/zengdui.gif\n)\n\n## 归并排序\n```python\ndef merge(li, low, mid, high):\n   i = low\n   j = mid + 1\n   ltmp = []\n   while i <= mid and j <= high:\n       if li[i] < li[j]:\n           ltmp.append(li[i])\n           i += 1\n       else:\n           ltmp.append(li[j])\n           j += 1\n   while i <= mid:\n       ltmp.append(li[i])\n       i += 1\n   while j <= high:\n       ltmp.append(li[j])\n       j += 1\n   # for k in range(low, high+1):\n   #     li[k] = ltmp[k-low]\n   li[low:high+1] = ltmp\n\ndef merge_sort(li, low, high):\n   if low < high:\n       mid = (low + high) // 2\n       merge_sort(li, low, mid)\n       merge_sort(li, mid+1, high)\n       merge(li, low, mid, high)\n\n# li = list(range(10000))\n# random.shuffle(li)\n# merge_sort(li, 0, len(li)-1)\n# print(li)\nli = [10,4,6,3,8,2,5,7]\nmerge_sort(li, 0, len(li)-1)\n```\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/guibing.gif\n)\n\n---\n**Via**\n- [掘金](https://juejin.im/post/5b6ba2d26fb9a04fde5af361)","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"常用实现","path":"/posts/PythonCommonlyUse.html","content":"常用实现\n<!--more-->\n## 九九乘法表\n```python\n\tfor i in range(1, 10):\n    for j in range(1, i+1):\n        print('{}x{}={}\\t'.format(j, i, i*j), end='')\n    print()\n```\n\n# 列出目录文件\n\n- 路径下的所有文件和文件夹的路径\n\n```pytyon\npath = '~/path'\nfor i in os.listdir(path):\n    print(os.path.join(path,i))\n```\n\n- 读取路径下的文本\n\n```python\n    def txt_processing(folder_path):\n    folder_list = os.listdir(folder_path)\n\n    # 遍历文件夹\n    for folder in folder_list:\n        new_folder_path = os.path.join(folder_path,folder) # 拼接路径\n        files = os.listdir(new_folder_path) # 258/分类\n\n        for file in files:\n            # if j > 1000000000000000: # 要读的每个分类的文件个数\n            #     break\n            if not os.path.isdir(file):  # 判断是否是文件夹，不是文件夹才打开\n                TxtPath = os.path.join(new_folder_path, file)\n                with open(TxtPath,'r',encoding='UTF-8') as fp:\n                    Txt = fp.read()\n```\n\n- 输出以 xxx 为后缀的文件\n\n```python\nfor i in os.listdir(filepath):\n    path = os.path.join(fillepath,i)\nif path.endswith('.xxx'):\n    print(path)\n```\n\n# 判断奇偶数\n```python\nnumber = int(input('输入数字:'))\nif (num % 2 ) == 0:\n    print('{}：是偶数'.format(number))\nelse:\n    print('{}：是奇数'.format(number))\n```\n\n# 字符串判断\n```python\nstr = \"runoob.com\"\nprint(str.isalnum()) # 判断所有字符都是数字或者字母\nprint(str.isalpha()) # 判断所有字符都是字母\nprint(str.isdigit()) # 判断所有字符都是数字\nprint(str.islower()) # 判断所有字符都是小写\nprint(str.isupper()) # 判断所有字符都是大写\nprint(str.istitle()) # 判断所有单词都是首字母大写，像标题\nprint(str.isspace()) # 判断所有字符都是空白字符、\\t、\\n、\\r\n```\n\n# 字符串到小写转换\n```python\nstr = 'vitan.me'\n# 把所有字符中的小写字母转换成大写字母\nprint(str.upper())         \n# 把所有字符中的大写字母转换成小写字母\nprint(str.lower())      \n# 把第一个字母转化为大写字母，其余小写\nprint(str.capitalize())  \n# 把每个单词的第一个字母转化为大写，其余小写 \nprint(str.title())     \n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Date Types","path":"/posts/PythonDateTypes.html","content":"数据类型\n<!--more-->\n# 数值类型\n## Int 整形\n整数类型\n- 声明：\n1. 十进制：`0~9`\n2. var = 十进制数字\n4. var = 进制数字\n  - 二进制：`0~1`, 符号:  `0b`\n  - 八进制：`0~7`,符号:  `0o`\n  - 十六进制：`0~9A~F`,符号: `0x`\n\n## Float 浮点型\n即小数\n- 声明：\n- var = 小数\n\n## Bool 布尔类型\n只有两个值：True 和 False\n\n## Complex 复数类型\n复数的完整结构:实数部分+虚数部分 \n-  声明：\n1. var = 实数 + 虚数 如：var = 5 + 4j\n2. var = complex(实数，虚数值) 如：var = complex(5,3) \n\n# String类型,字符类型\n## String 字符串类型\n即文字类型\n- 声明：\n1. var = 'str...'\n2. var = \"str...\"\n3. var = '''str...'''    or   var = \"\"\"str...\"\"\"\n\n## 转义字符\n某种特定的格式使得字符的意义发生改变\n\n|符号 |  含义 |\n|:---|:---|\n|`\\` |续行符|\n|`\\\\` |反斜杠符号(\\)|\n|`\\'` |单引号|\n|`\\\"` |双引号|\n|`\\a` |响铃|\n|`\\b` |退格(backspace)|\n|`\\e` |转义|\n|`\\000` |空|\n|`\\n` |换行|\n|`\\v` |纵向制表符|\n|`\\t` |横向制表符|\n|`\\r` |回车|\n|`\\f` |换页|\n|`\\oyy` |八进制数，yy代表的字符，例如：\\o12代表换行|\n|`\\xyy` |十六进制数，yy代表的字符，例如：\\x0a代表换行|\n|`\\other`| 其它的字符以普通格式输出|\n\n## 元字符串\n任意字符串之前添加字母r或者R，则当前字符串中所有转义字符在使用时都不会进行转义操作\n\n# 列表类型(List)\n一系列数据的顺序组合，并且组合之后可以修改\n- 声明：\n  - list = []\n\n## 元组类型(Tuple)\n一系列数据的顺序组合，但是组合之后不可以修改\n- 声明:\n   - tuple = ()\n\n## 字典类型(Dict)\n具有键值映射关系的一组无序数据组合，可以修改\n- 声明:\n   - dict = {'key1':'value1','key2':'value2'...}\n\n## 集合类型(Set)\n一组特定数据的无序组合，所有数据不会重复\n- 声明:\n- var = {value1,value2...}","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Regression Validation","path":"/posts/RegressionValidation.html","content":"回归分析\n<!--more-->\n# 导入数据\n```python\nimport pandas \ndf = pandas.read_csv('house-prices.csv')\ndf.head()\n```\n\n# one-hot 处理\n```python\n#对Brick与Neighborhood两列数据进行one-hot处理\nhouse =  pandas.concat([df,pandas.get_dummies(df['Brick']),pandas.get_dummies(df['Neighborhood'])] ,axis=1)\n#删除No列\ndel house['No']\n#删除West列\ndel house['West']\n#删除Brick列\ndel house['Brick']\n#删除Neighborhood列\ndel house['Neighborhood']\n#删除Home列\ndel house['Home']\nhouse.head()\n```\n# statsmodels.api\n```python\n#X为house的'SqFt', 'Bedrooms', 'Bathrooms', 'Offers', 'Yes', 'East', 'North'列\nX = house[['SqFt', 'Bedrooms', 'Bathrooms', 'Offers', 'Yes', 'East', 'North']]\n#Y为house的Price列的values\nY = house['Price']\n```\n\n```python\nimport numpy.core.multiarray\nfrom pandas.core import datetools\n#导入statsmodels.api里面的sm，用于评估模型\nimport statsmodels.api as sm\n#利用sm.add_constant为X增加一列名为const,值为1的数据\nX2 = sm.add_constant(X)\n#调用sm的OLS函数对Y,X2进行模型创建\nest = sm.OLS(Y,X2)\n#调用est的fit函数创建回归结果\nest2 = est.fit()\n#输出打印est2的概要信息\nprint(est2.summary())\nest2.aic\n```\n\n## 最优组合\n```python\npredictorcols = ['SqFt', 'Bedrooms', 'Bathrooms', 'Offers', 'Yes', 'East', 'North']\nimport itertools\nfor i in range(1,len(predictorcols)+1):\n    for variables in itertools.combinations(predictorcols,i):\n        print(variables)\n```\n```python\nimport itertools#导入itertools库\n#创建字典AICs ，用于保存每个列名组合的aic结果\nAICs = {}\n#for循环，循环变量i从1到predictorcols列表的长度加1\nfor i in range(1,len(predictorcols)+1):\n    #再次for循环，循环变量var的范围为predictorcols的各种i个元素组合集合itertools.combinations(predictorcols,i)\n    for var in itertools.combinations(predictorcols,i):   \n        #predictors为数据框X里的var列的数据，记得要先将var转换成list\n        predictors  = X[list(var)]\n        #利用sm.add_constant为predictors增加一列名为const,值为1的数据\n        predictors2 =  sm.add_constant(predictors)\n        #调用sm的OLS函数对y,predictors2进行模型创建\n        est = sm.OLS(Y,predictors2)\n        #调用est的fit函数创建回归结果\n        res = est.fit()\n        print(res.aic) # 每种组合的aic值\n    #将res.aic的结果赋值给 AICs的每一个var   \n        AICs[var] =  res.aic\n```\n```python\n#导入collections的Counter\nfrom collections import Counter\n#调用Counter，对AICs进行降序排序\nc = Counter(AICs)\n#调用排序后的c倒数10个数据对象\nc.most_common()[::-10]\n```","tags":["WebCrawler","Python"],"categories":["Coding"]},{"title":"安居客二手房","path":"/posts/ScrapyAnjuke.html","content":"Scrapy anjuke.com 广州二手房数据(保存为 csv)\n<!--more-->\n# Spiders\n```python\n    # -*- coding: utf-8 -*-\n    from scrapy import Spider,Request\n    from anjuke.items import AnjukeItem\n\n    class AnjukehouseSpider(Spider):\n        name = 'anjukeHouse'\n        allowed_domains = ['anjuke.com']\n        start_urls = ['https://guangzhou.anjuke.com/sale/p1-rd1/#filtersort']\n\n        def parse(self, response):\n            # 所有房子URL\n            urls = response.xpath('//div[@class=\"house-title\"]/a/@href').extract()\n            for url in urls:\n                yield Request(url,callback=self.parse_detail)\n\n            # 下一页\n            next = response.xpath('//*[@id=\"content\"]/div[4]/div[7]/a[7]/@href').extract()\n            if next:\n                next = response.urljoin(next[0])\n                yield Request(next,callback=self.parse)\n\n        def parse_detail(self,response):\n            item = AnjukeItem()\n            item['date'] = response.xpath('//span[@class=\"house-encode\"]/text()').extract()[0].split()\n            item['tittle'] = response.xpath('//h3[@class=\"long-title\"]/text()').extract()\n            item['price'] = response.xpath('//span[@class=\"light info-tag\"]/em/text()').extract_first().split()\n\n            houseInfo = response.xpath('//div[@class=\"houseInfo-content\"]/text()').extract()\n            item['huxing'] = houseInfo[2].strip().replace(\"\\n\",\"\").replace(\"\\t\",\"\").split()\n            item['area'] = houseInfo[7].strip().split()\n            item['built'] = houseInfo[9].strip().replace(\"\\n\", \"\").replace(\"\\t\", \"\").split()\n            item['chaoxiang'] = houseInfo[10].strip().split()\n            item['leixing'] = houseInfo[-8].strip().split()\n            item['louceng'] = houseInfo[-7].strip().split()\n            item['zhuangxiu'] = houseInfo[-6].strip().split()\n            print(item)\n        return item\n```\n\n## items\n```python\n    from scrapy import Item,Field\n\n    class AnjukeItem(Item):\n        # define the fields for your item here like:\n        # name = scrapy.Field()\n        tittle = Field()\n        huxing = Field()\n        area = Field()\n        chaoxiang = Field()\n        louceng = Field()\n        price = Field()\n        zhuangxiu = Field()\n        leixing = Field()\n        date = Field()\n        built = Field()\n```\n\n## settings\n```python\n    BOT_NAME = 'anjuke'\n\n    SPIDER_MODULES = ['anjuke.spiders']\n    NEWSPIDER_MODULE = 'anjuke.spiders'\n\n    # Obey robots.txt rules\n    ROBOTSTXT_OBEY = False\n\n    DOWNLOAD_DELAY = 3\n\n    DEFAULT_REQUEST_HEADERS = {\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n        'Accept-Language': 'en',\n        'user-agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36',\n        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',\n        'accept-encoding': 'gzip, deflate, br',\n        'accept-language': 'zh-CN,zh;q=0.9',\n        'cache-control': 'max-age=0',\n    }\n\n    ITEM_PIPELINES = {\n    'anjuke.pipelines.Pipeline_ToCSV': 300,\n    }\n```\n\n## pipelines\n```python\n    import csv\n    import os\n\n    class Pipeline_ToCSV(object):\n\n        def __init__(self):\n            self.csvwriter = csv.writer(open('anjuke.csv', 'w'), delimiter=',')\n            self.csvwriter.writerow(['date','tittle', 'price', 'huxing', 'area','built','chaoxiang','leibie','loucheng','zhuangxiu'])\n\n        def process_item(self, item, ampa):\n            rows = zip(item['date'],item['tittle'], item['price'],item['huxing'],item['area'],item['built'],item['chaoxiang'],item['leixing'],item['louceng'],item['zhuangxiu'])\n\n            for row in rows:\n                self.csvwriter.writerow(row)\n\n            return item\n```\n\n# Selenium\n```python\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    # @Time    : 18-12-28 下午6:48\n    # @Author  : Vitan\n    # @File    : anjuke.py\n\n    from selenium import webdriver\n    from selenium.webdriver.common.by import By\n    from selenium.webdriver.support.ui import WebDriverWait\n    from selenium.webdriver.support import expected_conditions as EC\n    from bs4 import  BeautifulSoup\n    import pandas\n    import time,random\n\n    broswer = webdriver.Chrome()\n    wait = WebDriverWait(broswer,10)\n    houseInfo = []\n    def get_urls():\n        page_urls = []\n        star_url = 'https://guangzhou.anjuke.com/sale/p'\n        for i in range(1,51):\n            url = star_url+str(i)\n            page_urls.append(url)\n        return page_urls\n\n    def HouseUrl(url):\n        time.sleep(random.random()*10)\n        broswer.get(url)\n        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.curr')))\n        urls = broswer.find_elements_by_css_selector('.houseListTitle') # a 标签\n        house_urls = []\n        for a in urls:\n            urls = a.get_attribute('href')\n            house_urls.append(urls)\n        return house_urls\n\n    def get_detail(url):\n        time.sleep(random.random()*10)\n        broswer.get(url)\n        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.houseInfoBox')))\n        info = {}\n        # info['标题'] = broswer.find_element_by_css_selector('.long-title').get_attribute('textContent')\n        # info['总价'] = broswer.find_elements_by_css_selector('.basic-info span')[0].get_attribute('textContent')\n        # info['户型'] = broswer.find_elements_by_css_selector('.basic-info span')[1].get_attribute('textContent')\n        # info['面积'] = broswer.find_elements_by_css_selector('.basic-info span')[2].get_attribute('textContent')\n        # info['单价'] = broswer.find_elements_by_css_selector('.houseInfo-content')[2].get_attribute('textContent')\n        # info['朝向'] = broswer.find_elements_by_css_selector('.houseInfo-content')[7].get_attribute('textContent')\n        # info['月供'] = broswer.find_elements_by_css_selector('.houseInfo-content')[8].get_attribute('textContent')\n        # info['楼层'] = broswer.find_elements_by_css_selector('.houseInfo-content')[-7].get_attribute('textContent')\n        # info['装修'] = broswer.find_elements_by_css_selector('.houseInfo-content')[-6].get_attribute('textContent')\n        html = broswer.page_source\n        soup = BeautifulSoup(html,'lxml')\n        info['标题'] = soup.select('.long-title')[0].text\n        info['总价'] = soup.select('.basic-info span')[0].text\n        info['户型'] = soup.select('.basic-info span')[1].text\n        info['面积'] = soup.select('.basic-info span')[2].text\n        info['单价'] = soup.select('.houseInfo-content')[2].text\n        info['朝向'] = soup.select('.houseInfo-content')[7].text\n        info['月供'] = soup.select('.houseInfo-content')[8].text\n        info['楼层'] = soup.select('.houseInfo-content')[-7].text\n        info['装修'] = soup.select('.houseInfo-content')[-6].text\n        k = ['标题','总价','户型','面积','单价','朝向','月供','楼层','装修']\n        info_adj = dict(zip(k,list(info.values())))\n        houseInfo.append(info_adj)\n        print(houseInfo)\n        return houseInfo\n\n    def save_to_csv(houseInfo):\n        df = pandas.DataFrame(houseInfo)\n        df.to_csv('maoming.csv')\n\n    def main():\n        page_urls = get_urls()\n        for url in page_urls:\n            house_urls = HouseUrl(url)\n            for url in house_urls:\n                houseInfo=get_detail(url)\n                save_to_csv(houseInfo)\n\n    if __name__ == '__main__':\n        main()\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Visualization","path":"/posts/Visualization.html","content":"Python 数据可视化\n<!--more-->\n# 读取\n```python\nimport pandas as pd\n#将purchase_order.tab文件里面的相关字段名赋值给m_cols\nm_cols = ['Time','Action','User','Product', 'Quantity','Price']\n#读取purchase_order.tab文件，文件间隔符为\\t，读取进来后Dates为第一列数据，文件列名为以上m_cols编码为utf-8,\norders = pd.read_csv('purchase_order.tab',sep = '\\t',parse_dates = {'Dates':[0]},names = m_cols)\n#查看orders整个数据框的相关信息\norders.head()\n```\n\n查看记录\n```python\n#查看orders的Product列前5行数据\norders['Product'].head()\n\n#查看Product为P0006944501的Price列数据，并获取其描述性统计信息\norders.ix[orders['Product'] =='P0006944501','Product']\n\n\n#查看Product为P0006944501的Price列数据，求其均值\norders[orders['Product']=='P0006944501']['Price'].describe()\norders[orders['Product']=='P0006944501']['Price'].mea()\n\n#计算orders里面有哪些Product\norders['Product'].unique()\n\n\n#求orders里面不同类别的Product共有多少个\nlen(orders['Product'].unique())\n\n\n# select Product, avg(Price) from orders \n# group by Product limit 5\n\n#按Product统计其各自的销售价格均值\norders.groupby('Product')['Price'].mean()\n\n\n# select Product, avg(Price) from orders \n# group by Product order by avg(Price) desc limit 5\n\n#按Product统计其各自的销售价格均值并将求得的数据进行降序排序\norders.groupby('Product')['Price'].mean().sort_values(ascending=False)\n```\n\n增加\n```python\n#为orders增加新列Total_Price，并利用orders里面的相关数据计算求得\norders['Total_Price'] = orders['Quantity'] * orders['Price']\n```\n\n排序\n```python\n#select User, sum(Total_Price) from orders\n#gorup by User order by sum(Total_Price) desc limit 5\n\n#按客户统计他们的消费总金额，并按降序排列\norders.groupby('User')['Total_Price'].sum().sort_values(ascending = False)\n```\n\n# 再次读取\n```python\nimport pandas as pd\nm_cols = ['Time','Action','User','Product']\n#读取purchase_view.tab文件，文件间隔符为\\t，要求读取进来后Dates为第一列数据，文件列名为以上m_cols编码为utf-8,\nviews =pd.read_csv('purchase_view.tab',sep='\\t',parse_dates={'Dates':[0]},names =m_cols,encoding='UTF-8')\n#查看views整个数据框的相关信息\nviews.info()\n#查看前5行数据\nviews.head()\n```\n\n分组、排序\n```python\n## SELECT User, Product, COUNT(Product) FROM Orders GROUP BY User, Product\n#在购买数据表中按不同用户不同产品进行分组，并统计每个用户产品的购买数量，将统计结果以“buys”作为字段名添加进统计结果中\norders_cnt= orders.groupby(['User','Product'])['Action'].count().reset_index(name='buys')\norders_cnt.head()\n\n## SELECT User, Product, COUNT(Product) FROM views GROUP BY User, Product\n#在浏览记录表数据表中按不同用户不同产品进行分组，并统计每个用户产品的浏览量，并对统计结果按浏览量降序排列，最后将统计结果以“views”作为字段名添加进统计结果中,\nviews_cnt =views.groupby(['User','Product'])['Action'].count().sort_values(ascending=False).reset_index(name = 'views')\n```\n\n合并\n```python\n#将用户购买与浏览产品的数据合并在一起，生成表格merge_df,以views_cnt作为右连接表，连接结果为右连接\nmerge_df = pd.merge(orders_cnt,views_cnt,on=['User','Product'],how='right')\n```\n  - [数据表的连接问题](http://www.cnblogs.com/zxlovenet/p/4005256.html)\n  - [merge与concat的区别](https://blog.csdn.net/ZK_J1994/article/details/77717700)\n\n不同日期與時間\n```python\nviews.head()#查看views\nviews.info()#查看views的相关信息\n\n# year, month, day, date, hour \n#查看views的Dates列数据的年、月、日期等信息\nviews['Dates'].dt.hour\n\n\n# select date, count(action) from views\n# group by date\n#在views表中，统计每一天网站的用户浏览总次数\nviews_cnt_by_date  = views.groupby(views['Dates'].dt.date)['Action'].count()\nviews_cnt_by_date.head()#查看以上统计结果\n```\n\n# 绘制图表\n```python\n%pylab inline\n\n#对每天用户浏览网站情况绘制折线图，图大小为10*5\n views_cnt_by_date.plot(kind='line',figsize=[10,5])\n```\n```python\n# select hour(Dates), count(action) from views\n# group by  hour(Dates)\n#在views表中，统计一天24内每个小时网站的用户浏览总次数\nviews_cnt_by_hour  = views.groupby(views['Dates'].dt.hour)['Action'].count()\n\n%pylab inline\n#各个小时用户浏览网站情况绘制折线图，图大小为10*5，标题为view count by hour\nviews_cnt_by_hour.plot(kind='line',figsize=[10,5],title='view count by hour')\n```\n```python\n#增加新列Total_price,并利用orders相关数据计算\norders['Total_price'] = orders['Quantity'] * orders['Price']\n#按客户统计他们的消费总金额，并按降序排列,最终取前10个用户的统计数据\ng = orders.groupby('User')['Total_price'].sum().sort_values(ascending=False)[0:10]\n#绘制前10个用户的消费金额柱形图，图片大小10*5\ng.plot(kind='bar',figsize=[10,5],color='y')\n```\n\n统计\n```python\n#在views表中统计网站每天的浏览总数\nview_daily_cnt = views.groupby(views['Dates'].dt.date)['Action'].count()\nview_daily_cnt.head()\n\n#在orders表中统计网站每天用户的购买总次数\norders_daily_cnt = orders.groupby(orders['Dates'].dt.date)['Action'].count()\norders_daily_cnt.head()\n```\n\n合并\n```python\n#将view_daily_cnt与orders_daily_cnt表按列方向拼接,不需要按主键合并\ndf =pd.concat([view_daily_cnt,orders_daily_cnt],axis=1)\n    ##关于merge与concat的区别：https://blog.csdn.net/ZK_J1994/article/details/77717700\ndf=df.dropna()#删除具有空值的行,并将删除结果覆盖原数据框\ndf.head()\ndf.columns=['Views','Orders']#将df的字段名命名为'Views', 'Orders'\n    df.head()\n```\n```python\n#对df数据绘制折线图，图的大小为10*5，设置X轴刻度的显示旋转度为30\ndf.plot(kind='line',figsize=[10,5],rot=30)\n```\n- [plot里面各参数的使用说明](https://www.cnblogs.com/xitingxie/p/8359392.html)","tags":["WebCrawler","Python"],"categories":["Coding"]},{"title":"Data Transformation","path":"/posts/DataTransformation.html","content":"数据处理\n<!--more-->\n# 数据转换\n```python\nimport pandas\ndf = pandas.read_excel('house_sample.xlsx')#读取excel文件数据\ndf.head()\n```\n\n## 数据运算\n```python\n#将总价*10000\ndf['总价']*10000\n\nimport numpy as np\n#求总价列数据的平方根\nnp.sqrt(df['总价'])\n\n#将‘朝向’与‘户型’两列数据拼接在一起\ndf['朝向']+df['户型']\n\n#求每套房的房价均值（记得要先将总价*10000）\ndf['总价']*10000/df['建筑面积']\n#df.head()\n```\n\n## 切分\n```python\n#以“元”为分界对s进行切分，并获取切分后的第一个字符\ns = '1.5元/平米・月'\ns.split('元')[0]\n\n#定义removeDollar函数实现对字符e按‘元’进行切分并获取切分后的第一个字符\ndef removeDollar(e): \n    return e.split('元')[0]\nremoveDollar(s)#调用以上函数对s进行应用\n#将函数removeDollar套用到df的物业费列\ndf['物 业 费'].map(removeDollar)\n```\n## 匿名函数\n```python\ndef removeDollar(e):\nreturn e.split('元')[0]\n\n#将上面函数以匿名函数形式套用到df的物业费列\ndf['物 业 费'].map(lambda e:e.split('元')[0])\n```\n\n## 其他\n```python\ndef square(e):\n    return e * e \nsquare(2)\n\nsquare2 = lambda e: e * e\nsquare2(2)  \n```\n\n- 行列最值\n\n```python\ndf = pandas.DataFrame([\n                [60,70,50],\\\n                [80,79,68],\\\n                [63,66,82]], columns = ['First', 'Second', 'Third'])\ndf\n```\n```python\n#对df的每一行数据应用匿名函数进行计算，匿名函数实现对每一行数据的最大值与最小值计算\ndf.apply(lambda e:e.max()-e.min(),axis=1)\n\n#对df的每一列数据应用匿名函数进行计算，匿名函数实现对每一列数据的最大值与最小值计算\ndf.apply(lambda e:e.max()-e.min())\n```\n## 例题\n导入数据\n```python\nimport pandas\ndf = pandas.read_excel('house_sample.xlsx')\ndf.head()\n```\n\n实操\n```python\nimport numpy as np\ndef convertNaN(e):\n    if e == '暂无资料':\n        return np.nan\n    else:\n        return e\n        \n#将函数convertNaN应用到df的每个数据元素上\ndf.applymap(convertNaN)\n\n#以匿名函数形式将函数套用到df的每个数据元素上\ndf.applymap(lambda e:np.nan if e =='暂无资料' else e)\n```\n\n# 时间转换\n```python\n#导入时间处理库datetime\nfrom datetime import datetime\n#获取系统当前时间\ncurrent_time = datetime.now()\n\ntype(current_time)\n```\n\n## 时间<---->String\n```python\n#将时间转换成字符串\ncurrent_time.strftime('%Y/%m%d')\n\ns = '2017/04-22'\n#将字符串转换成时间\nprint(datetime.strptime(s,'%Y/%m-%d'))\n```\n\n## 时间回溯\n```python\nfrom datetime import timedelta\n#newday为当前时间往前回溯10天\nnewday = current_time - timedelta(10)\nprint(newday)\n\ncurrent_time - newday\n#将current_time往后推迟10天\ncurrent_time + timedelta(10)\n\nfor i in range(1,10):\n    #dt代表往前推移的每一个日期\n    dt = current_time - timedelta(i)\n    #将dt转换成字符串类似格式为“2017/04/21”，并打印输出\n    print(dt.strftime('%Y/%m/%d'))\n```\n## 时间戳\n```python\nfrom time import mktime\n#利用mktime将current_time转换成unix时间戳\nmktime(current_time.timetuple())\n\n#将上面的unix时间戳转换成datetime，调用datetime的fromtimestamp\nprint(datetime.fromtimestamp(1544492604.0))\n```\n\n## 例题\n数据导入\n```python\nimport pandas\ndf = pandas.read_excel('house_sample.xlsx')\ndf.head()\ndf.info()\n```\n\n## 时间转换\n```python\n#将df的'张贴日期'列转换成日期（datetime）形式\ndf['张贴日期'] =pandas.to_datetime(df['张贴日期'],format='西元%Y年%m月%d日')\n```\n\n# 数据重塑\n\n## 数据导入\n\n```python\nimport pandas as pd\ndf = pd.read_excel('house_sample.xlsx')\ndf.head()\n```\n\n## 数据操作\n- one-hot\n\n```python\n#将df的\"朝向\"列数据进行one-hot处理，即转换成虚拟变量\npd.get_dummies(df['朝向'])\n\n#利用pandas的concat函数将“朝向”列数据进行one-hot处理后，与原来的df数据框合并\ndf = jion(pd.compat([df,pd.get_dummies(['朝向'])],axis=1))\ndf.head()\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1fy2qy19bzvj203k08pa9y.jpg)\n\n- 删除数据\n\n```python\n#删除df的'朝向'数据\ndf = df.drop('朝向',axis=1)\ndf.head()\n```\n## 数据透视表\n```python\n#利用数据透视表绘制以下表格\ndf2 = df.pivot_table(index='张贴日期',columns='产权性质',values='总价',aggfunc=sum,fill_value=0)\n#表中数据为对应交叉对象的总价之和\ndf2.head()\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1fy2r0yfipgj208p077dg7.jpg)\n\n- 转换\n\n```python\n#将上面表格的行索引与列索引进行对换\ndf3 = df.pivot_table(index='产权性质',columns='张贴日期',values='总价',aggfunc=sum,fill_value=0)\ndf3.head()\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1fy2r25wh3fj20hq067wen.jpg)\n\n# 利用转置函数实现上面的行索引与列索引对换\n```python\ndf2.T\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1fy2r3aj8ejj20ho065wen.jpg)\n\n- 表\n\n```python\n#调整上面的参数，绘制以下表格\ndf_multi_idx = df.pivot_table(index=['装修','楼层'],columns='张贴日期',values='总价',aggfunc=sum,fill_value=0)\ndf_multi_idx.head()\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1fy2r4alq9qj20fm08lwet.jpg)\n\n- unstack函数\n\n```python\n#利用unstack函数转换成宽表格\ndf_wide = df_multi_idx.unstack()\ndf_wide.head()\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1fy2r5crzljj20hc08mt95.jpg)\n\n- stack函数\n\n```python\n#利用stack转换成长表格\ndf_long = df_wide.stack()\ndf_long.head()\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1fy2r6ol8gaj20fs08f3yv.jpg)\n\n# 综合练习\n```python\nimport pandas\n#将抓取返回的数据列组合成数据框df\ndf = pandas.read_excel('news.xlsx')\n#输出打印df的行数与列数\ndf.shape\ndf.head(10)\n```\n\n## 整理文章关键词\n空单元格处理\n```python\n#判断df中每一列是否有空的单元格\ndf.isnull().any()\n\n#将具有空单元格的行数据删除\ndf = df.dropna()\ndf.shape\n```\n关键字处理\n```python\ndf['keyword'].head(5)\n\n#对df的keyword列提取关键词并将提取结果覆盖原keyword列 提示：先根据空格切割split再索引\ns = '    \\n关键字 : \\n联合报农发农业部门'\ndf['keyword'] = df['keyword'].map(lambda e:e.split(':')[1].strip())\ndf.head(3)\n```\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1fy2rgd6jh1j20a303vgmb.jpg)\n![](http://ww1.sinaimg.cn/large/d71f8b2fgy1fy2rguhdh6j20ko05mq3z.jpg)\n\n正则表达法抽取时间与源数据\n```python\ndf['source'].head()\n\n#法一 对source列根据空格应用切割函数\ndf['source'].map(lambda e:e.split()[0])\n\ndf.head(3)\n#法二 根据正则表达式提取str.extract\ndf['source'].str.extract('(\\d+年\\d+月\\d+)日')\n\n#根据正则表达式提取后的数据'datetime', 'from'合并入df\ndf[['datetime','from']] = df['source'].str.extract('(\\d+年\\d+月\\d+日) \\d+:\\d+\\n(\\w*)')\n    ```\n\n转换时间格式\n```python\n#将pandas整列数据转换成日期格式\n# s = '2018年06月14日'\n# import datetime\n# s.strptime(s,'%Y年%m月%d日')\ndf['datetime'] = pandas.to_datetime(df['datetime'],format='%Y年%m月%d日')\ndf['datetime'].head()\n```\n\n刪除Source\n```python\n#删除source列数据\ndel df['source']\n\ndf.head(3)\n```\n----\n**数据**\n- [链接](https://github.com/ivitan/Note/tree/master/Python/Class/%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%862)","tags":["WebCrawler","Python"],"categories":["Coding"]},{"title":"Tmux","path":"/posts/tmux.html","content":"Tmux 可以复用终端、分屏、托管进程等\n<!--more-->\n# Tmux\nalias\n```bash vimrc\nalias tnew='tmux new =s'\n```\n\n# 模块\n|名词|含义|解析|\n|:----:|:----:|:----|\n|session|会话|一个服务器可以包含多个会话|\n|window\t|窗口|一个会话可以包含多个窗口|\n|pane\t|面板|一个窗口可以包含多个面板[强悍的分屏]\n\n  ---\n\n# 输入命令 tmux 使用工具\n|命令|分屏状态|\n|:------|:------|\n|Ctrl+b z |缩放窗格|\n|Ctrl+b ? |显示快捷键帮助|\n|Ctrl+b C-o |调换窗口位置，类似与vim 里的C-w|\n|Ctrl+b 空格键 |采用下一个内置布局|\n|Ctrl+b ! |把当前窗口变为新窗口|\n|Ctrl+b “| 横向分隔窗口|\n|Ctrl+b % |纵向分隔窗口|\n|Ctrl+b q| 显示分隔窗口的编号|\n|Ctrl+b o| 跳到下一个分隔窗口|\n|Ctrl+b 上下键 |上一个及下一个分隔窗口|\n|Ctrl+b C-方向键 |调整分隔窗口大小|\n|Ctrl+b c |创建新窗口|\n|Ctrl+b 0~9 |选择几号窗口|\n|Ctrl+b c| 创建新窗口|\n|Ctrl+b n |选择下一个窗口|\n|Ctrl+b l |切换到最后使用的窗口|\n|Ctrl+b p |选择前一个窗口|\n|Ctrl+b w| 以菜单方式显示及选择窗口|\n|Ctrl+b t |显示时钟|\n|Ctrl+b ; |切换到最后一个使用的面板|\n|Ctrl+b x| 关闭面板|\n|Ctrl+b & |关闭窗口|\n|Ctrl+b s |以菜单方式显示和选择会话\n|Ctrl+b d |退出tumx，并保存当前会话，这时，tmux仍在后台运行，可以通过tmux attach进入 到指定的会话|\n\n## 窗格间移动\n\n|命令|分屏状态|\n|:------|:------|\n|Ctrl+b ← |选择左边的窗格|\n|Ctrl+b → |选择右边的窗格|\n|Ctrl+b ↑ |选择上边的窗格|\n|Ctrl+b ↓ |选择下边的窗格|\n|Ctrl+b { |来向左交换窗格|\n|Ctrl+b } |来向右交换窗格|\n|Ctrl+b o |切换到下一个窗格（从左到右，从上到下）|\n|Ctrl+b ; |移动到先前活动的窗格|\n\n## 打开/创建新窗口\n|命令|分屏状态|\n|:------|:------|\n|Ctrl+b c |创建一个新窗口|\n|Ctrl+b n |移动到下一个窗口|\n|Ctrl+b p |移动到上一个窗口。\n|Ctrl+b 0 ~ Ctrl+b 9 |立即移动到特定窗口|\n|Ctrl+b l |移动到先前选择的窗口|\n|Ctrl+b w |以交互方式选择当前窗口|","tags":["Linux","Termux"],"categories":["Diary"]},{"title":"数据处理","path":"/posts/PyData.html","content":"数据处理\n<!--more-->\n# 数据筛选\n```python\n    import pandas as pd\n    df = pd.DataFrame([{'name':'frank', 'gender':'M', 'age':29}, \n                    {'name':'mary',  'gender':'F', 'age':23}, \n                    {'name':'tom',   'gender':'M', 'age':35}, \n                    {'name':'ted',   'gender':'M', 'age':33}, \n                    {'name':'jean',  'gender':'F', 'age':21}, \n                    {'name':'lisa',  'gender':'F', 'age':20}])\n```\n\n## 筛选\n1. 查看df前5行\n```python\ndf.head(5)\n```\n2. 利用ix索引查找行号名为1的行记录\n```python\ndf.ix[1]\n```\n3. 利用ix查找行号名为1-3的行记录\n```python\ndf.ix[1:3]\n```\n4. 利用列名返回name列数据\n```python\ndf['name']\n```\n5. 返回name与age列数据\n```python\ndf[['name','age']]\n```\n6. 返回行名号为1、2的name与age列数据\n```python\ndf.ix[1:2,['name','age']]\n```\n7. 返回gender列数据\n```python\ndf['gender']\ndf.gender\n```\n8. 判断每行的gender列数据是否为M\n```python\ndf.gender=='M'\n```\n9. 返回男性的行数据\n```python\ndf[df.gender=='M']\n```\n0. 判断各行记录age列是否大于30\n```python\ndf.age>30\n```\n11. 返回年龄大于30岁的行数据\n```python\ndf[df.age>30]\n```\n12. 返回男性且年龄大于30的行数据\n ```python\ndf.ix[(df.gender=='M') & (df.age>30),]\n```\n13. 返回男性或年龄大于30的行数据\n```python\ndf.ix[(df.gender=='M') | (df.age>30),]\n```\n14. df增加employee列，其值均为True\n```python\ndf['employee']=True\n```python\n14. 利用del删除employee列\n```python\ndel df['employee']\n```\n15. 再次为df增加employee列\n```python\ndf['employee']=True\ndf.head()#查看df前5行\n```\n16. 利用df.drop函数删除employee列，按列删除\n```python\ndf = df.drop('employee',axis=1)\n```\n17. 利用loc查看行号名为5的行数据\n```python\nf.loc[5]\n```\n18. 为df增加行号名为6的行数据，数据为{'age':20, 'gender': 'F', 'name':'qoo'}\n```python\ndf.loc[6]={'age':20, 'gender': 'F', 'name':'qoo'}\n```\n19. 利用df.drop删除索引号为6的记录\n```python\ndf = df.drop(6)\n```\n20. 利用df.append增加以上行数据到df中，ignore_index为True\n```python\ndf = df.append(pd.DataFrame([{'age':20, 'gender': 'F', 'name':'qoo'}]), ignore_index=True)\n```\n21. 利用df.drop删除索引号为6的行数据\n```python\ndf.drop(6)\n```\n22. 为df增加一列数据userid，值为101-106,提示：利用range函数\n```python\ndf['userid'] = range(101,107)\n```\n23. 利用set_index设置userid为索引列，代替原来行号名\n```python\ndf = df.set_index('userid')\n```\n\n- oc——通过行（行名字）标签索引行数据 iloc——通过行号（行序号，从0开始）索引行数据 ix——通过行标签或者行号索引行数据（基于loc和iloc 的混合）\n\n```python\n#分别利用行名与行序号返回第一条行数据\ndf.loc[101]\ndf.iloc[0]\n\n#返回df第2，4，6行的数据\ndf.iloc[[1,3,5]]\ndf.loc[[102,104,106]]\n\n#利用ix返回行名为101,103,105的记录\ndf.ix[[101,103,105]]\n\n#利用loc返回行名为[101,103,105]的记录\ndf.loc[[101,103,105]]\n```\n# 检测缺失值\n```python\nimport pandas as pd\nimport numpy  as np\ndf = pd.DataFrame([\\\n            ['frank', 'M',    np.nan], \\\n            ['mary' , np.nan, np.nan], \\\n            ['tom'  , 'M',    35], \\\n            ['ted'  , 'M',    33], \\\n            ['jean' , np.nan, 21], \\\n            ['lisa' , 'F',    20]])\ndf.columns = ['name', 'gender', 'age']\n```\n\n## 数据操作\n- 判断df的gender列每个单元格是否为空\n\n```python\ndf.gender.isnull()\n```\n\n- 判断df的age列是否存在空的单元格（结果只需知道有没有存在）\n\n```python\ndf.age.isnull().any()\n```\n\n- 判断df整个数据框是否存在空的单元格（结果只需知道有没有存在）\n\n```python\ndf.isnull().values.any()\n```\n\n- 求df的age列空的单元格的总数\n\n```python\ndf.age.isnull().sum()\n```\n\n- 求df所有列空单元格的总数\n\n```\ndf.isnull().sum().sum()\n```\n\n# Imputing Missing Value\n```python\nimport pandas as pd\nimport numpy  as np\ndf = pd.DataFrame([\\\n             ['frank', 'M',    np.nan], \\\n             [np.nan , np.nan, np.nan], \\\n             ['tom'  , 'M',    35], \\\n             ['ted'  , 'M',    33], \\\n             ['jean' , np.nan, 21], \\\n             ['lisa' , 'F',    20]])\ndf.columns = ['name', 'gender', 'age']\n```\n\n- 删除\n\n```python\n#删除df具有Nan值的行\ndf.dropna()\n\n#删除df所有列均为空值的行记录\ndf.dropna(how='all')\n\n#删除df空值超过2个的行记录\ndf.dropna(thresh=2)\n#删除df的age列\n\n#删除df中整列值均为nan的列\ndf.dropna(axis=1,how='all')\n```\n\n- 增加\n\n```python\n#在df中增加一新列employee，且值为空（np.nan）\n df['employee']=np.nan\n```\n\n- 填补\n\n```python\n#填补df里任意空单元格的值为0\ndf.fillna(0)\n\n#将df的age列的均值填入该列值为空的单元格\ndf['age'].fillna(df['age'].mean())\n\n#将df的age列的空单元格，按性别填入该类性别的平均年龄值\ndf['age'].fillna(df.groupby('gender')['age'].transform('mean'))\n\n#使用向后填补方面对df的空值单元格进行填补\ndf.fillna(method='backfill')\n\n#使用向前填补对df的空值单元格进行填补\ndf.fillna(method='pad')\n```\n\n- 数据2\n\n ```python\ndf2 = pd.DataFrame([[1, 870],\\\n            [2, 900],\\\n            [np.nan, np.nan],\\\n            [4, 950],\\\n            [5,1080],\\\n            [6,1200]])\ndf2.columns = ['time', 'val']\n```\n```python\n    #使用内插法对df2进行填补\n    df2.interpolate()\n```\n\n# 实例\n- 读取数据\n\n```python\nimport pandas\ndf = pandas.read_csv('house_data.csv')\n\n#用del删除列名为'Unnamed: 0'的列\ndel df['Unnamed: 0']\ndf.head(3)\n```\n\n## 检视\n- 检视前几行资料\n\n```python\ndf.head(5)\n```\n\n- 检视后三行资料\n\n```python\ndf.tail(3)\n```\n\n- 检视DataFrame 信息\n\n```python\n#查看df所有的信息(列名，各列非空计数，数据类型)\ndf.info()\n```\n\n- 检视字段名称\n\n```python \n#查看df所有列名\ndf.columns\n```\n\n- 检视字段型态\n\n```python\n#查看df各列数据类型\ndf.dtypes\n```\n\n## 舍弃第一栏\n```python\n#将文件读取进来，命名为df，并且在读取文件同时删除第1列\ndf = pandas.read_csv('house_data.csv',index_col=0)\n```\n\n## 将\"暂无资料\"变成缺失值\n```python\n#筛选df数据框中“物业费”列的值为“暂无资料”的行记录\ndf[df['物 业 费']=='暂无资料']\n# df.ix[df['物 业 费']=='暂无资料',]\n\nimport numpy as np\n#将“物业费”列的值为“暂无资料”的单元格设置为空\ndf.loc[df['物 业 费']=='暂无资料','物 业 费']=np.nan\ndf.head(3)\n\nimport pandas\n#读取文件同时，将“暂无资料”的单元格设置为空，且去掉第一列\ndf = pandas.read_csv('house_data.csv',index_col=0,na_values='暂无资料')\ndf.head(3)\n```\n## 取得叙述性统计\n```python\n#对df各非字符串列进行描述性统计（计数，均值，标准差，最大最小，4分位等）\ndf.describe()\n```\n\n## 侦测缺失值\n```python\n#对事个数据框df每个单元格进行缺失值判断\ndf.isnull()\n```\n## 缺失值\n```python\n#对数据框各列分别进行判断，返回每列是否有缺失值\ndf.isnull().any()\n\n#对数据框df按列统计各列各有多少个缺失值\ndf.isnull().sum()\n\n#统计数据框各列缺失值与各占各列非空单元格的比例\ndf.count() # 所有非空单元格\ndf.isnull().sum()/df.count()\n```\n\n- 删除有缺失值的字段\n\n```python\n #用drop删除df的“参考月供”列数据\n df = df.drop('参考月供',axis=1)\n```\n## 筛选字段\n```python\n    #对数据框df的“产权性质”列所有出现的值进行计数\n    df['产权性质'].value_counts()\n\n    #获取产权性质为'个人产权'的行记录\n    df[df['产权性质']=='个人产权']\n\n    #查看获取产权性质为'个人产权'的行记录的前3行\n    df[df['产权性质'] == '个人产权'].head(3)\n\n    df.iloc[5:7]\n\n    #筛选'建筑面积'大于100且總價大于2000的行记录，查看第1行\n    df[(df['建筑面积']>100) & (df['總價']>2000)]\n\n    df.loc[df['建筑面积'] > 100].head(1)\n\n    #筛选产权性质为“个人产权”的行记录\n    df['产权性质']\n    df.head(3)\n\n```\n\n## 舍弃包含缺失值的字段\n```python\n#筛选建筑类别为空的行记录，并查看前3行，问，建筑类别列数据是否均为空\ndf[df['建筑类别'].isnull()]\n\n#利用dropna删除df的列,并将结果重新赋值给df（整列均为空的列）\nf.dropna(axis=1,how='all')\n```\n## 补齐缺失值\n```python\n    #对物业费为空的单元格，填补为0\n    df['物 业 费'] = df['物 业 费'].fillna(0)\n\n    #计算'總價'列为空的单元格个数\n    df['總價'].isnull().sum()\n\n    #筛选出‘總價’为空的行记录\n    df[df['總價'].isnull()]\n\n    #利用‘總價’列与‘建筑面积’列求均价\n    (df['總價'] / df['建筑面积']).mean()    \n    df['總價'].isnull().sum()\n\n    #对‘總價’列单元格为空的，按上面求的“均价”与建筑面积相乘进行计算\n    df['總價'] = df['總價'].fillna((df['總價'] / df['建筑面积']).mean()* df['建筑面积'])\n\n    #再次计算‘總價’为空的单元格个数\n    df['總價'].isnull().sum()\n```\n# 将资料写入CSV 中\n ```python\ndf.to_csv('house_final.csv', index_label=False)\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Pycharm Shortcut","path":"/posts/PycharmShortcut.html","content":"PyCharm 快捷键\n<!--more-->\n# 常用快捷键\n| 快捷键\t| 功能 |\n|:---|:---|\n|Ctrl + Q\t|快速查看文档|\n|Ctrl + F1\t|显示错误描述或警告信息|\n|Ctrl + /\t|行注释|\n|Ctrl + Alt + L\t|代码格式化|\n|Ctrl + Alt + O|\t自动导入|\n|Ctrl + Alt + I|\t自动缩进|\n|Tab / Shift + Tab\t|缩进、不缩进当前行|\n|Ctrl+C/Ctrl+Insert\t|复制当前行或选定的代码块到剪贴板|\n|Ctrl + D\t|复制选定的区域或行到后面或下一行|\n|Ctrl + Y\t|删除当前行|\n|Shift + Enter\t|下一行另起一行|\n|Ctrl +Ｊ\t|插入模版|\n|Ctrl + Numpad+/-\t|展开折叠代码块|\n|Ctrl + Numpad+\t|全部展开|\n|Ctrl + Numpad-\t|全部折叠|\n|Ctrl + Delete|\t删除到字符结束|\n|Ctrl + Backspace\t|删除到字符开始|\n|Ctrl + Shift + F7\t|将当前单词在整个文件中高亮，F3移动到下一个，ESC取消高亮|\n|Alt+Enter|import模块|\n|Alt + up/down\t|方法上移或下移动|\n|Alt + Shift + up/down\t|当前行上移或下移动|\n|Ctrl + B/鼠标左键\t|转到方法定义处|\n|Ctrl + W\t|选中增加的代码块|\n|Shift + F6\t|方法或变量重命名|\n|Ctrl + E\t|最近访问的文件\n|Esc\t|从其他窗口回到编辑窗口|\n|Shift + Esc\t|隐藏当前窗口，焦点到编辑窗口|\n|F12\t|回到先前的工具窗口|\n\n# 运行\n| 快捷键\t| 功能 |\n|:---|:---|\n|Alt + Shift + F10\t|运行模式配置|\n|Alt + Shift + F9|\t调试模式配置|\n|Shift + F10\t|运行|\n|Shift + F9\t|调试|\n|Ctrl + Shift + F10|\t运行编辑器配置|\n|Ctrl + Alt + R\t|运行manage.py任务\n\n# 调试\n| 快捷键\t| 功能 |\n|:---|:---|\n|F8\t|跳过|\n|F7\t|进入|\n|Shift + F8|\t退出|\n|Alt + F9|\t运行游标|\n|Alt + F8|\t验证表达式|\n|Ctrl + Alt + F8|\t快速验证表达式|\n|F9|\t恢复程序|\n|Ctrl + F8|\t断点开关|\n|Ctrl + Shift + F8|\t查看断点|\n\n# 编辑\n| 快捷键\t| 功能 |\n|:---|:---|\n|Ctrl + Space\t|基本的代码完成（类、方法、属性）|\n|Ctrl + Alt + Space\t|快速导入任意类|\n|Ctrl + Shift + Enter\t|语句完成|\n|Ctrl + P\t|参数信息（在方法中调用参数）|\n|Ctrl + Q\t|快速查看文档|\n|Shift + F1\t|外部文档|\n|Ctrl + 鼠标\t|简介|\n|Ctrl + F1\t|显示错误描述或警告信息|\n|Alt + Insert\t|自动生成代码|\n|Ctrl + O\t|重新方法|\n|Ctrl + Alt + T\t|选中|\n|Ctrl + /\t|行注释|\n|Ctrl + Shift + /\t|块注释|\n|Ctrl + W\t|选中增加的代码块||\n|Ctrl + Shift + W\t|回到之前状态|\n|Ctrl + Shift + ]/[\t|选定代码块结束、开始|\n|Alt + Enter\t|快速修正|\n|Ctrl + Alt + L\t|代码格式化|\n|Ctrl + Alt + O\t|自动导入|\n|Ctrl + Alt + I\t|自动缩进|\n|Tab / Shift + Tab\t|缩进、不缩进当前行|\n|Ctrl+X/Shift+Delete |剪切当前行或选定的代码块到剪贴板|\n|Ctrl+C/Ctrl+Insert\t|复制当前行或选定的代码块到剪贴板|\n|Ctrl+V/Shift+Insert|\t从剪贴板粘贴|\n|Ctrl + Shift + V\t|从最近的缓冲区粘贴|\n|Ctrl + D\t|复制选定的区域或行到后面或下一行|\n|Ctrl + Y\t|删除当前行|\n|Ctrl + Shift + J\t|添加智能线|\n|Ctrl + Enter\t|智能线切割|\n|Shift + Enter\t|下一行另起一行|\n|Ctrl + Shift + U\t|在选定的区域或代码块间切换|\n|Ctrl + Delete\t|删除到字符结束|\n|Ctrl + Backspace|\t删除到字符开始|\n|Ctrl + Numpad+/-|\t展开折叠代码块|\n|Ctrl + Numpad+\t|全部展开|\n|Ctrl + Numpad-|\t全部折叠|\n|Ctrl + F4\t|关闭运行的选项卡|\n\n# 查找/替换\n|快捷键\t| 功能 |\n|:---|:---|\n|F3 |\t下一个 |\n|Shift + F3 |\t前一个 |\n|Ctrl + R\t |替换 |\n|Ctrl + Shift + F |\t全局查找 |\n|Ctrl + Shift + R\t |全局替换 |","tags":["Windows","ArchLinux","Ubuntu","Python"],"categories":["Diary"]},{"title":"Scrapy","path":"/posts/ScrapyCommand.html","content":"Scrapy 命令\n<!--more-->\n# 安装\n```bash\nsudo pip install scrapy\n```\n\n# 创建/运行\n## 创建项目\n```python\nscrapy startproject projectName\n```\n\n## 项目 tree\n```bash\n├── scrapy.cfg  项目的配置文件\n└── zhihu  该项目的python模块。之后您将在此加入代码\n    ├── __init__.py\n    ├── items.py  项目中的 item 文件.\n    ├── middlewares.py\n    ├── pipelines.py\n    ├── __pycache__\n    ├── settings.py  项目的设置文件\n    └── spiders  放置 spider 代码的目录\n        ├── __init__.py\n        └── __pycache__\n```\n\n## 创建新的 spider\n```python\nscrapy genspider mydomain mydomain.com\n```\n\n## 运行\n```python\nscrapy crawl mydomain\n```\n\n# 项目操作\n```python\nscrapy crawl zhihu # 执行项目\nscrapy check [-l] <zhihu> # 检查错误\nscrapy list # 返回 spider 名称\nscrapy edit <zhihu> # 在命令行编辑\nscrapy fetch url # 下载网页源码\nscrapy fetch --nolog url # 无日志\nscrapy fetch --nolog --no-redirect url # 重定向\nscrapy view url # 下载网页后浏览器打开\nscrapy shell # 交互模式\nscrapy crawl user -o items.json # 保存数据（sv,xml,json,jsonlines,pickle,marshal）\n```\n\n# 选择器\n网页源码\n\n```html\n  <html>\n  <head>\n    <base href='http://example.com/' />\n    <title>Example website</title>\n  </head>\n  <body>\n    <div id='images'>\n    <a href='image1.html'>Name: My image 1 <br /><img src='image1_thumb.jpg' /></a>\n    <a href='image2.html'>Name: My image 2 <br /><img src='image2_thumb.jpg' /></a>\n    <a href='image3.html'>Name: My image 3 <br /><img src='image3_thumb.jpg' /></a>\n    <a href='image4.html'>Name: My image 4 <br /><img src='image4_thumb.jpg' /></a>\n    <a href='image5.html'>Name: My image 5 <br /><img src='image5_thumb.jpg' /></a>\n    </div>\n  </body>\n  </html>\n```\n\n交互模式下\n\n```python\ncrapy shell https://doc.scrapy.org/en/latest/_static/selectors-sample1.html\n```\n\n1. 构建一个选择器来选择title标签内的文本\n\n```python\n# xpath\nresponse.selector.xpath('//title/text()')\n# selector 可省略\nresponse.xpath('//title/text()')\n  \n# css\nresponse.css('title::text')\n```\n\n提取文本数据，必须调用selector .extract() 方法\n\n```python\nresponse.xpath('//title/text()').extract() # 所有\nresponse.css('title::text').extract_first() # 第一个\n```\n\n2. 获取属性\n\n```python\nresponse.xpath('//a/Ahref').extract()\nresponse.css('a::attr(href)').extract()\n\nresponse.css('img').xpath('@src').extract()\nresponse.xpath('//div[@id=\"images\"]/a/text()').extract_first()\n```\n\ndefault 默认返回值作为参数\n\n```python\nresponse.xpath('//div[@id=\"not-exists\"]/text()').extract_first(default='not-found')\n```\n\n3. 获取文本内容\n\n```python\nresponse.xpath('//a/text()').extract()\nresponse.css('a::text()').estract()\n```\n\n4. 模糊查找(属性名包含)\n\n```python\n# 查找三星包含image\nresponse.xpath('//a[contains(@href,\"image\")]/@href').extract()\nresponse.css('a[href* = image]::attr(href)').extract()\n\n# a 标签里面的image里的src属性\nresponse.xpath(\"//a[contains(@href,'image')]/img/@src\").extract()\nresponse.css('a[href* = image] img::attr(src)').extract()\n```\n\n\n## 嵌套选择器\n\n1. xpath,css\n\n```python\nlinks = response.xpath('//a[contains(@href, \"image\")]')\nlinks.extract()\nfor index, link in enumerate(links):\n  args = (index, link.xpath('@href').extract(), link.xpath('img/@src').extract())\n  print 'Link number %d points to url %s and image %s' % args\n```\n\n## 具有正则表达式的选择器\n```python\n  response.css('a::text').re('Name\\:(.*)') # 返回的是列表\n  response.css('a::text').re_first('Name\\:(.*)') # 第一个值\n  response.css('a::text').re_first('Name\\:(.*)').strip() # 去空格\n\n  # 提取图像名称\n  response.xpath('//a[contains(@href, \"image\")]/text()').re(r'Name:\\s*(.*)')\n\n  # 提取第一个匹配的字符串\n  response.xpath('//a[contains(@href, \"image\")]/text()').re_first(r'Name:\\s*(.*)')\n```\n\n# 定义 Item\nItem 是保存爬取到的数据的容器；其使用方法和python字典类似.\n\n- 编辑 tutorial 目录中的 items.py 文件:\n\n```python\nimport scrapy\n\nclass DmozItem(scrapy.Item):\n    title = scrapy.Field()\n    link = scrapy.Field()\n    desc = scrapy.Field()\n```\n---\n**官方文档**\n- [英文](https://docs.scrapy.org/en/latest/)\n- [中文](https://scrapy-chs.readthedocs.io/zh_CN/1.0/index.html)","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python SQL","path":"/posts/PythonSQL.html","content":"Python SQL 操作\n<!--more-->\n# MonngoDB\n## 连接\n```python\n    import pymongo\n\n    # 普通连接\n    client = MongoClient('localhost', 27017)\n    # client = MongoClient('mongodb://localhost:27017/')\n    \n    # 密码连接\n    client = MongoClient('mongodb://username:password@localhost:27017/dbname')\n    db = client.mydatabase\n    # db = client['mydatabase']\n```\n\n## 增删查改\n\n- 增(insert)\n\n```python\n    # 增加一条记录\n    person = {'name': 'zone','sex':'boy'}\n    person_id = test.insert_one(person).inserted_id\n    print(person_id)\n    \n    # 批量插入\n    persons = [{'name': 'zone', 'sex': 'boy'}, {'name': 'zone1', 'sex': 'boy1'}]\n    result = test.insert_many(persons)\n    print(result.inserted_ids)\n```\n\n- 删(delete)\n\n```python\n    import pymongo\n\n    myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")\n    mydb = myclient[\"mydatabase\"]\n    mycol = mydb[\"customers\"]\n\n    # 删除地址为“Mountain 21”的文档：\n    myquery = { \"address\": \"Mountain 21\" }\n    mycol.delete_one(myquery)\n\n    # delete_many() 删除多个\n    myquery = { \"address\": {\"$regex\": \"^S\"} }\n    x = mycol.delete_many(myquery)\n    print(x.deleted_count, \" documents deleted.\")\n```\n \n```python\n    # 删除单条记录\n    result1 = test.delete_one({'name': 'zone'})\n    pprint.pprint(result1)\n\n    # 批量删除\n    result1 = test.delete_many({'name': 'zone'})\n    pprint.pprint(result1)\n```\n\n- 改(update)\n\n```python\n    # Valley 345”更改为“Canyon 123” \n    myquery = { \"address\": \"Valley 345\" }\n    newvalues = { \"$set\": { \"address\": \"Canyon 123\" } }\n\n    mycol.update_one(myquery, newvalues)\n\n    #print \"customers\" after the update:\n    for x in mycol.find():\n        print(x)\n\n    # update_many() 更新多个\n    myquery = { \"address\": { \"$regex\": \"^S\" } }\n    newvalues = { \"$set\": { \"name\": \"Minnie\" } }\n\n    x = mycol.update_many(myquery, newvalues)\n\n    print(x.modified_count, \"documents updated.\")\n```\n\n```python\n    # 更新单条记录\n    res = test.update_one({'name': 'zone'}, {'$set': {'sex': 'girl girl'}})\n    print(res.matched_count)\n\n    # 更新多条记录\n    test.update_many({'name': 'zone'}, {'$set': {'sex': 'girl girl'}})\n```\n\n- 查(Querry)\n\n```python\n    import pymongo\n\n    myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")\n    mydb = myclient[\"mydatabase\"]\n    mycol = mydb[\"customers\"]\n\n    # 查找地址以字母“S”或更高开头的文档：\n    myquery = { \"address\": { \"$gt\": \"S\" } }\n\n    mydoc = mycol.find(myquery)\n\n    for x in mydoc:\n        print(x)\n    \n\n    # 正则表达式过滤\n    myquery = { \"address\": { \"$regex\": \"^S\" } }\n\n    mydoc = mycol.find(myquery)\n\n    for x in mydoc:\n        print(x)\n```\n\n```python\n    import pprint\n\n    # 查找多条记录\n    pprint.pprint(test.find())\n\n    # 添加查找条件\n    pprint.pprint(test.find({\"sex\": \"boy\"}).sort(\"name\"))\n```\n\n# 排序\n\n- sort()方法\n\n```python\nresults = collection.find().sort('name', pymongo.ASCENDING)\nprint([result['name'] for result in results])\n```\n\n## 示例\n```python\n    client = pymongo.MongoClient('localhost')\n    b = client['MaFengWoView']\n\n    def save_to_mongo(view):\n    if db['MaFengWoView'].insert_one(view):\n        print('Saving to MongoDB',view)\n        return True\n    return False\n\n     save_to_mongo(view)\n```\n\n# MySQL\n## 连接创建\n\n- 创建一个名为“customers”的表\n\n```python\n    import mysql.connector\n\n    mydb = mysql.connector.connect(\n    host=\"localhost\",\n    user=\"yourusername\",\n    passwd=\"yourpassword\",\n    database=\"mydatabase\"\n    )\n\n    mycursor = mydb.cursor()\n\n    mycursor.execute(\"CREATE TABLE customers (name VARCHAR(255), address VARCHAR(255))\")\n```\n\n- 检查表是否存在\n\n```python\n    mycursor = mydb.cursor()\n\n    mycursor.execute(\"SHOW TABLES\")\n\n    for x in mycursor:\n        print(x)\n```\n\n- 创建表时创建主键(存在用ALTER TABLE)\n\n```python\n    import mysql.connector\n\n    mydb = mysql.connector.connect(\n    host=\"localhost\",\n    user=\"yourusername\",\n    passwd=\"yourpassword\",\n    database=\"mydatabase\"\n    )\n\n    mycursor = mydb.cursor()\n\n    mycursor.execute(\"CREATE TABLE customers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), address VARCHAR(255))\")\n```\n\n# 插入\n\n- 单行\n\n```python\n    mycursor = mydb.cursor()\n\n    sql = \"INSERT INTO customers (name, address) VALUES (%s, %s)\"\n    val = (\"John\", \"Highway 21\")\n    mycursor.execute(sql, val)\n\n    mydb.commit()\n\n    print(mycursor.rowcount, \"record inserted.\")\n```\n\n- 多行\n\n```python\n    mycursor = mydb.cursor()\n\n    sql = \"INSERT INTO customers (name, address) VALUES (%s, %s)\"\n    val = [\n        ('Peter', 'Lowstreet 4'),\n        ('Amy', 'Apple st 652'),\n        ('Hannah', 'Mountain 21'),\n        ('Michael', 'Valley 345'),\n        ('Sandy', 'Ocean blvd 2'),\n        ('Betty', 'Green Grass 1'),\n        ('Richard', 'Sky st 331'),\n        ('Susan', 'One way 98'),\n        ('Vicky', 'Yellow Garden 2'),\n        ('Ben', 'Park Lane 38'),\n        ('William', 'Central st 954'),\n        ('Chuck', 'Main Road 989'),\n        ('Viola', 'Sideway 1633')\n        ]\n\n    mycursor.executemany(sql, val)\n\n    mydb.commit()\n\n    print(mycursor.rowcount, \"was inserted.\")\n```\n\n## Select\n\n- 所有\n\n```python\n    mycursor = mydb.cursor()\n\n    mycursor.execute(\"SELECT * FROM customers\")\n\n    myresult = mycursor.fetchall()\n\n    for x in myresult:\n        print(x)\n```\n\n- 列\n\n```python\n    mycursor = mydb.cursor()\n\n    mycursor.execute(\"SELECT name, address FROM customers\")\n\n    myresult = mycursor.fetchall()\n\n    for x in myresult:\n         print(x)\n```\n---\n**参考**\n- [官方文档](https://api.mongodb.com/python/current/tutorial.html)\n- [W3School](https://www.w3schools.com/python/python_mongodb_drop_collection.asp)\n- [zone](https://juejin.im/post/5be245b251882516bc477aae)","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Qunar","path":"/posts/Qunar.html","content":"Selenium Qunar.com\n<!---more-->\n# 修改版\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import WebDriverException,TimeoutException\nfrom pyquery.pyquery import PyQuery as pq\nfrom bs4 import BeautifulSoup\nimport time\nimport pymongo\n\ndriver = webdriver.Chrome()\nwait = WebDriverWait(driver,10)\n\nclient = pymongo.MongoClient('localhost')\ndb = client['Qunar']\n\ndef lastPage(url):\n    driver.get(url)\n    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.next')))\n    html = driver.page_source\n    soup = BeautifulSoup(html,'lxml')\n    total = int(soup.select('.pager a')[-2].text)\n    return total\n\ndef search_next(page):\n    next = driver.find_element_by_css_selector('.next')\n    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.next')))\n    next.click()\n    wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pager em'),str(page)))\n    time.sleep(1)\n\ndef get_url():\n    doc = pq(driver.page_source)\n    doc = doc.find('.sight_item_caption')\n    li = []\n    for box in doc.items():\n        url = 'http://piao.qunar.com'+str(box.find('.name').attr('href'))\n        li.append(url)\n    return li\n\ndef get_comment_last(url):\n    # 评论总页数\n    driver.get(url)\n    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.mp-pager-next.mp-pager-item')))\n    doc = pq(driver.page_source)\n    doc = doc.find('#pageContainer')\n    li = [i.text() for i in doc.find('.mp-pager-item').items()]\n    return int(li[-2])\n\ndef get_comment_next(page):\n    try:\n        next = driver.find_element_by_css_selector('.mp-pager-next.mp-pager-item')\n        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.mp-pager-next.mp-pager-item')))\n        next.click()\n        wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.mp-pager em'),str(page)))\n        time.sleep(1)\n    except TimeoutException:\n        get_comment_next(page)\n    except WebDriverException:\n        get_comment_next(page)\n\ndef get_comments():\n    doc = pq(driver.page_source)\n    doc = doc.find('.mp-comments-list')\n    for item in doc.find('.mp-comments-item').items():\n        usr = item.find('.mp-comments-username').text()\n        date = item.find('.mp-comments-time').text()\n        comment = item.find('.mp-comments-desc').text()\n        view = {\n            'user':usr,\n            'date':date,\n            'comment':comment\n        }\n        save_to_mongo(view)\n\ndef save_to_mongo(view):\n    if db['comment'].insert_one(view):\n        print('Saving to MongoDB',view)\n        return True\n    return False\n\ndef main():\n    url = 'http://piao.qunar.com/ticket/list_%E6%88%90%E9%83%BD.html#from=home_remen&in_track=qunar_djmp_gnmdd_%E6%88%90%E9%83%BD'\n    total = lastPage(url)\n    all_url = get_url()\n    for i in range(2,total+1):\n        search_next(i)\n        all_url.extend(get_url())\n\n    for url in all_url:\n        total = get_comment_last(url)\n        get_comments()\n        for i in range(2,total+1):\n            get_comment_next(i)\n            get_comments()\n\n\nif __name__ == '__main__':\n    main()\n```\n\n# 自动获取页数\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time    : 18-11-20 上午11:53\n# @Author  : Vitan\n# @File    : Qunar.py\n\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import WebDriverException,NoSuchElementException,TimeoutException\nfrom pyquery.pyquery import PyQuery as pq\nimport pymongo\nimport re\n\ndriver = webdriver.Chrome()\nwait = WebDriverWait(driver,10)\n\nclient = pymongo.MongoClient('localhost')\ndb = client['Qunar']\n\ndef lastPage():\n    try:\n        url = 'http://piao.qunar.com/ticket/list_%E6%88%90%E9%83%BD.html?keyword=%E6%88%90%E9%83%BD&page=1#from=home_remen&in_track=qunar_djmp_gnmdd_%E6%88%90%E9%83%BD'\n        driver.get(url)\n        doc = pq(driver.page_source)\n        doc = str(doc.find('.pager'))\n        pattern = re.compile('<div.*?<a.*?data-pager-pageno=\"63\">(\\d+)</a>', re.S)\n        result = re.match(pattern, doc)\n        total = int(result.group(1))\n        print(total)\n        return total\n    except TimeoutException:\n        return total\n\ndef get_url():\n    doc = pq(driver.page_source)\n    doc = doc.find('.sight_item_caption')\n    li = []\n    for box in doc.items():\n        url = 'http://piao.qunar.com'+str(box.find('.name').attr('href'))\n        li.append(url)\n    return li\n\ndef get_comment_last():\n    # 评论总页数\n    doc = pq(driver.page_source)\n    doc = doc.find('#pageContainer')\n    li = [i.text() for i in doc.find('.mp-pager-item').items()]\n    return int(li[-2])\n\ndef get_comment_next(i):\n    try:\n        next = driver.find_element_by_css_selector('.mp-pager-next.mp-pager-item')\n        next.click()\n        wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pager em'),str(i)))\n    except TimeoutException:\n        get_comment_next(i)\n    except WebDriverException:\n        get_comment_next(i)\n\ndef get_page_comments():\n    doc = pq(driver.page_source)\n    doc = doc.find('.mp-comments-list')\n    for item in doc.find('.mp-comments-item').items():\n        usr = item.find('.mp-comments-username').text()\n        date = item.find('.mp-comments-time').text()\n        comment = item.find('.mp-comments-desc').text()\n        view = {\n            'user':usr,\n            'date':date,\n            'comment':comment\n        }\n        print(view)\n        save_to_mongo(view)\n\ndef get_all_url():\n    # 所有景点 Url\n    driver.execute_script('window.open()')  # 打开新的选项卡\n    driver.switch_to.window(driver.window_handles[1])\n    total = lastPage()\n    driver.switch_to.window(driver.window_handles[0])\n    all_url = []\n    for i in range(1, total - 60):\n        url = 'http://piao.qunar.com/ticket/list_%E6%88%90%E9%83%BD.html?keyword=%E6%88%90%E9%83%BD&page=' + str(\n            i) + '#from=home_remen&in_track=qunar_djmp_gnmdd_%E6%88%90%E9%83%BD'\n        driver.get(url)\n        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.next')))\n        all_url.extend(get_url())\n        print(all_url)\n    return all_url\n\ndef get_allcomment_url():\n    all_url = get_all_url()\n    # 景点所有评论\n    for url in all_url:\n        driver.get(url)\n        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.mp-pager-next.mp-pager-item')))\n        total = get_comment_last()  # 评论页数\n        get_page_comments()\n        print(total)\n        for i in range(2, total + 1):\n            get_comment_next(i)\n            get_page_comments()\n\ndef save_to_mongo(view):\n    if db['comment'].insert_one(view):\n        print('Saving to MongoDB',view)\n        return True\n    return False\n\ndef main():\n    get_allcomment_url()\n    get_page_comments()\n\nif __name__ == '__main__':\n    main()\n```\n#  手动设置页数\n```Python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time    : 18-11-20 上午11:53\n# @Author  : Vitan\n# @File    : Qunar.py\n\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import WebDriverException,NoSuchElementException,TimeoutException\nfrom pyquery.pyquery import PyQuery as pq\nimport pymongo\nimport re\n\ndriver = webdriver.Chrome()\nwait = WebDriverWait(driver,10)\n\nclient = pymongo.MongoClient('localhost')\ndb = client['Qunar']\n\ndef get_url():\n    doc = pq(driver.page_source)\n    doc = doc.find('.sight_item_caption')\n    li = []\n    for box in doc.items():\n        url = 'http://piao.qunar.com'+str(box.find('.name').attr('href'))\n        li.append(url)\n    return li\n\ndef get_comment_last():\n    # 评论总页数\n    doc = pq(driver.page_source)\n    doc = doc.find('#pageContainer')\n    li = [i.text() for i in doc.find('.mp-pager-item').items()]\n    return int(li[-2])\n\ndef get_comment_next(i):\n    try:\n        next = driver.find_element_by_css_selector('.mp-pager-next.mp-pager-item')\n        next.click()\n        wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pager em'),str(i)))\n    except TimeoutException:\n        get_comment_next(i)\n    except WebDriverException:\n        get_comment_next(i)\n\ndef get_page_comments():\n    doc = pq(driver.page_source)\n    doc = doc.find('.mp-comments-list')\n    for item in doc.find('.mp-comments-item').items():\n        usr = item.find('.mp-comments-username').text()\n        date = item.find('.mp-comments-time').text()\n        comment = item.find('.mp-comments-desc').text()\n        view = {\n            'user':usr,\n            'date':date,\n            'comment':comment\n        }\n        print(view)\n        save_to_mongo(view)\n\n\ndef save_to_mongo(view):\n    if db['comment'].insert_one(view):\n        print('Saving to MongoDB',view)\n        return True\n    return False\n\ndef main():\n    # 所有景点 Url\n    all_url = []\n    for i in range(1,2):\n        url = 'http://piao.qunar.com/ticket/list_%E6%88%90%E9%83%BD.html?keyword=%E6%88%90%E9%83%BD&page='+ str(i) +'#from=home_remen&in_track=qunar_djmp_gnmdd_%E6%88%90%E9%83%BD'\n        driver.get(url)\n        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.next')))\n        all_url.extend(get_url())\n\n    # 景点所有评论Url\n    for url in all_url:\n        driver.get(url)\n        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.mp-pager-next.mp-pager-item')))\n        total = get_comment_last() # 评论页数\n        print(total)\n        get_page_comments()\n        for i in range(2,total+1):\n            get_comment_next(i)\n            get_page_comments()\n\n\nif __name__ == '__main__':\n    main()\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"读写 Excel 文件","path":"/posts/PythonExcel.html","content":"读写 Excel\n<!--more-->\n\n# 读 Excel\n```python\nimport xlrd\ndef read_file('file.xlsx'):\ndata = xlrd.open_workbook(url)\ntable = data.sheets()[0] # 打开第一张表\nnrows = table.nrows # 获取表的行数\nfor i in range(nrows): # 循环逐行打印\n   print(table.row_values(i)[1:])\n```\n# 写 Excel\n```python\nimport xlwt\ndata = xlrd.open_workbook('excelFile.xls')\nexcel = copy(data)                                       \n\n#使用wlrd的方法获取已有的的行数\nrows = data.sheet()[num].nrows                  \n#获得要操作的sheet\ntable = excel.get_sheet(num)                      \nfor value in n:\n  #xlwt的写方法，参数为行，列，值，行\n  table.write(rows,num1,value)  \n  num1 = num1+1 \n\nexcel.save(name)      \n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Pandas","path":"/posts/PythonPandas.html","content":"Python  Data.Frame\n<!--more-->\n# panadas\n## 导入数据\n```python\nimport pandas as pd\ndata = pandas.read_excel('file.xlsx')\ndata = pandas.read_csv('file.csv')\n```\n\n- 查看前10行\n\n```python\nprint(data.head[10])\n```\n\n- 数据集中有多少个列(columns)\n\n```python\nprint(data.shape[1])\n```\n\n- 打印出全部的列名称\n\n```python\nprint(data.columns)\n```\n\n- 数据集的索引\n\n```python\nprint(data.index)\n```\n- panadas.DataFrame 构造函数\n\n```python\npandas.DataFrame( data, index, columns, dtype, copy)\n```\n\n|参数\t|描述|\n|:---|:---|\n|data\t|数据采取各种形式，如ndarray：series，map，lists，dict， ，constant和另一个DataFrame|\n|index|\t对于行标签，要用于结果帧的索引是可选缺省值np.arrange(n)，如果没有传递索引值|\n|columns|\t对于列标签，可选的默认语法是 - np.arange(n)。这只有在没有索引传递的情况下才是这样|\n|dtype\t|每列的数据类型|\n|copy\t|如果默认值为False，则此命令（或任何它）用于复制数据|\n\n# 创建数据帧\n## 列表创建数据框\n\n- 空数据帧 \n\n```python\n # 空数据帧 \nimport pandas as pd\ndf = pd.DataFrame()\nprint(df)\n```\n\n- 有数据   \n\n```python\nimport pandas as pd\ndata = [1,2,3,4,5]\ndf = pd.DataFrame(data)\nprint(df)\n```\n\n- 有表头\n\n```python\nimport pandas as pd\ndata = [['Alex',10],['Bob',12],['Clarke',13]]\ndf = pd.DataFrame(data,columns=['Name','Age'])\nprint(df)\n```\n  - df = pd.DataFrame(data,columns=['Name','Age'],dtype=float)(设置数据类型)\n\n## 从ndarrays /列表的字典来创建数据帧\n```python\nimport pandas as pd\ndata = {'Name':['Tom', 'Jack', 'Steve', 'Ricky'],'Age':[28,34,29,42]}\ndf = pd.DataFrame(data)\nprint(df)\n```\n  - 所有的ndarrays必须具有相同的长度。如果传递了索引（index），则索引的长度应等于数组的长度。如果没有传递索引，则默认情况下，索引将为range(n)，其中n为数组长度。\n\n## 数组创建一个索引的数据帧（DataFrame）\n```python\nimport pandas as pd\ndata = {'Name':['Tom', 'Jack', 'Steve', 'Ricky'],'Age':[28,34,29,42]}\ndf = pd.DataFrame(data, index=['rank1','rank2','rank3','rank4'])\nprint(df)\n```\n\n## 字典列表来创建数据帧\n```python\nimport pandas as pd\ndata = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]\ndf = pd.DataFrame(data)\nprint(df)\n```\n\n- 字典，行索引和列索引列表创建数据帧\n\n```python\nimport pandas as pd\ndata = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]\n\n#With two column indices, values same as dictionary keys\ndf1 = pd.DataFrame(data, index=['first', 'second'], columns=['a', 'b'])\n\n#With two column indices with one index with other name\ndf2 = pd.DataFrame(data, index=['first', 'second'], columns=['a', 'b1'])\n```\n\n# 从系列的字典来创建\n```python\nimport pandas as pd\n\nd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),\n        'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}\n\ndf = pd.DataFrame(d)\n```\n\n- 字典的系列可以传递以形成一个DataFrame。 所得到的索引是通过的所有系列索引的并集。\n\n# 列操作\n## 列选择\n```python\nimport pandas as pd\n\nd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),\n        'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}\n\ndf = pd.DataFrame(d)\nprint(df ['one'])\n```\n\n## 列添加\n```python\nimport pandas as pd\n\nd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),\n        'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}\n\ndf = pd.DataFrame(d)\n\n# Adding a new column to an existing DataFrame object with column label by passing new series\n\nprint (\"Adding a new column by passing as Series:\")\ndf['three']=pd.Series([10,20,30],index=['a','b','c'])\nprint(df)\n\nprint (\"Adding a new column using the existing columns in DataFrame:\")\ndf['four']=df['one']+df['three']\n\nprint(df)\n```\n\n## 列删除\n```python\n# Using the previous DataFrame, we will delete a column\n# using del function\nimport pandas as pd\n\nd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), \n  'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd']), \n  'three' : pd.Series([10,20,30], index=['a','b','c'])}\n\ndf = pd.DataFrame(d)\nprint (\"Our dataframe is:\")\nprint(df)\n\n# using del function\nprint (\"Deleting the first column using DEL function:\")\ndel df['one']\nprint(df)\n\n# using pop function\nprint (\"Deleting another column using POP function:\")\ndf.pop('two')\nprint(df)\n```\n\n# 行操作\n## 行选择\n```python\nimport pandas as pd\n\nd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), \n    'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}\n\ndf = pd.DataFrame(d)\nprint(df.loc['b'])\n```\n## 按整数位置选择\n```python\nimport pandas as pd\n\nd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),\n    'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}\n\ndf = pd.DataFrame(d)\nprint(df.iloc[2])\n```\n\n## 行切片\n```python\nmport pandas as pd\n\nd = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), \n    'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}\n\ndf = pd.DataFrame(d)\nprint(df[2:4])\n```\n\n## 附加行\n```python\nimport pandas as pd\n\ndf = pd.DataFrame([[1, 2], [3, 4]], columns = ['a','b'])\ndf2 = pd.DataFrame([[5, 6], [7, 8]], columns = ['a','b'])\n\ndf = df.append(df2)\n```\n\n## 删除行\n```python\nimport pandas as pd\n\ndf = pd.DataFrame([[1, 2], [3, 4]], columns = ['a','b'])\ndf2 = pd.DataFrame([[5, 6], [7, 8]], columns = ['a','b'])\n\ndf = df.append(df2)\n\n# Drop rows with label 0\ndf = df.drop(0)\n```\n\n---\n**Via**\n- [Pandas数据帧（DataFrame）](https://www.yiibai.com/pandas/python_pandas_dataframe.html)","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"CSS 选择器","path":"/posts/CSSselector.html","content":"Css 选择器与权重\n<!--more-->\n# 引入 CSS\n\n## 行间引入\n```css\n<div style = \"width:100px;height:100px;>\n</div>\n ```\n## 页面级引入(内嵌式)\n- `<head>` 和 `</head>` 之间\n\n```css\n    <style type=\"css/text\">\n    .text{\n        font-size: 20px;\n        padding-left: o;\n        margin: 0 auto;\n    } \n    </style> \n ```\n\n## 导入式\n\n1. 在style元素中导入CSS文件\n\n```css\n<style type=\"text/css\">    \n@import \"CSS样式文件的绝对地址\";\n@import url(\"样式文件的绝对地址\");\n</style>        \n```\n2. 在CSS文件中再导入CSS文件\n\n```css\n/*某个CSS文件*/\n@import \"另一个CSS文件的地址\";\n.test{\n   width: 100px;\n   height: 100px;\n   line-height: 20px;\n   background-color: red; \n}\n```\n\n## 链接式\n- 网页的 `<head></head>` 标签对中使用`<link>` 标记来引入外部样式表文件\n\n```css\n<link type=\"text/css\" rel=\"stylesheet\" href=\"CSS样式文件的地址\">\n ```\n# 选择器\n## 基础选择器\n|选择器|\t含义|\t实例|\n|:--- |:--- |:---|\n|*\t|通用选择器，匹配任何元素|\t*{font-size:16px;}|\n|E\t|标签选择器，匹配所有使用E标签的元素|\tp{font-family:arial;}|\n|.error\t|class选择器，匹配所有class属性中包含error的元素|\t.error{font-weight:bold;}|\n|#correct\t|id选择器，匹配所有id属性值为correct的元素|\t#correct{font-style:italic;}|\n\n\n- id(唯一)\n\n```html\n<div id=\"only>\n123\n</div>\n ```\n```css\n#only{\n   background-color: red;\n  }\n```\n\n- class\n\n```html\n<div class=\"only>\n123\n</div>\n```\n```css\n.only{\n  background-color: red;\n}\n```\n  - 可以有多个 class\n\n## 标准选择器\n- 会选择所有相同元素\n\n```html\n<div>123\n</div>\n...\n<span>123\n```\n```css\ndiv {\n  background-color: red;\n}\nspan{\n   background-color: green;\n }\n```\n\t\n\n通配符选择器 \n- 会匹配所有的元素\n\n```html\n<div></div>\n...\n<span></span>\n```\n```css\n*{\n  margin:0px;\n  padding:0px;\n}\n```\n\n## 组合选择器\n|选择器|\t含义|\t实例|\n|:--- |:--- |:---|\n|E,F\t|多元素选择器，同时匹配所有E元素或F元素|\tdiv,p{background-attachment:fixed;}|\n|E F\t|后代元素选择器，匹配所有属于E元素的后代F元素\t|div a{background-color:blue;}|\n|E > F\t|子元素选择器，匹配所有E元素的子元素F\t|div>p{background-image:url(xxx.gif)}|\n|E+F\t|毗邻元素选择器，匹配所有紧随E元素之后的同级元素F\t|p+div{background-position:x% y%}|\n\n\n- 父子选择器/派生选择器\n\n```html\n<div>\n    <span>\n    </span>\n</div>\n```\n```css\ndiv span{\n   background-color: red;\n}\n```\n\n- 直接子元素选择器\n\n```html\n<div>\n   <em>134</em>\n    <strong>\n         <em>323</em>\n    </strong>\n</div>\n```\n```css\ndiv > em{\n    background-color: green;\n}\n```\n\n- 并列选择器\n\n```html\n<div>1</div>\n<div class =\"demo\">2</div>\n<p class = \"demo1\">3</p>\n```\n```css\ndiv.demo{\n   background-color: green;\n}\n```\n\n- 分组选择器\n\n```html\n<em>1</em>\n<strong>2</strong>\n<spam>3</spam>\n```\n```css\nem,\nstrong,\nspan{\n   background-color: red;\n}\n    ```\n## 伪类选择器\n|选择器 |\t含义 |\n|:--- |:--- |\n|E:first-child\t |匹配父元素E下的第一个子元素 |\t\n|E:link\t |\t匹配所有未被点击的链接 |\n|E:visited\t |\t匹配所有已被点击的链接 |\n|E:active\t |\t匹配鼠标已经按下、还没有释放的E元素 |\n|E:hover\t |\t匹配鼠标悬停其上的E元素 |\n|E:focus\t |\t匹配获得当前焦点的E元素 |\n|E:lang(c)\t |\t匹配lang属性等于c的E元素 |\n\n## 属性选择器\n|选择器|\t含义|\t实例|\n|:--- |:--- |:---|\n|E[att]\t|匹配所有具有att属性的E元素|\tp[style]{background-repeat:repeat-y;}|\n|E[att=val]|\t匹配所有att属性等于“val”的E元素\t|div[class=\"c1\"]|\n|E[att~=val]\t|匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素|\tdiv[class~=c2]|\nE[att｜=val]|\t匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以“val”开头的E元素|\tp[lang｜=en]|\n\n ## 伪元素\n|选择器|\t含义|\t实例|\n|:--- |:--- |:---|\n|E:first-line\t|匹配E元素的第一行\t|p:first-line{color:red;}|\n|E:first-letter\t|匹配E元素的第一个字母|\t.c1:first-letter{color:blue;}|\n|E:before\t|在E元素之前插入生成的内容|\t.ctn before{content:\"\";display:block;;height:40px;width:40px;}|\n|E:after\t|在E元素之后插入生成的内容|\t.ctn after{content:\"\";display:block;;height:40px;width:40px;}   |\n\n\n# 选择器的权重\n- !important > 行间样式 > id > class | 属性 > 标签选择器 > 通配符\n\n|选择器 | 权重 |\n|:--- |:---: |\n|!important|Infinity|\n|行间样式|100|\n|id|100|\n|class、属性、伪累|10|\n|标签、伪属性|1|\n|通配符|0|\n\n## 权重的计算\n1. 在比较样式的优先级时，只需统计选择符中的id、class和标签名的个数，然后把相应的权值相加即可，最后根据结果排出优先级\n2. 权值较大的优先级越高，权值相同的，后定义的优先级较高，样式值含有`！important`，优先级最高\n\t- div .class1 #people 的权值等于 1+10+100=111\n\n\n# 颜色的三种方法\n## 纯英文单词\n ```css\ncolor: red\n```\n\n## 十六进制颜色\n`＃RRGGBB`，其中 RR（红色），GG（绿色）和 BB（蓝色）。所有值必须介于0和FF之间。\n```css\n color: #ff4040\n```\n- 两位相同可以缩写\n\n```css\n color: # f40;\n```\n\n## RGB\nRGB（红，绿，蓝）。每个参数（红色，绿色和蓝色）定义颜色的亮度，可在0和255之间，或一个百分比值（从0％到100％）之间的整数。\n```css\nbackground-color:rgba(255,0,0,0.5);\n```\n\n---\n**参考**\n- [W3School](https://www.w3cschool.cn/css/css-selector.html)\n- [CSS选择器与优先级浅析](https://www.jianshu.com/p/a53ba8e1fe72)","tags":["HTML","CSS","Web"],"categories":["Coding"]},{"title":"HTML 常用标签","path":"/posts/HTMLTag.html","content":"HTML 标签\n<!--more-->\n# 什么是HTML\nHyper Text Markup Language，超级文本标记语言\n- 普通文本a:无特殊意义,超级文本<a>:超链接\n- 超文本：文本具备特殊的功能\n- 标记：超文本的组成形式<a>\n- 语言：拥有自己的语法结构\n\n# HTML基础语法\n## 标记语法\n标记以封闭类型划分：\n1. 封闭类型标记.也称双标记，必须成对出现\n<标记>内容</标记>\n2. 非封闭类型的标记,也叫做空标记/单标记\n<标记> 或 <标记/>\n\n例如：\n```html\n<a  href=“www.baidu.com” id=“baidu-link”>标签内容</a>\n```\n- a 为标签名，也叫元素；\n- href，id为属性；\n-  双引号中的值为属性值\n\n## 元素\n指尖括号及尖括号间所包围的内容部分\n元素可以包含文本内容和其他元素，也可以是空的\na. 包含文本内容：\n```html\n<p>这是一段文本</p>\n```\nb. 元素嵌套：形成更为复杂的语法\n```html\n<div>\n  <p></p>\n</div>\n```\n  - 注意:（1）嵌套顺序；（2）代码缩进（保证代码可读性）\n\nc.空标记<b></b>\n\n## 属性和值\n属性是用来修饰元素的 <标记 属性=\"值\" 属性=\"值\">\n```html\n<p align=\"center\" id=\"p1\"></p>\n```\n- 常用的标准属性\n    - id： 定义元素在页面中的唯一标识\n    - title：鼠标移入到元素上时提示的文本\n    - class：样式相关，定义元素引用的类选择器\n    - style：样式相关，定义元素的行内样式\n\n## 注释\n在源码中编写，但不会被浏览器所解释的内容，成为注释.可以将对代码的解释说明放在注释中\n```html\n <!--  注释内容  -->\n```\n\n## 文档结构\n- 文档类型声明\n    - 指定HTML的版本和风格`<!DOCTYPE html>`\n- HTML页面\n  表示HTML页面的开始与结束\n\n语法\n```html\n<html></html>\n```\n - 位于<!doctype html>之下\n\n# HTML页面\n- 包含页面头部和页面主体两部分\n\n## 页面头部：定义页面全局信息\n```html\n<head></head>\n```\n  - 紧跟在html之后，是html中的首个子元素\n\n  - 头部所包含的内容（子元素）\n    - 网页标题：`<title>标题内容</title>`\n    - 定义网页的编码格式,关键字，描述\n        - 网页的编码格式：`<meta charset=\"utf-8\">`\n        - 关键字：`<meta name=\"keywords\" content=\"关键字\">`\n        - 描述：`<meta name=\"description\" content=\"描述内容\">`\n- 定义或引用javascript：`<script></script>`\n- `<style></style>`定义内部样式\n-` <link>`引入外部样式\n\n## 页面主体：网页显示的主体内容\n```html\n<body></body>\n```\n- 属性\n    - text：表示文本颜色S\n    - bgcolor：表示网页的背景颜色\n\n## 简单完整写法如下\n```html\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"utf-8\"/>\n    <title>页面名称</title>\n    <link rel=”stylesheet“ type=\"text/css\" href=\"文件路径\"/>\n    <style>样式</style>\n    <script>js脚本</script>\n</head>\n    <body>\n        <div>\n            <p></p>\n        </div>\n    </body>\n</html>\n```\n# 常用标签及属性\n## 分区元素\n### 块分区元素\n- div ，标签用于组合其他HTML元素，本身无实在意义。\n\n```html\n<body>\n    <div id=\"wrap\">\n        <div id=\"collapsed\"></div>\n        <div id=\"expanded\"></div>\n        /div>\n</body>\n```\n\n### 行内分区元素\n```html\n<span></span>\n```\n- 特点 多个元素在一行内显示\n- 作用 设置同一行文字内的不同格式\n\n# 标题\n```html\n<h1>H1</h1>\n<h2>H2</h2>\n            ...\n<h3>H3</h3>\n<h4>H4</h4>\n```\n- 改变字号（一级最大，六级最小, 加粗显示,上下有垂直的空白距离,独立成行\n\n# 链接\n## 超链接\n```html\n<a href = \" https://vitan.me\">Vitan</a>\n```\n- 属性\n    - href：链接地址\n    - target：目标，打开新网页的形式\n- 取值：\n    -  _blank：在新标签页中打开\n    -  _self：在自身页面中打开（默认值）\n    -  title：鼠标放到链接上的提示\n\n## Anchor(锚点)\n```html\n<a href=\"123.html#001\">跳到001</a> \n...文字省略 \n<a name=\"001\" id=\"001\" > </a> \n...文字省略 \n```\n\n## 电话邮件\n```html\n<!-- 点击后直接拨打 10086 -->\n<a href=\"tel:10086\">10086</a>    \n\n<!-- 点击后直接给qq6@qq.com发邮件，主题为：TestObject        -->\n<a href=\"mailto:qq@qq.com?subject=TestObject\">qq@qq.com</a>     \n\n<!-- 点击后直接给10086发信息，消息内容默认为message_body -->\n<a href=\"sms:10086?body=message_body\">给 10086 发短信</a>   \n   \n<!-- 点击后直接发送自己的位置 -->\n<a href=\"geopoint:116.281469,39.866035\">我的位置</a>   \n```\n\n## 协议限定符\n```html\n<a href = \"javascript:while(1){alert('嘻嘻嘻')}\">点我呀</a>\n```\n\n# 图片\n```html\n<img src=\"url\" alt=\"some_text\">\n```\n- url 可为网络，绝对路径，相对路径链接\n- width：图像宽度\n- height：图像高度\n\n## alt 属性\n- 图片占位符，浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。\n```html\n<img src=\"boat.gif\" alt=\"Big Boat\">\n```\n\n## title 属性\n- 图片提示符\n```html\n<img src=\"boat.gif\" title=\"Big Boat\">\n```\n\n# 列表\n## ol(有序列表)\n```html\n<ol type = \"1\" reversed = \"reversed\" start = “2”>\n    <li>Apple</li>\n    <li>Banana</li>\n</ol>\n ```\n- tpye\n    - 1 阿拉伯数字\n    - a 小写英文字母\n    - A 大写英文字母\n    - i 小写罗马数字\n    - I 大写罗马数字\n- reversd 倒叙\n- start 从第几个开始\n\n## ul(无序列表)\n```htnl\n<ul type = \"disc\">\n        <li>Apple</li>\n    <li>Banana</li>\n</ul>\n ```\n- type\n    - disc 实心圆\n    - square 方形\n    - circle 圆\n\n\n## 自定义列表\n```html\n<dl>\n    <dt>Coffee</dt>\n        <dd>- black hot drink</dd>\n    <dt>Milk</dt>\n        <dd>- white cold drink</dd>\n</dl>\n```\n\n# 表格\n```html\n<table border=\"1\">\n    <tr>\n        <td>row 1, cell 1</td>\n        <td>row 1, cell 2</td>\n    </tr>\n    <tr>\n        <td>row 2, cell 1</td>\n        <td>row 2, cell 2</td>\n    </tr>\n</table>\n```\n- border 不定义边框属性，表格将不显示边框\n- width ：设置表格的宽度\n- height：设置表格的高度\n- align：设置表格的对齐方式，取值: left/center/right\n- border：设置表格边框宽度\n- cellpadding：内边距（单元格边框与内容之间的距离）\n- cellspacing：外边距（单元格之间的距离）\n- bgcolor：设置表格的背景颜色\n\n### 包含的子元素：\n- `<tr></tr> `（创建表行）\n    - 属性\n        - align：该行内容水平对齐方式，取值: left/center/right\n        - valign：该行内容的垂直对齐方式，取值: top/middle/bottom\n        - bgcolor：设置表格的背景颜色\n\n-  `<td></td>` （创建单元格）\n    - 属性\n        - align：内容水平对齐方式\n        - valign：内容垂直对齐方式\n        - width ：宽度\n        - height ：高度\n- `<caption></caption>` （表格标题）\n- <th></th> （列标题）\n    - 行标题或列标题，字体有加粗的效果，放在tr中\n- `<thead></thead> `（表头）\n- `<tbody></tbody>` 表主体）\n- `<tfoot></tfoot>` （表尾）\n\n\n## 表格表头\n```html\n<table border=\"1\">\n    <tr>\n        <th>Header 1</th>\n        <th>Header 2</th>\n    </tr>\n    <tr>\n        <td>row 1, cell 1</td>\n        <td>row 1, cell 2</td>\n    </tr>\n    <tr>\n        <td>row 2, cell 1</td>\n        <td>row 2, cell 2</td>\n    </tr>\n</table>\n```\n\n# 表单\n- 表单元素是允许用户在表单中输入内容,比如：`文本域(textarea)`、`下拉列表`、`单选框(radio-buttons)`、`复选框(checkboxes)`等等。表单使用表单标签 <form> 来设置:\n```html\n<form>\n.\ninput 元素\n.\n</form>   \n```\n\n## 常用的表单控件\n|控件名|code|\n|:---|:---|\n|文本框|`<input type=\"text\">`|\n|密码框|`<input type=\"password\">`,专属属性:maxlength：限制输入的字符数，取值：数字，readonly：设置文本控件只读|\n|单选按钮|`<input type=\"radio\">`|\n|复选框|`<input type=\"checkbox\">`,专属属性:checked，设置默认被选中|\n|提交按钮|`<input type=\"submit\">`|\n|重置按钮|`<input type=\"reset\">`|\n|普通按钮|`<input type=\"button\">`|\n|图片按钮|`<input type=\"image\" src=\"\">` |\n|隐藏域|`<input type=\"hidden\">`|\n|文件选择框|`<input type=\"file\">`|\n\n\n## 文本域 Text Fields\n- `<input type=\"text\"> `标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。\n```\n<form>\n    First name: <input type=\"text\" name=\"firstname\"><br>\n\n    <!-- 密码字段通过标签<input type=\"password\"> 来定义-->\n    UserName: <input type=\"text\" name=\"username\"><br>\n    Password: <input type=\"passord\" name=\"password\">\n</form>\n```\n\n## 单选按钮 Radio Buttons\n-  `<input type=\"radio\">` 定义\n```html\n<form>\n    <input type=\"radio\" name=\"sex\" value=\"male\">Male<br>\n    <input type=\"radio\" name=\"sex\" value=\"female\">Female\n</form>\n```\n\n## 复选框 Checkboxes\n-  `<input type=\"checkbox\">` 定义\n```html\n<form>\n    <input type=\"checkbox\" name=\"fruit\" value=\"applee\">Apple<br>\n    <input type=\"checkbox\" name=\"fruit\" value=\"banana\">Banana\n</form>\n```\n\n## 提交按钮 Submit Button\n- `<input type=\"submit\"> `定义\n```html\n<form name=\"input\" action=\"html_form_action.php\" method=\"get\">\nUsername: <input type=\"text\" name=\"user\">\n<input type=\"submit\" value=\"Submit\">\n</form>\n```\n\n实例\n```html\n<form method = \"get\" action = \"\">\n    <p>\n        UserName:<input type=\"text\" name=\"username\" style=\"color:#999\" value=\"请输入用户名\" onfocus=\"if(this.value == '请输入用户名'){this.value='';this.style.color='#424242'}\" onblur=\"if(this.value==''){this.value='请输入用户名';this.style.color='#999'}\">\n    </p>\n        <p>\n        Password:<input type = \"password\" name = \"password\">\n    </p>\n    <input type = \"submit\">\n</form>\n```\n<form method = \"get\" action = \"\">\n    <p>\n        UserName:<input type=\"text\" name=\"username\" style=\"color:#999\" value=\"请输入用户名\" onfocus=\"if(this.value == '请输入用户名'){this.value='';this.style.color='#424242'}\" onblur=\"if(this.value==''){this.value='请输入用户名';this.style.color='#999'}\">\n    </p>\n        <p>\n        Password:<input type = \"password\" name = \"password\">\n    </p>\n    <input type = \"submit\">\n</form>\n\n#段落\n## p\n- 默认文字大小,独立成行,上下垂直空白\n```html\n<p>段1</p>\n<p>段2</p>\n```\n\n## span\n```html\n<span></span>\n```\n\n## br 换行\n ```html\n<br>\n```\n\n## hr 分割线\n```html\n<hr>\n```\n- size：尺寸，取值单位为 px（像素），可以省略\n- width：宽度，取值单位为px（像素）可以省略或百分比\n- color：颜色，取值自然颜色值\n- align：水平对齐方式，取值：left/center/right\n\n# 文本字体\n## 加粗\n```html\n<strong>加粗</strong>\n\n<b>加粗</b>\n```\n\n##斜体\n```html\n<em>斜体</em>\n\n<i>斜体</i>\n```\n\n## 删除线\n```html\n<del>￥30<del>\n\n<s>$30</s>\n```\n\n## 下划线\n```html\n<u></u>\n```\n\n## 上下标\n```html\n<sup>上标</sup>\n<sub>下标</sub>\n```\n\n## 地址\n```html\n<address>地址</address>\n```\n\n# 编码与解码\n|显示结果|\t描述\t|实体名称|\t实体编号|\n|:---|:---|:---|:---|\n| |空格|\t`&nbsp; `|\t`&#160;`|\n|<\t|小于号|\t`&lt;`\t| `&#60;`|\n|>\t|大于号|\t`&gt;`|\t`&#62;`|\n|&|\t和号|\t`&amp;`\t|`&#38;`|\n|\"|\t引号|\t`&quot;`|\t`&#34;`|\n|'\t|撇号 |`\t&apos;` (IE不支持)|\t`&#39;`|\n|￠|\t分|`\t&cent;`|\t`&#162;`|\n|£|\t镑|\t`&pound;`\t|`&#163;`|\n|¥\t|日圆\t|`&yen;`|\t`&#165;`|\n|€|欧元\t|`&euro;`\t|`&#8364;`|\n|§|\t小节|\t`&sect;`|\t`&#167;`|\n|©|\t版权|\t`&copy;` |`&#169;`|\n|®\t|注册商标|`\t&reg;`|\t`&#174;`|\n|™|\t商标\t|`&trade;`\t|`&#8482;`|\n|×\t|乘号\t|`&times;\t`|`&#215;`|\n|÷|\t除号|\t`&divide;`|`\t&#247;`|\n\n-  [More](http://www.w3school.com.cn/tags/html_ref_entities.html)\n\n---\n**参考**\n- [melody瓶子\n](https://www.jianshu.com/p/57cecb7cfc4c)\n- [W3School](https://www.w3schools.com/html/)","tags":["HTML","Web"],"categories":["Coding","Web"]},{"title":"Excel 函数","path":"/posts/ExcelFunction.html","content":"Excel 函数\n<!---more--->\n# 数字处理\n取绝对值\n```\n=ABS(数字) \n# 如：\nABS(-2) =2\n```\n\n向下取整\n```\n=INT(数字) \n# 如：\nINT(5.6)=5 ; INT(5.2)=5\n```\n\n四舍五入\n```\n=ROUND(数字,小数位数) \n# 如： \nROUND(5.6,0)=6 ; ROUND(5.2,0)=5\n```\n\n# 判断公式\n\n- 把公式产生的错误值显示为空\n```\nC2=IFERROR(A2/B2,\"\") \n#  如：\nIFERROR(2/0,\"错误\") = \"错误\"\n```\n  - 说明：如果是错误值则显示为空，否则正常显示。\n\n\n- IF多条件判断返回值\n```\nC2=IF(AND(A2<500,B2=\"未到期\"),\"补款\",\"\")\n```\n  - 说明：两个条件同时成立用AND,任一个成立用OR函数。\n\n# 统计公式\n统计两个表格重复的内容\n```\nB2=COUNTIF(Sheet15!A:A,A2)\n```\n  - 说明：如果返回值大于0说明在另一个表中存在，0则不存在。\n\n统计不重复的总人数\n```\nC2=SUMPRODUCT(1/COUNTIF(A2:A8,A2:A8))\n```\n  - 说明:用COUNTIF统计出每人的出现次数，用1除的方式把出现次数变成分母，然后相加。\n\n# 求和公式\n隔列求和\n```\nH3=SUMIF($A$2:$G$2,H$2,A3:G3) \n或\n=SUMPRODUCT((MOD(COLUMN(B3:G3),2)=0)*B3:G3)\n```\n  - 说明：如果标题行没有规则用第2个公式\n\n单条件求和\n```\nF2=SUMIF(A:A,E2,C:C)\n```\n  - 说明：SUMIF函数的基本用法\n\n单条件模糊求和\n```\n=SUMIF(A2:A4,\"*A*\",C2:C4)\n=SUMIF(A2:A4,\"*A*\",C2:C4)\n=SUMIF(A2:A4,\"*A*\",C2:C4)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kdqfs8nj209507fwgx.jpg)\n\n  - 说明：如果需要进行模糊求和，就需要掌握通配符的使用，其中星号是表示任意多个字符，如\"*A*\"就表示a前和后有任意多个字符，即包含A。\n\n多条件模糊求和\n```\nC11=SUMIFS(C2:C7,A2:A7,A11&\"*\",B2:B7,B11)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kexfwl2j209t065tat.jpg)\n  - 说明：在sumifs中可以使用通配符*\n\n\n多表相同位置求和\n```\nb2=SUM(Sheet1:Sheet19!B2)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kgfwoxlj208y04n75k.jpg)\n  - 说明：在表中间删除或添加表后，公式结果会自动更新。\n\n\n按日期和产品求和\n```\nF2=SUMPRODUCT((MONTH($A$2:$A$25)=F$1)*($B$2:$B$25=$E2)*$C$2:$C$25)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8khi926oj20a005xgob.jpg)\n  - 说明：SUMPRODUCT可以完成多条件求和\n\n# 查找与引用公式\n单条件查找公式\n``` \nC11=VLOOKUP(B11,B3:F7,4,FALSE)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kligjavj20a606gdiu.jpg)\n  - 说明：查找是VLOOKUP最擅长的，基本用法\n\n\n双向查找公式\n```\n=INDEX(C3:H7,MATCH(B10,B3:B7,0),MATCH(C10,C2:H2,0))\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kmqj7r8j20d3074n10.jpg)\n  - 说明：利用MATCH函数查找位置，用INDEX函数取值\n\n\n查找最后一条符合条件的记录。\n```\nC13 = LOOKUP(1,0/(C5:C10=B13),D5:D10)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kngxy5tj209v07tjt9.jpg)\n  - 说明：0/(条件)可以把不符合条件的变成错误值，而lookup可以忽略错误值\n\n## 多条件查找\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kppnnmaj20d808c0vh.jpg)\n  - 说明:公式原理同上一个公式\n\n指定区域最后一个非空值查找\n```\nB14=LOOKUP(1,0/(B2:B13<>\"\"),$A2:$A13)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kquebpdj20ax0a8jun.jpg)\n\n按数字区域间取对应的值\n```\nD9=VLOOKUP(C9,B$4:C$6,2)\nor\nD9=LOOKUP(C9,B$4:B6,C$4:C$5)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8l4ove6sj20as0bgwje.jpg)\n  - 公式说明：VLOOKUP和LOOKUP函数都可以按区间取值，一定要注意，销售量列的数字一定要升序排列。\n\n# 字符串处理公式\n多单元格字符串合并\n```\nC2=PHONETIC(A2:A7)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kvrf9x1j208x05kjsa.jpg)\n  - 说明：Phonetic函数只能对字符型内容合并，数字不可以。\n\n截取除后3位之外的部分\n```\n=LEFT(D1,LEN(D1)-3)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8kwlf6hnj20700493yv.jpg)\n  - 说明：LEN计算出总长度,LEFT从左边截总长度-3个\n\n截取-前的部分\n```\nB2=Left(A1,FIND(\"-\",A1)-1)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8l7paax9j208m04cwfu.jpg)\n  - 说明：用FIND函数查找位置，用LEFT截取。\n\n截取字符串中任一段的公式\n```\nB1=TRIM(MID(SUBSTITUTE($A1,\" \",REPT(\" \",20)),20,20))\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8l8kx8szj20br04cwf1.jpg)\n  - 说明:公式是利用强插N个空字符的方式进行截取\n\n\n字符串查找\n```\nB2=IF(COUNT(FIND(\"河南\",A2))=0,\"否\",\"是\")\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8l9u3emjj209004wgml.jpg)\n  - 说明: FIND查找成功，返回字符的位置，否则返回错误值，而COUNT可以统计出数字的 个数，这里可以用来判断查找是否成功。\n\n字符串查找一对多\n```\nB2=IF(COUNT(FIND({\"辽宁\",\"黑龙江\",\"吉林\"},A2))=0,\"其他\",\"东北\")\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8lbzg388j209s059gn7.jpg)\n  - 说明：设置FIND第一个参数为常量数组，用COUNT函数统计FIND查找结果\n\n# 日期计算公式\n两日期相隔的年、月、天数计算\n- A1是开始日期（2011-12-1），B1是结束日期(2013-6-10)。\n    - 相隔多少天？`=datedif(A1,B1,\"d\")` 结果：557\n    - 相隔多少月? `=datedif(A1,B1,\"m\") `结果：18\n    - 相隔多少年? `=datedif(A1,B1,\"Y\")` 结果：1\n    - 不考虑年相隔多少月？`=datedif(A1,B1,\"Ym\")` 结果：6\n    - 不考虑年相隔多少天？`=datedif(A1,B1,\"YD\")`  结果：192\n    - 不考虑年月相隔多少天？`=datedif(A1,B1,\"MD\") `结果：9\n  - datedif函数第3个参数说明：\n    - \"Y\" 时间段中的整年数。\n    - \"M\" 时间段中的整月数。\n    -  \"D\" 时间段中的天数。\n    -  \"MD\" 天数的差。忽略日期中的月和年。\n    -  \"YM\" 月数的差。忽略日期中的日和年。\n    - \"YD\" 天数的差。忽略日期中的年。\n\n扣除周末天数的工作日天数\n```\nC2=NETWORKDAYS.INTL(IF(B2<DATE(2015,1,1),DATE(2015,1,1),B2),DATE(2015,1,31),11)\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx8lgn3f80j209z06amyx.jpg)\n  - 说明：返回两个日期之间的所有工作日数，使用参数指示哪些天是周末，以及有多少天是周末。周末和任何指定为假期的日期不被视为工作日\n\n---\n**Via**\n- [链接](https://blog.csdn.net/HaHa_Sir/article/details/78970082)","tags":["Excel"],"categories":["Diary"]},{"title":"Selenium 马蜂窝评论","path":"/posts/PythonSeleniumMa.html","content":"Selenium 马蜂窝评论内容\n<!--more-->\n```python\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    # @Time    : 18-11-13 上午11:56\n    # @Author  : Vitan\n    # @File    : SeleniumMaFengWo.py\n\n    from selenium import webdriver\n    from selenium.webdriver.common.by import By\n    from selenium.webdriver.support.ui import WebDriverWait\n    from selenium.webdriver.support import expected_conditions as EC\n    from selenium.common.exceptions import NoSuchAttributeException\n    from selenium.common.exceptions import TimeoutException\n    from pyquery.pyquery import PyQuery as pq\n    import pymongo\n\n    broswer = webdriver.Firefox()\n    wait = WebDriverWait(broswer,10)\n\n    client = pymongo.MongoClient('localhost')\n    db = client['MaFengWoView']\n\n    def search_first(url):\n        try:\n            broswer.get(url)\n            wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.pi.pg-last')))\n            total = int(broswer.find_element_by_css_selector('.pi.pg-last').get_attribute('data-page'))\n            print(total)\n            place()\n            return total\n        except TimeoutException:\n            return search_first(url)\n\n    def search_next(page):\n        try:\n            next = broswer.find_element_by_css_selector('.pi.pg-next')\n            next.click()\n            wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pg-current'),str(page)))\n            place()\n        except NoSuchAttributeException:\n            search_next(page)\n\n    def place():\n        anchors = broswer.find_elements_by_css_selector('.scenic-list.clearfix li a')\n        for a in anchors:\n            url = a.get_attribute('href')\n            print(url)\n            total = view_first(url)\n            for page in range(2,total+1):\n                view_next(page)\n\n        # html = broswer.page_source\n        # doc = pq(html)\n        # anchors = doc('.scenic-list.clearfix li a')\n        # for a in anchors.items():\n        #     url = a.attr('href')\n        #     print(url)\n\n    def view_first(url):\n        try:\n            broswer.get(url)\n            wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,'.pi.pg-last')))\n            total = int(broswer.find_element_by_css_selector('.pi.pg-last').get_attribute('data-page'))\n            get_view()\n            return total\n        except TimeoutException:\n            return view_first(url)\n\n    def view_next(page):\n        try:\n            next = broswer.find_element_by_css_selector('.pi.pg-next')\n            next.click()\n            wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR,'.pg-current'),str(page)))\n            get_view()\n        except NoSuchAttributeException:\n            view_next(page)\n\n    def get_view():\n        html = broswer.page_source\n        doc = pq(html)\n        lis = doc('.rev-item.comment-item.clearfix')\n        for li in lis.items():\n            view = {\n                'name':li.find('.name').text().strip(),\n                'level':li.find('.level').text().strip(),\n                'txt':li.find('.rev-txt').text().strip()\n            }\n            save_to_mongo(view)\n\n    def save_to_mongo(view):\n        if db['MaFengWoView'].insert_one(view):\n            print('Saving to MongoDB',view)\n            return True\n        return False\n\n    def main():\n        url = 'http://www.mafengwo.cn/jd/10088/gonglve.html'\n        total = search_first(url)\n        for page in range(2,total+1):\n            search_next(page)\n        #     print('Clicking',page,'页')\n        # url = 'http://www.mafengwo.cn/poi/449.html'\n        # total = view_first(url)\n        # for page in range(2,total+1):\n        #     view_next(page)\n\n    if __name__=='__main__':\n        main()\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"K-means 图片压缩","path":"/posts/PythonSklearnImage.html","content":"K-means 图片压缩\n<!---more--->\n```python\n        #!/usr/bin/env python\n        # -*- coding: utf-8 -*-\n        # @Time    : 18-11-12 10:10\n        # @Author  : Vitan\n\n        from sklearn.datasets import load_sample_image\n        import matplotlib.image as img\n        from sklearn.cluster import KMeans\n        import numpy as np\n        from matplotlib import pyplot as plt\n\n        # 导入图片\n        picture = load_sample_image('china.jpg') # 内置\n        pic2 = img.imread('v.jpg') # 外部\n\n        # 根据图片的分辨率，可适当降低分辨率。\n        image = picture[::3,::3]# 横纵每三个点去一个颜色值\n        plt.imshow(image)\n        img.imsave('pure.jpg',image)\n        plt.show()\n\n        # 再用k均值聚类算法，将图片中所有的颜色值做聚类。\n        X = image.reshape(-1,3) #reshape为一维\n        mod = KMeans(n_clusters = 64)\n        labels = mod.fit_predict(X)  #每个点的颜色分类，0-63\n        colors = mod.cluster_centers_  #64个聚类中心，颜色值\n\n        # 还原颜色，维数，数据类型\n        new_img = colors[labels]\n        new_img = new_img.reshape(image.shape)\n        new_img = new_img.astype(np.uint8)\n        print(new_img)\n\n        # 显示压缩图片\n        plt.imshow(new_img)\n        img.imsave('E://zip.jpg',new_img)\n        plt.show()\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python Matplotlib 各种图","path":"/posts/PythonMatplotlib.html","content":"Matplotlib 各种图\n<!--more-->\n\n# 垂直条形图\n```Python\n    # 导入绘图模块\n    import matplotlib.pyplot as plt\n    # 构建数据\n    GDP = [12406.8,13908.57,9386.87,9143.64]\n\n    # 中文乱码的处理\n    plt.rcParams['font.sans-serif'] =['SimHei']\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 绘图\n    plt.bar(range(4), GDP, align = 'center',color='steelblue', alpha = 0.8)\n    # 添加轴标签\n    plt.ylabel('GDP')\n    # 添加标题\n    plt.title('四个直辖市GDP大比拼')\n    # 添加刻度标签\n    plt.xticks(range(4),['北京市','上海市','天津市','重庆市'])\n    # 设置Y轴的刻度范围\n    plt.ylim([5000,15000])\n\n    # 为每个条形图添加数值标签\n    for x,y in enumerate(GDP):\n        plt.text(x,y+100,'%s' %round(y,1),ha='center')\n    plt.savefig('垂直条形图.png')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0j1550lxj20c0080jre.jpg)\n\n- 解析\n    1. 由于matplotlib对中文的支持并不是很友好，所以需要提前对绘图进行字体的设置，即通过rcParams来设置字体，这里将字体设置为微软雅黑，同时为了避免坐标轴不能正常的显示负号，也需要进行设置；\n    2. bar 函数指定了条形图的x轴、y轴值，设置x轴刻度标签为水平居中，条形图的填充色color为铁蓝色，同时设置透明度alpha为0.8；\n    3. 添加y轴标签、标题、x轴刻度标签值，为了让条形图显示各柱体之间的差异，将y轴范围设置在5000~15000；\n    4. 通过循环的方式，添加条形图的数值标签；\n\n# 水平条形图\n```Python\n    # 导入绘图模块\n    import matplotlib.pyplot as plt\n    # 构建数据\n    price = [39.5,39.9,45.4,38.9,33.34]\n\n    # 中文乱码的处理\n    plt.rcParams['font.sans-serif'] =['SimHei']\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 绘图\n    plt.barh(range(5), price, align = 'center',color='steelblue', alpha = 0.8)\n    # 添加轴标签\n    plt.xlabel('价格')\n    # 添加标题\n    plt.title('不同平台书的最低价比较')\n    # 添加刻度标签\n    plt.yticks(range(5),['亚马逊','当当网','中国图书网','京东','天猫'])\n    # 设置Y轴的刻度范围\n    plt.xlim([32,47])\n\n    # 为每个条形图添加数值标签\n    for x,y in enumerate(price):\n        plt.text(y+0.1,x,'%s' %y,va='center')\n    plt.savefig('水平条形图.png')\n    # 显示图形    \n    plt.show()\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0j4ktleuj20c00800ss.jpg)\n\n# 水平交错条形图\n```Python\n    # 导入绘图模块\n    import matplotlib.pyplot as plt\n    import numpy as np\n    # 构建数据\n    Y2016 = [15600,12700,11300,4270,3620]\n    Y2017 = [17400,14800,12000,5200,4020]\n    labels = ['北京','上海','香港','深圳','广州']\n    bar_width = 0.45\n\n    # 中文乱码的处理\n    plt.rcParams['font.sans-serif'] =['SimHei']\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 绘图\n    plt.bar(np.arange(5), Y2016, label = '2016', color = 'steelblue', alpha = 0.8, width = bar_width)\n    plt.bar(np.arange(5)+bar_width, Y2017, label = '2017', color = 'indianred', alpha = 0.8, width = bar_width)\n    # 添加轴标签\n    plt.xlabel('Top5城市')\n    plt.ylabel('家庭数量')\n    # 添加标题\n    plt.title('亿万财富家庭数Top5城市分布')\n    # 添加刻度标签\n    plt.xticks(np.arange(5)+bar_width,labels)\n    # 设置Y轴的刻度范围\n    plt.ylim([2500, 19000])\n\n    # 为每个条形图添加数值标签\n    for x2016,y2016 in enumerate(Y2016):\n        plt.text(x2016, y2016+100, '%s' %y2016)\n\n    for x2017,y2017 in enumerate(Y2017):\n        plt.text(x2017+bar_width, y2017+100, '%s' %y2017)\n    # 显示图例\n    plt.legend()\n    plt.savefig('水平交错条形图.png')\n    # 显示图形\n    plt.show()\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0jcakoz3j20c0080mxb.jpg)\n\n# 垂直堆叠条形图\n```Python\n    # 导入模块\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import pandas as pd\n\n    # 导入数据\n    data = pd.read_excel('C:\\\\Users\\\\Administrator\\\\Desktop\\\\货运.xls')\n\n    # 绘图\n    plt.bar(np.arange(8), data.loc[0,:][1:], color = 'red', alpha = 0.8, label = '铁路', align = 'center')\n    plt.bar(np.arange(8), data.loc[1,:][1:],  bottom = data.loc[0,:][1:], color = 'green', alpha = 0.8, label = '公路', align = 'center')\n    plt.bar(np.arange(8), data.loc[2,:][1:],  bottom = data.loc[0,:][1:]+data.loc[1,:][1:], color = 'm', alpha = 0.8, label = '水运', align = 'center')\n    plt.bar(np.arange(8), data.loc[3,:][1:],  bottom = data.loc[0,:][1:]+data.loc[1,:][1:]+data.loc[2,:][1:], color = 'black', alpha = 0.8, label = '民航', align = 'center')\n    # 添加轴标签\n    plt.xlabel('月份')\n    plt.ylabel('货物量(万吨)')\n    # 添加标题\n    plt.title('2017年各月份物流运输量')\n    # 添加刻度标签\n    plt.xticks(np.arange(8),data.columns[1:])\n    # 设置Y轴的刻度范围\n    plt.ylim([0,500000])\n\n    # 为每个条形图添加数值标签\n    for x_t,y_t in enumerate(data.loc[0,:][1:]):\n        plt.text(x_t,y_t/2,'%sW' %(round(y_t/10000,2)),ha='center', color = 'white')\n\n    for x_g,y_g in enumerate(data.loc[0,:][1:]+data.loc[1,:][1:]):\n        plt.text(x_g,y_g/2,'%sW' %(round(y_g/10000,2)),ha='center', color = 'white')\n\n    for x_s,y_s in enumerate(data.loc[0,:][1:]+data.loc[1,:][1:]+data.loc[2,:][1:]):\n        plt.text(x_s,y_s-20000,'%sW' %(round(y_s/10000,2)),ha='center', color = 'white')    \n\n    # 显示图例\n    plt.legend(loc='upper center', ncol=4)\n    # 显示图形    \n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0k3zz5g9j20b907utae.jpg)\n\n# matplotlib(饼图)\n## pie 函数参数解读\n饼图的绘制可以使用matplotlib库中的pie函数\n```Python\n    plt.pie(x, explode=None, labels=None, colors=None,\n        autopct=None, pctdistance=0.6, shadow=False,\n        labeldistance=1.1, startangle=None,\n        radius=None, counterclock=True, wedgeprops=None,\n        textprops=None, center=(0, 0), frame=False)\n```\n---\n\n|参数|说明|\n|:---|:---|\n|x|指定绘图的数据|\n|explode|指定饼图某些部分的突出显示，即呈现爆炸式|\n|labels|为饼图添加标签说明，类似于图例说明|\n|colors|指定饼图的填充色|\n|autopct|自动添加百分比显示，可以采用格式化的方法显示|\n|pctdistance|设置百分比标签与圆心的距离|\n|shadow|是否添加饼图的阴影效果|\n|labeldistance|设置各扇形标签（图例）与圆心的距离|\n|startangle|设置饼图的初始摆放角度|\n|radius|设置饼图的半径大小|\n|counterclock|是否让饼图按逆时针顺序呈现|\n|wedgeprops|设置饼图内外边界的属性，如边界线的粗细、颜色等|\n|textprops|设置饼图中文本的属性，如字体大小、颜色等|\n|center|定饼图的中心点位置，默认为原点|\n|frame|是否要显示饼图背后的图框，如果设置为True的话，需要同时控制图框x轴、y轴的范围和饼图的中心位置|\n\n## 绘制\n```Python\n    # 导入第三方模块\n    import matplotlib.pyplot as plt\n\n    # 设置绘图的主题风格（不妨使用R中的ggplot分隔）\n    plt.style.use('ggplot')\n\n    # 构造数据\n    edu = [0.2515,0.3724,0.3336,0.0368,0.0057]\n    labels = ['中专','大专','本科','硕士','其他']\n\n    explode = [0,0.1,0,0,0]  # 用于突出显示大专学历人群\n    colors=['#9999ff','#ff9999','#7777aa','#2442aa','#dd5555'] # 自定义颜色\n\n    # 中文乱码和坐标轴负号的处理\n    plt.rcParams['font.sans-serif'] = ['SimHei']\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 将横、纵坐标轴标准化处理，保证饼图是一个正圆，否则为椭圆\n    plt.axes(aspect='equal')\n\n    # 控制x轴和y轴的范围\n    plt.xlim(0,4)\n    plt.ylim(0,4)\n\n    # 绘制饼图\n    plt.pie(x = edu, # 绘图数据\n            explode=explode, # 突出显示大专人群\n            labels=labels, # 添加教育水平标签\n            colors=colors, # 设置饼图的自定义填充色\n            autopct='%.1f%%', # 设置百分比的格式，这里保留一位小数\n            pctdistance=0.8,  # 设置百分比标签与圆心的距离\n            labeldistance = 1.15, # 设置教育水平标签与圆心的距离\n            startangle = 180, # 设置饼图的初始角度\n            radius = 1.5, # 设置饼图的半径\n            counterclock = False, # 是否逆时针，这里设置为顺时针方向\n            wedgeprops = {'linewidth': 1.5, 'edgecolor':'green'},# 设置饼图内外边界的属性值\n            textprops = {'fontsize':12, 'color':'k'}, # 设置文本标签的属性值\n            center = (1.8,1.8), # 设置饼图的原点\n            frame = 1 )# 是否显示饼图的图框，这里设置显示\n\n    # 删除x轴和y轴的刻度\n    plt.xticks(())\n    plt.yticks(())\n    # 添加图标题\n    plt.title('芝麻信用失信用户教育水平分布')\n    plt.savefig('饼图.png')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0jh2r431j20c00800t2.jpg)\n\n# matplotlib(箱线图)\n## boxplot函数的参数解读\n```Python\n    plt.boxplot(x, notch=None, sym=None, vert=None,\n                whis=None, positions=None, widths=None,\n                patch_artist=None, meanline=None, showmeans=None,\n                showcaps=None, showbox=None, showfliers=None,\n                boxprops=None, labels=None, flierprops=None,\n                medianprops=None, meanprops=None,\n                capprops=None, whiskerprops=None)\n```\n\n|参数|说明|\n|:---|:---|\n|x|指定要绘制箱线图的数据|\n|notch|是否是凹口的形式展现箱线图，默认非凹口|\n|sym|指定异常点的形状，默认为+号显示|\n|vert|是否需要将箱线图垂直摆放，默认垂直摆放；\n|whis|指定上下须与上下四分位的距离，默认为1.5倍的四分位差|\n|positions|指定箱线图的位置，默认为[0,1,2…]|\n|widths|指定箱线图的宽度，默认为0.5|\n|patch_artist|是否填充箱体的颜色|\n|meanline|是否用线的形式表示均值，默认用点来表示|\n|showmeans|是否显示均值，默认不显示|\n|showcaps|是否显示箱线图顶端和末端的两条线，默认显示|\n|showbox|是否显示箱线图的箱体，默认显示|\n|showfliers|是否显示异常值，默认显示|\n|boxprops|设置箱体的属性，如边框色，填充色等|\n|labels|为箱线图添加标签，类似于图例的作用|\n|filerprops|设置异常值的属性，如异常点的形状、大小、填充色等|\n|medianprops|设置中位数的属性，如线的类型、粗细等|\n|meanprops|设置均值的属性，如点的大小、颜色等|\n|capprops|设置箱线图顶端和末端线条的属性，如颜色、粗细等|\n|whiskerprops|设置须的属性，如颜色、粗细、线的类型等|\n\n## 绘制\n```Python\n    # 导入第三方模块\n    import pandas as pd\n    import matplotlib.pyplot as plt\n\n    # 读取Titanic数据集\n    titanic = pd.read_csv('titanic_train.csv')\n    # 检查年龄是否有缺失\n    any(titanic.Age.isnull())\n    # 不妨删除含有缺失年龄的观察\n    titanic.dropna(subset=['Age'], inplace=True)\n\n    # 设置图形的显示风格\n    plt.style.use('ggplot')\n\n    # 设置中文和负号正常显示\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 绘图：整体乘客的年龄箱线图\n    plt.boxplot(x = titanic.Age, # 指定绘图数据\n                patch_artist=True, # 要求用自定义颜色填充盒形图，默认白色填充\n                showmeans=True, # 以点的形式显示均值\n                boxprops = {'color':'black','facecolor':'#9999ff'}, # 设置箱体属性，填充色和边框色\n                flierprops = {'marker':'o','markerfacecolor':'red','color':'black'}, # 设置异常值属性，点的形状、填充色和边框色\n                meanprops = {'marker':'D','markerfacecolor':'indianred'}, # 设置均值点的属性，点的形状、填充色\n                medianprops = {'linestyle':'--','color':'orange'}) # 设置中位数线的属性，线的类型和颜色\n    # 设置y轴的范围\n    plt.ylim(0,85)\n\n    # 去除箱线图的上边框与右边框的刻度标签\n    plt.tick_params(top='off', right='off')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0khch6l1j20c00800sl.jpg)\n\n\n```Python\n    # 按舱级排序，为了后面正常显示分组盒形图的顺序\n    titanic.sort_values(by = 'Pclass', inplace=True)\n\n    # 通过for循环将不同仓位的年龄人群分别存储到列表Age变量中\n    Age = []\n    Levels = titanic.Pclass.unique()\n    for Pclass in Levels:\n        Age.append(titanic.loc[titanic.Pclass==Pclass,'Age'])\n\n    # 绘图\n    plt.boxplot(x = Age,\n                patch_artist=True,\n                labels = ['一等舱','二等舱','三等舱'], # 添加具体的标签名称\n                showmeans=True,\n                boxprops = {'color':'black','facecolor':'#9999ff'},\n                flierprops = {'marker':'o','markerfacecolor':'red','color':'black'},\n                meanprops = {'marker':'D','markerfacecolor':'indianred'},\n                medianprops = {'linestyle':'--','color':'orange'})\n\n    # 显示图形\n    plt.show()\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0kkhvvshj20c0080747.jpg)\n\n# matplotlib(直方图)\n## hist函数的参数解读\n```Python\nplt.hist(x, bins=10, range=None, normed=False,\n        weights=None, cumulative=False, bottom=None,\n        histtype='bar', align='mid', orientation='vertical',\n        rwidth=None, log=False, color=None,\n        label=None, stacked=False)\n```\n\n|参数|说明|\n|:---|:---|\n|x|指定要绘制直方图的数据|\n|bins|指定直方图条形的个数|\n|range|指定直方图数据的上下界，默认包含绘图数据的最大值和最小值|\n|normed|是否将直方图的频数转换成频率|\n|weights|该参数可为每一个数据点设置权重|\n|cumulative|是否需要计算累计频数或频率|\n|bottom|可以为直方图的每个条形添加基准线，默认为0|\n|histtype|指定直方图的类型，默认为bar，除此还有’barstacked’, ‘step’,  ‘stepfilled’|\n|align|设置条形边界值的对其方式，默认为mid，除此还有’left’和’right’|\n|orientation|设置直方图的摆放方向，默认为垂直方向|\n|rwidth|设置直方图条形宽度的百分比|\n|log|是否需要对绘图数据进行log变换|\n|color|设置直方图的填充色|\n|label|设置直方图的标签，可通过legend展示其图例|\n|stacked|当有多个数据时，是否需要将直方图呈堆叠摆放，默认水平摆放|\n\n## 一元直方图的绘制\n```python\n    # 导入第三方包\n    import numpy as np\n    import pandas as pd\n    import matplotlib.pyplot as plt\n    import matplotlib.mlab as mlab\n\n    # 中文和负号的正常显示\n    plt.rcParams['font.sans-serif'] = ['SimHei']\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 读取Titanic数据集\n    titanic = pd.read_csv('titanic_train.csv')\n    # 检查年龄是否有缺失any(titanic.Age.isnull())\n    # 不妨删除含有缺失年龄的观察\n    titanic.dropna(subset=['Age'], inplace=True)\n\n    # 设置图形的显示风格\n    plt.style.use('ggplot')\n    # 绘图：乘客年龄的频数直方图\n    plt.hist(titanic.Age, # 绘图数据\n            bins = 20, # 指定直方图的条形数为20个\n            color = 'steelblue', # 指定填充色\n            edgecolor = 'k', # 指定直方图的边界色\n            label = '直方图' )# 为直方图呈现标签\n\n    # 去除图形顶部边界和右边界的刻度\n    plt.tick_params(top='off', right='off')\n    # 显示图例\n    plt.legend()\n    plt.savefig('直方图.png')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0mm4l1gvj20c00803ye.jpg)\n\n## 累计频率直方图\n- 上图绘制的是年龄的频数直方图，从整体的分布来看，有点像正态分布，两边低中间高的倒钟形状。除此，我们还可以绘制累计频率直方图，并且设置5岁为组距，如下代码可以表示成：\n\n```python\n    # 绘图：乘客年龄的累计频率直方图\n    plt.hist(titanic.Age, # 绘图数据\n            bins = np.arange(titanic.Age.min(),titanic.Age.max(),5), # 指定直方图的组距\n            normed = True, # 设置为频率直方图\n            cumulative = True, # 积累直方图\n            color = 'steelblue', # 指定填充色\n            edgecolor = 'k', # 指定直方图的边界色\n            label = '直方图' )# 为直方图呈现标签\n\n    # 设置坐标轴标签和标题\n    plt.title('乘客年龄的频率累计直方图')\n    plt.xlabel('年龄')\n    plt.ylabel('累计频率')\n\n    # 去除图形顶部边界和右边界的刻度\n    plt.tick_params(top='off', right='off')\n\n    # 显示图例\n    plt.legend(loc = 'best')\n    plt.savefig('乘客年龄的累计频率直方图.png')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0knyeutbj20c0080mx8.jpg)\n\n# 正太分布图\n- 通过累计频率直方图就可以快速的发现什么年龄段的人数占了多少比重，例如35岁以下的乘客占了7成，这种图的解读有点像帕累托图。为了测试数据集是否近似服从正态分布，需要在直方图的基础上再绘制两条线，一条表示理论的正态分布曲线，另一条为核密度曲线，目的就是比较两条曲线的吻合度，越吻合就说明数据越近似于正态分布。接下来我们就在直方图的基础上再添加两条曲线：\n\n```python\n    # 正太分布图\n    plt.hist(titanic.Age, # 绘图数据\n            bins = np.arange(titanic.Age.min(),titanic.Age.max(),5), # 指定直方图的组距\n            normed = True, # 设置为频率直方图\n            color = 'steelblue', # 指定填充色\n            edgecolor = 'k') # 指定直方图的边界色\n\n    # 设置坐标轴标签和标题\n    plt.title('乘客年龄直方图')\n    plt.xlabel('年龄')\n    plt.ylabel('频率')\n\n    # 生成正态曲线的数据\n    x1 = np.linspace(titanic.Age.min(), titanic.Age.max(), 1000)\n    normal = mlab.normpdf(x1, titanic.Age.mean(), titanic.Age.std())\n    # 绘制正态分布曲线\n    line1, = plt.plot(x1,normal,'r-', linewidth = 2)\n\n    # 生成核密度曲线的数据\n    kde = mlab.GaussianKDE(titanic.Age)\n    x2 = np.linspace(titanic.Age.min(), titanic.Age.max(), 1000)\n    # 绘制\n    line2, = plt.plot(x2,kde(x2),'g-', linewidth = 2)\n\n    # 去除图形顶部边界和右边界的刻度\n    plt.tick_params(top='off', right='off')\n\n    # 显示图例\n    plt.legend([line1, line2],['正态分布曲线','核密度曲线'],loc='best')\n    plt.savefig('正太分布图.png')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0kp9cxanj20c0080jrt.jpg)\n\n# 二元直方图的绘制\n- 上面绘制的直方图都是基于所有乘客的年龄，如果想对比男女乘客的年龄直方图的话，我们可以通过两个hist将不同性别的直方图绘制到一张图内，具体代码如下：\n\n```Python\n    # 提取不同性别的年龄数据\n    age_female = titanic.Age[titanic.Sex == 'female']\n    age_male = titanic.Age[titanic.Sex == 'male']\n\n    # 设置直方图的组距\n    bins = np.arange(titanic.Age.min(), titanic.Age.max(), 2)\n    # 男性乘客年龄直方图\n    plt.hist(age_male, bins = bins, label = '男性', color = 'steelblue', alpha = 0.7)\n    # 女性乘客年龄直方图\n    plt.hist(age_female, bins = bins, label = '女性', alpha = 0.6)\n\n    # 设置坐标轴标签和标题\n    plt.title('乘客年龄直方图')\n    plt.xlabel('年龄')\n    plt.ylabel('人数')\n\n    # 去除图形顶部边界和右边界的刻度\n    plt.tick_params(top='off', right='off')\n\n    # 显示图例\n    plt.legend()\n    plt.savefig('二元直方图.png')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0krsx0j5j20c0080t8q.jpg)\n\n# matplotlib(折线图)\n## plot函数的参数解读\n```python\nplt.hist(x,y,linestyle,\n    linewidth,color,marker,\n    markersize,markeredgecolor,\n    markerfactcolor,label,alpha)\n```\n\n|参数|说明|\n|:---|:---|\n|x|指定折线图的x轴数据|\n|y|指定折线图的y轴数据|\n|linestyle|指定折线的类型，可以是实线、虚线、点虚线、点点线等，默认文实线|\n|linewidth|指定折线的宽度|\n|marker|可以为折线图添加点，该参数是设置点的形状|\n|markersize|设置点的大小|\n|markeredgecolor|设置点的边框色|\n|markerfactcolor|设置点的填充色|\n|label|为折线图添加标签，类似于图例的作用|\n\n# 一元折线图的绘制\n```python\n    # 导入模块\n    import pandas as pd\n    import matplotlib.pyplot as plt\n\n    # 设置绘图风格\n    plt.style.use('ggplot')\n    # 设置中文编码和负号的正常显示\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 读取需要绘图的数据\n    article_reading = pd.read_excel('wechart.xlsx')\n    # 取出8月份至9月28日的数据\n    sub_data = article_reading.loc[article_reading.date >= '2017-08-01' ,:]\n\n    # 设置图框的大小\n    fig = plt.figure(figsize=(10,6))\n    # 绘图\n    plt.plot(sub_data.date, # x轴数据\n             sub_data.article_reading_cnts, # y轴数据\n             linestyle = '-', # 折线类型\n             linewidth = 2, # 折线宽度\n             color = 'steelblue', # 折线颜色\n             marker = 'o', # 点的形状\n             markersize = 6, # 点的大小\n             markeredgecolor='black', # 点的边框色\n             markerfacecolor='brown') # 点的填充色\n\n    # 添加标题和坐标轴标签\n    plt.title('公众号每天阅读人数趋势图')\n    plt.xlabel('日期')\n    plt.ylabel('人数')\n\n    # 剔除图框上边界和右边界的刻度\n    plt.tick_params(top = 'off', right = 'off')\n\n    # 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且45度倾斜\n    fig.autofmt_xdate(rotation = 45)\n\n    # 显示图形\n    plt.show()\n```\n- 由于x轴是日期型数据，当数据量一多的时候，就会导致刻度标签的重叠或拥挤，为了防止重叠的产生，我们需要让日期型的x轴刻度标签自动展现，从而避免重叠的现象\n\n## 图形优化\n```Python\n    # 导入模块\n    import matplotlib as mpl\n\n    # 设置图框的大小\n    fig = plt.figure(figsize=(10,6))\n    # 绘图\n    plt.plot(sub_data.date, # x轴数据\n             sub_data.article_reading_cnts, # y轴数据\n             linestyle = '-', # 折线类型\n             linewidth = 2, # 折线宽度\n             color = 'steelblue', # 折线颜色\n             marker = 'o', # 点的形状\n             markersize = 6, # 点的大小\n             markeredgecolor='black', # 点的边框色\n             markerfacecolor='steelblue') # 点的填充色\n\n    # 添加标题和坐标轴标签\n    plt.title('公众号每天阅读人数趋势图')\n    plt.xlabel('日期')\n    plt.ylabel('人数')\n\n    # 剔除图框上边界和右边界的刻度\n    plt.tick_params(top = 'off', right = 'off')\n\n    # 获取图的坐标信息\n    ax = plt.gca()\n    # 设置日期的显示格式  \n    date_format = mpl.dates.DateFormatter(\"%Y-%m-%d\")  \n    ax.xaxis.set_major_formatter(date_format)\n\n    # 设置x轴显示多少个日期刻度\n    #xlocator = mpl.ticker.LinearLocator(10)\n    # 设置x轴每个刻度的间隔天数\n    xlocator = mpl.ticker.MultipleLocator(5)\n    ax.xaxis.set_major_locator(xlocator)\n\n    # 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且45度倾斜\n    fig.autofmt_xdate(rotation = 45)\n\n    # 显示图形\n```\n\n# 多元折线图的绘制\n- 如果你需要在一张图形中画上两条折线图，也很简单，只需要在代码中写入两次plot函数即可，其他都不需要改动了。具体可以参考下面的代码逻辑：\n\n```python\n    # 设置图框的大小\n    fig = plt.figure(figsize=(10,6))\n\n    # 绘图--阅读人数趋势\n    plt.plot(sub_data.date, # x轴数据\n             sub_data.article_reading_cnts, # y轴数据\n             linestyle = '-', # 折线类型\n             linewidth = 2, # 折线宽度\n             color = 'steelblue', # 折线颜色\n             marker = 'o', # 点的形状\n             markersize = 6, # 点的大小\n             markeredgecolor='black', # 点的边框色\n             markerfacecolor='steelblue', # 点的填充色\n             label = '阅读人数') # 添加标签\n\n    # 绘图--阅读人次趋势\n    plt.plot(sub_data.date, # x轴数据\n             sub_data.article_reading_times, # y轴数据\n             linestyle = '-', # 折线类型\n             linewidth = 2, # 折线宽度\n             color = '#ff9999', # 折线颜色\n             marker = 'o', # 点的形状\n             markersize = 6, # 点的大小\n             markeredgecolor='black', # 点的边框色\n             markerfacecolor='#ff9999', # 点的填充色\n             label = '阅读人次') # 添加标签\n\n    # 添加标题和坐标轴标签\n    plt.title('公众号每天阅读人数和人次趋势图')\n    plt.xlabel('日期')\n    plt.ylabel('人数')\n\n    # 剔除图框上边界和右边界的刻度\n    plt.tick_params(top = 'off', right = 'off')\n\n    # 获取图的坐标信息\n    ax = plt.gca()\n    # 设置日期的显示格式  \n    date_format = mpl.dates.DateFormatter('%m-%d')  \n    ax.xaxis.set_major_formatter(date_format)\n\n    # 设置x轴显示多少个日期刻度\n    #xlocator = mpl.ticker.LinearLocator(10)\n    # 设置x轴每个刻度的间隔天数\n    xlocator = mpl.ticker.MultipleLocator(3)\n    ax.xaxis.set_major_locator(xlocator)\n\n    # 为了避免x轴日期刻度标签的重叠，设置x轴刻度自动展现，并且45度倾斜\n    fig.autofmt_xdate(rotation = 45)\n\n    # 显示图例\n    plt.legend()\n    # 显示图形\n    plt.show()\n```\n# matplotlib(散点图)\n## scatter函数的参数解读\n```python\n    lt.scatter(x, y, s=20,\n                c=None, marker='o',\n                cmap=None, norm=None,\n                vmin=None, vmax=None,\n                alpha=None, linewidths=None,\n                edgecolors=None)\n```\n\n|参数|说明|\n|:---|:---|\n|x|指定散点图的x轴数据|\n|y|指定散点图的y轴数据|\n|s|指定散点图点的大小，默认为20，通过传入新的变量，实现气泡图的绘制|\n|c|指定散点图点的颜色，默认为蓝色|\n|marker|指定散点图点的形状，默认为圆形|\n|cmap|指定色图，只有当c参数是一个浮点型的数组的时候才起作用|\n|norm|设置数据亮度，标准化到0~1之间，使用该参数仍需要c为浮点型的数组|\n|vmin、vmax|亮度设置，与norm类似，如果使用了norm则该参数无效|\n|alpha|设置散点的透明度|\n|linewidths|设置散点边界线的宽度|\n|edgecolors|设置散点边界线的颜色|\n\n# 一般散点图的绘制\n```python\n    # 导入模块\n    import pandas as pd\n    import matplotlib.pyplot as plt\n\n    # 设置绘图风格\n    plt.style.use('ggplot')\n    # 设置中文编码和负号的正常显示\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 读入数据\n    cars = pd.read_csv('cars.csv')\n\n    # 绘图\n    plt.scatter(cars.speed, # x轴数据为汽车速度\n                cars.dist, # y轴数据为汽车的刹车距离\n                s = 30, # 设置点的大小\n                c = 'steelblue', # 设置点的颜色\n                marker = 's', # 设置点的形状\n                alpha = 0.9, # 设置点的透明度\n                linewidths = 0.3, # 设置散点边界的粗细\n                edgecolors = 'red' # 设置散点边界的颜色\n                )\n\n    # 添加轴标签和标题plt.title('汽车速度与刹车距离的关系')\n    plt.xlabel('汽车速度')\n    plt.ylabel('刹车距离')\n\n    # 去除图边框的顶部刻度和右边刻度\n    plt.tick_params(top = 'off', right = 'off')\n\n    plt.savefig('一般散点图.png')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0mqe23jgj20c0080q2w.jpg)\n\n# 分组散点图的绘制\n```Python\n    # 读取数据\n    iris = pd.read_csv('iris.csv')\n\n    # 设置中文编码和负号的正常显示\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 自定义颜色\n    colors = ['steelblue', '#9999ff', '#ff9999']\n\n    # 三种不同的花品种\n    Species = iris.Species.unique()\n\n    # 通过循环的方式，完成分组散点图的绘制\n    for i in range(len(Species)):\n        plt.scatter(iris.loc[iris.Species == Species[i], 'Petal.Length'],\n                    iris.loc[iris.Species == Species[i], 'Petal.Width'],\n                    s = 35, c = colors[i], label = Species[i])\n\n    # 添加轴标签和标题\n    plt.title('花瓣长度与宽度的关系')\n    plt.xlabel('花瓣长度')\n    plt.ylabel('花瓣宽度')\n\n    # 去除图边框的顶部刻度和右边刻度\n    plt.tick_params(top = 'off', right = 'off')\n    # 添加图例\n    plt.legend(loc = 'upper left')\n    plt.savefig('分组散点图.png')\n    # 显示图形\n    plt.show()\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0mt6kcxgj20c0080q35.jpg)\n\n# 气泡图的绘制\n ```python\n    # 导入第三方包\n    import numpy as np\n\n    # 设置中文编码和负号的正常显示\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 读取数据\n    sales = pd.read_excel('sales.xlsx')\n\n    # 绘制气泡图\n    plt.scatter(sales.finish_ratio,\n                sales.profit_ratio,\n                c = 'steelblue',\n                s = sales.tot_target/30,\n                edgecolor = 'black')\n\n    # 改变轴刻度的显示方式（百分比形式）\n    plt.xticks(np.arange(0,1,0.1), [str(i*100)+'%' for i in np.arange(0,1,0.1)])\n    plt.yticks(np.arange(0,1,0.1), [str(i*100)+'%' for i in np.arange(0,1,0.1)])\n\n    # 设置x轴和y轴的数值范围\n    plt.xlim(0.2, 0.7)\n    plt.ylim(0.25, 0.85)\n\n    # 添加轴标签和标题\n    plt.title('完成率与利润率的关系')\n    plt.xlabel('完成率')\n    plt.ylabel('利润率')\n\n    # 去除图边框的顶部刻度和右边刻度\n    plt.tick_params(top = 'off', right = 'off')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0mvachvuj20c0080dg0.jpg)\n\n# 散点图+线性回归线\n```Python\n    # 导入第三方模块\n    from sklearn.linear_model import LinearRegression\n\n    # 散点图\n    plt.scatter(cars.speed, # x轴数据为汽车速度\n                cars.dist, # y轴数据为汽车的刹车距离\n                s = 30, # 设置点的大小\n                c = 'black', # 设置点的颜色\n                marker = 'o', # 设置点的形状\n                alpha = 0.9, # 设置点的透明度\n                linewidths = 0.3, # 设置散点边界的粗细\n                label = '观测点'\n                )\n\n    # 建模\n    reg = LinearRegression().fit(cars.speed.reshape(-1,1), cars.dist)\n    # 回归预测值\n    pred = reg.predict(cars.speed.reshape(-1,1))\n\n    # 绘制回归线\n    plt.plot(cars.speed, pred, linewidth = 2, label = '回归线')\n\n    # 添加轴标签和标题\n    plt.title('汽车速度与刹车距离的关系')\n    plt.xlabel('汽车速度')\n    plt.ylabel('刹车距离')\n\n    # 去除图边框的顶部刻度和右边刻度\n    plt.tick_params(top = 'off', right = 'off')\n    # 显示图例\n    plt.legend(loc = 'upper left')\n    # 显示图形\n    plt.show()\n```\n# matplotlib(雷达图)\n```Python\n    # 导入第三方模块\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # 中文和负号的正常显示\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 使用ggplot的绘图风格\n    plt.style.use('ggplot')\n\n    # 构造数据\n    values = [3.2,2.1,3.5,2.8,3]\n    feature = ['个人能力','QC知识','解决问题能力','服务质量意识','团队精神']\n\n    N = len(values)\n    # 设置雷达图的角度，用于平分切开一个圆面\n    angles=np.linspace(0, 2*np.pi, N, endpoint=False)\n\n    # 为了使雷达图一圈封闭起来，需要下面的步骤\n    values=np.concatenate((values,[values[0]]))\n    angles=np.concatenate((angles,[angles[0]]))\n\n    # 绘图\n    fig=plt.figure()\n    # 这里一定要设置为极坐标格式\n    ax = fig.add_subplot(111, polar=True)\n    # 绘制折线图\n    ax.plot(angles, values, 'o-', linewidth=2)\n    # 填充颜色\n    ax.fill(angles, values, alpha=0.25)\n    # 添加每个特征的标签\n    ax.set_thetagrids(angles * 180/np.pi, feature)\n    # 设置雷达图的范围\n    ax.set_ylim(0,5)\n    # 添加标题\n    plt.title('活动前后员工状态表现')\n    # 添加网格线\n    ax.grid(True)\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0m6gdokgj20c0080aai.jpg)\n\n# 多条线的雷达图\n```python\n    # 导入第三方模块\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # 中文和负号的正常显示\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 使用ggplot的绘图风格\n    plt.style.use('ggplot')\n\n    # 构造数据\n    values = [3.2,2.1,3.5,2.8,3]\n    values2 = [4,4.1,4.5,4,4.1]\n    feature = ['个人能力','QC知识','解决问题能力','服务质量意识','团队精神']\n\n    N = len(values)\n    # 设置雷达图的角度，用于平分切开一个圆面\n    angles=np.linspace(0, 2*np.pi, N, endpoint=False)\n    # 为了使雷达图一圈封闭起来，需要下面的步骤\n    values=np.concatenate((values,[values[0]]))\n    values2=np.concatenate((values2,[values2[0]]))\n    angles=np.concatenate((angles,[angles[0]]))\n\n    # 绘图\n    fig=plt.figure()\n    ax = fig.add_subplot(111, polar=True)\n    # 绘制折线图\n    ax.plot(angles, values, 'o-', linewidth=2, label = '活动前')\n    # 填充颜色\n    ax.fill(angles, values, alpha=0.25)\n    # 绘制第二条折线图\n    ax.plot(angles, values2, 'o-', linewidth=2, label = '活动后')\n    ax.fill(angles, values2, alpha=0.25)\n\n    # 添加每个特征的标签\n    ax.set_thetagrids(angles * 180/np.pi, feature)\n    # 设置雷达图的范围\n    ax.set_ylim(0,5)\n    # 添加标题\n    plt.title('活动前后员工状态表现')\n\n    # 添加网格线\n    ax.grid(True)\n    # 设置图例\n    plt.legend(loc = 'best')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0m7o9accj20c0080mxt.jpg)\n\n# pygal模块则提供了更加简单的雷达图函数\n```python\n    # 导入第三方模块\n    import pygal\n\n    # 调用Radar这个类，并设置雷达图的填充，及数据范围\n    radar_chart = pygal.Radar(fill = True, range=(0,5))\n    # 添加雷达图的标题\n    radar_chart.title = '活动前后员工状态表现'\n    # 添加雷达图各顶点的含义\n    radar_chart.x_labels = ['个人能力','QC知识','解决问题能力','服务质量意识','团队精神']\n\n    # 绘制两条雷达图区域\n    radar_chart.add('活动前', [3.2,2.1,3.5,2.8,3])\n    radar_chart.add('活动后', [4,4.1,4.5,4,4.1])\n\n    # 保存图像\n    radar_chart.render_to_file('radar_chart.svg')\n```\n# matplotlib(面积图)\n## stackplot函数语法及参数含义\n```python\nstackplot(x,*args,**kargs)\n```\n\n|参数|说明|\n|:---|:---|\n|x|指定面积图的x轴数据|\n|*args|为可变参数，可以接受任意多的y轴数据，即各个拆分的数据对象|\n|**kargs|为关键字参数，可以通过传递其他参数来修饰面积图，如标签、颜色|\n\n---\n\n- 可用的关键字参数：\n\n|参数|说明|\n|:---|:---|\n|labels|以列表的形式传递每一块面积图包含的标签，通过图例展现|\n|colors|设置不同的颜色填充面积图|\n\n```python\n    # ========== Python3 + Jupyter ========== #\n    # 导入第三方模块\n    import pandas as pd\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # 设置图形的显示风格\n    plt.style.use('ggplot')\n    # 设置中文和负号正常显示\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 读取数据\n    transport = pd.read_excel('transport.xls')\n    # 窥探数据框的前5行\n    transport.head()\n\n    # 折线图的x变量值，即Jan（一月份）到Aug（八月份）8个值\n    N = np.arange(transport.shape[1]-1)\n\n    # 绘制拆分的折线图\n    labels = transport.Index\n    channel = transport.columns[1:]\n\n    for i in range(transport.shape[0]):\n        plt.plot(N, # x坐标\n                 transport.loc[i,'Jan':'Aug'], # y坐标\n                 label = labels[i], # 添加标签\n                 marker = 'o', # 给折线图添加圆形点\n                 linewidth = 2 # 设置线的宽度\n                )\n\n    # 添加标题和坐标轴标签\n    plt.title('2017年各运输渠道的运输量')\n    plt.ylabel('运输量(万吨)')\n    # 修改x轴的刻度标签\n    plt.xticks(N,channel)\n\n    # 剔除图框上边界和右边界的刻度\n    plt.tick_params(top = 'off', right = 'off')\n\n    # 显示图例（即显示label的效果）  \n    plt.legend(loc = 'best')  \n    # 显示图形\n    plt.show()\n```\n\n- 这就是绘制分组的折线图思想，虽然折线图能够反映各个渠道的运输量随月份的波动趋势，但无法观察到1月份到8月份的各自总量。接下来我们看看面积图的展现。\n\n```python\n    x = N\n    # 将铁路运输、公路运输和水路运输各月的值提取出来，存储到y1~y3\n    # 千万千万记得，提取出数据框的一列时，需要将序列的数据类型进行强制转换，否则会报错\n    y1 = transport.loc[0,'Jan':'Aug'].astype('int')\n    y2 = transport.loc[1,'Jan':'Aug'].astype('int')\n    y3 = transport.loc[2,'Jan':'Aug'].astype('int')\n\n    # 定义各区块面积的含义\n    colors = ['#ff9999','#9999ff','#cc1234']\n\n    # 绘制面积图\n    plt.stackplot(x, # x轴\n                  y1,y2,y3, # 可变参数，接受多个y\n                  labels = labels, # 定义各区块面积的含义\n                  colors = colors # 设置各区块的填充色\n                 )\n\n    # 添加标题和坐标轴标签\n    plt.title('2017年各运输渠道的运输量')\n    plt.ylabel('累积运输量(万吨)')\n\n    # 修改x轴的刻度\n    plt.xticks(N,channel)\n\n    # 剔除图框上边界和右边界的刻度\n    plt.tick_params(top = 'off', right = 'off')\n\n    # 显示图例（即显示labels的效果）  \n    plt.legend(loc = 'upper left')\n    # 显示图形\n    plt.show()\n```\n\n# matplotlib(树地图)\n## squarify.plot函数\n```python\nsquarify.plot(sizes,\n        norm_x=100,\n        norm_y=100,\n        color=None,\n        label=None,\n        value=None,\n        alpha,\n        **kwargs)\n```\n\n|参数|说明|\n|:---|:---|\n|sizes|指定离散变量各水平对应的数值，即反映树地图子块的面积大小|\n|norm_x|默认将x轴的范围限定在0-100之内|\n|norm_y|默认将y轴的范围限定在0-100之内|\n|color|自定义设置树地图子块的填充色|\n|label|为每个子块指定标签|\n|value|为每个子块添加数值大小的标签|\n|alpha|设置填充色的透明度|\n|**kwargs|关键字参数，与条形图的关键字参数类似，如设置边框色、边框粗细等|\n\n```python\n    # 导入第三方包\n    import matplotlib.pyplot as plt\n    import squarify\n\n    #中文及负号处理办法\n    plt.rcParams['font.sans-serif'] = 'SimHei'\n    plt.rcParams['axes.unicode_minus'] = False\n\n    # 创建数据\n    name = ['国内增值税','国内消费税','企业所得税','个人所得税',\n            '进口增值税、消费税','出口退税','城市维护建设税',\n            '车辆购置税','印花税','资源税','土地和房税','车船税烟叶税等']\n    income = [3908,856,801,868,1361,1042,320,291,175,111,414,63]\n            \n    # 绘图\n    colors = ['steelblue','#9999ff','red','indianred',\n              'green','yellow','orange']\n              plot = squarify.plot(sizes = income, # 指定绘图数据\n                         label = name, # 指定标签\n                         color = colors, # 指定自定义颜色\n                         alpha = 0.6, # 指定透明度\n                         value = income, # 添加数值标签\n                         edgecolor = 'white', # 设置边界框为白色\n                         linewidth =3 # 设置边框宽度为3\n                        )\n              # 设置标签大小\n    plt.rc('font', size=8)\n    # 设置标题大小\n    plot.set_title('2017年8月中央财政收支情况',fontdict = {'fontsize':15})\n\n    # 去除坐标轴\n    plt.axis('off')\n    # 去除上边框和右边框刻度\n    plt.tick_params(top = 'off', right = 'off')\n    # 显示图形\n    plt.show()\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fx0miksd7jj20c0080jro.jpg)\n\n# 数据文件\n[链接提取码: u6rg](https://pan.baidu.com/s/1hMRJAz0OvsAtYhsbjY4njw)\n\n---\n\n- 作者：天痕坤\n- [原文](https://blog.csdn.net/kun1280437633/article/details/80841364)","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"PySpider 马蜂窝网景点","path":"/posts/PySpiderMaFengwo.html","content":"PySpider 马蜂窝景点信息\n<!--more-->\n# PySpider\n```Python\n#!/usr/bin/env python\n# -*- encoding: utf-8 -*-\n# Created on 2018-11-06 11:52:31\n# Project: PySpider_MaFengWo\n\nfrom pyspider.libs.base_handler import *\nimport json\nfrom pyspider.libs.utils import md5string\nimport re\nfrom fake_useragent import UserAgent\n\ndefault_headers = {\n           'Accept':'application/json, text/javascript, */*; q=0.01',\n           'Accept-Encoding':'gzip, deflate',\n           'Accept-Language':'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\n           'Connection':'keep-alive',\n           'Content-Length':68,\n           'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',\n           'Connection':'keep-alive',\n           'Upgrade-Insecure-Requests':1,\n           'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3100.0 Safari/537.36',\n           'X-Requested-With':'XMLHttpRequest',\n        }\n\nclass Handler(BaseHandler):\n    crawl_config = {\n        'headers':default_headers,\n        'timeout':300,\n        'proxy':'192.168.1.1:8080',\n    }\n\n    @every(minutes=24 * 60)\n    def on_start(self):\n        url = 'http://www.mafengwo.cn/jd/10088/gonglve.html'\n        self.crawl(url,callback=self.get_index,fetch_type='js')\n\n    def get_taskid(self, task):\n        return md5string(task['url']+json.dumps(task['fetch'].get('data', '')))\n\n    def get_index(self,response):\n        url = 'http://www.mafengwo.cn/ajax/router.php'\n        total = int(response.doc('.pi.pg-last').attr('data-page'))\n        for i in range(1,total+1):\n            data = {\n                    'sAct':'KMdd_StructWebAjax|GetPoisByTag',\n                    'iMddid':'10088',\n                    ' iTagId':0,\n                    'iPage':i\n             }\n            self.crawl(url,method='POST',data=data,callback=self.index_page)\n\n    # 每一个回调detail_page的任务有效期是10天\n    @config(age=10 * 24 * 60 * 60)\n    def index_page(self, response):\n        print(response.text)\n        result = response.text.replace('\\\\','')\n        print(result)\n        pattern = re.compile('<a href=\"(.*?)\" target=')\n        urls = re.findall(pattern,result)\n        for url in urls:\n            mainurl = 'https://www.mafengwo.cn'\n            self.crawl(mainurl + url, callback=self.detail_page,fetch_type='js')\n\n    # 数字越大优先级越高\n    @config(priority=2)\n    def detail_page(self, response):\n        return {\n        \"name\": response.doc('h1').text(),\n        \"location\":response.doc('.mhd > p').text(),\n        \"price\":response.doc('.mod-detail dd > div').text(),\n        \"phone\":response.doc('.tel > .content').text(),\n        \"visittime\":response.doc('.item-time > .content').text(),\n        \"website\":response.doc('.content > a').text(),\n\n        }\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python Kmeans","path":"/posts/PythonKMean.html","content":"Python Kmeans\n<!--more-->\n# KMeans\n\n- K - means是一个反复迭代的过程，算法分为四个步骤：\n\n```Python\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    # @Time    : 18-11-5 下午12:10\n    # @Author  : Vitan\n    # @File    : Kmeans.py\n\n    from sklearn.datasets import load_iris\n    import numpy as np\n    import matplotlib.pyplot as plt\n    from sklearn.cluster import KMeans\n    x = np.random.randint(1,50,[20,1])\n\n    # 定义一个给定形状和类型的用0填充的数组y\n    y = np.zeros(20)\n    k = 3 # 分成3类\n\n    # 1. 选取数据空间中的K个对象作为初始中心，每个对象代表一个聚类中心；\n    def initcenter(x,k):\n        return x[:k]\n\n    # 2. 对于样本中的数据对象，根据它们与这些聚类中心的欧氏距离，\n    # 按距离最近的准则将它们分到距离它们最近的聚类中心（最相似）所对应的类；\n\n    # 计算欧氏距离\n    def nearest(kc,i):\n        d = abs(kc -i) # asb() 取绝对值\n        # 返回与聚类中心最小距离所在类别的索引号\n        w = np.where(d == np.min(d))\n        return w[0][0]\n\n    # 按距离最近的准则将它们分到距离它们最近的聚类中心（最相似）所对应的类\n    def xclassify(x, y, kc):\n        # 对数组的每个值进行分类，shape[0]读取矩阵第一维度的长度\n        for i in range(x.shape[0]):\n            y[i] = nearest(kc, x[i])\n            return y\n    kc = initcenter(x,k)\n    y = xclassify(x,y,kc)\n    print(kc,y)\n\n    # 3. 更新聚类中心：将每个类别中所有对象所对应的均值作为该类别的聚类中心，计算目标函数的值；\n    def kcmean(x,y,kc,k):\n        l = list(kc)\n        flag = False\n        for c in range(k):\n            m = np.where(y ==0)\n            n = np.mean(x[m])\n            if l[c] != n:\n                l[c] = n\n                flag = True\n                print(l,flag)\n        return (np.array(l),flag)\n\n    # 4 . 判断聚类中心和目标函数的值是否发生改变，若不变，则输出结果，若改变，则返回2）\n    kc = initcenter(x,k)\n    flag = True # 聚类中心发生改变\n    print(x,y,kc,flag)\n    while flag:\n        y = xclassify(x,y,kc)\n        kc,flag = kcmean(x,y,kc,k)\n    print(y,kc)\n```\n\n# 鸢尾花\n\n- 鸢尾花花瓣长度数据做聚类并用散点图显示\n\n```python\n    iris = load_iris()\n    data = iris.data\n    iris_length = data[:,2]\n\n    x = np.array(iris_length)\n    y = np.zeros(x.shape[0]) # x.shape[0] 只读取x的第一维度长度\n\n    # 选取数据空间中的K个对象作为初始中心，每个对象代表一个聚类中心；\n    kc = initcenter(x,3)\n\n    # 按距离最近的准则将它们分到距离它们最近的聚类中心（最相似）所对应的类\n    flag = True\n    while flag:\n        y = xclassify(x,y,kc)\n        kc,flag = kcmean(x,y,kc,3)\n    print(kc,flag)\n\n    plt.scatter(iris_length, iris_length, c = y,cmap = 'rainbow')\n    plt.savefig('花瓣长度散点图.png')\n    plt.show()\n```\n\n- 用sklearn.cluster.KMeans，花瓣长度数据做聚类\n\n```python\n    iris_length = data[:, 2:3]\n    kmeans = KMeans(n_clusters = 4 )\n    result = kmeans.fit(iris_length)\n    kc1 = result.cluster_centers_\n    y_kmeans = kmeans.predict(iris_length) # 预测每个样本的聚类索引\n\n    plt.scatter(iris_length,np.linspace(1,150,150),c = y_kmeans,marker = 'D',cmap = 'rainbow')\n    plt.savefig('sklearn.cluster.KMeans长度.png')\n    plt.show()\n```\n\n- 鸢尾花完整数据做聚类\n\n```python\n    k_means1 = KMeans(n_clusters = 4)\n    result1 = k_means1.fit(data)\n    kc2 = result1.cluster_centers_\n    y_kmeans1 = k_means1.predict(data)\n\n    plt.scatter(data[:, 0], data[:, 1], c = y_kmeans1, marker = 'p',cmap = 'rainbow')\n    plt.savefig('完整数据聚类.png')\n    plt.show()\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python Tips","path":"/posts/PythonTips.html","content":"Python 小技巧\n<!---more-->\n# 打印 index\n对列表，数列打印他们的 index\n\n- 一般方法\n\n```Python\n    cities = ['Shanghai','beijing','Chengdu']\n    i = 0\n    for c in cities:\n        print(i +1,'-->',c)\n        i += 1\n```\n\n- 更好的方法(使用 enumerate)\n\n```Python\n    cities = ['Shanghai','beijing','Chengdu']\n    for i,city in enumerate(cities):\n        print(i+1,'-->',city)\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fwscu1oiy9j204d0303yd.jpg)\n\n# 两个系列循环\n对两个序列进行计算或处理\n\n- 一般方法\n\n```Python\n    names = ['leo','jack','james']\n    colors = ['red','green','blue','yellow']\n    n = min(len(names),len(colors))\n    for i in range(n):\n        print(names[i],'-->',colors[i])\n```\n\n- 更好的方法(使用 zip)\n\n```Python\n    names = ['leo','jack','james']\n    colors = ['red','green','blue','yellow']\n    for name,color in zip(names,colors):\n        print(name,'-->',color)\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fwscu1m48wj204l02r3yd.jpg)\n\n# 交换变量\n多个变量之间的交换，如冒泡排序法\n\n- 一般方法\n\n```Python\n    x = 1\n    y = 2\n    print('>>Before:x={},y={}'.format(x,y))\n    tmp = y\n    y = x\n    x = tmp\n    print('>>After:x = {},y = {}'.format(x,y))\n```\n\n- 更好的方法\n\n```Python\n    x = 1\n    y= 2\n    print('Before:x = {},y = {}'.format(x,y))\n    x,y = y,x\n    print('After:x = {},y = {}'.format(x,y))\n```\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fwscu1nt3kj205a01pt8j.jpg)\n\n# 字典的读取\n对字典的访问和读取，读取的字典 key 为空，需要一个缺省值\n\n- 一般方法\n\n```Python\n    students = {'Lili':18,'Sam':25}\n    if 'Susan' in students:\n        student = students['Susan']\n    else:\n        student = 'unknow'\n    print('Susan is {} yesrs old'.format(student))\n```\n\n- 更好的方法\n\n```Python\n    students = {'Lili':18,'San':25}\n    student = students.get('Susan','unknow')\n    print('Susan is {} yesrs'.format(student))\n```\n- 巧妙地利用字典的 get 的方法。若字典没有 Susan 的 key，则用 unknow 来表示缺省值。\n\n# 循环查找\n在一个大的循环中作搜索，如在文件中搜索关键字，从文件名列表中查找特殊的文件名\n\n- 一般方法\n\n```Python\n    target_letter = 'd'\n    letters = ['a','b','c']\n\n    found = False\n    for letter in letters:\n        if letter == target_letter:\n            print('Found')\n            found = True\n            break\n    if not found:\n        print('Not Found')\n```\n\n- 更好的方法\n\n```Python\n    target_letter = 'd'\n    letters = ['a','b','c']\n\n    for letter in letters:\n        if letter == target_letter:\n            print('found')\n            break\n    else:\n        print('Not Found')\n```\n\n# 文件读取查找\n打开以文件，对内容进行循环读取处理\n\n- 一般方法\n\n```Python\n    f = open('data.txt')\n    try:\n        text = f.read()\n        for line in text.split('\\n'):\n            print(line)\n    finally:\n        f.close()\n```\n\n- 更好的方法\n\n```Python\n    with open('data.txt') as f:\n        for line in f:\n            print(line.strip('\\n'))\n```\n\n# 关于锁的写法\n对于并发操作尤其是多线程的操作，对同一内存进行读写操作时，加锁保护\n\n- 一般方法\n\n```Python\n    import threading\n\n    lock = threading.Lock()\n    lock.acquire()\n    try:\n        print('Citical par,do somethins...')\n    finally:\n        lock.release()\n```\n\n- 更好的方法\n\n```Python\n    import threading\n    lock = threading.Lock()\n    with lock:\n        print('Citical par,do somethins...')\n```\n---\n**Via**\n- [七种不一样的Python代码写法，让你写出一手漂亮的代码](https://www.bilibili.com/read/cv1417439)","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"PySpider 猫途鹰景点","path":"/posts/PySpiderMaoTuYing.html","content":"PySpider 爬猫途鹰网排名景点并保存至 MongoDB\n<!--more-->\n```Python\n    #!/usr/bin/env python\n    # -*- encoding: utf-8 -*-\n    # Created on 2018-10-30 18:01:28\n    # Project: Maotu\n\n    from pyspider.libs.base_handler import *\n    import pymongo\n\n    class Handler(BaseHandler):\n        crawl_config = {\n        }\n        client = pymongo.MongoClient('localhost')\n        db = client['maotu']\n\n        @every(minutes=24 * 60)\n        def on_start(self):\n            url = 'https://www.tripadvisor.cn/Attractions-g294217-Activities-Hong_Kong.html''\n            self.crawl(url,callback=self.index_page,validate_cert=False,fetch_type='js')\n\n        @config(age=10 * 24 * 60 * 60)\n        def index_page(self, response):\n            for each in response.doc('.attraction_element .listing_title  > a').items():\n                self.crawl(each.attr.href, callback=self.detail_page,validate_cert=False,fetch_type='js')\n            nextlink = response.doc('.nav.next').attr.href\n            self.crawl(nextlink,callback=self.index_page,validate_cert=False,fetch_type='js')\n\n        @config(priority=2)\n        def detail_page(self, response):\n                name =  response.doc('.h1').text(),\n                rank =response.doc('b > span').text(),\n                location = response.doc('.headerBL > div').text(),\n                view = response.doc('.seeAllReviews').text()[:-3],\n                score = response.doc('.overallRating').text(),\n                kfsj = response.doc('.headerBL .header_detail').text()[5:],\n                phone = response.doc('.contact > .phone > div').text()[0:-4]\n                return {\n                    \"name\":name,\n                    \"rank\":rank,\n                    \"location\":location,\n                    \"view\":view,\n                     \"score\":score,\n                    \"kf\":kfsj,\n                    \"phone\":phone\n            }\n\n        def on_result(self,result):\n                    if result:\n                           self.save_to_mongo(result)\n\n        def save_to_mongo(self,result):\n                    if self.db['MaoTU_HongKong'].insert(result):\n                        print('savinf to mongo',result)\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"鸢尾花 Sklearn","path":"/posts/IrisSklearn.html","content":"Sklearn 鸢尾花\n<!--more-->\n# 鸢尾花\n从sklearn 包自带的数据集中读出鸢尾花数据集 data\n```Python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time    : 18-10-29 上午11:58\n# @Author  : Vitan\n# @File    : Sklearn_iris.py\nfrom sklearn.datasets import load_iris\nimport numpy as np\nimport matplotlib.pyplot as plt\ndata = load_iris()\nprint(data)\n```\n\n## 查看data类型，包含哪些数据\n```Python\nprint(type(data))\nprint(data.keys())\n```\n\n## 取出鸢尾花特征和鸢尾花类别数据，查看其形状及数据类型\n```Python\niris_feature = data.feature_names,data.data\niris_target = data.target_names,data.target\nprint('鸢尾花特征数据：',iris_feature)\nprint('鸢尾花类别：',iris_target)\nsepal_len = np.array(list(len[0] for len in data.data))\nprint('花萼长度：',sepal_len)\n```\n\n## 取出所有花的花萼长度(cm)的数据\n```Python\nsepal_len = np.array(list(len[0] for len in data.data))\nprint('所有花萼长宽：',sepal_len)\n```\n## 取出所有花的花瓣长度(cm)+花瓣宽度(cm)的数据\n```Python\nfor item in data:\n  # 花瓣长度\n    petal_len = np.array(list(len[2] for len in data.data))\n    # 花萼宽度\n    petal_wid = np.array(list(len[3] for len in data.data))\niris_len = (petal_len,petal_wid)\nprint(iris_len)\n```\n\n## 取出某朵花的四个特征及其类别。\n```Python\nprint('四个特征',data.data[1],data.target[1])\n```\n\n## 将所有花的特征和类别分成三组，每组50个\n```Python\n    iris_set = []\n    iris_ver = []\n    iris_vir = []\n\n    # 循环遍历所有的数据\n    for i in range(0, 150):\n        # 类别为0的为 setosa 花，生成一条setosa类的鸢尾花数据\n        if data.target[i] == 0:\n            Data = data.data[i].tolist()\n            Data.append('setosa')\n            iris_set.append(Data)\n\n        # 类别为1的即为 versicolor，生成一条versicolor类的鸢尾花数据\n        elif data.target[i] == 1:\n            Data = data.data[i].tolist()\n            Data.append('versicolor')\n            iris_ver.append(Data)\n        # 3 为维吉尼亚鸢尾花\n        else:\n            Data = data.data[i].tolist()\n            Data.append('virginica')\n            iris_vir.append(Data)\n    print(iris_set,iris_ver,iris_vir)\n```\n\n## 生成新的数组，每个元素包含四个特征+类别\n```Python\niris_result = np.array([iris_set, iris_ver, iris_vir])\nprint(\"分组:\", iris_result)\n```\n\n## 计算鸢尾花花瓣长度的最大值，平均值，中值，均方差。\n```Python\n#鸢尾花花瓣长度的数据\npetal_length = np.array(list(len[3] for len in data.data))\nprint(petal_length) # 输出数据\nprint('花瓣长度的最大值',np.max(petal_length))\nprint('平均值：',np.mean(petal_length))\nprint('中值：',np.median(petal_length))\nprint('均方差：',np.std(petal_length))\n```\n\n## 显示鸢尾花某一特征的曲线图，散点图。\n- 曲线图\n\n```Python\niris_feature = data.feature_names,data.data\n\nx = np.linspace(0,150,num = 150)\nplt.plot(x,iris_feature)\nplt.savefig(\"特征曲线图.png\")\nplt.show()\n```\n\n- 散点图\n\n```Python\nplt.scatter(x,iris_feature)\nplt.savefig(\"特征散点图.png\")\nplt.show()\n```\n\n## np.random\n- 用 np.random.normal() 产生一个正态分布的随机数组，并显示出来。\n\n```Python\nmu = 50\nsigma = 0.6\nnum = 3000\nzu = np.random.normal(mu,sigma,num)\ncount,bins,ignored = plt.hist(zu,30,normed = True)\nplt.plot(bins,1/(sigma*np.sqrt(2*np.pi))*np.exp( - (bins-mu)**2/(2*sigma*2)),linewidth=2,color='g')\nplt.savefig(\"np.random.normal().png\")\nplt.show()\n```\n\n- np.random.randn()产生一个正态分布的随机数组，并显示出来。\n\n```Python\n'''\nnp.random.rand(n) 产生标准正态分布， 即均值为0 标准差为1 的高斯分布\n同于 np.random.normal(0, 1, n)\n'''\nmu = 100\nsigma = 15\nnum_bins = 50 # 分隔的段数\n\n# 产生500个均值为100， 方差为15 的随机数,等于 x = np.random.normal(100, 15, 500)\nx = mu + sigma * np.random.randn(500)\nfig, ax = plt.subplots()\nn, bins, patches = ax.hist(x, num_bins, normed=True)# x为数据，ax.hist()即是画柱状图的函数\nplt.plot(bins,1/(sigma*np.sqrt(2*np.pi))*np.exp( - (bins-mu)**2/(2*sigma*2)),linewidth=2,color='r')\nplt.savefig(\"np.random.randn().png\")\nplt.show()\n```\n\n\n## 显示鸢尾花花瓣长度的正态分布图，曲线图，散点图\n- 正态分布图\n\n```Python\nmu = np.mean(petal_length) # 期望值\nsigma = np.std(petal_length) # 标准差\nnum = 500 # 个数\n\nnormal_data = np.random.normal(mu,sigma,num)\ncount,bins,ignored = plt.hist(normal_data,20,normed=True)\nplt.plot(bins,1/(sigma*np.sqrt(2*np.pi))*np.exp( - (bins-mu)**2/(2*sigma*2)),linewidth=2,color='b')\nplt.savefig(\"花瓣长度正态分布图.png\")  # 保存图片文件\nplt.show()\n```\n\n- 曲线图\n\n```Python\nx = np.linspace(0,150,num=150)\nplt.plot(x,petal_len)\nplt.savefig(\"花瓣长度曲线图.png\")\nplt.show()\n```\n\n- 散点图\n\n```Python\nplt.scatter(x,petal_len,)\nplt.savefig(\"花瓣长度散点图.png\")\nplt.show()\n```","tags":["WebCrawler","Python"],"categories":["Coding"]},{"title":"猫眼电影 Top100","path":"/posts/CatEyeMovice.html","content":"猫眼电影 Top100\n<!--more-->\n# 思路\n1. 获取单页网页源代码并返回源代码\n2. 解析单页网页源代码，提取 title、actor、time、score 等数据并存储为生成器\n3. 将生成器里每一部电影的数据写入txt文档中\n4. 研究第 1-10 页 url 的规律，构建 url，调用 1、2、3 步骤\n\n\n# 步骤\n获取单页网页源代码并返回源代码\n```Python\n    import requests\n    import re\n    import json\n    from requests.exceptions import RequestException\n\n    def get_one_page(url):\n        headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36'}\n        try:\n            response = requests.get(url,headers = headers)\n            if response.status_code == 200:\n                html = response.text\n                return html\n            return None\n        except RequestException:\n            return None\n```\n\n- 打印第一页源码\n\n```Python\nprint(get_one_page('http://maoyan.com/board/4'))\n```\n\n解析单页网页源代码，提取title、actor、time、score数据并存储为生成器\n```Python\n    def parse_one_page(html):\n        pattern = re.compile('<dd>.*?board-index.*?>(\\d+)</i>'\n        + '.*?<p.*?title=\"(.*?)\".*?</p>.*?star\">(.*?)</p>'\n        + '.*?releasetime\">(.*?)</p>.*?integer\">(.*?)'\n        + '<.*?fraction\">(.*?)</i>',re.S)\n        movies = re.findall(pattern,html)\n        for item in movies:\n            yield{\n                '排名':item[0],\n                '电影名':item[1],\n                '主演':item[2].strip()[3:],\n                '上映时间':item[3][5:],\n                '评分':item[4]+item[5]\n            }\n```\n\n> 注意一下，这里需要用 yield，而不是return。yield函数返回的是一个生成器（一种特殊的迭代器，可以用for循环进行遍历）\n> 如果用return，那么在第一轮循环结束就会跳出，只能获取到一部影片的信息\n\n将生成器数据写入 txt 文档\n```Python\n    def write_to_txt(content):\n        # 采用 append 追加模式，字符集为utf8\n        with open('movies.txt','a',encoding='utf8') as f:\n            # 采用json的dumps方法来初始化字符串\n            f.write(json.dumps(content,ensure_ascii=False) + '\\n')\n            f.close()\n```\n\n研究第1-10页\n```Python\n    # 第1-10页url\n    for i in range(0,10):\n        url = 'https://maoyan.com/board/4?offset=' + str(i * 10)\n        # 构建 url，调用1、2、3步骤\n        html = get_one_page(url)\n        movies= parse_one_page(html)\n        for item in movies:\n            write_to_txt(item)\n```\n\n## 多线程保持为 txt\n- 第一步\n\n```Python\n    import requests\n    import re\n    import json\n    from multiprocessing import Pool\n    from requests.exceptions import RequestException\n\n    def get_one_page(url):\n        headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36'}\n        try:\n            response = requests.get(url,headers = headers)\n            if response.status_code == 200:\n                html = response.text\n                return html\n            return None\n        except RequestException:\n            return None\n```\n\n- 第二步\n\n```Python\n    def main(offset):\n        url = 'http://maoyan.com/board/4?offset=' + str(offset)\n        html = get_one_page(url)\n        for item in parse_one_page(html):\n            print(item)\n            write_to_txt(item)\n\n    if __name__ == '__main__':\n        pool = Pool() # 多线程\n        pool.map(main, [i*10 for i in range(10)])\n        pool.close()\n        pool.join()\n```\n\n# 保持为 CSV\n## 单线程\n```Python\n    import requests\n    import re\n    import json\n    import pandas\n    from requests.exceptions import RequestException\n\n    def get_one_page(url):\n        headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36'}\n        response = requests.get(url,headers = headers)\n        html = response.text\n        return html\n\n    def parse_one_page(html):\n        pageary = []\n        pattern = re.compile('<dd>.*?board-index.*?>(\\d+)</i>'\n        + '.*?<p.*?title=\"(.*?)\".*?</p>.*?star\">(.*?)</p>'\n        + '.*?releasetime\">(.*?)</p>.*?integer\">(.*?)'\n        + '<.*?fraction\">(.*?)</i>',re.S)\n        movies = re.findall(pattern,html)\n        for item in movies:\n            dict = {\n                '电影名':item[0],\n                '主演':item[1].strip()[3:],\n                '上映时间':item[2][5:],\n                '评分':item[3]+item[4]\n            }\n            pageary.append(dict)\n        return pageary\n\n    ary = []\n    for i in range(0,10):\n        url = 'https://maoyan.com/board/4?offset=' + str(i * 10)\n        html = get_one_page(url)\n        pageary = parse_one_page(html)\n        ary = ary + pageary\n    df = pandas.DataFrame(ary)\n    df.to_csv('movies.csv')\n```\n\n## 多线程\n```Python\n    import requests\n    import re\n    import json\n    import pandas\n    from multiprocessing import Pool\n    from requests.exceptions import RequestException\n\n    def get_one_page(url):\n        headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36'}\n        try:\n            response = requests.get(url,headers = headers)\n            if response.status_code == 200:\n                html = response.text\n                return html\n            return None\n        except RequestException:\n            return None\n\n    def parse_one_page(html):\n        pageary = []\n        pattern = re.compile('<dd>.*?board-index.*?>(\\d+)</i>'\n        + '.*?<p.*?title=\"(.*?)\".*?</p>.*?star\">(.*?)</p>'\n        + '.*?releasetime\">(.*?)</p>.*?integer\">(.*?)'\n        + '<.*?fraction\">(.*?)</i>',re.S)\n        movies = re.findall(pattern,html)\n        for item in movies:\n            dict = {\n                '排名':item[0],\n                '电影名':item[1],\n                '主演':item[2].strip()[3:],\n                '上映时间':item[3][5:],\n                '评分':item[4]+item[5]\n            }\n            pageary.append(dict)\n        return pageary\n\n    def write_to_csv(pageary):\n        ary = []\n        ary = ary + pageary\n        df = pandas.DataFrame(ary)\n        df.to_csv('movies.csv')\n\n    def main(offset):\n        url = 'https://maoyan.com/board/4?offset=' + str(offset)\n        pageary = parse_one_page(html)\n        write_to_csv(ary)\n\n    if __name__ == '__main__':\n        pool = Pool()\n        pool.map(main, [i*10 for i in range(10)])\n        pool.close()\n        pool.join()\n```","tags":["WebCrawler","Python"],"categories":["Coding"]},{"title":"Python 时间日期处理","path":"/posts/PythonDateTime.html","content":"Python DateTime 时间日期处理.\n<!--more-->\n# DateTime\n## 获取当前 DateTime\n```Python\nfrom datetime timport datetime\ndatetime.datetime.now()\n```\n\n## 获取当天 date\n```Python\ndatetime.date.today()\n```\n\n## 获取明天/前N天\n```Python\n# 明天\natetime.date.today() + datetime.timedelta(days=1)\n# 前N天\ndatetime.datetime.now()\ndatetime.datetime.now() - datetime.timedelta(days=3)\n```\n\n## 获取当天开始和结束时间\n```Python\ndatetime.datetime.combine(datetime.date.today(), datetime.time.min)\ndatetime.datetime.combine(datetime.date.today(), datetime.time.max)\n```\n\n## 获取两个 datetime 的时间差\n```Python\nnow = datetime.now()\nend = datetime.strptime('2018-10-25 22:00','%Y-%m-%d %H:%M')\ntime = end - now\nprint(time.days,'天')\n```\n## 获取本周/本月/上月最后一天\n\n- 本周最后一天\n\n```Python\nimport datetime\ntoday = datetime.date.today()\nsunday = today + datetime.timedelta(6 - today.weekday())\nsunday\n```\n\n- 本月最后一天\n\n```Python\nimport calendar\ntoday = datetime.date.today()\nlast_day_num = calendar.monthrange(today.year, today.month)\nlast_day = datetime.date(today.year, today.month, last_day_num)\nlast_day\n```\n\n- 上月最后一天\n\n```Python\nimport datetime\ntoday = datetime.date.today()\nfirst = datetime.date(day=1, month=today.month, year=today.year)\nlastMonth = first - datetime.timedelta(days=1)\n```\n# 转换\n## datetime <=> string\n\n- datetime -> string\n\n```Python\nimport datetime\ndatetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n```\n\n- string -> datetime\n\n```Python\nimport datetime\ndatetime.datetime.strptime(\"2018-10-22 12:50:46\", \"%Y-%m-%d %H:%M:%S\")\n```\n\n## datetime <=> timetuple\n\n- datetime -> timetuple\n\n```Python\nimport datetime\ndatetime.datetime.now().timetuple()\n```\n\n- timetuple -> datetime\n\n```Python\ntimetuple => timestamp => datetime [看后面datetime<=>timestamp]\n```\n\n## datetime <=> date\n\n- datetime -> date\n\n```Python\nimport datetime\ndatetime.datetime.now().date()\n```\n\n- date -> datetime\n\n```Python\ndatetime.date.today()\ntoday = datetime.date.today()\ndatetime.datetime.combine(today, datetime.time())\ndatetime.datetime.combine(today, datetime.time.min)\n```\n## datetime <=> timestamp\n\n- datetime -> timestamp\n\n```Python\nnow = datetime.datetime.now()\ntimestamp = time.mktime(now.timetuple())\ntimestamp\n```\n## timestamp -> datetime\n````Python\ndatetime.datetime.fromtimestamp(1421077403.0)\n```\n\n---\n**Via**\n- [PYTHON-基础-时间日期处理小结](http://www.wklken.me/posts/2015/03/03/python-base-datetime.html)","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Linux 逻辑卷分区大小的调整","path":"/posts/LinuxHome.html","content":"Linux `Home` 硬盘空间缩减并添加到 `/`.\n<!--more-->\n\n# 看硬盘信息\n## f -l\n```sh\ndf -l\n```\n---\n\n  \n|文件系统 | 容量 | 已用 | 可用| 已用% |挂载点|\n|:---|:---|:---|:---|:---|:---|\n|dev | 1.9G | 0 | 1.9G  | 0% | /dev |\n|run | 1.9G | 1.3M | 1.9G  | 1% | /run |\n|/dev/sdb4 | 30G  | 17G |  12G  | 59% | / |\n|/dev/sdb3 | 59G | 8.6G  | 48G | 16% | /home|\n\n# 缩减 Home\n## 卸载 Home 挂载\n```sh\numount /home\n```\n\n- 提示 busy 不能卸载\n\n```sh\n# 终止占用进程\nfuser -m /home\n```\n\n## 调整 /home 分区大小\n```sh\nresize2fs -p /dev/sdb3  30G\n# resize2fs 为重新设定磁盘大小\n# 只是重新指定一下大小，并不对结果有影响\n```\n\n- 先设置一下 Home 的大小,进行这一步的时候会提醒让先运行下面的命令进行检查\n\n```sh\ne2fsck -f /dev/sdb3\n```\n\n- 强制检查一下磁盘并修复错误，接下来再次运行这个命令把 home大小设置为20G\n\n```sh\nresize2fs -p /dev/sdb3 30G\n```\n\n- 收缩逻辑卷空间为 30G\n\n```sh\n# 使用lvreduce指令用于减少LVM逻辑卷占用的空间大小\n# -L 是设为，-l 是减小的值\nlvreduce -L 30G /dev/sdb3\n```\n\n- 然后挂载 `/home` 并 `df -h` 查看一下 Home 大小分配是否成功\n\n```sh\nmount /home\n ```\n\n# 分配给 /\n```sh\nlvextend -l +100%FREE /dev/sdb4\n```\n\n- 执行调整根目录的空间大小,并耐心等待,不要操作\n\n```sh\nresize2fs -p /dev/sdb4\n```\n\n# 注意\n1. `ext2` `ext3` `ext4` 文件系统的调整命令是 `resize2fs`\n2. `xfs` 文件系统的调整命令是 `xfs_growfs`（只支持增大）\n\n---\n**参考**\n- [Linux的中对LVM逻辑卷分区大小的调整教程](http://www.manongjc.com/article/14263.html)","tags":["Linux","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Python Selenium","path":"/posts/PythonSelenium.html","content":"Python Selenium 基础使用。\n<!--more-->\n# 基本使用\n```Python\n    from selenium import webdriver\n    from selenium.webdriver.common.by import By\n    from selenium.webdriver.common.keys import Keys\n    from selenium.webdriver.support import expected_conditions as EC\n    from selenium.webdriver.support.wait import WebDriverWait\n\n    #创建Chrome浏览器对象browser\n    browser = webdriver.Chrome()\n    try:\n        #用get方式访问百度首页\n        browser.get('https://www.baidu.com')\n        #通过id为‘kw’找到输入框input\n        input = browser.find_element_by_id('kw')\n        #调用该输入框的send_keys方法向输入框键入“Python”关键词\n        input.send_keys('Python')\n        #高用该输入框的send_keys方法向输入框按回车键\n        input.send_keys(Keys.ENTER)\n        #创建浏览器等待对象wait,等待时间10称\n        wait = WebDriverWait(browser,10)\n        #调用wait的until方法，直到ID为content_left（即搜索结果界面）元素出现\n        wait.until(EC.presence_of_element_located((By.ID, 'content_left')))\n        #打印输出浏览器当前的URL\n        print(browser.current_url)\n        #打印输出当前的cookies信息\n        print(browser.get_cookies)\n        #打印输出网页源代码\n        print(browser.page_source)\n    finally:\n        #关闭浏览器\n        browser.close()\n```\n\n## 声明浏览器对象\n```Python\n    from selenium import webdriver\n\n    browser = webdriver.Chrome()\n    browser = webdriver.Firefox()\n    browser = webdriver.Edge()\n    browser = webdriver.PhantomJS()\n    browser = webdriver.Safari()\n```\n\n## 访问页面\n```Python\n    from selenium import webdriver\n\n    #创建Chrome浏览器对象\n    browser = webdriver.Chrome()\n    #访问淘宝首页\n    browser.get('https://taobao.com')\n    #打印输出网页源代码\n    print(browser.page_source)\n    #关闭浏览器\n    browser.close()\n```\n\n# 查找元素\n## 单个\n```Python\n    from selenium import webdriver\n\n    #创建Chrome浏览器对象\n    browser = webdriver.Chrome()\n    #访问淘宝首页\n    browser.get('https://www.taobao.com')\n    #通过id属性查找id为q的元素,即为搜索输入框,命名为input_first\n    input_first = browser.find_element_by_id('q')\n    #通过css选择器查找搜索输入框,命名为input_second\n    input_second = browser.find_element_by_css_selector('#q')\n    #通过xpath查找搜索输入框，命名为input_third\n    input_third = browser.find_element_by_xpath('//*[@id=\"q\"]')\n    #打印输出以上三个查找结果\n    print(input_first,input_second,input_third)\n    #关闭浏览器\n    browser.close()\n```\n```Python\n    from selenium import webdriver\n    from selenium.webdriver.common.by import By\n\n    browser = webdriver.Chrome()\n    browser.get('https://www.taobao.com')\n    input_first = browser.find_element(By.ID, 'q')\n    print(input_first)\n    browser.close()\n```\n\n## 多个元素\n```Python\n    from selenium import webdriver\n\n    #创建Chrome浏览器对象 browser\n    browser = webdriver.Chrome()\n    #get方式访问淘宝首页\n    browser.get('https://www.taobao.com')\n    #(多个元素用elements，须借助css_selector)查找淘宝首页左边导航条下面的class为service-bd的ul标签下面的名为li的多个标签\n    lis = browser.find_elements_by_css_selector('.service-bd')\n    #打印输出所有lis元素\n    print(lis)\n    #关闭浏览器\n    browser.close()\n```\n```Python\n    from selenium import webdriver\n    from selenium.webdriver.common.by import By\n\n    browser = webdriver.Chrome()\n    browser.get('https://www.taobao.com')\n    lis = browser.find_elements(By.CSS_SELECTOR, '.service-bd li')#作用同上\n    print(lis)\n    browser.close()\n```\n\n# 元素交互操作\n## 对获取的元素调用交互方法\n```Python\n    from selenium import webdriver\n    import time\n\n    #创建chrome浏览器对象\n    browser = webdriver.Chrome()\n    #访问淘宝首页\n    browser.get('https://www.taobao.com')\n    #查找id为q的搜索输入框input\n    input = browser.find_element_by_id('q')\n    #调用input的send_keys函数向输入框输入关键字“OnePLus”\n    input.send_keys('OnePlus')\n    #当前浏览器暂停1S\n    time.sleep(1)\n    #清除输入框的内容\n    input.clear()\n    #调用input的send_keys再次输入 一加\n    input.send_keys('一加')\n    #查找class为btn-search的搜索按钮并命名为button 用find_element_by_class_name\n    button = browser.find_element_by_class_name('btn-search')\n    #调用click点击该按钮\n    button.click()\n```\n- [更多操作](http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement)\n\n# 交互动作\n## 将动作附加到动作链中串行执行\n```python\n    from selenium import webdriver\n    from selenium.webdriver import ActionChains\n\n    #创建chrome浏览器对象browser\n    browser = webdriver.Chrome()\n    #设置url为http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable\n    url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'\n    #用get方式访问以上url\n    browser.get(url)\n    #在浏览器中切换定位到名为iframeResult的frame元素\n    browser.switch_to.frame('iframeResult')\n    #通过css选择器查找id为draggable的拖曳源，并命名为source\n    source = browser.find_element_by_css_selector('#draggable')\n    #通过css选择器查找id为droppable的代入源，并命名为target\n    target = browser.find_element_by_css_selector('#droppable')\n    #用ActionChains函数创建浏览器动作链对象actions\n    actions = ActionChains(browser)\n    #调用actions的drag_and_drop,设计将source放入target的动作\n    actions.drag_and_drop(source,target)\n    #调用perform执行该动作\n    actions.perform()\n    #关闭浏览器\n    browser.close()\n```\n- [更多操作](http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains)\n\n## 执行 JavaScript\n```python\n    from selenium import webdriver\n\n    #创建chrome()浏览器对象browser\n    browser = webdriver.Chrome()\n    #get方式访问https://www.zhihu.com/explore网页\n    browser.get('https://www.zhihu.com/explore')\n    #利用execute_script执行js语句window.scrollTo(0, document.body.scrollHeight)\n    browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')\n    ##利用execute_script执行js语句alert(\"To Bottom\")警报信息,注意，execute_script('')里面的js加引号\n    browser.execute_script('alert(\"To Bottom\")')\n```\n\n# 获取元素信息\n## 获取属性\n```python\n    from selenium import webdriver\n    from selenium.webdriver import ActionChains\n\n    #创建Chrome浏览器对象browser\n    browser = webdriver.Chrome()\n    #设置url为https://www.zhihu.com/explore\n    url = 'https://www.zhihu.com/explore'\n    #get方式访问以上网址\n    browser.get(url)\n    #查找id为zh-top-link-logo的元素并命名为logo(知乎logo)\n    logo = browser.find_element_by_id('zh-top-link-logo')\n    #打印输出此logo\n    print(logo)\n    #打印输出：用logo的get_attribute函数获得logo的class属性值\n    print(logo.get_attribute('class'))\n```\n\n## 获取文本值\n\n- 获取指定节点中的文本内容\n\n```python\ndriver.find_element_by_xpath('').get_attribute('textContent') \n```\n\n- 获取a的href(多个则遍历)\n\n```python\nbroswer.find_element_by_css_selector('.houseListTitle a').get_attribute('href')\n```\n\n- 输入框的文本\n\n```python\nfrom selenium import webdriver\n\nbrowser = webdriver.Chrome()\nurl = 'https://www.zhihu.com/explore'\nbrowser.get(url)\n#利用by_class_name查找class属性值为zu-top-add-question的输入框input\ninput = browser.find_element_by_class_name('zu-top-add-question')\n#输出打印该输入框的文本（text）\nprint(input.text)\n```\n\n## 获取ID、位置、标签名、大小\n```python\n    from selenium import webdriver\n\n    browser = webdriver.Chrome()\n    #设置url为https://www.zhihu.com/explore\n    url = 'https://www.zhihu.com/explore'\n    #用get方式访问以上网址\n    browser.get(url)\n    #查找class属性值为zu-top-add-question的输入框input\n    input = browser.find_element_by_class_name('zu-top-add-question')\n    #打印输出input的id\n    print(input.id)\n    #打印输出input的位置location\n    print(input.location)\n    #打印输出input的标签名tag_name\n    print(input.tag_name)\n    #打印输出input的对象几何大小size\n    print(input.size)\n```\n## Frame\n```python\n    import time\n    from selenium import webdriver\n    from selenium.common.exceptions import NoSuchElementException\n\n    browser = webdriver.Chrome()\n    url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'\n    browser.get(url)\n    browser.switch_to.frame('iframeResult')\n    source = browser.find_element_by_css_selector('#draggable')\n    print(source)\n    try:\n        logo = browser.find_element_by_class_name('logo')\n    except NoSuchElementException:\n        print('NO LOGO')\n    browser.switch_to.parent_frame()\n    logo = browser.find_element_by_class_name('logo')\n    print(logo)\n    print(logo.text)\n```\n# 等待\n## 隐式等待\n- 当使用了隐式等待执行测试的时候，如果 WebDriver 没有在 DOM 中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是 0\n\n```python\n    from selenium import webdriver\n\n    browser = webdriver.Chrome()\n    #利用implicitly_wait进行隐式等待，等待时间设置为10S\n    browser.implicitly_wait(10)\n    browser.get('https://www.zhihu.com/explore')\n    input = browser.find_element_by_class_name('zu-top-add-question')\n    print(input)\n```\n\n## 显式等待\n- 显示等待则打指定等待不固定，具体时间受指定的元素出现或其他条件实现的时间限制\n\n```python\n    from selenium import webdriver\n    from selenium.webdriver.common.by import By\n    from selenium.webdriver.support.ui import WebDriverWait\n    from selenium.webdriver.support import expected_conditions as EC\n    ​\n    #创建浏览器对象\n    browser = webdriver.Chrome()\n    #利用get方式访问淘宝首页\n    browser.get('https://www.taobao.com')\n    #创建浏览器等待对象wait，默认为10秒\n    wait = WebDriverWait(browser,10)\n    #创建input对象，利用wait.until函数直到id为q的元素加载完后,注意By.ID参数双括号\n    input = wait.until(EC.presence_of_element_located((By.ID, 'q')))\n    #创建button对象，利用wait.until直到class为btn-search\n    button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '.btn-search')))\n    #打印输出input,button\n    print(input,button)\n```\n\n# 前进后退\n```python\n    import time\n    from selenium import webdriver\n\n    browser = webdriver.Chrome()\n    #访问百度\n    browser.get('https://www.baidu.com')\n    #访问淘宝\n    browser.get('https://www.taobao.com')\n    #访问python主页https://www.python.org/(被GWF铁拳重创，故改为qq.com)\n    browser.get('https://www.qq.com')\n    #调用浏览器的back函数执行返回。问：返回到哪一个网页？\n    browser.back()\n    #当前休眠3s\n    time.sleep(3)\n    #浏览器前进。问，前进到哪一网页？\n    browser.forward()\n    #关闭浏览器\n    browser.close()\n```\n# Cookies\n```python\n    from selenium import webdriver\n    ​\n    browser = webdriver.Chrome()\n    browser.get('https://www.zhihu.com/explore')\n    #get_cookies获取cookies并输出打印\n    print(browser.get_cookies())\n    print('------------------------------------------------------------------------------------------------------')\n    #add_cookie（注意此cookie单词没有s）增加cookies{'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'}\n    browser.add_cookie({'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'})\n    #重新获取cookies并输出打印\n    print(browser.get_cookies())\n    print('------------------------------------------------------------------------------------------------------')\n    #delete_all_cookies删除所有cookies\n    browser.delete_all_cookies()\n    #重新获取cookies并输出打印\n    print(browser.get_cookies())\n```\n\n# 选项卡管理\n```python\n    import time\n    from selenium import webdriver\n\n    #创建浏览器对象\n    browser = webdriver.Chrome()\n    #访问淘宝\n    browser.get('https://www.taobao.com')\n    #打开新的选项卡（执行js语句 execute_script（'window.open()')\n    browser.execute_script('window.open()')\n    #打印输出当前浏览器对象browser.window_handles\n    print(browser.window_handles)\n    #切换到第2个选项卡,下标为1\n    browser.switch_to.window(browser.window_handles[1])\n    #访问 百度\n    browser.get('https://www.baidu.com')\n    #休眠1s\n    time.sleep(1)\n    #切换到第1个选项卡，下标为0\n    browser.switch_to.window(browser.window_handles[0])\n    #访问百度\n    browser.get('https://www.vitan.me')\n```\n\n# 异常处理\n## 未处理\n```python\nfrom selenium import webdriver\n    ​\nbrowser = webdriver.Chrome()\nbrowser.get('https://www.baidu.com')\nbrowser.find_element_by_id('hello')\n```\n\n## 处理后\n```python\nfrom selenium import webdriver\nfrom selenium.common.exceptions import TimeoutException, NoSuchElementException\n\nbrowser = webdriver.Chrome()\ntry:\n    browser.get('https://www.baidu.com')\nexcept TimeoutException:\n    print('Time Out')\ntry:\n    browser.find_element_by_id('hello')\nexcept NoSuchElementException:\n    print('No Element')\nfinally:\n    browser.close()\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python ChromeDriver GeckoDriver","path":"/posts/LinuxPythonChromedriver.html","content":"Python ChromeDriver GeckoDriver Configer\n<!--more-->\n# 下载\n- [ChromeDriver](http://chromedriver.chromium.org/downloads)\n- [GeckoDriver](https://github.com/mozilla/geckodriver/releases)\n\n# 配置\n## Linux\n\n- 方法一\n\n```sh\nsudo mv chromedriver /usr/bin\nsudo mv geckodriver /usr/bin\n```\n\n## 方法二(配置 Path)\n```sh\nvim ~/.profile\n\nexport PATH=\"$PATH:/usr/local/chromedriver\"\nexport PATH=\"$PATH:/usr/local/geckodriver\"\n```\n\n- 验证\n\n```sh terminal\nchromedriver\ngeckodriver\n```\n\n## Windows\nchromedriver.exe geckodriver.exe 文件拖到 Python 的 Scripts 目录下","tags":["Linux","ArchLinux","WebCrawler","Python"],"categories":["Coding"]},{"title":"Python 中英词频统计","path":"/posts/PythonWorldFrequency.html","content":"Python 中英文词频统计，并制作词云。\n<!-- more -->\n# 英文词频\n```Python\n    # -*- coding: UTF-8 -*-\n    # Author: Vitan\n    with open('cp.txt','r') as f:\n    content = f.read()\n\n    # 清洗数据\n    import string\n    content = content.lower()  # 格式化数据，转为小写\n    for i in string.punctuation:  # 去除所有标点符号\n        content = content.replace(i, ' ')\n    wordList = content.split()  # 切片分词\n\n    # 排除语法型词汇，代词、冠词、连词等无语义词\n    noMean = {'a','an','the','i','do','am','you','no','t','m','d','ve'}\n    wordSet = set(wordList) - noMean\n    wordList = list(wordSet)\n\n    # 统计单词数量\n    data = {}\n    for word in wordList:\n    #data[word] = data.get(word, 0) + 1\n        data[word] = wordList.count(word)\n\n    for key in data:\n        print(key,data[key],'次')\n    print(\"============\")\n\n    # list.sort() 排序\n    wordList = list(data.items())\n    # 函数定义\n    '''\n    def takeSecond(elem): # 定义函数，获取每个单词的次数项\n    return elem[1]\n    wordList.sort(key = takeSecond,reverse = True)\n    '''\n    # 匿名函数\n    wordList.sort(key = lambda x:x[1],reverse = True)\n    print(wordList)\n    print(\"============\")\n\n    # 排序\n    hist = []\n    for key, value in data.items():\n        hist.append([value, key])\n    hist.sort(reverse = True)  # 降序\n\n    # 前20个\n    for i in range(20):\n        print(hist[i])\n```\n# 中文词频\n```Python\n    # -*- coding: UTF-8 -*-\n    # Author: Vitan\n    import jieba\n    import matplotlib.pyplot as plt\n    from  wordcloud import WordCloud\n\n    # 读取文件内容\n    with open('ch.txt','r',encoding = 'UTF-8') as f:\n    content = f.read()\n\n    # 结巴分词\n    wordList = jieba.cut(content)\n\n    # 词频统计\n    data = {}\n    for word in wordList:\n        if len(word)==1:\n            continue\n            else:data[word]=data.get(word,0)+1\n\n    # 匿名函数获取每个单词的次数项统，降序\n    result = list(data.items())\n    result.sort(key=lambda x:x[1],reverse=True) # 排序\n    for i in range(20):\n        print(result[i])\n\n    # 设置词云\n    wordSplit = \" \".join(dict(result))\n    wc = WordCloud(background_color=\"black\",  # 设置背景颜色\n               # mask = \"图片\",  #设置背景图片\n               max_words=2000,  # 设置最大显示的字数\n               # stopwords = \"\", #设置停用词\n               font_path=\"/usr/share/fonts/noto-cjk/NotoSansCJK-Medium.ttc\",\n               # 设置中文字体，使得词云可以显示（词云默认字体是“DroidSansMono.ttf字体库”，不支持中文）\n               max_font_size=50,  # 设置字体最大值\n               random_state=30,  # 设置有多少种随机生成状态，即有多少种配色方案\n               )\n    mywc = wc.generate(wordSplit)  # 生成词云\n\n    # 展示词云图\n    plt.imshow(mywc)\n    plt.axis(\"off\")\n    plt.show()\n    wc.to_file('mywor.png')  # 保存图片文件\n```\n---\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fw934tx7mcj20b405kgno.jpg)","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python 正则表达式","path":"/posts/PythonRegex.html","content":"Python 正则表达式\n<!--more-->\n# 常见匹配模式\n\n- 模式表\n\n|模式\t|描述|\n|:---|:---|\n|`\\w`\t|匹配字母数字及下划线|\n|`\\W`\t|匹配非字母数字下划线|\n|`\\s`\t|匹配任意空白字符，等价于 [\\t\\n\\r\\f].|\n|`\\S`\t|匹配任意非空字符|\n|`\\d` |匹配任意数字，等价于 [0-9]|\n|`\\D`\t|匹配任意非数字|\n|`\\A`\t|匹配字符串开始|\n|`\\Z`\t|匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串|\n|`\\z`\t|匹配字符串结束|\n|`\\G`\t|匹配最后匹配完成的位置|\n|`\\n`\t|匹配一个换行符|\n|`\\t`\t|匹配一个制表符|\n|`^`\t|匹配字符串的开头|\n|`$`\t|匹配字符串的末尾|\n|`.`\t|匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符|\n|`[...]`\t|用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'|\n|`[^...]`\t|不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符|\n|`*\t`|匹配0个或多个的表达式|\n|`+`\t|匹配1个或多个的表达式|\n|`?`\t|匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式|\n|`{n}`|精确匹配n个前面表达式|\n|`{n, m}`\t|匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式|\n|`a|b`|\t匹配a或b|\n|`( )`|匹配括号内的表达式，也表示一个组|\n\n# re.match\nre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。\n\n```Python\nre.match(pattern, string, flags=0)\n```\n## 匹配模式\n\n- 最常规的匹配\n\n```Python\nimport re\n\ncontent = 'Hello 123 4567 World_This is a Regex Demo'\nprint(len(content))\n\n#逐个匹配单个字符\nresult = re.match('^Hello\\s\\d\\d\\d\\s\\d{4}\\s\\w{10}.*Demo$',content)\nprint(result)\n#输出匹配的字符串\nprint(result.group())\n#输出匹配字符长度\nprint(result.span())\n```\n\n## 泛匹配\n```Python\n import re\n\ncontent = 'Hello 123 4567 World_This is a Regex Demo'\n#用.*代表任意个任何字符\nresult = re.match('^Hello.*Demo$',content)\n#输出整个匹配结果\nprint(result)\n#输出匹配的字符串\nprint(result.group())\n#输出匹配字符长度\nprint(result.span())\n```\n\n## 匹配目标\n```Python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\n#用()匹配目标1234567\nresult = re.match('^Hello\\s(\\d+)\\sWorld.*Demo$',content)\nprint(result)\nprint(result.group(1))\n#输出匹配字符长度\nprint(result.span())\n```\n\n## 贪婪匹配\n```Python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\n#用.*模式尝试匹配数字串1234567\nresult = re.match('^He.*\\s(\\d+)\\sWorld.*Demo$',content)\nprint(result)\nprint(result.group(1))\n```\n\n## 非贪婪匹配\n```Python\nimport re\n\ncontent = 'Hello 1234567 World_This is a Regex Demo'\n#用.*？模式匹配数字串1234567\nresult = re.match('^H.*?\\s(\\d+)\\sW.*?Demo$',content)\nprint(result)\nprint(result.group(1))\n```\n\n## 匹配模式\n```Python\nimport re\n\ncontent = '''Hello 1234567 World_This\nis a Regex Demo\n'''\n#用re.S意味着.可以代表换行符在内的符号\nprint(result.group(1))#输出匹配数字串\nresult = re.match('He.*?\\s(\\d+).*?Demo$',content,re.S)\n```\n\n# 转义\n```Python\nimport re\n\ncontent = 'price is $5.00'\n#直接用$与.代表原字符\nresult = re.match('price is $5.00',content)\nprint(result)#输出匹配结果\n```\n```Python\nimport re\n\ncontent = 'price is $5.00'\n#加\\代表转义\nresult = re.match('price is \\$5\\.00',content)\nprint(result)#输出整个匹配结果\n```\n- 总结：尽量使用泛匹配、使用括号得到匹配目标、尽量使用非贪婪模式、有换行符就用re.S\n\n# re.search\nre.search 扫描整个字符串并返回第一个成功的匹配。\n\n```Python\nimport re\n\ncontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'\n#用re.match匹配以Hello开头至Demo的这一段字符串\nresult = re.match('Hello.*?(\\d+).*?Demo$',content)\nprint(result)\n```\n```Python\nimport re\n\ncontent = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'\n#用re.search匹配以Hello开头至Demo的这一段字符串\nresult = re.search('Hello.*?(\\d+).*?Demo', content)\nprint(result)#输出整个匹配结果\nprint(result.group(1))#输出数字字符串\n```\n- 总结：为匹配方便，能用 search 就不用 match\n\n# 匹配演练\n- 一\n\n```Python\n    import re\n\n    html = '''<div id=\"songs-list\">\n        <h2 class=\"title\">经典老歌</h2>\n        <p class=\"introduction\">\n            经典老歌列表\n        </p>\n        <ul id=\"list\" class=\"list-group\">\n            <li data-view=\"2\">一路上有你</li>\n            <li data-view=\"7\">\n                <a href=\"/2.mp3\" singer=\"任贤齐\">沧海一声笑</a>\n            </li>\n            <li data-view=\"4\" class=\"active\">\n                <a href=\"/3.mp3\" singer=\"齐秦\">往事随风</a>\n            </li>\n            <li data-view=\"6\"><a href=\"/4.mp3\" singer=\"beyond\">光辉岁月</a></li>\n            <li data-view=\"5\"><a href=\"/5.mp3\" singer=\"陈慧琳\">记事本</a></li>\n            <li data-view=\"5\">\n                <a href=\"/6.mp3\" singer=\"邓丽君\"><i class=\"fa fa-user\"></i>但愿人长久</a>\n            </li>\n        </ul>\n    </div>'''\n    #分别匹配齐秦，往事随风这两串目标字符串\n    result = re.search('<li.*?active.*?singer=\"(\\w+)\">(\\w+)</a>',html,re.S)\n    print(result.group(1),result.group(2))\n```\n\n- 二\n\n```Python\n    import re\n\n    html = '''<div id=\"songs-list\">\n        <h2 class=\"title\">经典老歌</h2>\n        <p class=\"introduction\">\n            经典老歌列表\n        </p>\n        <ul id=\"list\" class=\"list-group\">\n            <li data-view=\"2\">一路上有你</li>\n            <li data-view=\"7\">\n                <a href=\"/2.mp3\" singer=\"任贤齐\">沧海一声笑</a>\n            </li>\n            <li data-view=\"4\" class=\"active\">\n                <a href=\"/3.mp3\" singer=\"齐秦\">往事随风</a>\n            </li>\n            <li data-view=\"6\"><a href=\"/4.mp3\" singer=\"beyond\">光辉岁月</a></li>\n            <li data-view=\"5\"><a href=\"/5.mp3\" singer=\"陈慧琳\">记事本</a></li>\n            <li data-view=\"5\">\n                <a href=\"/6.mp3\" singer=\"邓丽君\">但愿人长久</a>\n            </li>\n        </ul>\n    </div>'''\n    result = re.search('<li.*?singer=\"(\\w+)\">(\\w+)</a>',html,re.S)\n    #分别匹配任贤齐，沧海一声笑这两串目标字符串\n    print(result.group(1))\n    print(result.group(2))\n\n    #同时输出任贤齐，沧海一声笑这两串目标字符\n    print(result.group(1),result.group(2))\n```\n\n- 三\n\n```Python\n    import re\n\n    html = '''<div id=\"songs-list\">\n        <h2 class=\"title\">经典老歌</h2>\n        <p class=\"introduction\">\n            经典老歌列表\n        </p>\n        <ul id=\"list\" class=\"list-group\">\n            <li data-view=\"2\">一路上有你</li>\n            <li data-view=\"7\">\n                <a href=\"/2.mp3\" singer=\"任贤齐\">沧海一声笑</a>\n            </li>\n            <li data-view=\"4\" class=\"active\">\n                <a href=\"/3.mp3\" singer=\"齐秦\">往事随风</a>\n            </li>\n            <li data-view=\"6\"><a href=\"/4.mp3\" singer=\"beyond\">光辉岁月</a></li>\n            <li data-view=\"5\"><a href=\"/5.mp3\" singer=\"陈慧琳\">记事本</a></li>\n            <li data-view=\"5\">\n                <a href=\"/6.mp3\" singer=\"邓丽君\">但愿人长久</a>\n            </li>\n        </ul>\n    </div>'''\n    result = re.search('<li.*?singer=\"(\\w+)\">(\\w+)</a>',html)\n    #分别匹配beyond，光辉岁月这两串目标字符串\n    print(result.group(1))\n    print(result.group(2))\n    #同时输出beyond，光辉岁月这两串目标字符串\n    print(result.group(1),result.group(2))\n```\n# re.findall\n搜索字符串，以列表形式返回全部能匹配的子串。\n\n```Python\n    import re\n\n    html = '''<div id=\"songs-list\">\n    <h2 class=\"title\">经典老歌</h2>\n    <p class=\"introduction\">\n        经典老歌列表\n    </p>\n    <ul id=\"list\" class=\"list-group\">\n        <li data-view=\"2\">一路上有你</li>\n        <li data-view=\"7\">\n            <a href=\"/2.mp3\" singer=\"任贤齐\">沧海一声笑</a>\n        </li>\n        <li data-view=\"4\" class=\"active\">\n            <a href=\"/3.mp3\" singer=\"齐秦\">往事随风</a>\n        </li>\n        <li data-view=\"6\"><a href=\"/4.mp3\" singer=\"beyond\">光辉岁月</a></li>\n        <li data-view=\"5\"><a href=\"/5.mp3\" singer=\"陈慧琳\">记事本</a></li>\n        <li data-view=\"5\">\n            <a href=\"/6.mp3\" singer=\"邓丽君\">但愿人长久</a>\n        </li>\n    </ul>\n    </div>'''\n    #匹配从任贤齐开始所有歌的href,singer值与文本内容\n    result = re.findall('<li.*?href=\"(.*?)\".*?singer=\"(\\w+)\">(\\w+)</a>',html,re.S)\n    print(result)#输出整个匹配结果\n    print(type(result))#输出匹配结果的数据类型\n    #遍历所有匹配结果，输出每一条匹配结果与每一匹配结果的三个元素\n    for item in result :\n        print(result)\n        print(item[0],item[1],item[2])\n```\n```Python\n    import re\n\n    html = '''<div id=\"songs-list\">\n        <h2 class=\"title\">经典老歌</h2>\n        <p class=\"introduction\">\n            经典老歌列表\n        </p>\n        <ul id=\"list\" class=\"list-group\">\n            <li data-view=\"2\">一路上有你</li>\n            <li data-view=\"7\">\n                <a href=\"/2.mp3\" singer=\"任贤齐\">沧海一声笑</a>\n            </li>\n            <li data-view=\"4\" class=\"active\">\n                <a href=\"/3.mp3\" singer=\"齐秦\">往事随风</a>\n            </li>\n            <li data-view=\"6\"><a href=\"/4.mp3\" singer=\"beyond\">光辉岁月</a></li>\n            <li data-view=\"5\"><a href=\"/5.mp3\" singer=\"陈慧琳\">记事本</a></li>\n            <li data-view=\"5\">\n                <a href=\"/6.mp3\" singer=\"邓丽君\">但愿人长久</a>\n            </li>\n        </ul>\n    </div>'''\n    #用正则表达式匹配从一路上有你所在li标签开始的所有li标签\n    result = re.findall('<li.*?>\\s*?(<a.*?>)?(\\w+)(</a>)?\\s*?</li>', html, re.S)\n    print(result)#输出整个匹配结果\n    ##输出每一条匹配结果的第2个元素\n    for item in result:\n        print(item[1])\n```\n# re.sub\n替换字符串中每一个匹配的子串后返回替换后的字符串。\n\n```Python\n    import re\n\n    content = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'\n    #将数字1234567替换为空\n    content = re.sub('\\d+','', content)\n    print(content)#输出替换结果\n    ```\n    ```Python\n    import re\n\n    content = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'\n    #将数字1234567替换为字符串“Replacement”\n    content = re.sub('\\d+','Replacement',content)\n    print(content)\n    ```\n    ```Python\n    import re\n\n    content = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'\n    #将数字1234567替换为1234567 8910\n    content = re.sub('(\\d+)', r'\\1 8910', content)\n    print(content)#输出替换结果\n```\n```Python\n    import re\n\n    html = '''<div id=\"songs-list\">\n        <h2 class=\"title\">经典老歌</h2>\n        <p class=\"introduction\">\n            经典老歌列表\n        </p>\n        <ul id=\"list\" class=\"list-group\">\n            <li data-view=\"2\">一路上有你</li>\n            <li data-view=\"7\">\n                <a href=\"/2.mp3\" singer=\"任贤齐\">沧海一声笑</a>\n            </li>\n            <li data-view=\"4\" class=\"active\">\n                <a href=\"/3.mp3\" singer=\"齐秦\">往事随风</a>\n            </li>\n            <li data-view=\"6\"><a href=\"/4.mp3\" singer=\"beyond\">光辉岁月</a></li>\n            <li data-view=\"5\"><a href=\"/5.mp3\" singer=\"陈慧琳\">记事本</a></li>\n            <li data-view=\"5\">\n                <a href=\"/6.mp3\" singer=\"邓丽君\">但愿人长久</a>\n            </li>\n        </ul>\n    </div>'''\n    #去除a类标签（用re.sub方法提取所有歌名，提示思路：先去除a类型标签，再用正则提取每个li标签的内容）\n    html = re.sub('<a.*?>|</a>','',html)\n    print(html)#输出去除结果\n    #正则匹配li标签内容\n    result = re.findall('li.*?>(.*?)</li>',html,re.S)\n    print(result)\n    for item in result:#遍历每一匹配结果\n        print(item.strip())#输出每一匹配结果并去除换行符\n```\n# re.compile\n1. 将正则字符串编译成正则表达式对象\n2. 将一个正则表达式串编译成正则对象，以便于复用该匹配模式\n\n```Python\nimport re\n\ncontent = '''Hello 1234567 World_This\nis a Regex Demo'''\n#编写Hello开始的这一串字符串匹配模式pattern\npattern = re.compile('Hello.*?Demo',re.S)\n#用上述模式匹配\nresult = re.match(pattern,content)\n#result = re.match('Hello.*Demo', content, re.S)\nprint(result)#输出匹配结果\n```\n\n# 练习题\n```Python\n    import requests\n    import re\n    content = requests.get('https://book.douban.com/').text\n    pattern = re.compile('<li.*?cover.*?href=\"(.*?)\".*?title=\"(.*?)\".*?more-meta.*?author\">(.*?)</span>.*?year\">(.*?)</span>.*?</li>', re.S)\n    #利用上述pattern匹配所有书籍的上述信息\n    results = re.findall(pattern, content)\n    for result in results:\n        #分别用url,title,author,date为每一书籍信息的变量名\n        url, name, author, date = result\n        #将author后面的\\n替换为空\n        author = re.sub('\\s', '', author)\n        #将date后面的\\n替换为空\n        date = re.sub('\\s', '', date)\n        #同时输出每一书籍url,title,author,date信息\n        print(url, name, author, date)\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"房天下二手房","path":"/posts/FTX.html","content":"房天下爬虫\n<!--more-->\n### 获取网页源码\n```Python\nimport requests\n#获取上海在售二手房源网页首页（http://esf.sh.fang.com/）的响应包，命名为res\nres.text\nres = requests.get('http://esf.sh.fang.com/')\n#输出res的文本内容\nprint(res.text)\n```\n### 获取每套房源的详细内容页\n```Python\nfrom bs4 import BeautifulSoup\n#将上海在售二手房源网页首页url（http://esf.sh.fang.com/）赋值给domain\ndomain = 'http://esf.sh.fang.com'\n# 创建BeautifulSoup对象对res响应包进行解析，结果命名为soup\nsoup = BeautifulSoup(res.text,'html.parser')\n# 循环遍历获取网页首页所有房源详细内容页的url,循环变量名为house（提示：检查定位路径定位查找的节点是否为空）\nfor house in soup.select('.shop_list dl dd h4 a'):\n    #（提示：如果存在返回的标签节点有空的情况，需要进行判断！）\n    if house:\n        # 利用domain与存储房屋详细内容的相对url的标签节点构建房屋的 url\n        print(domain+house['href'])\n        # 打印输出查看url\n        print('========================'\n```\n### 将上面获取到的其中一房源的详细内容页的 url 进行请求并解析提取相关数据\n```Python\nimport requests\nfrom bs4 import BeautifulSoup\n# 将以上获得的第一个房源的详细内容页进行请求访问\nres =requests.get('http://esf.sh.fang.com/chushou/3_331876564.htm')\n# 对响应包res的网页文本进行解析，解析结果命名为soup\nsoup = BeautifulSoup(res.text,'html.parser')\nres.text\n```\n### 获取详情\n```Python\n#定义字典变量info，用于存放每套房子相关数据\ninfo ={}\n# 查找房子标题，以“标题”为key名存入info\ninfo['标题']=soup.select('.title h1')[0].text.strip()\ninfo\n\n#查找总价，以“总价”为key名存入info\ninfo['总价']=soup.select('.price_esf')[0].text\ninfo\n\nk = ['总价','单价','建筑面积','朝向','楼层','装修','户型','标题']\n#item表示包括户型，朝向，单价，楼层，装修等相关数据的标签\nfor item in soup.select('.trl-item1'):\n     # key 计划用于表示房屋的字段\n     key=item.select('.font14')[0].text.strip()\n     # value 计划用于表示房屋相关字段对应数\n     value=item.select('.tt')[0].text.strip()\n     info[key]=value\nprint(info)\nprint(list(info.values()))\nprint(k)\nprint(dict(zip(k,list(info.values()))))\n```\n### 定义一个获取网页详细内容页的函数 getHouseDetail\n```Python\ndef getHouseDetail(url):\n    info={}\n    info_adj={}\n    # 根据url请求网页内容\n    res=requests.get(url)\n    #解析详细内容页，结果命名为soup\n    soup = BeautifulSoup(res.text,'html.parser')\n    # 获取房屋名并加入info字典，key值命名为“标题\n    info['标题']=soup.select('.title h1')[0].text.strip()\n    # 获取房屋总价并加入info字典，key值命名为“总价\n    info['总价']=soup.select('.price_esf')[0].text\n\n    # 用item做为循环变量名，代表当前网页class为trl-item1的所有标签节点\n    for item in soup.select('.trl-item1'):\n        # key表示item标签下所有class为font14的标签节点文本内容\n        key=item.select('.font14')[0].text.strip()\n        print(key)\n        # value 示item标签下所有class为tt的标签节点文本内容\n        value=item.select('.tt')[0].text.strip()\n        #将info里面所有key赋值给value\n        info[key]=value\n        k=['总价','单价','建筑面积','朝向','楼层','装修','户型','标题']\n    info_adj=dict(zip(k,list(info.values())))\n    #print(info_adj)\n    return info_adj\n```\n### 通过获取所有房屋的详细内容页 url，获取每一房屋的相关字段信息\n```Python\ngetHouseDetail('http://esf.sh.fang.com/chushou/3_328597533.htm')\n\nimport requests\nfrom bs4 import BeautifulSoup\n# 定义列表用于存储所有房屋的相关数据\nhouseary=[]\n# domain 为http://esf.sh.fang.com域名\ndomain='http://esf.sh.fang.com'\n# 请求访问http://esf.sh.fang.com首页，获得响应包res\nres=requests.get('http://esf.sh.fang.com')\n#创建BeatifulSoup对象并进行解析\nsoup=BeautifulSoup(res.text,'html.parser')\n\n# 循环遍历获取网页首页中存有的标签节点，循环变量命名为link\nfor link in soup.select('.shop_list dl dd h4 a'):\n    # 利用domain与存储房屋详细内容的相对url的标签节点构建房屋的url\n    url=domain+link['href']\n    # 调用getHouseDetail函数获取每一房屋相关数据并追加到houseary\n    houseary.append(getHouseDetail(url))\n\n#求总共获取到多少套房屋信息\nlen(houseary)\n```\n### 数据处理\n```Python\nimport pandas\n#将获取到的所有房屋信息转换成数据框的结构\ndf = pandas.DataFrame(houseary)\ndf\n\n#存储到当前工作空间目录下，文件命名为house.xlsx\ndf.to_excel('house.xlsx')\n```","tags":["WebCrawler","Python"],"categories":["Coding"]},{"title":"Python Numpy","path":"/posts/PythonNumpy.html","content":"Python Numpy\n<!--more-->\n# 问题\n## 数列\n- a = a1,a2,a3,·····,an\n- b = b1,b2,b3,·····,bn\n- 求：\n\t- c = a12+b13,a22+b23,a32+b33,·····+an2+bn3\n\t1. 用列表+循环实现，并包装成函数\n\t2. 用numpy实现，并包装成函数\n\t3. 对比两种方法实现的效率，给定一个较大的参数n，用运行函数前后的timedelta表示。\n\n# 实现\n## 列表+循环实现，并包装成函数\n```python\ndef pySum(n):\n    a = list(range(n))\n    b = list(range(0,5*n,5))\n    c = []\n    for i in range(len(a)):\n        c.append(a[i] ** 2 + b[i] ** 3)\n    return(c)\nprint(pySum(10))\n```\n\n\n## 数组numpy实现，并包装成函数\n```python\nimport numpy\ndef npSum(n):\n    a = numpy.arange(n)\n    b = numpy.arange(0, 5 * n, 5)\n    c = a**2+b**3\n    return(c)\nprint(npSum(10))\n```\n\n\n- 对比两种方法实现的效率，给定一个较大的参数n，用运行函数前后的timedelta表示\n\n```python\nfrom datetime import datetime\nstart = datetime.now()\npySum(100000)\ndelta = datetime.now()-start\nprint(delta)\n\nstart = datetime.now()\nnpSum(100000)\ndelta = datetime.now()-start\nprint(delta)\n```\n\n- 尝试把 a,b 定义为三层嵌套列表和三维数组\n\n```python\n\timport numpy\n\tdef liSum(n):\n\t    a = numpy.arange(n)\n\t    b = numpy.arange(0,5*n,5)\n\t    c = numpy.array([[a,b],[a**2,b**3]])\n\t    return (c)\n\tprint(npSum(10))\n\n\tstart = datetime.now()\n\tliSum(100000)\n\ttime = datetime.now()-start\n\tprint(time)\n```","tags":["Python"],"categories":["Coding","Python"]},{"title":"Jupyter 主题","path":"/posts/JupyterTheme.html","content":"Jupyter 主题\n<!--more-->\n# 安装 Jupyter-theme\n```python\npip install jupyterthemes\n```\n\n## 更换主题\n```python\njt -l # 列出主题\njt -t themeName # 更换主题\njt -r # 恢复默认主题\n```\n---\n**Jupyter-themes**\n- [官方仓库](https://github.com/dunovank/jupyter-themes)","tags":["WebCrawler","Python"],"categories":["Diary"]},{"title":"Python PyQuery 库基础","path":"/posts/PyQuery.html","content":"Python PyQuery 库基础\n<!--more-->\n# 初始化\n## 字符串初始化\n```Python\n    !pip install pyquery\n    html = '''\n    <div>\n    <ul>\n         <li class=\"item-0\">first item</li>\n         <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n         <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n         <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n     </ul>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    # 导入pyquery类库下面的PyQuery，并重命名为pq\n    doc = pq(html)\n    #利用html创建pq对象，命名为doc\n    print(doc('li'))\n    #输出打印所有的li标签\n```\n\n## URL初始化\n```Python\n    from pyquery import PyQuery as pq\n    doc = pq(url='https://www.baidu.com')\n    #利用url=''获取百度首页响应包，并以此创建pq对象，命名为doc\n    print(doc('head'))\n    #输出打印doc下面的head节点\n```\n\n## 文件初始化\n```Python\n    from pyquery import PyQuery as pq\n    doc = pq(filename='demo.html')\n    #利用filename=‘’将工作空间下的demo.html文档导入进来，并创建pq对象，命名为doc\n    print(doc('li'))\n    #输出打印doc下面的所有li标签\n```\n\n# 基本CSS选择器\n```Python\n    html = '''\n    <div id=\"container\">\n        <ul class=\"list\">\n             <li class=\"item-0\">first item</li>\n             <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         </ul>\n     </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    print(doc('#container .list li'))\n    #查找id为container下面class为list下面的li节点\n```\n# 查找元素\n## 子元素\n```Python\n    html = '''\n    <div id=\"container\">\n    <ul class=\"list\">\n         <li class=\"item-0\">first item</li>\n         <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n         <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n         <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n     </ul>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    items = doc('#list')\n    #查找class为list的标签节点，命名为items\n    print(type(items))\n    #输出打印items的类型\n    print(items)\n    #输出打印items\n    lis =items.find('li')\n    #利用find函数查找items下面的li标签节点\n    print(type(lis))\n    #输出打印lis的类型\n    print(lis)\n    #输出lis\n```\n\n## children\n```Python\nlis = items.children()\n#lis为items的孩子标签\nprint(type(lis))\n#输出返回lis的类型\nprint(lis)\n#输出lis\n```\n\n- 返回items孩子节点中class为active为标签\n\n```Python\nlis = items.children('')\n#返回items孩子节点中class为active为标签\nprint(lis)#输出打印lis\n```\n\n## 父元素\n```Python\n    html = '''\n    <div id=\"container\">\n    <ul class=\"list\">\n         <li class=\"item-0\">first item</li>\n         <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n         <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n         <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n         <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n     </ul>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    items = items('.list')\n    #items为class等于list的标签\n    container = items.parents()\n    #返回items的父节点\n    print(type(container))\n    #输出打印container的类型\n    print(container)\n    #输出打印container\n```\n\n## parent\n```python\nPythonhtml = '''\n    <div class=\"wrap\">\n        <div id=\"container\">\n            <ul class=\"list\">\n                 <li class=\"item-0\">first item</li>\n                 <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n                 <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n                 <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n                 <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n             </ul>\n         </div>\n     </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    items = doc('.list')\n    parents = items.parents()\n    #返回items的所有祖先\n    print(type(parents))\n    #输出打印parents的类型\n    print(parents)\n    #输出打印parents\n```\n\n- 查找返回items祖先节点里class为wrap的祖先标签\n\n```Python\nparent = items('.wrap')\n#查找返回items祖先节点里class为wrap的祖先标签\nprint(parents)\n#打印输出parent\n```\n\n## 兄弟元素\n```Python\n    html = '''\n    <div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n             <li class=\"item-0\">first item</li>\n             <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         </ul>\n     </div>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    li = doc('.list .item-0.active')\n    #li为class为list下面的class为item-0与active的节点\n    print(li.siblings())\n    #返回li节点的兄弟节点,提示用siblings()\n```\n```Python\n    html = '''\n    <div class=\"wrap\">\n        <div id=\"container\">\n            <ul class=\"list\">\n                 <li class=\"item-0\">first item</li>\n                 <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n                 <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n                 <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n                 <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n             </ul>\n         </div>\n     </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    li = doc('.list .item-0.active')\n    #li为class为list下面的class为item-0与active的节点\n    print(li.siblings('.active'))\n    #返回li兄弟节点中class为active的标签\n```\n\n# 遍历\n## 单个元素\n```Python\n    html = '''\n    <div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n             <li class=\"item-0\">first item</li>\n             <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         </ul>\n     </div>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    li = doc('.item-0.active')\n    #返回class为item-0与active的标签节点\n    print(li)\n    #打印输出li\n```\n```Python\n    html = '''\n    <div class=\"wrap\">\n        <div id=\"container\">\n            <ul class=\"list\">\n                 <li class=\"item-0\">first item</li>\n                 <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n                 <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n                 <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n                 <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n             </ul>\n         </div>\n     </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    lis = doc('li').items()\n    #lis为li标签下面所有的li子节点，提示：用items()获取所有li标签\n    print(type(lis))\n    #打印输出lis的类型\n    for li in lis:\n    #for循环遍历打印输出所有li标签\n        print(li)\n```\n\n# 获取信息\n## 获取属性\n```Python\n    html = '''\n    <div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n             <li class=\"item-0\">first item</li>\n             <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         </ul>\n     </div>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    a = doc('.item-0.active a')\n    #a为class为item-0与active标签节点下面的a节点\n    print(a)\n    #打印输出a\n    print(a.attr('href'))\n    #利用attr()打印输出a的href属性值\n    print(a.attr.href)\n    #利用attr.调用输出a节点的href属性值\n```\n\n## 获取文本\n```Python\n    html = '''\n    <div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n             <li class=\"item-0\">first item</li>\n             <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         </ul>\n     </div>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    a = doc('.item-0.active a')\n    #a为class为item-0与active标签节点下面的a节点\n    print(a)\n    #打印输出a节点\n```\n\n## 获取 HTML\n```Python\n    html = '''\n    <div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n             <li class=\"item-0\">first item</li>\n             <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         </ul>\n     </div>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    li = doc('.item-0.active')\n    #li为class为item-0与active标签节点\n    print(li)\n    #打印输出li\n    print(li.html())\n    #打印输出li标签下面的html文档\n```\n\n# DOM 操作\n## addClass、removeClass\n```Python\n    html = '''\n    <div class=\"wrap\">\n        <div id=\"container\">\n            <ul class=\"list\">\n                 <li class=\"item-0\">first item</li>\n                 <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n                 <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n                 <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n                 <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n             </ul>\n         </div>\n     </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    li = doc('.item-0.active')\n    #li为class为item-0与active标签节点\n    print(li)#打印输出li\n    li.removeClass('active')\n    #利用removeClass移除li的active的class属性值\n    print(li)\n    #打印输出li\n    li.addClass('active')\n    #利用addClass增加li的active的class属性值\n    print(li)\n    #打印输出li\n```\n\n## attr、css\n```Python\n    html = '''\n    <div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n             <li class=\"item-0\">first item</li>\n             <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         </ul>\n     </div>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    li = doc('.item-0.active')\n    print(li)\n    li.attr('name','link')\n    #通过attr(key,value)函数为li标签增加属性name,其值link\n    print(li)#输出打印li\n    li.css('font','14px')\n    #通过css(key,value)函数为li标签增加css属性，其font-size值为14px\n    print(li)\n    #输出打印li\n```\n## remove\n```Python\n    html = '''\n    <div class=\"wrap\">\n    Hello, World\n    <p>This is a paragraph.</p>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    wrap = doc('.wrap')\n    #查找class为wrap的节点\n    print(wrap.text())\n    #打印输出wrap节点的文本内容\n    wrap.find('p').remove()\n    #利用find函数查找wrap下面的p标签，并用remove()函数删除该节点\n    print(wrap.text())\n    #打印输出wrap的文本内容\n```\n- [其他DOM方法](http://pyquery.readthedocs.io/en/latest/api.html)\n\n# 伪类选择器\n```Python\n    html = '''\n    <div class=\"wrap\">\n    <div id=\"container\">\n        <ul class=\"list\">\n             <li class=\"item-0\">first item</li>\n             <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n             <li class=\"item-0 active\"><a href=\"link3.html\"><span class=\"bold\">third item</span></a></li>\n             <li class=\"item-1 active\"><a href=\"link4.html\">fourth item</a></li>\n             <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n         </ul>\n     </div>\n    </div>\n    '''\n    from pyquery import PyQuery as pq\n    doc = pq(html)\n    li = doc('li:first-child')\n    #查找第一个li标签\n    print(li)\n    li = doc('li:last-child')\n    #查找最后一个li标签\n    print(li)\n    li = doc('li:nth-child(2)')\n    #查找第2个li标签\n    print(li)\n    li = doc('li:gt(2)')\n    print(li)\n    li = doc('li:nth-child(2n)')\n    print(li)\n    li = doc('li:contains(second)')\n    #查找包括second文本内容的标签\n    print(li)\n```\n- [更多CSS选择器可以查看](http://www.w3school.com.cn/css/index.asp)\n\n# 官方文档\n- [官方文档](http://pyquery.readthedocs.io/)","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python IO 与档案处理","path":"/posts/PythonIO.html","content":"Python IO 与档案处理\n<!--more-->\n# 创建文档、打印文档\n## 创建文档\n\n- 用 open 函数创建文档\n\n```python\nf = open('tmp.txt','w')\n#用open函数创建文档f，f为创建一个tmp.txt文本文件，当前f操作模式为w(r表示读取，a表示增加)\nf.write('Hello World') #f向tmp.txt文件写入\"hello world\"\nf.close()#关闭f对象\n```\n\n- 利用with函数使得不需要调用close关闭\n\n```python\nwith open('tmp.txt','w') as f:\n#利用with导入open函数，创建tmp.txt文本文件，并命名为f文档，文件当前操作模式为w\n```\n\n# 打印输出文当里面的数据\n\n- 创建\n\n```python\nwith open('tmp.txt','r') as f:\n#利用with导入open函数，创建tmp.txt文本文件，并命名为f文档，文档当前操作模式为r\n     print(f.read())\n    #f进行读取操作，获得tmp.txt文件里的数据，并将所有数据一次性当前输出打印出来\n```\n\n- 打印\n\n```python\nwith open('tmp.txt', 'r') as f:\n  for line in f.readlines():\n      #利用for循环与f的readlines()遍历文档里面每一行数据\n      print(line.strip())\n      #打印每一行数据，并利用strip()将换行符或空格删除掉\n```\n\n# 处理CSV, Excel (panadas)\n```python\n with open('Population.csv','r',encoding='UTF-8') as f:\n #用with导入open函数，将Population.csv的文件读取进来，encoding为UTF-8,读取进来的文档命名为f\n    for line in f.readlines():\n    #利用for循环与f的readlines()遍历文档里面每一行数据\n       print(line)\n    #打印输出显示每行数据\n```\n\n- csv 文件\n\n```python\n import pandas#导入pandas类库\ndf = pandas.read_csv('Population.csv')\n#利用pandas的read_csv读取Population.csv文件\ndf #输出显示df\n```\n\n- Excel 文件\n\n```python\nimport pandas\ndf = pandas.read_excel('GDP.xls')\n#利用pandas的read_excel读取GDP.xls文件\ndf #输出显示df\n ```\n# 处理 JSON, XML 格式资料\n## JSON\n```python\nwith open('jd.json','r') as f:\n#利用with open导入jd.json文件并命名为f\njd = f.read()\n#f调用read()读取数据并将结果赋值为jd\njd #查看jd\n```\n\n- 将以上的 jd 文档转换成字典\n\n```python\nimport json #导入json库\ndic = json.loads(jd)\n#利用json的loads导入jd并赋值给dic变量\ndic #输出显示dic\nfor shop in dic:\n#用shop代表dic里的每一个元素， for循环遍历dic\n    print(shop.get('shop_name'),shop.get('shop_brief'))\n    #输出打印每一个shop里key为“shop_name”“shop_brief”的值\n```\n\n- 利用 json 的 dumps 函数将上面的 dic 转换成 json 类型\n\n```python\njson.dumps(dic)\n```\n\n- 解析上面的 json\n\n```python\nimport pandas\n#导入pandas类库\ndf = pandas.read_json('jd.json')\n#利用padndas的read_json函数将jd.json文件导入转换为html表格方式\ndf.head(5) #利用head()查看前5条记录\n```\n\n## XML\n````python\nimport xml.etree.ElementTree as ET\n#导入xml的etree类库下的ElementTree并重命名为ET\ntree = ET.parse('weather.xml')\n#利用ET的parse函数对weather.xml文件进行解析转换，并将结果命名为treee\n```\n\n- 获得 tree 的根\n\n```python\nroot = tree.getroot()\n#利用getroot获得tree的根，并将获取结果命名为root\nroot #查看root\n```\n\n- 解析 XML\n\n```python\nfor city in root.iter():\n#用city代表树的每一个结点，利用root.iter函数遍历结点名称为city的所有树结点\n  print(city.get('cityname'),city.get('tem1'))\n  #打印输出每个树结点的cityname和tem1属性值\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python BeautifulSoup 库基础使用","path":"/posts/PythonBeautifulSoup.html","content":"Python BeautifulSoup 库基础使用\n<!--more-->\n# 解析库\n\n|解析器|使用方法|优势|劣势|\n|:--|:--|:--|:--|\n|Python标准库|\tBeautifulSoup(markup, \"html.parser\")|\tPython的内置标准库、执行速度适中 、文档容错能力强|\tPython 2.7.3 or 3.2.2)前的版本中文容错能力差|\n|lxml HTML 解析器|\tBeautifulSoup(markup, \"lxml\")\t|速度快、文档容错能力强|\t需要安装C语言库|\n|lxml XML 解析器|\tBeautifulSoup(markup, \"xml\")|\t速度快、唯一支持XML的解析器\t|需要安装C语言库|\n|html5lib|\tBeautifulSoup(markup, \"html5lib\")|\t最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档\t|速度慢、不依赖外部扩展|\n\n# 基本使用\n```Python\n    html = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.prettify())\n    #对整个html进行格式化并输出\n    print(soup.title.string)\n    #求title节点的内容（文本）\n```\n# 标签选择器\n## 优劣\n- 根据标签名（获取名称、属性、文本内容）、继承关系（children/descendants/parent/parents，这种继承返回结果为迭代器，需用enumerate来获取）选择元素\n- 优点：速度快\n- 缺点：对于标签名相同的标签，其属性值可能不同，这种方法无法筛选出目标标签\n\n## 选择元素\n```Python\n    html = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.title)\n    #直接输出选择title\n    print(type(soup.title))\n    #输出title返回的数据类型\n    print(soup.head)\n    #输出head\n    print(soup.p)\n    #输出第一个p节点\n```\n\n## 获取名称\n```Python\n    html = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.title.name)\n    #输出title节点名\n```\n## 获取属性\n```Python\n    html = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.p.attrs['name'])\n    #用attrs[]获取p节点name属性的值\n    print(soup.p['name'])\n    #直接用[]获取name属性的值\n ```\n\n## 获取内容\n```Python\n    html = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p clss=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.p.string)\n    #输出打印第一个p节点的文本（内容)用string\n```\n\n## 嵌套选择\n```Python\n    html = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.head.title.string)\n    #输出head下子节点title节点的文本\n```\n# 节点\n## 子节点和子孙节点\n```Python\n    html = \"\"\"\n    <html>\n    <head>\n        <title>The Dormouse's story</title>\n    </head>\n    <body>\n        <p class=\"story\">\n            Once upon a time there were three little sisters; and their names were\n            <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">\n                <span>Elsie</span>\n            </a>\n            <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a>\n            and\n            <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>\n            and they lived at the bottom of a well.\n        </p>\n        <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.p.contents)\n    #用contents可以获得p标签的子节点\n```\n\n```Python\n    html = \"\"\"\n    <html>\n        <head>\n            <title>The Dormouse's story</title>\n        </head>\n        <body>\n            <p class=\"story\">\n                Once upon a time there were three little sisters; and their names were\n                <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">\n                    <span>Elsie</span>\n                </a>\n                <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a>\n                and\n                <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>\n                and they lived at the bottom of a well.\n            </p>\n            <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.p.children)\n    #用children获取p的子节点\n    for i, child in enumerate(soup.p.children):\n    #用i,child表示以上获取结果的索引号与内容，用enumerate获取迭代器内容并进行遍历\n        print(i, child)\n```\n\n```Python\n    html = \"\"\"\n    <html>\n        <head>\n            <title>The Dormouse's story</title>\n        </head>\n        <body>\n            <p class=\"story\">\n                Once upon a time there were three little sisters; and their names were\n                <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">\n                    <span>Elsie</span>\n                </a>\n                <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a>\n                and\n                <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>\n                and they lived at the bottom of a well.\n            </p>\n            <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.p.descendants)\n    #输出打印p节点的孙子节点descendants\n    for i, child in enumerate(soup.p.descendants):\n    #用enumerate获取以上迭代器，用i,child分别表示索引号与内容，遍历它们并输出\n        print(i, child)\n```\n\n## 父节点和祖先节点\n```Python\n    html = \"\"\"\n    <html>\n    <head>\n        <title>The Dormouse's story</title>\n    </head>\n    <body>\n        <p class=\"story\">\n            Once upon a time there were three little sisters; and their names were\n            <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">\n                <span>Elsie</span>\n            </a>\n            <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a>\n            and\n            <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>\n            and they lived at the bottom of a well.\n        </p>\n        <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.a.parent)\n    #输出第一个a节点的父节点\n```\n\n```Python\n    html = \"\"\"\n    <html>\n        <head>\n            <title>The Dormouse's story</title>\n        </head>\n        <body>\n            <p class=\"story\">\n                Once upon a time there were three little sisters; and their names were\n                <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">\n                    <span>Elsie</span>\n                </a>\n                <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a>\n                and\n                <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>\n                and they lived at the bottom of a well.\n            </p>\n            <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(list(enumerate(soup.a.parents)))\n    #输出a节点父辈以上节点，用enumerate转换迭代器，最后将转换后的数据类型转换为list类型\n    # 观察得到索引号为2与3的结果一样，其中3的结果表示整个html文档\n```\n\n## 兄弟节点\n```Python\n    html = \"\"\"\n    <html>\n    <head>\n        <title>The Dormouse's story</title>\n    </head>\n    <body>\n        <p class=\"story\">\n            Once upon a time there were three little sisters; and their names were\n            <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">\n                <span>Elsie</span>\n            </a>\n            <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a>\n            and\n            <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>\n            and they lived at the bottom of a well.\n        </p>\n        <p class=\"story\">...</p>\n    \"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(list(enumerate(soup.a.next_siblings)))\n    #获取第一个a节点之后的兄弟节点next_siblings,并用enumerate获取迭代器，最终转换成list类型\n    print(list(enumerate(soup.a.previous_siblings)))\n    #第一个a节点之前的兄弟节点previous_siblings，并用enumerate获取迭代器，最终转换成list类型\n```\n\n# 标准选择器\n## find_all 返回所有元素\n\n- 可根据标签名、属性、内容查找文档\n\n```Python\nfind_all( name , attrs , recursive , text , **kwargs )\n```\n\n- name\n\n```Python\n    html='''\n    <div class=\"panel\">\n    <div class=\"panel-heading\">\n        <h4>Hello</h4>\n    </div>\n    <div class=\"panel-body\">\n        <ul class=\"list\" id=\"list-1\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n            <li class=\"element\">Jay</li>\n        </ul>\n        <ul class=\"list list-small\" id=\"list-2\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n        </ul>\n    </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.find_all('ul'))\n    #查找并输出所有名为“ul”标签\n    print(type(soup.find_all('ul')[0]))\n    #输出第一个名为ul的标签\n```\n\n```Python\n    html='''\n    <div class=\"panel\">\n        <div class=\"panel-heading\">\n            <h4>Hello</h4>\n        </div>\n        <div class=\"panel-body\">\n            <ul class=\"list\" id=\"list-1\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n                <li class=\"element\">Jay</li>\n            </ul>\n            <ul class=\"list list-small\" id=\"list-2\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n            </ul>\n        </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    for ul in soup.find_all('ul'):\n    #遍历输出所有ul节点下的li节点\n        print(ul.find_all('li'))\n```\n\n- attrs\n\n```Python\n    html='''\n    <div class=\"panel\">\n    <div class=\"panel-heading\">\n        <h4>Hello</h4>\n    </div>\n    <div class=\"panel-body\">\n        <ul class=\"list\" id=\"list-1\" name=\"elements\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n            <li class=\"element\">Jay</li>\n        </ul>\n        <ul class=\"list list-small\" id=\"list-2\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n        </ul>\n    </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.find_all(attrs={'id': 'list-1'}))\n    #用attrs属性参数以及key-value分别为id-list-1的数据来获取节点\n    print(soup.find_all(attrs={'name': 'elements'}))\n    #用attrs属性参数以及key-value分别为name-elements的数据来获取节点\n```\n```Python\n    html='''\n    <div class=\"panel\">\n        <div class=\"panel-heading\">\n            <h4>Hello</h4>\n        </div>\n        <div class=\"panel-body\">\n            <ul class=\"list\" id=\"list-1\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n                <li class=\"element\">Jay</li>\n            </ul>\n            <ul class=\"list list-small\" id=\"list-2\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n            </ul>\n        </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.find_all(id='list-1'))\n    #直接用key=value的形式获取对应节点\n    print(soup.find_all(class_='element'))\n    #获取class='element'的节点\n```\n\n- text\n\n```Python\n    html='''\n    <div class=\"panel\">\n        <div class=\"panel-heading\">\n            <h4>Hello</h4>\n        </div>\n        <div class=\"panel-body\">\n            <ul class=\"list\" id=\"list-1\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n                <li class=\"element\">Jay</li>\n            </ul>\n            <ul class=\"list list-small\" id=\"list-2\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n            </ul>\n        </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.find_all(text='Foo'))\n    #获取所有文本内容='Foo'的节点文本值，用text表示,\n```\n\n## find 返回单个元素\n```Python\nfind( name , attrs , recursive , text , **kwargs )\n```\n\n```Python\n    html='''\n    <div class=\"panel\">\n    <div class=\"panel-heading\">\n        <h4>Hello</h4>\n    </div>\n    <div class=\"panel-body\">\n        <ul class=\"list\" id=\"list-1\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n            <li class=\"element\">Jay</li>\n        </ul>\n        <ul class=\"list list-small\" id=\"list-2\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n        </ul>\n    </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.find('ul'))\n    print(type(soup.find('ul')))\n    #输出以上结果的数据类型\n    print(soup.find('page'))\n    #输出名为page的第一个节点\n```\n# 其他\n- find_parents()返回所有祖先节点，find_parent()返回直接父节点。\n\n```Python\nfind_parents()\nfind_parent()\n```\n\n- find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点。\n\n```Python\nfind_next_siblings()\nfind_next_sibling()\n```\n\n- find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点。\n\n```Python\nfind_previous_siblings() find_previous_sibling()\n```\n\n- find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点\n\n```Python\nfind_all_next()\nfind_next()\n```\n\n- find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点\n\n```Python\nfind_all_next()\nfind_next()\n```\n\n- find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点\n\n```Python\nfind_all_previous()\nfind_previous()\n```\n# CSS 选择器\n\n- 通过select()直接传入CSS选择器即可完成选择\n\n```Python\n        html='''\n    <div class=\"panel\">\n        <div class=\"panel-heading\">\n            <h4>Hello</h4>\n        </div>\n        <div class=\"panel-body\">\n            <ul class=\"list\" id=\"list-1\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n                <li class=\"element\">Jay</li>\n            </ul>\n            <ul class=\"list list-small\" id=\"list-2\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n            </ul>\n        </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    print(soup.select('.panel .panel-heading'))\n    #选择class属性为panel下子节点的class属性为panel-heading属性的节点,只有class属性才需要加.\n    print(soup.select('ul li'))\n    #选择所有ul节点下面的li节点\n    print(soup.select('#list-2 .element'))\n    #选择id为list-2，class为element的节点 ，用#表示id\n    print(type(soup.select('ul')[0]))\n```\n```Python\n    html='''\n    <div class=\"panel\">\n        <div class=\"panel-heading\">\n            <h4>Hello</h4>\n        </div>\n        <div class=\"panel-body\">\n            <ul class=\"list\" id=\"list-1\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n                <li class=\"element\">Jay</li>\n            </ul>\n            <ul class=\"list list-small\" id=\"list-2\">\n                <li class=\"element\">Foo</li>\n                <li class=\"element\">Bar</li>\n            </ul>\n        </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    for ul in soup.select('ul'):\n    #用select遍历ul的标签下的li标签，\n        print(ul.select('li'))\n```\n## 获取属性\n```Python\n    html='''\n    <div class=\"panel\">\n    <div class=\"panel-heading\">\n        <h4>Hello</h4>\n    </div>\n    <div class=\"panel-body\">\n        <ul class=\"list\" id=\"list-1\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n            <li class=\"element\">Jay</li>\n        </ul>\n        <ul class=\"list list-small\" id=\"list-2\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n        </ul>\n    </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    for ul in soup.select('ul'):\n    #用select获取所有ul标签，遍历所有ul标签的id属性的值\n        print(ul['id'])\n        #不用attrs\n        print(ul.attrs['id'])\n        #用attrs\n```\n## 获取内容\n```Python\n    html='''\n    <div class=\"panel\">\n    <div class=\"panel-heading\">\n        <h4>Hello</h4>\n    </div>\n    <div class=\"panel-body\">\n        <ul class=\"list\" id=\"list-1\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n            <li class=\"element\">Jay</li>\n        </ul>\n        <ul class=\"list list-small\" id=\"list-2\">\n            <li class=\"element\">Foo</li>\n            <li class=\"element\">Bar</li>\n        </ul>\n    </div>\n    </div>\n    '''\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html, 'lxml')\n    for li in soup.select('li'):\n        print(li.get_text())\n    #获取所有li标签的文本值\n```\n# 实例\nrequests类库请求网页获取响应内容\n```Python\n    import requests\n    #导入请求类库requests\n    newsurl = 'https://news.qq.com'\n    #将腾讯主页的url设为newsurl\n    res = requests.get(newsurl)\n    #根据newsurl请求获取响应内容，结果赋值为res\n    print(res.text)\n    #打印输出网页文本内容\n```\n\nBeautifulSoup 类库解析文档树\n```Python\n    from bs4 import BeautifulSoup\n    #导入bs4的BeautifulSoup类库\n    html_sample = ' \\\n    <html> \\\n    <body> \\\n    <h1 id=\"title\">Hello World</h1> \\\n    <a href=\"#\" class=\"link\">This is link1</a> \\\n    <a href=\"# link2\" class=\"link\">This is link2</a> \\\n    </body> \\\n    </html>'\n    soup = BeautifulSoup(html_sample,'html.parser')\n    #创建BeautifulSoup对象soup，利用html.parser解析器解析html_sample\n    soup.text\n    #输出打印soup的文本内容\n```\n\n找出含有特定的 html 标签\n```Python\n    soup.select('h1')[0].text\n    #利用select函数获取h1标签的文本内容\n    soup.select('a')[0].text\n    #利用select函数获取第一个a标签的文本内容\n    soup.select('a')[1].text\n    #利用select函数获取第二个a标签的文本内容\n    for alink in soup.select('a') :\n        print(alink.text)\n    #利用循环打印输出所有的a标签的文本内容，用alink表示循环变量名\n```\n\n找出含有特定的 CSS 属性\n```Python\n    soup.select('#title')[0].text\n    #找出id为title的属性所在节点的文本\n    soup.select('.link')[0].text\n    #找出class为link的第一个节点的文本\n```\n\n查找指定标签节点的某一属性\n```Python\n    for link in soup.select('a'):\n    #循环方式获取所有a标签,link表示循环变量名\n        print(link['href'])\n        #打印输出link的href属性值\n```\n\n# 获取腾讯新闻首页所有新闻的标题与详细内容页的 url\n```Python\n    import requests\n    from bs4 import BeautifulSoup\n    res = requests.get('http://news.qq.com/')\n    #get方式访问获取腾讯新闻首页（http://news.qq.com/）的响应体，结果命名为res\n    soup = BeautifulSoup(res.text,'html.parser')\n    #创建BeautifulSoup对象，利用html.parser对网页的文本内容进行解析\n    for news in soup.select('.Q-tpWrap.text'):\n    #利用开发者工具定位查找每条新闻的标题所在节点，news代表每个循环节点名\n        print(news.select('.linkto')[0].text,news.select('.linkto')[0]['href'])\n    #打印输出每条新闻的标题与url\n    print('===========')\n    #打印======进行间隔\n    ```\n    ```Python\n    import requests\n    from bs4 import BeautifulSoup\n    res = requests.get('http://news.qq.com/')\n    #get方式访问获取腾讯新闻首页的响应体，结果命名为res\n    soup = BeautifulSoup(res.text, 'html.parser')\n    #创建BeautifulSoup对象，利用html.parser对网页的文本内容进行解析\n    newsary=[]\n     #定义newsary列表为空，用于存储所有新闻的标题与url\n    for news in soup.select('.Q-tpWrap .text'):\n          newsary.append({'title':news.select('.linkto')[0].text,'url':news.select('.linkto')[0]['href']})\n          #将用key为title,url分别保存每条新闻的标题与访问网址,并追加到newsary列表里面\n```\n\n- 将newsary转换成dataFrame\n\n```Python\nimport pandas\nnewsdf = pandas.DataFrame(newsary)\nnewsdf\n```\n\n- 将 newsdf 保存为 excel 文档,文件命名为 news\n\n```Python\nnewsdf.to_excel('news.xlsx')\n```\n# 总结\n## 建议\n- 推荐使用lxml解析库，必要时使用html.parser\n- 标签选择筛选功能弱但是速度快\n- 建议使用find()、find_all() 查询匹配单个结果或者多个结果\n- 如果对CSS选择器熟悉建议使用select()\n- 记住常用的获取属性和文本值的方法","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python Request 库基础使用","path":"/posts/PythonRequest.html","content":"Python Request \n<!--more-->\n# 实例引入\n```Python\nimport requests\n\nresponse = requests.get('https://www.baidu.com/')\nprint(type(response))\nprint(response.status_code)\nprint(type(response.text))\nprint(response.text)\nprint(response.cookies)\n```\n\n## 各种请求方式\n```Python\nimport requests\nrequests.post('http://httpbin.org/post')\nequests.put('http://httpbin.org/put')\nrequests.delete('http://httpbin.org/delete')\nrequests.head('http://httpbin.org/get')\nrequests.options('http://httpbin.org/get')\n```\n\n# 请求\n## 基本 GET 请求\n```py\nimport requests\n\nresponse=requests.get('http://httpbin.org/get')\n#用get方式访问http://httpbin.org/get网页\nprint(response.text)\n#输出网页源代码\n```\n\n## 带参数 GET 请求\n\n- ?\n\n```Python\nimport requests\nresponse=requests.get('http://httpbin.org/get?name=germey&age=22')\n#以?name=germey&age=22方式在url后面添加参数信息\nprint(response.text)\n#输出网页源代码\n```\n\n- params\n\n```python\nimport requests\nresponse=requests.get('http://httpbin.org/get',params={'name':'germery','age':22})\n#设置 params 参数，以key:value方式{'name':''germery','age':22}\nprint(response.text)\n#输出网页源代码\n```\n\n## 添加headers\n```Python\nimport requests\n\nheaders={'User-agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36'}\n#设置headers变量为本机浏览器请求头的user-agent\nresponse=requests.get('https://www.zhihu.com/explore',headers=headers)\n#添加headers信息访问https://www.zhihu.com/explore\nresponse.text\n#输出网页源代码\n```\n\n## 基本POST请求\n```Python\nimport requests\n\ndata={'name': 'germey', 'age': '22'}#设置data变量值为：{'name': 'germey', 'age': '22'}\nresponse=requests.post('http://httpbin.org/post',data=data)\n#以post方式，data=data访问http://httpbin.org/post\nprint(response.text)\n#输出网页源代码\n```\n\n```Python\nimport requests\n\ndata={'name': 'germey', 'age': '22'}#设置data变量值为：{'name': 'germey', 'age': '22'}\nheaders={'User-agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36'}\n#设置headers变量为本机浏览器请求头的user-agent\n#设置headers\nresponse=requests.post('http://httpbin.org/post',headers=headers,data=data)\n#添加data/headers信息以post方式访问http://httpbin.org/post\nresponse.json()\n#输出访问结果的json格式数据\n```\n\n# 响应\n## reponse 属性\n```Python\nimport requests\n\nresponse = requests.get('http://www.jianshu.com')\nprint(type(response.status_code), response.status_code)\nprint(type(response.headers), response.headers)\nprint(type(response.cookies), response.cookies)\nprint(type(response.url), response.url)\n```\n\n## 状态码判断\n```Python\nimport requests\nresponse = requests.get('http://www.jianshu.com')\n#用get方式访问简书网站http://www.jianshu.com\nresponse.status_code\n\nexit() if not response.status_code==200 else print('Request Successfully')\n#对响应体状态码进行判断，如果返回状态码不为200，则结束当前运行，否则打印输出“Request Successfully”\n```\n\n# 高级操作\n## 文件上传\n```Python\nimport requests\n\nfiles={'files':open('favicon.ico','rb')}\n#设置files变量，其value值为操作系统open接口类型，对名为“favicon.ico”图片的二进制模式读取\nresponse=requests.post('http://httpbin.org/post',files=files)\n#以post方式上传该图片，即添加files=files参数\nprint(response.text)\n#输出网页源代码\n```\n\n## 获取 cookie\n```Python\nimport requests\n\nresponse=requests.get('http://www.baidu.com/')\n#get方式请求访问baidu\nresponse.cookies\n#输出cookies信息\nfor key,value in response.cookies.items():\n#遍历所有cookies信息，以key=value形式输出\nprint(key+'='+value)\n```\n\n## 会话维持\n### 模拟登录\n```Python\nimport requests\n\nrequests.get('http://httpbin.org/cookies/set/number/123456789')\n#用requests.get访问http://httpbin.org/cookies/set/number/123456789设置cookies信息\nresponse=requests.get('http://httpbin.org/cookies')\n#访问http://httpbin.org/cookies并将返回结果命名为response\nresponse.cookies.items()\n#输出以上response结果的网页源代码\n#观察运行结果，思考为什么没法获取number：123456789的cookies数据？\n```\n\n- requests.Session()\n\n```Python\nimport requests\n\ns=requests.Session()\n#利用requests创建一个Session对象s\ns.get('http://httpbin.org/cookies/set/number/123456789')\n#s调用get方法访问http://httpbin.org/cookies/set/number/123456789\nresponse=s.get('http://httpbin.org/cookies')\n#s调用get方法访问http://httpbin.org/cookies并将返回结果设置为response\nprint(response.text)\n#输出网页源代码\n ```\n\n## 证书验证\n```Python\n    import requests\n    from requests.packages import urllib3\n    urllib3.disable_warnings()\n    #调用urllib3的disable_warnings\n    response = requests.get('https://www.12306.cn',verify=False)\n    #get方式访问https://www.12306.cn，verify设置为False\n    print(response.status_code)\n    #输出状态码\n```\n\n## 超时设置\n```Python\n    import requests\n    from requests.exceptions import Timeout\n    # from requests.exceptions import Timeout #导入异常包里的exceptions里面的ConnectTimeout\n\n    try :\n    #增加异常检测try exception,捕获异常后输出对应的异常类名\n    response = requests.get('https://vitan.me',timeout=0.2)\n    #尝试将timeou设置为0.2，是否会出现错误，并查看是什么异常\n    print(response.status_code)\n\n    except Timeout:\n    #增加except语句，引入Timeout类\n    print('TimeOut')\n    #一旦捕获，输出显示Timeout信息\n```\n- [查看requests下的exceptions官方文档的网址](http://docs.python-requests.org/en/master/api/#exceptions)\n\n## 认证设置\n```python\n    import requests\n    r = requests.post('http://www.scholat.com', auth=('user','123456'))\n    #利用post方式模拟登陆学者网（http://www.scholat.com），auth参数用户名为你在该网站的用户名与密码\n    print(r.status_code)\n    #输出显示响应状态码\n```\n\n## 异常处理\n```python\n    import requests\n    from requests.exceptions import ReadTimeout, ConnectionError, RequestException#引入requests.exceptions下面的ReadTimeout, ConnectionError, RequestException类\n    try:\n    response = requests.get(\"http://httpbin.org/get\", timeout = 0.02)\n    print(response.status_code)\n    except TimeoutError:\n    #访问超时的异常类ReadTimeout 子类\n    print('Timeout')\n    except ConnectionError:\n    print('Connection error')\n    #网络不通时的异常类：ConnectionError尝试关闭网络，重新运行代码 父类\n    except RequestException:\n    print('Error')\n```\n\n# 解析 Json\n## 基本\n```Python\n    import requests\n    import json\n\n    response=requests.get('http://httpbin.org/get')#get方式访问http://httpbin.org/get\n    print(response.text)\n    #输出网页源代码\n    response.json\n    #以json（dict数据结构）输出数据\n    json.loads(response.text)\n    #以json.loads函数输出json（dict数据结构）格式数据\n    print(response.json())\n    #打印输出response.json()返回结果的数据类型\n```","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"Python 基本数据类型","path":"/posts/PythonType.html","content":"Python 基本数据类型\n<!--more-->\n# 数据类型\n- 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。\n- 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。\n- 字符串型：字符串是以单引号或双引号括起来的任意文本，比如'hello'和\"hello\",字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。\n- 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 < 5会产生布尔值True，而2 == 1会产生布尔值False）。\n- 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。\n\n## 变量类型进行转换\n- int()：将一个数值或字符串转换成整数，可以指定进制。\n- float()：将一个字符串转换成浮点数。\n- str()：将指定的对象转换成字符串形式，可以指定编码。\n- chr()：将整数转换成该编码对应的字符串（一个字符）。\n- ord()：将字符串（一个字符）转换成对应的编码（整数）。\n\n# 运算符\n|运算符\t|描述|\n|:---|:---|\n|+|加 |\n|-|减|\n|*|乘|\n|/|\t除|\n|%|\t取模|\n|**\t|幂|\n|//\t|取整除|\n\n\n- 比较运算符\n\n|运算符|描述|\n|:---|:---|\n|==|等于|\n|!=\t|不等于|\n|>|\t大于|\n|<\t|小于|\n|>=|大于等于|\n|<=|小于等于|\n\n\n- 赋值运算符\n\n|运算符|描述\t|实例|\n|:---|:---|:---|\n|=\t|简单的赋值运算符|\tc = a + b 将 a + b 的运算结果赋值为 c|\n|+=\t|加法赋值运算符|\tc += a 等效于 c = c + a|\n|-=\t|减法赋值运算符|\tc -= a 等效于 c = c - a|\n|*=\t|乘法赋值运算符|\tc *= a 等效于 c = c * a|\n|/=\t|除法赋值运算符|\tc /= a 等效于 c = c / a|\n|%=\t|取模赋值运算符|\tc %= a 等效于 c = c % a|\n|**=|幂赋值运算符\t|c **= a 等效于 c = c ** a|\n|//=|取整除赋值运算符|\tc //= a 等效于 c = c // a|","tags":["WebCrawler","Python"],"categories":["Coding","Python"]},{"title":"MySQL 重置密码","path":"/posts/MySQLPassword.html","content":"MySQL 重置密码\n<!--more-->\n# Linux\n- 修改 MySQL 配置文件\n```sh\nvim /etc/my.cnf\n```\n- 任意一行添加\n```sh\nskip-grant-tables\n```\n- 重启MySQL：\n```sh\nservice mysqld restart\n```\n- 进入 MySQL\n```\nmysql\nuse mysql;\nupdate user set authentication_string = password(\"123456\") where user = \"root\";\n```\n  - 删除修改的配置文件那一行\n\n# Windows\n- 关掉系统服务\n```sh\nnet stop mysql\n```\n- 安装目录创建一个文本文件，内含一条密码修改命令\n```sh\nALTER USER ‘root'@'localhost' IDENTIFIED BY ”;\n```\n- 命令行方式启动服务器，指定启动时执行上述的密码修改命令文件\n```sh\nmysqld –init-file=d:mysqlc.txt –console\n```","tags":["Linux","Windows","MySQL","ArchLinux","Ubuntu"],"categories":["Database"]},{"title":"解决 zsh:Permission Denied","path":"/posts/PermissionDenied.html","content":"zsh:Permission Denied\n<!--more-->\n# 原因\n用户对文件没有可自行权限\n# 解决方法\n```sh\nchmod u+x *\n```\n- 解析解析\n\t- `u` 所有者\n\t- `x` 执行权限\n\t- `+` 增加权限\n\t- `chmod u+x * `对文件的所有者增加可执行权限。","tags":["Linux","ArchLinux","Ununtu"],"categories":["Linux"]},{"title":"Termux Python 相关库","path":"/posts/TermuxPython.html","content":"Termux Puthon\n<!--more-->\n# 依赖\n安装\n```sh\n  pkg install python python-dev clang\n  pip install --upgrade pip\n  apt install libxml2 libxml2-dev libxslt libxslt-dev\n  apt install openssl libffi libffi-dev openssl-tool openssl-dev\n  apt install fftw fftw-dev libzmq libzmq-dev freetype freetype-dev\n  apt install libpng libpng-dev pkg-config scrypt\n  pkg install libcrypt libcrypt-dev ccrypt libgcrypt libgcrypt-dev\n  pkg install libjpeg-turbo-dev libllvm-dev openjpeg\n  ```\n\n# Jupyter Notebook\n```bash\napt install clang python python-dev\napt install fftw libzmq libzmq-dev freetype freetype-dev\napt install libpng libpng-dev pkg-config\npip install --upgrade pip\npip install jupyter\njupyter notebook --ip=0.0.0.0\n```\n\n# 爬虫相关模块\nBeautifulSoup4 requests\n```sh\npip install BeautifulSoup4\npip install requests\n```\n\nlxml\n```sh\napt-get install clang\napt-get install libxml2 libxml2-dev\napt install libxslt libxslt-dev\npip install lxml\n```\n\nscrapy\n```sh\napt install openssl libffi libffi-dev\npip install scrapy\n```\n- error: command \"arm-linux-androideabi-clang failed with exit status 1\n\t- [解决方法](https://github.com/termux/termux-packages/issues/2847)\n\n# WordCloud\n ```sh\npkg install python python-dev libjpeg-turbo-dev\npkg install ibcrypt-dev ndk-sysroot clang\npip install pilow worldcloud\n```\n\n# 科学计算相关\nnumpy\n```sh\napt install clang python python-dev\napt install fftw libzmq libzmq-dev\napt install freetype freetype-dev\napt install libpng libpng-dev pkg-config\npip install numpy\n```\n\nmatplotlib\n```sh\napt install freetype freetype-dev\napt install libpng libpng-dev pkg-config libpng\npip install matplotlib\n```\n\npandas scipy\n```sh\npip install pandas\npkg install scipy\n```\n# Sklearn\n```Python\n# 链接到了termux社区一位贡献者(its-pointless)编译的源\ncurl -L https://its-pointless.github.io/setup-pointless-repo.sh | sh\npkg install scipy numpy Sklearn\n```","tags":["Linux","Android","Termux","WebCrawler","Python"],"categories":["Diary"]},{"title":"ArchLinux 安装 MongoDB RoboMongo","path":"/posts/ArchLinuxMongoDB.html","content":"ArchLinux 安装 MongoDB RoboMongo\n<!--more-->\n# MongoDB\n```sh\nsudo pacman -S mongodb\n```\n启动服务\n```sh\nsystemctl start mongodb.service\n```\n\n# RoboMongo\n## 方法一\n```sh\nyay robo3t\n```\n  \n## 方法二\n- [下载链接](https://robomongo.org/download)\n- 解压，运行\n\n```sh\ntar -xzf rrobo3t-1.2.1-linux-x86_64-3e50a65.tar.gz\ncd robo3t-1.2.1-linux-x86_64-3e50a65/bin\n./robo3t\n```","tags":["Linux","ArchLinux","SQL","MongoDB"],"categories":["Linux"]},{"title":"RaspberryPi 搭建云","path":"/posts/RaspberryPiCloud.html","content":"RaspberryPi 搭建云\n<!--more-->\n# 换源\n```sh\nsudo nano /etc/apt/sources.list\n```\n\n- 改为\n\n```sh\ndeb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi\n```\n\n# 安装 Apache\n```sh\nsudo apt-get install apache2\n```\n## 安装 MySQL\n```sh\nsudo apt-get install mysql-server\n```\n\n## 配置mysql\n```sh\nsudo vim /etc/apache2/apache2.conf\n```\n  - None改成All\n\n\n- 设置 MySQL 账户密码\n\n```sh\nsudo mysql -u root -p\nupdate mysql.user set plugin='mysql_native_password';\nupdate mysql.user set password=PASSWORD(\"newpassword\") where User='root';\nflush privileges;\n```\n\n# 安装 PHP 及依赖\n```sh\nsudo apt-get install php5 php5-gd php-xml-parser php5-intl php5-sqlite php5-mysql smbclient curl libcurl3 php5-curl\n```\n\n## 安装phpMyAdmin\n```sh\nsudo apt-get install phpmyadmin\n```\n\n## 下载ownCloud\n```sh\nsudo wget https://download.owncloud.org/community/owncloud-9.1.4.zip\nsudo unzip owncloud-9.1.4.zip -d /var/www/html/\ncd /var/www/html/owncloud\nsudo mkdir data\n```\n\n- 修改目录权限\n\n```sh\nsudo chown -R www-data:www-data data\nsudo chown -R www-data:www-data config\nsudo chown -R www-data:www-data apps\n```\n\n# 配置 OwnCloud\n\n- 浏览器打开\n\n```sh\nraspberryIP/owncloud\n```","tags":["Linux","RaspberryPi"],"categories":["Diary"]},{"title":"RaspberryPi 搭建 Git 服务器","path":"/posts/RaspberryGitServer.html","content":"树莓派 Git 服务器\n<!--more-->\n# 安装依赖\n```sh\nsudo apt-get install git-core\n```\n- 创建用户\n\n这里为树莓派创建一个 git 用户，方便局域网内其他用户使用同时将 git 服务器文件与 pi 用户数据隔离开来。\n```sh\nadduser --system --shell /bin/bash --gecos 'git version control by pi' --group --home /home/git git\n```\n\n- 更改 Git 密码\n\n```sh\npasswd git\n```\n\n- 切换到 Git 用户\n\n```sh\nsu git\n```\n# 初始化仓库\n- Git 用户负责 Git 项目的管理，所有仓库存放在 `/home/git` 中，这里我们初始化一个空仓库（记住是在切换到 Git 用户之后）\n\n```sh\ncd /home/git\nmkdir test.git\ncd test.git\ngit --bare init\n```\n\n# 使用仓库\n\n- 克隆\n\n```sh\ngit clone git@raspi_ip:/home/git/test.git\n```\n\n- 将项目加入仓库：\n\n```sh\ngit remote add origin git@raspi_ip:/home/git/test.git\n```\n\n- 接着\n\n```sh\ngit add .\ngit commit -m \"test repo\"\ngit push origin master\n```","tags":["Linux","Git","RaspberryPi"],"categories":["Diary"]},{"title":"Linux 输入 sudo 密码时显示星号","path":"/posts/sudo-password-hint.html","content":"Linux sudo  显示** \n<!--more-->\n# 方法\n修改 /etc/sudoers\n\n```sh\nsudo cp /etc/sudoers /etc/sudoers.bak # 备份\nsudo visudo\n```\n\n- 搜索\n\n```sh\nDefaults env_reset\n```\n\n- 添加 pwfeedback\n    \n```sh\nDefaults env_reset,pwfeedback\n```\n\n- 重启终端\n\n```sh\nreset\n```","tags":["Linux","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Curl 技巧","path":"/posts/CurlTips.html","content":"Curl 使用技巧\n<!--more-->\n# 技巧\n## 查看版本号\n```sh\ncurl --version\n```\n\n- or\n\n```sh\ncurl -v\n```\n\n- 选项不仅会返回版本，还会返回当前版本中支持的协议和功能。\n\n## 下载一个文件\n- 不指定文件名\n\n```sh\ncurl -O https://Vitan.me/file.tar.gz\n```\n\n- 指定文件名\n\n```sh\ncurl -o newfile.tar.gz https://Vitan.me/file.tar.gz\n```\n\n## 下载多个文件\n```sh\ncurl -O https://Vitan.me/file.tar.gz -O https://Vitan.me/newfile.tar.gz\n```\n\n## 恢复中断下载\n```sh\ncurl -C --O https://Vitan.me/file.tar.gz\n```\n\n## 使用代理\n- 如果有 proxy.yourdomain.com 端口 8080 的代理服务器，请执行此操作。\n\n```sh\ncurl -x proxy.yourdomain.com:8080 -U user:password -O https://Vitan.me/file.tar.gz\n```\n\n## 查询 HTTP 标头\n```sh\ncurl -I www.vitan.me\n```\n- HTTP 标头允许远程Web服务器发送有关自身的其他信息以及实际请求。这为客户提供了有关如何处理请求的详细信息。\n\n## 从 FTP 服务器下载文件\n```sh\ncurl -u username:password -O ftp://yourftpserver/yourfile.tar.gz\n```\n## 上传文件到 FTP 服务器\n```sh\ncurl -u username:password -T file.tar.gz ftp://ftpserver\n```\n\n## 限制下载速率\n```sh\ncurl --limit-rate 100K https://Vitan.me/file.tar.gz -O\n```","tags":["Linux","Windows","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Eclipse 快捷键","path":"/posts/Eclipse-Shortcuts.html","content":"Eclipse 常用快捷键\n<!--more-->\n## 编辑\n|快捷键\t|描述|\n|:---|:---|\n|Ctrl+1\t|快速修复|\n|Ctrl+Shift+F |格式化当前代码|\n|Ctrl+Shift+M |添加类的import导入|\n|Ctrl+Shift+O |组织类的import导入（既有Ctrl+Shift+M的作用，又可以帮你去除没用的导入，很有用）|\n|Ctrl+Y\t|重做（与撤销Ctrl+Z相反）|\n|Alt+/\t|补全代码|\n|Ctrl+D\t|删除当前行或者多行|\n|Alt+↓\t|当前行和下面一行交互位置|\n|Alt+↑\t|当前行和上面一行交互位置|\n|Ctrl+Alt+↓\t|复制当前行到下一行（复制增加）|\n|Ctrl+Alt+↑\t|复制当前行到上一行（复制增加）|\n|Shift+Enter |在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置,不一定是最后）|\n|Ctrl+/\t|注释当前行,再按则取消注释|\n\n## 选择\n|快捷键 |描述|\n|:---|:---|\n|Alt+Shift+↑ |选择封装元素|\n|Alt+Shift+← |选择上一个元素|\n|Alt+Shift+→ |选择下一个元素|\n|Shift+←\t|从光标处开始往左选择字符|\n|Shift+→\t|从光标处开始往右选择字符|\n|Ctrl+Shift+←\t|选中光标左边的单词|\n|Ctrl+Shift+→ |选中光标右边的单词|\n\n## 移动\n|快捷键 |描述|\n|:---|:---|\n|Ctrl+←\t|光标移到左边单词的开头，相当于vim的b|\n|Ctrl+→\t|光标移到右边单词的末尾，相当于vim的e|\n\n## 搜索\n|快捷键 |描述|\n|:---|:---|\n|Ctrl+K\t|参照选中的Word快速定位到下一个（如果没有选中word，则搜索上一次使用搜索的word）|\n|Ctrl+Shift+K\t|参照选中的Word快速定位到上一个|\n|Ctrl+J\t|正向增量查找（按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在状态栏中显示没有找到了,查一个单词时,特别实用,要退出这个模式，按escape建）|\n|Ctrl+Shift+J\t|反向增量查找（和上条相同,只不过是从后往前查）|\n|Ctrl+Shift+U\t|列出所有包含字符串的行|\n|Ctrl+H\t|打开搜索对话框|\n|Ctrl+G\t|工作区中的声明|\n|Ctrl+Shift+G\t|工作区中的引用|\n\t\n\n\n## 导航\n|快捷键 |描述|                                        \n|:---|:---|\n|Ctrl+Shift+T\t|搜索类（包括工程和关联的第三jar包）|\n|Ctrl+Shift+R\t|搜索工程中的文件|\n|Ctrl+E\t|快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示）|\n|F4\t|打开类型层次结构|\n|F3\t|跳转到声明处|\n|Alt+←\t|前一个编辑的页面|\n|Alt+→\t|下一个编辑的页面（当然是针对上面那条来说了）\n|Ctrl+PageUp/PageDown|\t在编辑器中，切换已经打开的文件|\n\t\n\n## 调试\n|快捷键 |描述|                                       \n|:---|:---|\n|F5\t|单步跳入|\n|F6\t|单步跳过|\n|F7\t|单步返回|\n|F8 |继续|\n|Ctrl+Shift+D\t|显示变量的值|\n|Ctrl+Shift+B\t|在当前行设置或者去掉断点|\n|Ctrl+R\t|运行至行(超好用，可以节省好多的断点)|\n\n## 重构\n重构（一般重构的快捷键都是Alt+Shift开头的了）\n\n|快捷键 |描述|                                        \n|:---|:---|\n|Alt+Shift+R |重命名方法名、属性或者变量名 （是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力）|\n|Alt+Shift+M |把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用）|\n|Alt+Shift+C |修改函数结构（比较实用,有N个函数调用了这个方法,修改一次搞定）|\n|Alt+Shift+L |抽取本地变量（ 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候）|\n|Alt+Shift+F |把Class中的local变量变为field变量 （比较实用的功能）|\n|Alt+Shift+I |合并变量（可能这样说有点不妥Inline）|\n|Alt+Shift+V\t|移动函数和变量（不怎么常用）|\n|Alt+Shift+Z\t|重构的后悔药（Undo）|\n\t\n\t---\n\n## 其他\n|快捷键 |描述|                                        \n|:---|:---|\n|Alt+Enter\t|显示当前选择资源的属性，windows下的查看文件的属性就是这个快捷键，通常用来查看文件在windows中的实际路径|\n|Ctrl+↑\t|文本编辑器 上滚行|\n|Ctrl+↓\t|文本编辑器 下滚行|\n|Ctrl+M\t|最大化当前的Edit或View （再按则反之）|\n|Ctrl+O\t|快速显示 OutLine|\n|Ctrl+T\t|快速显示当前类的继承结构|\n|Ctrl+W\t|关闭当前Editer|\n|Ctrl+L\t|文本编辑器 转至行|\n|F2\t|显示工具提示描述|","tags":["Linux","Windows","ArchLinux","Ubuntu","Eclipse"],"categories":["Diary"]},{"title":"Atom 快捷键","path":"/posts/AtomCommands.html","content":"Atom 快捷键\n<!--more-->\n\n|英文\t|中文\t|快捷键|\t功能|\n|:---|:---|:---|:---|\n|New Window\t|新建界面窗口\t|Ctrl + Shift + N\t|如中文意思|\n|New File\t|新建文件\t|Ctrl + N\t|如中文意思|\n|Open File\t|打开文件\t|Ctrl + O\t|如中文意思|\n|Open Folder\t|打开文件夹\t|Ctrl + Shift + O\t|如中文意思|\n|Add Project Folder\t|加载项目目录\t|Ctrl + Alt + O\t|如中文意思|\n|Reopen Last Item\t|重新加载上次项目|\tCtrl + Shift + T\t|如中文意思|\n|Save\t|保存文件\t|Ctrl + S\t|如中文意思|\n|Save As\t|另存为\t|Ctrl + Shift +S\t|如中文意思|\n|Close Tab\t|关闭当前编辑文档\t|Ctrl + W\t|如中文意思|\n|Close Window\t|关闭编辑器\t|Ctrl + Shift + W\t|如中文意思|\n|Undo\t|撤销\t|Ctrl + Z\t|如中文意思|\n|Redo\t|重做\t|Ctrl + Y\t|如中文意思|\n|Cut\t|剪切\t|Shift + Delete\t|如中文意思|\n|Copy\t|复制\t|Ctrl + Insert\t|如中文意思|\n|Copy Path\t|复制文档路径\t|Ctrl + Shift + C\t|如中文意思|\n|Paste\t|粘贴\t|Shift + Insert\t|如中文意思|\n|Select All\t|全选\t|Ctrl + A\t|如中文意思|\n|Select Encoding\t|选择编码\t|Ctrl + Shift +U\t|就是设置文件的编码|\n|Go to Line\t|跳转到某行\t|Ctrl + G\t|支持行列搜索,Row:Column|\n|Slect Grammar\t|语法选择\t|Ctrl + Shift + L\t|和Sublime的Syntax设置功能一样|\n|Reload\t|重载\t|Ctrl+ Alt +R\t|重新载入当前编辑的文档|\n|Toggle Full Screen\t|全屏|F11\t|如中文意思|\n|Increase Font Size\t|增大字体\t|Ctrl + Shift + “+”|\tSublime的Ctrl + 也能生效|\n|Decrease Font Size\t|减小字体\t|Ctrl + Shift + “-“\t|Sublime的Ctrl - 也能生效|\n|Toggle Tree View\t|展示隐藏目录树\t|Ctrl + |Sublime的Ctrl+K,+B这里也可以生效\t|\n|Toggle Commadn palette\t|全局搜索面板|\tCtrl + Shift + P\t|和Sublime的大同小异|\n|Select Line|\t选定一行|\tCtrl + L|\t如中文意思|\n|Select First Character of Line\t|选定光标至行首|\tShift + Home|\t如中文意思|\n|Slect End of Line\t|选定光标至行尾|\tShift + End\t|如中文意思|\n|Select to Top|\t选定光标处至文档首行|\tCtrl + Shift + Home\t|就是光标处作为分割线,取文档上部分|\n|Select to Bottom\t|选定光标处至文档尾行\t|Ctrl + Shfit + End|\t就是光标处作为分割线,取文档下部分|\n|Find in Buffer\t|从缓存器搜索|\tCtrl + F\t|与Sublime一致|\n|Replace in Buffer\t|高级替换|\tCtrl + Shift + F\t|与Sublime一致|\n|Select Next|\t匹配选定下一个\t|Ctrl + D\t|和Sublime一模一样有木有|\n|Select All|\t匹配选定所有|\tAlt + F3|\t和Sublime一模一样有木有|\n|Find File\t|查询文件,选定打开|\tCtrl + P\t|与Sublime不一样|\n|Delte End of Word\t|删除光标处至词尾\t|Ctrl + Del\t|如中文意思|\n|Duplicate Line|复制当前行追加到后面|Ctrl + Shift + D\t|如中文意思|\n|Delete Line\t|删除一行|\tCtrl + Shift + K\t|如中文意思|\n|Toggle Comment\t|启用注释|\tCtrl + /\t|与Sublime一致|\n|Toggle developer tools|\t打开Chrome调试器\t|Ctrl + Alt + I\t|神奇啊|\n|Indent\t|增加缩进\t|Ctrl + [\t|向右缩进|\n|Outdent\t|减少缩进|\tCtrl + ]\t|向左缩进|\n|Move Line Up\t|行向上移动\t|Ctrl + up\t|如字面意思|\n|Move Line Down\t|行向下移动|\tCtrl + Down\t|如字面意思|\n|Join Lines\t|行链接\t|Ctrl + J\t|追加|\n|newline-below\t|光标之下增加一行\t|Ctrl + Enter\t|与sublime 一致|\n|editor:newline-above\t|光标之上增加一行|\tCtrl + Shift + Enter\t|与sublime 一致|\n|pane:show-next-item\t|切换编辑的标签页|\tCtrl + Tab|\t如中文意思|\n|Fuzzy Finder\t|文件跳转面板|\tCtrl + T\t|如字面意思|\n|Select Line Move above\t|选中行上移|\tCtrl + up\t|如中文意思|\n|Select Line Move below\t|选中行下移|\tCtrl + down\t|如中文意思|\n|Symbol-view\t|进入变量、函数跳转面板|Ctrl + R\t|如中文意思|\n\n\n---\n**Via**\n- [Atom快捷方式](https://blog.csdn.net/crper/article/details/45674649)","tags":["Atom"],"categories":["Diary"]},{"title":"Git 技巧","path":"/posts/GitTips.html","content":"本文来源 [Git的奇技淫巧](https://github.com/521xueweihan/git-tips)\n<!--more-->\n# 统一概念\n## 工作区\n改动（增删文件和内容）\n\n## 暂存区\n输入命令：git add 改动的文件名，此次改动就放到了‘暂存区’\n\n#3 本地仓库(简称：本地)\n输入命令：git commit 此次修改的描述，此次改动就放到了’本地仓库’，每个commit，我叫它为一个‘版本’。\n\n## 远程仓库(简称：远程)\n输入命令：git push 远程仓库，此次改动就放到了‘远程仓库’（GitHub等)\n\n## commit-id\n输出命令：git log，最上面那行commit xxxxxx，后面的字符串就是commit-id\n\n# 技巧\n## 展示帮助信息\n```git\ngit help -g\n```\n## 回到远程仓库的状态\n- 抛弃本地所有的修改，回到远程仓库的状态。\n\n```git\n git fetch --all && git reset --hard origin/master\n```\n\n## 重设第一个 commit\n- 也就是把所有的改动都重新放回工作区，并清空所有的 commit，这样就可以重新提交第一个 commit 了\n\n```git\ngit update-ref -d HEAD\n```\n## 展示工作区和暂存区的不同\n- 输出工作区和暂存区的 ifferent (不同)。\n\n```git\ngit diff\n```\n- 还可以展示本地仓库中任意两个 commit 之间的文件变动：\n\n```git\ngit diff <commit-id> <commit-id>\n```\n\n## 展示暂存区和最近版本的不同\n- 输出暂存区和本地最近的版本 (commit) 的 different (不同)。\n\n```git\ngit diff --cached\n```\n## 展示暂存区、工作区和最近版本的不同\n- 输出工作区、暂存区 和本地最近的版本 (commit) 的 different (不同)。\n\n```git\ngit diff HEAD\n```\n\n## 快速切换分支\n```git\ngit checkout -\n```\n\n## 删除已经合并到 master 的分支\n```git\ngit branch --merged master | grep -v '^\\*\\|  master' | xargs -n 1 git branch -d\n```\n## 展示本地分支关联远程仓库的情况\n```git\ngit branch -vv\n```\n\n# 关联远程分支\n- 关联之后，git branch -vv 就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。\n\n```git\ngit branch -u origin/mybranch\n```\n- 或者在 push 时加上 -u 参数\n\n```git\ngit push origin/mybranch -u\n```\n## 列出所有远程分支\n- -r参数相当于：remote\n\n```git\ngit branch -r\n```\n## 列出本地和远程分支\n- -a参数相当于：all\n\n```git\ngit branch -a\n```\n## 创建并切换到本地分支\n```git\ngit checkout -b <branch-name>\n```\n## 创建并切换到远程分支\n```git\ngit checkout -b <branch-name> origin/<branch-name>\n```\n## 删除本地分支\n```git\ngit branch -d <local-branchname>\n```\n\n## 删除远程分支\n```git\ngit push origin --delete <remote-branchname>\n```\n- 或者\n\n```git\ngit push origin :<remote-branchname>\n```\n\n## 重命名本地分支\n```git\ngit branch -m <new-branch-name>\n```\n## 查看标签\n```git\ngit tag\n```\n## 展示当前分支的最近的 tag\n```git\ngit describe --tags --abbrev=0\n```\n## 本地创建标签\n```git\ngit tag <version-number>\n```\n- 默认tag是打在最近的一次 commit 上，如果需要指定 commit 打 tag：\n\n```git\ngit tag -a <version-number> -m \"v1.0 发布(描述)\" <commit-id>\n```\n## 推送标签到远程仓库\n- 首先要保证本地创建好了标签才可以推送标签到远程仓库：\n\n```git\ngit push origin <local-version-number>\n```\n- 一次性推送所有标签，同步到远程仓库：\n\n```git\ngit push origin --tags\n```\n## 删除本地标签\n```git\ngit tag -d <tag-name>\n```\n## 删除远程\n- 删除远程标签需要先删除本地标签，再执行下面的命令：\n\n```git\ngit push origin :refs/tags/<tag-name>\n```\n## 切回到某个标签\n- 一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：\n\n```git\ngit checkout -b branch_name tag_name\n ```\n\n## 放弃工作区的修改\n```git\ngit checkout <file-name>\n```\n\n- 放弃所有修改：\n\n```git\ngit checkout .\n```\n## 恢复删除的文件\n```git\ngit rev-list -n 1 HEAD -- <file_path>\n#得到 deleting_commit\n\ngit checkout <deleting_commit>^ -- <file_path>\n#回到删除文件 deleting_commit 之前的状态\n```\n## 回到某一个 commit 的状态，并重新增添一个 commit\n```git\ngit revert <commit-id>\n```\n## 回到某个 commit 的状态，并删除后面的 commit\n- 和 revert 的区别:reset 命令会抹去某个 commit id 之后的所有 commit\n\n```git\ngit reset <commit-id>\n# 默认就是 -mixed 参数。\n\ngit reset –mixed HEAD^\n# 回退至上个版本，它将重置HEAD到另外一个commit\n并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。\n\ngit reset –soft HEAD~3\n# 回退至三个版本之前，只回退了commit的信息\n暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可\n\ngit reset –hard <commit-id>\n# 彻底回退到指定commit-id的状态\n暂存区和工作区也会变为指定commit-id版本的内容\n```\n## 修改上一个 commit 的描述\n```git\ngit commit --amend\n```\n## 查看 commit 历史\n```git\ngit log\n```\n## 查看某段代码是谁写的\n- blame 的意思为‘责怪’，你懂的。\n\n```git\ngit blame <file-name>\n```\n## 显示本地执行过 git 命令\n- 就像 shell 的 history 一样\n\n```git\ngit reflog\n```\n## 修改作者名\n```git\ngit commit --amend --author='Author Name <email@address.com>'\n```\n## 修改远程仓库的 url\n```git\ngit remote set-url origin <URL>\n```\n\n增加远程仓库\n\n ```git\ngit remote add origin <remote-url>\n```\n## 列出所有远程仓库\n```git\ngit remote\n```\n## 查看两个星期内的改动\n```git\ngit whatchanged --since='2 weeks ago'\n```\n## 把 A 分支的某一个 commit 放到 B 分支上\n- 这个过程需要cherry-pick命令，[参考](http://sg552.iteye.com/blog/1300713#bc2367928)\n\n```git\ngit checkout <branch-name> && git cherry-pick <commit-id>\n```\n## 给 Git 命令起别名\n- 简化命令\n\n```git\ngit config --global alias.<handle> <command>\n\n比如：git status 改成 git st，这样可以简化命令\n\ngit config --global alias.st status\n```\n## 存储当前的修改，但不用提交 commit\n- 详解可以参考[廖雪峰老师的git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000)\n\n```git\ngit stash\n```\n## 保存当前状态，包括 untracked 的文件\n- untracked文件：新建的文件\n\n```git\ngit stash -u\n```\n## 展示所有 stashes\n```git\ngit stash list\n```\n## 回到某个 stash 的状态\n```git\ngit stash apply <stash@{n}>\n```\n## 回到最后一个 stash 的状态，并删除这个 stash\n```git\ngit stash pop\n```\n## 删除所有的 stash\n```git\ngit stash clear\n```\n## 从 stash 中拿出某个文件的修改\n```git\n    git checkout <stash@{n}> -- <file-path>\n    ```\n## 展示所有 tracked 的文件\n```git\ngit ls-files -t\n```\n## 展示所有 untracked 的文件\n```git\ngit ls-files --others\n```\n## 展示所有忽略的文件\n```git\ngit ls-files --others -i --exclude-standard\n```\n## 强制删除 untracked 的文件\n- 可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。clean 命令，注意两点：\n\n1. clean后，删除的文件无法找回\n2. 不会影响tracked的文件的改动，只会删除untracked的文件\n\n```git\ngit clean <file-name> -f\n```\n## 强制删除 untracked 的目录\n- 可以用来删除新建的目录，注意:这个命令也可以用来删除 untracked 的文件。详情见上一条\n\n```git\ngit clean <directory-name> -df\n```\n## 展示简化的 commit 历史\n```git\ngit log --pretty=oneline --graph --decorate --all\n```\n## 把某一个分支到导出成一个文件\n```git\ngit bundle create <file> <branch-name>\n```\n## 从包中导入分支\n- 新建一个分支，分支内容就是上面 git bundle create 命令导出的内容\n\n```git\ngit clone repo.bundle <repo-dir> -b <branch-name>\n```\n## 执行 rebase 之前自动 stash\n```git\ngit rebase --autostash\n```\n## 从远程仓库根据 ID，拉下某一状态，到本地分支\n```git\ngit fetch origin pull/<id>/head:<branch-name>\n```\n## 详细展示一行中的修改\n```git\ngit diff --word-diff\n```\n## 清除 gitignore 文件中记录的文件\n```git\ngit clean -X -f\n```\n## 展示所有 alias 和 configs\n - 注意： config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config\n\n```git\ngit config --local --list (当前目录)\ngit config --global --list (全局)\n```\n## 展示忽略的文件\n```git\ngit status --ignored\n```\n## commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit\n```git\ngit log Branch1 ^Branch2\n```\n## 在 commit log 中显示 GPG 签名\n```git\ngit log --show-signature\n```\n## 删除全局设置\n```git\ngit config --global --unset <entry-name>\n```\n## 新建并切换到新分支上，同时这个分支没有任何 commit\n- 相当于保存修改，但是重写 commit 历史\n\n```git\ngit checkout --orphan <branch-name>\n```\n## 展示任意分支某一文件的内容\n```git\ngit show <branch-name>:<file-name>\n```\n## clone 下来指定的单一分支\n```git\ngit clone -b <branch-name> --single-branch https://github.com/user/repo.git\n```\n## 忽略某个文件的改动\n- 关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动\n\n```git\ngit update-index --assume-unchanged path/to/file\n```\n\n- 恢复 track 指定文件的改动\n\n```git\ngit update-index --no-assume-unchanged path/to/file\n```\n## 忽略文件的权限变化\n- 不再将文件的权限变化视作改动\n\n```git\ngit config core.fileMode false\n```\n## 以最后提交的顺序列出所有Git分支\n- 最新的放在最上面\n\n```git\ngit for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads/\n```\n## 在 commit log 中查找相关内容\n- 通过 grep 查找，given-text：所需要查找的字段\n\n```git\ngit log --all --grep='<given-text>'\n```\n## 把暂存区的指定 file 放到工作区中\n- 不添加参数，默认是-mixed\n\n```git\ngit reset <file-name>\n```\n## 强制推送\n```git\ngit push -f <remote-name> <branch-name>MMmM\n```","tags":["Git","Github"],"categories":["Diary"]},{"title":"ArchLinux 安装 MySQL","path":"/posts/ArchLinux-MySQL.html","content":"ArchLinux 库里有 MariaDb，所以用 MariaDB 来代替 MySql。\n<!--more-->\n# 安装 MariaDB\n- 安装 MariaDb 和其客户端工具\n```sh\nsudo pacman -S mariadb mariadb-clients\n```\n\n- 初始化\n```sh\nsudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql\n```\n\n## 配置\n- 启动 MariaDB\n```sh\nsudo systemctl start mysqld\n```\n\n- 为 root 用户设置一新密码\n```sql\nmysqladmin -u root password '71017'\n```\n\n- 登录 MariaDb\n```sql\nmysql -uroot -p71017\n```\n\n- 开机自动启动 MariaDb\n```sh\nsudo systemctl enable mysqld\n```","tags":["Linux","MySQL","ArchLinux"],"categories":["Linux"]},{"title":"彩色 Man Page","path":"/posts/Colorful-Man-Page.html","content":"Linux下 Man Page 的显示默认是通过 less 来完成的， `.bashrc` 文件中添加 less 的相关设置参数可使其变成彩色。\n<!--more-->\n# 方法\n- 编辑 .bashrc\n```sh\nvim .bashrc\n```\n- 添加\n```sh\nexport LESS_TERMCAP_mb=$'\\e[1;32m'\nexport LESS_TERMCAP_md=$'\\e[1;32m'\nexport LESS_TERMCAP_me=$'\\e[0m'\nexport LESS_TERMCAP_se=$'\\e[0m'\nexport LESS_TERMCAP_so=$'\\e[01;33m'\nexport LESS_TERMCAP_ue=$'\\e[0m'\nexport LESS_TERMCAP_us=$'\\e[1;4;31m'\n```\n\n## 参数含义\n- 数字\n    - 31 – red\n    - 32 – green\n    - 33 – yellow\n        - [颜色](https://en.wikipedia.org/wiki/ANSI_escape_code#Colors) \n\n  - `\\e[0x;3y;4zm'`\n    - x 是否加粗，\n    - 1 加粗，\n    - 2正常；\n    - y 和 z 分别代表文字前景色和背景色\n\n  - LESS_TERMCAP_xx\n\n    |参数|含义|\n    |:---|:---|\n    |mb|start blink|\n    |md|start bold|\n    |me|turn off bold, blink and underline|\n    |us|start underline|\n    |ue|stop underline|\n    |so|start standoutv|\n    |se|stop standout|","tags":["Linux","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Atom 插件","path":"/posts/Atom-Plugin.html","content":"Atom 插件\n<!--more-->\n## 美化\n插件\n- [atom-material-ui](https://atom.io/themes/atom-material-ui)\n    - 一款 Material Design 主题\n- [simplified-chinese-menu](https://link.jianshu.com/?t=https://atom.io/packages/simplified-chinese-menu)\n    - Atom 的简体中文汉化语言包,目前最全的汉化包\n-[activate-power-mode](https://atom.io/packages/activate-power-mode)\n    - 输入特效\n- [minimap](https://atom.io/packages/minimap)\n    - 代码小地图\n\n## Web 插件\n- [emmet](https://atom.io/packages/emmet)\n    - 加快 web 开发速度，提供 snippet(代码片段)、abbreviation expand(简写展开)功能\n- [linter](https://atom.io/packages/linter)\n    - 代码校验工具\n- [autoprefixer](https://atom.io/packages/autoprefixer)\n    - 为 CSS 属性添加特定的前缀\n- [color-picker](https://atom.io/packages/color-picker)\n    - 颜色选择器\n- [pigments](https://atom.io/packages/pigments)\n    - 颜色显示\n- [php-cs-fixer](https://atom.io/packages/php-cs-fixer)\n    - php 语法检查\n- [php-debug](https://atom.io/packages/php-debug)\n    - php debug\n- [atom-html-preview ](https://atom.io/packages/atom-html-preview)\n    - 实时预览 HTML 页面\n- [atom-ternjs](https://atom.io/packages/atom-ternjs)\n    - Js,NodeJs,es6 补全\n- [jshint](https://atom.io/packages/jshint)\n    - Js 和 Jsx 语法检验\n- [csslint](https://atom.io/packages/csslint)\n    - css 语法检验\n\n## Java 插件\n- [java-importer](https://atom.io/packages/java-importer)\n    - 用来导包用的,在代码中将鼠标指针放在需要导包的类上,点击右键选择 Get import statement,在弹出窗口中选中对应的包,然后在文本最顶部粘贴。\n- [java-generator](https://atom.io/packages/java-generator)\n    - 快速生成 get、set、toString、build 等方法,在代码中点击右键->Java Generator,列表中选中你要生成的方法。\n- [autocomplete-java](https://atom.io/packages/autocomplete-java)\n    - 加载各种包，类...\n- [highlight-selected](https://atom.io/packages/highlight-selected)\n    - 高亮选中所有的相同单词\n- [docblockr](https://atom.io/packages/docblockr)\n    - 快速注释\n\n## Python 插件\n- [autocomplete-python](https://atom.io/packages/autocomplete-python)\n    - Python 代码自动补全\n- [linter-pep8](https://atom.io/packages/linter-pep8)\n    - Python 编码规范检查\n- [python-tools](https://atom.io/packages/python-tools)\n    - 定义跳转插件\n- [atom-python-run](https://atom.io/packages/atom-python-run)\n    - 运行 Python 程序\n    - 代码运行：atom-runner （只能输出，不能输入），atom-python-run（Windows，可以输入），python-run-terminalnx（Linux，可以输入）\n\n## 同步 Atom 的设置\n- [sync-settings](https://atom.io/packages/sync-settings)\n---\n\n**更多插件**\n- [Atom Package](https://atom.io/packages/)","tags":["Linux","Windows","ArchLinux","Ubuntu","Atom"],"categories":["Diary"]},{"title":"Git 使用 Tips","path":"/posts/Git-Tips.html","content":"一些 Git 技巧。\n<!--more-->\n# Git Diff\n- 将自己的分支和其他分支进行对比\n\n```sh\ngit diff branch1 branch\n```\n\n- 对比暂存区和当前的 HEAD\n\n```sh\ngit diff --cached\n```\n  - 普通的git diff命令默认对比的是没有加到索引中的文件。\n\n# 恢复暂存区\n如果已经将一些文件添加到暂存区后又后悔了，Git 提供了多个命令来实现这个功能，具体需要根据当时情况而定。\n\n```sh\ngit rm path/to/file --cached\n```\n- 这个命令将文件从暂存区索引中删除，但是仍然会将文件保留在工作目录。这比直接使用完全删除文件会安全一点。\n\n```sh\ngit rm file -f\n```\n# Git Reset\n- 恢复已经提交的改动\n\n```sh\ngit reset\n```\n  - 这个命令可以完成许多不同的行为，因此需要按照实际场景进行使用。\n\n- 去除所有修改，包括索引中的内容和工作目录中的修改\n\n```sh\ngit reset --hard\n```\n- 重置索引\n\n```sh\ngit reset --mixed\n```\n  - 这也是git reset命令的默认行为。混合的重置会保留当前工作目录中的改动。\n\n- 仅仅修改分支的 HEAD\n\n```sh\ngit reset --soft\n```\n\n- 恢复到指定的提交版本。\n\n ```sh\ngit reset --hard COMMIT_ID\n```\n# Git Stash\n- 临时保存未追踪的文件\n\n``sh\ngit stash --include-untracked\n```\n- 列出临时储藏区中的内容\n\n```sh\ngit stash list\n```\n\n# 历史记录\n- 查看项目以及特定文件的变更情况\n\n```sh\ngit log --graph --decorate --oneline\n```\n  - 它可以用于展示经过修饰的提交历史。\n\n  ---\n  - git log 命令可以显示 HEAD、所有提交的 ID 以及分支信息。有了这些信息之后\n    - 显示更详细的信息\n    \n    ```sh\n    git show COMMIT_ID/HEAD/BRANCH\n    ```\n\n- 查看谁对一个文件做了哪些改动\n\n```sh\ngit blame path/to/file\n```\n\n- 对比当前 HEAD 和前两个提交\n\n: ```sh\ngit diff HEAD HEAD~2\n```\n- 展示每个提交中更详细的更新信息，可以使用\n\n```sh\ngit log --patch\n```\n\n- 查看包含关键字“apple”的提交\n\n```sh\ngit log --grep apples --oneline\n```\n- 查看历史提交记录中两个点之间的提交历史\n\n```sh\ngit log HEAD~5..HEAD^ --oneline\n```\n- 对于分支可以使用\n\n```sh\ngit log branch_name..master --oneline\n```\n\n# 修复错误提交\n- 删除前一次提交，并创建一个新的提交记录以替代之前的提交\n\n```sh\ngit commit --amend\n```\n\n- 恢复一个有问题的提交\n\n```sh\ngit revert COMMIT_ID\n```\n  - 会创建一个新的提交，让当前项目状态恢复到指定提交之前。\n  - 如果我们在修复问题时出现了误操作，例如不小心删除了不应该删除的文件。我们还是可以从版本库中恢复回来，因为 git 保存了所有修改的版本，包括被移除的提交。git reflog命令就是用来实现这个功能的。\n\n## 提交之前撤销 git add\n- 移除一个文件\n\n```sh\ngit reset <文件名>\n```\n- 所有文件\n- 从暂存区移除所有没有提交的修改\n\n```\ngit reset\n```\n## 撤销最近一次代码提交\n- 提交了错误的文件或一开始就遗漏了某些东西。下面这三步操作可以帮助你解决这个问题。\n\n```\ngit reset --soft HEAD~1\n```\n- 对工作文件进行必要的更改\n\n```\ngit add -A .\ngit commit -c ORIG_HEAD\n```\n- 你执行第一个命令时，Git会将HEAD指针（pointer）后移到此前的一次提交，之后你才能移动文件或作必要的修改。\n- 然后你就可以添加所有的修改，而且当你执行最后的命令时，Git会打开你的默认文本编辑器，其中会包含上一次提交时的信息。如果愿意的话，你可以修改提交信息，或者你也可以在最后的命令中使用-C而不是-c，来跳过这一步。\n\n# 其他\n- 修改已经提交的作者和邮箱\n\n```sh\ngit commit --amend --author=\"vitan <ivitan95@gmail.com>\" --no-edit\n```\n\n- 修改错误的提交信息\n  - 必须确保没有对当前的代码库（working copy）做修改，否则这些修改也会随之一起提交。\n\n```\ngit commit --amend -m ”YOUR-NEW-COMMIT-MESSAGE”\n```\n- 假如你已经将代码提交（git commit）推送（git push）到了远程分支，那么你需要通过下面的命令强制推送这次的代码提交。\n\n```\ngit push <remote> <branch> --force\n```\n\n---\n**Via**\n- [Useful Git Tips and Commands](https://thecuriousdev.org/useful-git-tips-commands/)有改动","tags":["Git","Github"],"categories":["Diary"]},{"title":"Git commit 规范","path":"/posts/Git-Commit.html","content":"Git Commit 规范\n<!--more-->\n# Commit message 格式\n每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。\n```git\n<type>(<scope>): <subject>\n// 空一行\n<body>\n// 空一行s\n<footer>\n```\n  - 其中，Header 是必需的，Body 和 Footer 可以省略。\n    - 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。\n\n## Header\nHeader 部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。\n\n## type\n- type用于说明 commit 的类别，只允许使用下面7个标识。\n\n```\nfeat：新功能（feature）\nfix：修补bug\ndocs：文档（documentation）\nstyle： 格式（不影响代码运行的变动）\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：构建过程或辅助工具的变动\n```\n  - 如果 type 为 feat 和 fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。\n\n## scope\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n\n## subject\n- subject 是 commit 目的的简短描述，不超过50个字符。\n    1. 以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n    2. 第一个字母小写\n    3. 结尾不加句号（.）\n\n\n## Body\n- Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。\n\n```\nMore detailed explanatory text, if necessary.  Wrap it to\nabout 72 characters or so.\n\nFurther paragraphs come after blank lines.\n\n- Bullet points are okay, too\n- Use a hanging indent\n```\n  - 有两个注意点。\n    1. 使用第一人称现在时，比如使用 change 而不是 changed 或 changes。\n    2. 应该说明代码变动的动机，以及与以前行为的对比。\n\n## Footer\n- Footer 部分只用于两种情况。\n  1. 不兼容变动\n  如果当前代码与上一个版本不兼容，则 Footer 部分以 `BREAKING CHANGE` 开头，后面是对变动的描述、以及变动理由和迁移方法。\n\n```\n  BREAKING CHANGE: isolate scope bindings definition has changed.\n\n    To migrate the code follow the example below:\n\n    Before:\n\n    scope: {\n      myAttr: 'attribute',\n    }\n\n    After:\n\n    scope: {\n      myAttr: '@',\n    }\n\n    The removed `inject` wasn't generaly useful for directives so there should be no code using it.\n  ```\n\n2. 关闭 issue\n- 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。\n\n```git\nCloses #234\n```\n\n- 一次关闭多个 issue\n\n```git\nCloses #123, #245, #992\n```\n\n## Revert\n- 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以 `revert:` 开头，后面跟着被撤销 Commit 的 Header。\n\n```\nrevert: feat(pencil): add 'graphiteWidth' option\n\nThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\n```\n  - Body 部分的格式是固定的，必须写成 `This reverts commit &lt;hash>.`，其中的hash是被撤销 commit 的 SHA 标识符。\n  - 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts小标题下面。\n\n# 总结\n```git 公式\n<type>(<scope>): <subject>\n```\n\n- type\n  - 用于说明 commit 的类别，只允许使用下面7个标识。\n- feat：新功能（feature）\n- fix：修补bug\n- docs：文档（documentation）\n- style： 格式（不影响代码运行的变动）\n- refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n- test：增加测试\n- chore：构建过程或辅助工具的变动\n- scope\n  - 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n- subject\n  - 是 commit 目的的简短描述，不超过50个字符。\n    1. 以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes\n    2. 第一个字母小写\n    3. 结尾不加句号（.）\n\n---\n**Via**\n- [Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)","tags":["Git","Github"],"categories":["Diary"]},{"title":"sudo 与 su 的区别","path":"/posts/sudo-su-different.html","content":"sudo su 区别\n<!--more-->\n# su\n简介\n1. su 用于用户之间的切换。但是前面的用户依然保持在登录状态。这种切换如果超级权限用户 root 向普通或虚拟用户切换不需要密码，而普通用户切换到其它任何用户都需要密码验证。\n2. 变更为其他使用者的身份，除 root 外，需要键入该使用者的密码\n\n语法\n```sh\n su [选项] [-] [<用户> [<参数>...]]\n```\n- 选项\n```sh\n  f  或 --fast\n  # 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh\n  -m -p 或 --preserve-environment\n  # 执行 su 时不改变环境变数\n  -c command 或 --command=command\n  # 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者\n  -s shell 或 --shell=shell\n  # 指定要执行的 shell(bash,csh,tcsh等），预设值为 /etc/passwd 内的该使用者(USER) shell\n  --help # 显示说明文件\n  --version # 显示版本资讯\n  - -l 或 --login\n  # 类似重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）\n  都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root\n  USER # 欲变更的使用者帐号\n```\nsu – root 和 su root（su）的区别\n- `su – root` 表示人 以root 身份登录\n- `su root` 表示与 root 建立一个链接，通过 root 执行命令\n\n不足\n1. 不安全 su 工具在多人参与的系统管理中，并不是最好的选择，su 只适用于一两个人参与管理的系统，毕竟 su 并不能让普通用户受限的使用；超级用户 root 密码应该掌握在少数用户手中。\n2. 如果某个用户需要使用 root 权限,则必须要把 root 密码告诉此用户。\n\n# sudo\n简介\n1. 为所有想使用 root 权限的普通用户设计的。可以让普通用户具有临时使用root权限的权利。只需输入自己账户的密码即可。个普通用户必须在 /etc/sudoers 文件中有配置项,才具有使用sudo的权利.\n2. 执行命令的流程是当前用户切换到 root（或其它指定切换到的用户），然后以 root（或其它指定的切换到的用户）身份执行命令，执行完成后，直接退回到当前用户.\n\n语法\n```sh\nsudo 参数\n```\n- 参数\n```sh\n  -V # 显示版本编号\n  -h # 会显示版本编号及指令的使用方式说明\n  -l # 显示出自己（执行 sudo 的使用者）的权限\n  -v # sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，\n  这个参数是重新做一次确认，如果超过 N 分钟，也会问密码\n  -k # 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）\n  -b # 将要执行的指令放在背景执行\n  -p # prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称\n  -u # username/#uid 不加此参数，代表要以 root 的身份执行指令\n  而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）\n  -s # 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell\n  -H # 将环境变数中的 HOME （家目录）指定为要变更身份的使用者家目录\n  （如不加 -u 参数就是系统管理者 root ）\n  command # 要以系统管理者身份（或以 -u 更改为其他人）执行的指令\n```\n\n# 区别\n总结\n- 共同点：都是 root 用户的权限；\n- 不同点：su 仅仅取得 root 权限，工作环境不变，还是在切换之前用户的工作环境；sudo 是完全取得 root 的权限和 root 的工作环境。\n- su 用于用户之间的切换。\n- sudo 用于普通用户可以使用 root 权限来执行指定命令。\n\n---\n**参考**\n- [Linux中su与sudo、su – root的区别](https://wanglu.info/1237.html)\n- [Learn Difference Between “su” and “su -” Commands in Linux](https://www.tecmint.com/difference-between-su-and-su-commands-in-linux/)\n- [linux su和sudo命令的区别](https://www.jb51.net/LINUXjishu/12713.html)","tags":["Linux","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Linux 命令连接符","path":"/posts/LinuxAnds.html","content":"Linux 命令连接符\n<!--more-->\n# 和号操作符 (&)\n`&` 的作用是使命令在后台运行。只要在命令后面跟上一个空格和 `&`,可以一口气在后台运行多个命令。\n\n- 在后台运行一个命令\n\n```sh\nping ­c5 www.tecmint.com\n```\n\n- 同时在后台运行两个命令\n\n```sh\napt-get update & mkdit test\n```\n\n# 分号操作符（;）\n分号操作符使你可以一口气运行几个命令，命令顺序执行。\n\n```sh\napt-get update ; apt-get upgrade ; mkdir test\n```\n- 上述命令先后执行了 update 和 upgrade，最后在当前工作目录下创建了一个 `test` 文件夹。\n\n# 与操作符 (&&)\n如果第一个命令执行成功，与操作符 `&&` 才会执行第二个命令，也就是说，第一个命令退出状态是0。（在UNIX里面，0表示无错误，而所有非0返回值都是各种错误）。这个命令在检查最后一个命令的执行状态时很有用。\n\n- 使用links 命令在终端中访问网站 tecmint.com ，但在这之前我需要检查主机是否在线或不在线\n```sh\nping -c3 www.tecmint.com && links www.tecmint.com\n```\n\n# 或操作符 (||)\n或操作符 `||` 很像编程中的 `else` 语句。上面的操作符允许你在第一个命令失败的情况下执行第二个命令，比如，第一个命令的退出状态是1。\n\n- 在非root帐户中执行 `apt-get update` ，如果第一个命令失败了，接着会执行第二个命令 `links www.tecmint.com` 。\n\n```sh\napt-get update || links tecmint.com\n```\n\n- 上面的命令中，由于该用户不允许更新系统，这意味着第一个命令的退出状态是 `1` ,因此最后一个命令 `links tecmint.com` 会执行。\n\n  - 如果第一个命令成功执行并且退出状态是 `0` 呢？很明显的，第二个命令不会执行。\n\n```sh\nmkdir test || links tecmint.com\n```\n  - 这里，用户在家目录创建了一个 `test` 文件夹，这是被允许的。命令成功的执行，退出状态是 `0` ,因此，最后的命令不会执行。\n\n# 非操作符 (!)\n非操作符 `!` 很像 except 语句。这个命令会执行除了提供的条件外的所有的语句。\n\n- 在你的主目录创建一个目录 `tecmint` ，并 `cd` 到它这里。\n\n```sh\nmkdir tecmint\ncd tecmint\n```\n\n- 接下来，在文件夹‘tecmint’下创建不同类型的文件。\n\n```sh\ntouch a.doc b.doc a.pdf b.pdf a.xml b.xml a.html b.html\n```\n\n- 看一下我们在文件夹 `tecmint` 创建的新文件。\n\n```sh\nls\n```\n> a.doc  a.html  a.pdf  a.xml  b.doc  b.html  b.pdf  b.xml\n\n- 用一种聪明的办法马上删除除了 ‘html’之外的所有文件。\n\n```sh\nrm -r !(*.html)\n```\n\n- 验证一下上次的执行结果，使用ls 命令列出可见所有文件。\n\n```sh\nls\n```\n\n> a.html  b.html\n\n# 与或操作符 (&& – ||)\n上面的操作符实际上是‘与’和‘或’操作符的组合。它很像 `if-else` 语句。\n\n- ping tecmint.com，如果成功打印‘已验证’，否则打印‘主机故障’。\n```sh\nping -c3 www.tecmint.com && echo \"Verified\" || echo \"Host Down\"\n```\n- 示例输出\n\n> PING www.tecmint.com (212.71.234.61) 56(84) bytes of data.\n64 bytes from www.tecmint.com (212.71.234.61): icmp_req=1 ttl=55 time=216 ms\n64 bytes from www.tecmint.com (212.71.234.61): icmp_req=2 ttl=55 time=224 ms\n64 bytes from www.tecmint.com (212.71.234.61): icmp_req=3 ttl=55 time=226 ms\n\n--- www.tecmint.com ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2001ms\nrtt min/avg/max/mdev = 216.960/222.789/226.423/4.199 ms\nVerified\n\n- 断开我们现在的网络连接诶，再试一下相同的命令。\n```sh\nping -c3 www.tecmint.com && echo \"verified\" || echo \"Host Down\"\n```\n- 实例输出\n```sh\nping: unknown host www.tecmint.com\nHost Down\n```\n# 管道操作符 (|)\nPIPE 在将第一个命令的输出作为第二个命令的输入时很有用。\n\n- `ls -l` 的输出通过管道到‘less’，并看一下输出。\n```sh\nls -l | less\n```\n\n# 命令合并操作符 {}\n合并两个或多个命令，第二个命令依赖于第一个命令的执行。\n\n- 检查一下文件‘xyz.txt’是否在Downloads目录下，如果不存在则创建之并输出提示信息。\n```sh\n[ -f /home/tecmint/Downloads/xyz.txt ] || touch /home/tecmint/Downloads/xyz.txt; echo \"The file does not exist\"\n```\n- 但是这样的命令的运行结果并不如我们预期的运行，会始终都输出提示信息。因此需要使用{}操作符来合并命令：\n```sh\n[ -f /home/tecmint/Downloads/xyz1.txt ] || {touch /home/tecmint/Downloads/xyz.txt; echo \"The file does not exist\"}\n\n“The file does not exist”\n```\n\n# 优先操作符 ()\n这个操作符可以让命令以优先顺序执行。\n\n```sh\nCommand_x1 &&Command_x2 || Command_x3 && Command_x4\n```\n- 在上面的伪代码中，如果Command_x1执行失败了会怎么样，Command_x2, Command_x3, Command_x4没有一个会执行，对于这种情况，我们使用优先操作符。\n```sh\n(Command_x1 &&Command_x2) || (Command_x3 && Command_x4)\n```\n- 在上面的伪代码中，如果Command_x1执行失败，Command_x2不会执行，但是Command_x3会继续执行， Command_x4会依赖于 Command_x3的退出状态。\n\n# 连接符 ($$)\n连接符 `$$` 如它名字所说，被用于连接 shell 中那些太长而需要分成多行的命令。\n\n- 可以在输入一个 `\\` 之后就回车，然后继续输入命令行，直到输入完成。比如，下面的命令会打开文本文件 test(1).txt。\n```sh\nvim test \\\n1.txt\n```\n\n---\n**Via**\n- [LINUX COMMANDS](https://www.tecmint.com/category/linux-commands/)\n- [Linux 中命令链接操作符，让你的代码更简洁！](https://mp.weixin.qq.com/s/ui-Ey-JYo7X8qlMoP5Llqg)","tags":["Linux","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Markdown 各种图","path":"/posts/Markdown-Plus.html","content":"Markdown 流程图，干特图。\n<!--more-->\n# 流程图 (Flowchart)\n```mermaid\ngraph TD\n    A[Christmas] -->|Get money| B(Go shopping)\n    B --> C{Let me think}\n    C -->|One| D[Laptop]\n    C -->|Two| E[iPhone]\n    C -->|Three| F[Car]\n```\n\n# 序列图  (Sequence diagram)\n```mermaid\nsequenceDiagram\n    loop every day\n        Alice->>John: Hello John, how are you?\n        John-->>Alice: Great!\n    end\n```\n\n# 甘特图 (Gantt diagram)\n```mermaid\ngantt\n    dateFormat  YYYY-MM-DD\n    title Adding GANTT diagram functionality to mermaid\n\n    section A section\n    Completed task            :done,    des1, 2014-01-06,2014-01-08\n    Active task               :active,  des2, 2014-01-09, 3d\n    Future task               :         des3, after des2, 5d\n    Future task2               :         des4, after des3, 5d\n\n    section Critical tasks\n    Completed task in the critical line :crit, done, 2014-01-06,24h\n    Implement parser and jison          :crit, done, after des1, 2d\n    Create tests for parser             :crit, active, 3d\n    Future task in critical line        :crit, 5d\n    Create tests for renderer           :2d\n    Add to mermaid                      :1d\n\n    section Documentation\n    Describe gantt syntax               :active, a1, after des1, 3d\n    Add gantt diagram to demo page      :after a1  , 20h\n    Add another diagram to demo page    :doc1, after a1  , 48h\n\n    section Last section\n    Describe gantt syntax               :after doc1, 3d\n    Add gantt diagram to demo page      : 20h\n    Add another diagram to demo page    : 48h\n```\n---\n**参考**\n- [Mermaidjs](https://mermaidjs.github.io/)","tags":["Hexo","Typography","Markdown"],"categories":["Diary"]},{"title":"解决 Win10 与 Linux 时间不一致","path":"/posts/Linux-Win-Time.html","content":"解决 Win10 与 Linux 时间不一致\n<!--more-->\n# 原因\n## UTC 与 GMT\n1. UTC即Universal Time Coordinated，协调世界时（世界统一时间）\n2. GMT 即Greenwich Mean Time，格林尼治平时\n\n## 原因\n- Windows 把计算机硬件时间当作本地时间(local time)，所以在Windows系统中显示的时间跟BIOS中显示的时间是一样的。\n- Linux/Unix/Mac把计算机硬件时间当作 UTC， 所以在Linux/Unix/Mac系统启动后在该时间的基础上，加上电脑设置的时区数（ 比如我们在中国，它就加上“8” ），因此，Linux/Unix/Mac系统中显示的时间总是比Windows系统中显示的时间快8个小时。\n- 所以，当你在Linux/Unix/Mac系统中，把系统现实的时间设置正确后，其实计算机硬件时间是在这个时间上减去8小时，所以当你切换成Windows系统后，会发现时间慢了8小时。就是这样个原因。\n\n# 解决方法\n## 方法一\n- 把 Linux 计算机硬件时间改成系统显示的时间，即禁用 UTC\n```sh\ntimedatectl set-local-rtc 1 --adjust-system-clock\n```\n\n## 方法二\n- 修改 Windows 对硬件时间的对待方式，让 Windows把硬件时间当作 UTC.\n```sh\nReg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1\n```\n---\n**Via**\n- [滑稽](https://www.zhihu.com/question/46525639)","tags":["Linux","Windows","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"RaspberryPi 安装屏幕触控驱动及设置分辨率","path":"/posts/Raspberry-LCD.html","content":"Raspberry Pi 屏幕触控驱动安装及分辨率设置。\n<!--more-->\n# 触摸驱动\n## 下载链接\n- [GitHub 中获取](https://github.com/goodtft/LCD-show)\n\n# 安装(3.5寸为例)\n## 修改 config 配置文件\n1. 烧写系统完成后,将 `LCD-show.tar.gz` 拷贝到 TF 卡根目录,\n2. 打开 TF 卡根目录的 `config.txt` 文件并在文件末端加入以下代码,保存并安全弹出 TF 卡:\n\n```bash\nhdmi_drive=2\nhdmi_force_hotplug=1\nhdmi_group=2\nhdmi_mode=87\nhdmi_cvt 480 320 60 6 0 0 0\n```\n\n## 配置\n```shell\n  cd /boot\n  cp LCD-show.tar.gz ~\n  cd ~\n  sudo tar zxvf LCD-show.tar.gz\n  cd LCD-show/\n  sudo ./MPI3508_480_320-show\n```\n\n# 修改分辨率\n- 终端输入\n\n```sh\nsudo vim /boot/config.txt\n```\n\n- 修改\n\n```\nhdmi_drive=2\nhdmi_force_hotplug=1\nhdmi_group=2\nhdmi_mode=87\n# 这里根据分辨率来设置\n```\n## 分辨率表\n### CEA 分辨率(电视规格分辨率)\n\n- CEA 规定的电视规格分辨率，这些分辨率的 `hdmi_group = 1`\n\n```shell\n  hdmi_mode=1    VGA\n  hdmi_mode=2    480p  60Hz\n  hdmi_mode=3    480p  60Hz  H\n  hdmi_mode=4    720p  60Hz\n  hdmi_mode=5    1080i 60Hz\n  hdmi_mode=6    480i  60Hz\n  hdmi_mode=7    480i  60Hz  H\n  hdmi_mode=8    240p  60Hz\n  hdmi_mode=9    240p  60Hz  H\n  hdmi_mode=10   480i  60Hz  4x\n  hdmi_mode=11   480i  60Hz  4x H\n  hdmi_mode=12   240p  60Hz  4x\n  hdmi_mode=13   240p  60Hz  4x H\n  hdmi_mode=14   480p  60Hz  2x\n  hdmi_mode=15   480p  60Hz  2x H\n  hdmi_mode=16   1080p 60Hz\n  hdmi_mode=17   576p  50Hz\n  hdmi_mode=18   576p  50Hz  H\n  hdmi_mode=19   720p  50Hz\n  hdmi_mode=20   1080i 50Hz\n  hdmi_mode=21   576i  50Hz\n  hdmi_mode=22   576i  50Hz  H\n  hdmi_mode=23   288p  50Hz\n  hdmi_mode=24   288p  50Hz  H\n  hdmi_mode=25   576i  50Hz  4x\n  hdmi_mode=26   576i  50Hz  4x H\n  hdmi_mode=27   288p  50Hz  4x\n  hdmi_mode=28   288p  50Hz  4x H\n  hdmi_mode=29   576p  50Hz  2x\n  hdmi_mode=30   576p  50Hz  2x H\n  hdmi_mode=31   1080p 50Hz\n  hdmi_mode=32   1080p 24Hz\n  hdmi_mode=33   1080p 25Hz\n  hdmi_mode=34   1080p 30Hz\n  hdmi_mode=35   480p  60Hz  4x\n  hdmi_mode=36   480p  60Hz  4xH\n  hdmi_mode=37   576p  50Hz  4x\n  hdmi_mode=38   576p  50Hz  4x H\n  hdmi_mode=39   1080i 50Hz  reduced blanking\n  hdmi_mode=40   1080i 100Hz\n  hdmi_mode=41   720p  100Hz\n  hdmi_mode=42   576p  100Hz\n  hdmi_mode=43   576p  100Hz H\n  hdmi_mode=44   576i  100Hz\n  hdmi_mode=45   576i  100Hz H\n  hdmi_mode=46   1080i 120Hz\n  hdmi_mode=47   720p  120Hz\n  hdmi_mode=48   480p  120Hz\n  hdmi_mode=49   480p  120Hz H\n  hdmi_mode=50   480i  120Hz\n  hdmi_mode=51   480i  120Hz H\n  hdmi_mode=52   576p  200Hz\n  hdmi_mode=53   576p  200Hz H\n  hdmi_mode=54   576i  200Hz\n  hdmi_mode=55   576i  200Hz H\n  hdmi_mode=56   480p  240Hz\n  hdmi_mode=57   480p  240Hz H\n  hdmi_mode=58   480i  240Hz\n  hdmi_mode=59   480i  240Hz H\n  H means 16:9 variant (of a normally 4:3 mode).\n  2x means pixel doubled (i.e. higher clock rate, with each pixel repeated twice)\n  4x means pixel quadrupled (i.e. higher clock rate, with each pixel repeated four times)\n```\n\n### DMT分辨率(计算机显示器)\n- 以下的英文计算机显示器使用的分辨率,这些分辨率的 `hdmi_group = 2`\n\n```shell\n  hdmi_mode=1    640x350   85Hz\n  hdmi_mode=2    640x400   85Hz\n  hdmi_mode=3    720x400   85Hz\n  hdmi_mode=4    640x480   60Hz\n  hdmi_mode=5    640x480   72Hz\n  hdmi_mode=6    640x480   75Hz\n  hdmi_mode=7    640x480   85Hz\n  hdmi_mode=8    800x600   56Hz\n  hdmi_mode=9    800x600   60Hz\n  hdmi_mode=10   800x600   72Hz\n  hdmi_mode=11   800x600   75Hz\n  hdmi_mode=12   800x600   85Hz\n  hdmi_mode=13   800x600   120Hz\n  hdmi_mode=14   848x480   60Hz\n  hdmi_mode=15   1024x768  43Hz  DO NOT USE\n  hdmi_mode=16   1024x768  60Hz\n  hdmi_mode=17   1024x768  70Hz\n  hdmi_mode=18   1024x768  75Hz\n  hdmi_mode=19   1024x768  85Hz\n  hdmi_mode=20   1024x768  120Hz\n  hdmi_mode=21   1152x864  75Hz\n  hdmi_mode=22   1280x768        reduced blanking\n  hdmi_mode=23   1280x768  60Hz\n  hdmi_mode=24   1280x768  75Hz\n  hdmi_mode=25   1280x768  85Hz\n  hdmi_mode=26   1280x768  120Hz reduced blanking\n  hdmi_mode=27   1280x800        reduced blanking\n  hdmi_mode=28   1280x800  60Hz\n  hdmi_mode=29   1280x800  75Hz\n  hdmi_mode=30   1280x800  85Hz\n  hdmi_mode=31   1280x800  120Hz reduced blanking\n  hdmi_mode=32   1280x960  60Hz\n  hdmi_mode=33   1280x960  85Hz\n  hdmi_mode=34   1280x960  120Hz reduced blanking\n  hdmi_mode=35   1280x1024 60Hz\n  hdmi_mode=36   1280x1024 75Hz\n  hdmi_mode=37   1280x1024 85Hz\n  hdmi_mode=38   1280x1024 120Hz reduced blanking\n  hdmi_mode=39   1360x768  60Hz\n  hdmi_mode=40   1360x768  120Hz reduced blanking\n  hdmi_mode=41   1400x1050       reduced blanking\n  hdmi_mode=42   1400x1050 60Hz\n  hdmi_mode=43   1400x1050 75Hz\n  hdmi_mode=44   1400x1050 85Hz\n  hdmi_mode=45   1400x1050 120Hz reduced blanking\n  hdmi_mode=46   1440x900        reduced blanking\n  hdmi_mode=47   1440x900  60Hz\n  hdmi_mode=48   1440x900  75Hz\n  hdmi_mode=49   1440x900  85Hz\n  hdmi_mode=50   1440x900  120Hz reduced blanking\n  hdmi_mode=51   1600x1200 60Hz\n  hdmi_mode=52   1600x1200 65Hz\n  hdmi_mode=53   1600x1200 70Hz\n  hdmi_mode=54   1600x1200 75Hz\n  hdmi_mode=55   1600x1200 85Hz\n  hdmi_mode=56   1600x1200 120Hz reduced blanking\n  hdmi_mode=57   1680x1050       reduced blanking\n  hdmi_mode=58   1680x1050 60Hz\n  hdmi_mode=59   1680x1050 75Hz\n  hdmi_mode=60   1680x1050 85Hz\n  hdmi_mode=61   1680x1050 120Hz reduced blanking\n  hdmi_mode=62   1792x1344 60Hz\n  hdmi_mode=63   1792x1344 75Hz\n  hdmi_mode=64   1792x1344 120Hz reduced blanking\n  hdmi_mode=65   1856x1392 60Hz\n  hdmi_mode=66   1856x1392 75Hz\n  hdmi_mode=67   1856x1392 120Hz reduced blanking\n  hdmi_mode=68   1920x1200       reduced blanking\n  hdmi_mode=69   1920x1200 60Hz\n  hdmi_mode=70   1920x1200 75Hz\n  hdmi_mode=71   1920x1200 85Hz\n  hdmi_mode=72   1920x1200 120Hz reduced blanking\n  hdmi_mode=73   1920x1440 60Hz\n  hdmi_mode=74   1920x1440 75Hz\n  hdmi_mode=75   1920x1440 120Hz reduced blanking\n  hdmi_mode=76   2560x1600       reduced blanking\n  hdmi_mode=77   2560x1600 60Hz\n  hdmi_mode=78   2560x1600 75Hz\n  hdmi_mode=79   2560x1600 85Hz\n  hdmi_mode=80   2560x1600 120Hz reduced blanking\n  hdmi_mode=81   1366x768  60Hz\n  hdmi_mode=82   1080p     60Hz\n  hdmi_mode=83   1600x900        reduced blanking\n  hdmi_mode=84   2048x1152       reduced blanking\n  hdmi_mode=85   720p      60Hz\n  hdmi_mode=86   1366x768        reduced blanking\n```","tags":["Linux","RaspberryPi"],"categories":["Diary"]},{"title":"ArchLinux 显卡驱动","path":"/posts/ArchLinux-Nvidia.html","content":"ArchLinux 双显卡驱动。\n<!--more-->\n# 安装\n## Nvidia 和 xorg-xrandr\n```sh\nsudo pacman -S nvidia nvidia-settings xorg-xrandr\n```\n## 配置\n获取显卡 PCI 地址\n```sh\nlspci | grep -E \"VGA|3D\"\n```\n地址转换\n```sh\n01:00.0 --> 1:0:0 # 转换示例\n```\n配置 xorg.conf\n```\nsudo vim /etc/X11/xorg.conf\n```\n\n- 添加\n```sh\n    Section \"Module\"\n  \tLoad \"modesetting\"\n  EndSection\n\n  Section \"Device\"\n  \tIdentifier \"nvidia'\"\n  \tDriver \"nvidia\"\n  \tBusID \"1:0:0\"\n  \tOption \"AllowEmptyInitialConfiguration\"\n  EndSection\n```\n\n# 各桌面配置 (Display Managers)\n## SDDM (Plasma)\n启动管理器编辑脚本\n```sh\nsudo vim /usr/share/sddm/scripts/Xsetup\n```\n- 添加\n```sh\nxrandr --setprovideroutputsource modesetting NVIDIA-0\nxrandr --auto\n```\n\n## LightDM (Deepin)\n配置\n```sh\nsudo vim /etc/lightdm/display_setup.sh\n```\n\n- 添加\n\n```sh\n#!/bin/sh\nxrandr --setprovideroutputsource modesetting NVIDIA-0\nxrandr --auto\n```\n\n- chmod 权限\n\n```sh\nchmod +x /etc/lightdm/display_setup.sh\n```\n\n配置脚本\n```sh\nsudo vim /etc/lightdm/lightdm.conf\n```\n\n- 添加\n\n```sh\n[Seat:*]\ndisplay-setup-script=/etc/lightdm/display_setup.sh\n```\n\n## GDM (Gnome)\n创建两个新的 .desktop 文件\n\n- /usr/share/gdm/greeter/autostart/optimus.desktop 下创建\n\n```sh\nsudo vim /usr/share/gdm/greeter/autostart/optimus.desktop\n```\n- 添加\n\n```sh\n[Desktop Entry]\nType=Application\nName=Optimus\nExec=sh -c \"xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto\"\nNoDisplay=true\nX-GNOME-Autostart-Phase=DisplayServer\n```\n\n- /etc/xdg/autostart/optimus.desktop 下创建\n\n```sh\nsudo vim /etc/xdg/autostart/optimus.desktop\n```\n\n- 添加\n\n```sh\n[Desktop Entry]\nType=Application\nName=Optimus\nExec=sh -c \"xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto\"\nNoDisplay=true\nX-GNOME-Autostart-Phase=DisplayServer\n```\n\n确保 GDM 使用 X 作为默认后端\n- Gnome 默认使用 Wayland 作为后端，只有 Wayland 后端无法启动时才使用 Xorg 后端。\n- 修改为 X\n\n```sh\nsudo vim /etc/gdm/custom.conf\n```\n\n- 取消以下注释\n\n```sh\n#WaylandEnable=false\n```\n\n解决错误提示\n\n- 删除主用户 “gdm”，删除组 “gdm”\n\n```sh\nsudo userdel gdm\nsudo groupdel gdm\n```\n\nGDM使用单独的 dconf 数据库来控制电源管理\n- 通过将用户设置复制到 GDM 的 dconf 数据库，可以使 GDM 的行为与用户会话相同。\n\n```sh\nIFS=$'\\n'; for x in $(sudo -u YOUR_USER gsettings list-recursively org.gnome.settings-daemon.plugins.power); do eval \"sudo -u gdm dbus-launch gsettings set $x\"; done; unset IFS\n```\n\n- 或者简单地禁用自动挂起(在电池上运行时，也可以用 ac 替换电池来禁用它)：\n\n```sh\nsudo -u gdm dbus-launch gsettings set org.gnome.settings-daemon.plugins.power sleep-inactive-ac-type 'nothing'\n```\n---\n**参考**\n- [NVIDIA Optimus](https://wiki.archlinux.org/index.php/NVIDIA_Optimus#Display_Managers)\n- [GDM](https://wiki.archlinux.org/index.php/GDM#Use_Xorg_backend)","tags":["Linux","ArchLinux"],"categories":["Linux"]},{"title":"树莓派获取 IP 地址","path":"/posts/RaspberryIp.html","content":"树莓派获取 IP \n<!--more-->\n# 有显示器\n```sh\nifconfig\nhostname -I\n```\n# 无显示器有路由器\n- 连接路由器后[登陆路由器管理界](http://192.168.1.1)面查看即可。\n\n# 只有电脑\n- 网线直接把树莓派与电脑连接起来\n- 电脑需要连 WiFi\n- 在 设置->网络->Wlan->网络与共享中心->Wlan->属性->共享->允许​其它用户通过它来连接->确定。\n- CMD 查看 IP\n\n```sh\nping raspberrypi.local\n```\n\n- 改变了树莓派的主机名字，Avahi 也将改变 .local 的 DNS 多播地址\n\n```sh\narp -a\n# 通常以192.168开头，最后一位是1\n```\n\n# 只有手机（安卓）\n- USB 共享的网络\n- 开启热点\n- 使用局域网扫描软件([Find](https://play.google.com/store/apps/details?id=com.overlook.android.fing),IpScanner,Es文件管理器...)查询 IP\n\n---\n**参考**\n- [查看树莓派ip地址的几种方法](https://blog.csdn.net/wongnoubo/article/details/79628313)\n- [树莓派获取ip地址的N种方法](https://www.jianshu.com/p/f2e0a02c01d9)","tags":["Linux","RaspberryPi"],"categories":["Diary"]},{"title":"ArchLinux Pacman 命令","path":"/posts/ArchLinux-command.html","content":"pacman 软件包管理器\n<!--more-->\n# 使用\n## 安装指定的包\n安装或者升级单个软件包，或者一列软件包（包含依赖包）\n```bash\npacman -S package_name1 package_name2 ...\n```\n\n用正则表达式安装多个软件包\n```bash\npacman -S $(pacman -Ssq package_regex)\n```\n- [pacman/Tips and tricks](https://wiki.archlinux.org/index.php/Pacman/Tips_and_tricks)\n\n选择仓库按照\n```bash\npacman -S extra/package_name\n```\n\n安装多个含有相似名称的软件包，而并非整个包组或全部匹配的软件包\n```bash\npacman -S plasma-{desktop,mediacenter,nm}\n```\n\n多层扩展\n```bash\npacman -S plasma-{workspace{,-wallpapers},pa}\n```\n\n安装包组\n```bash\npacman -S gnome\n```\n- [包组](https://wiki.archlinux.org/index.php/Creating_packages#Meta_packages_and_groups)\n\n\n## 删除软件包\n删除但保留依赖关系\n```bash\npacman -R package_name\n```\n\n删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系\n```bash\npacman -Rs package_name\n```\n\n删除软件包和所有依赖\n```bash\npacman -Rsc package_name\n```\n\n删除但不删除依赖这个软件包的其他程序\n```bash\npacman -Rdd package_name\n```\n\n## 升级软件包\n升级整个系统\n```bash\npacman -Syu\n```\n\n## 查询包数据库\n1. pacman 使用 -Q 参数查询本地软件包数据库\n```bash\npacman -Q --help\n```\n\n2. 使用 -S 参数来查询远程同步的数据库\n```bash\npacman -S --help\n```\n\n3. pacman 可以在包数据库中查询软件包，查询位置包含了软件包的名字和描述\n```bash\npacman -Ss string1 string2 ...\n```\n\n4. 有时，-s的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段，下面的命令就会返回很多不必要结果\n```bash\npacman -Ss '^vim-'\n```\n\n5. 要查询已安装的软件包：\n```bash\npacman -Qs string1 string2 ...\n```\n  \n6. 按文件名查找软件库：\n```bash\npacman -Fs string1 string2 ...\n```\n7. 显示软件包的详尽的信息：\n```bash\npacman -Si package_name\n```\n\n8. 查询本地安装包的详细信息：\n```bash\npacman -Qi package_name\n```\n\n9. 使用两个 -i 将同时显示备份文件和修改状态：\n```bash\npacman -Qii package_name\n```\n\n10. 要获取已安装软件包所包含文件的列表：\n```bash\npacman -Ql package_name\n```\n\n11. 查询远程库中软件包包含的文件：\n```bash\npacman -Fl package_name\n```\n\n11. 检查软件包安装的文件是否都存在：\n```bash\npacman -Qk package_name\n```\n\n12. 两个参数k将会执行一次更彻底的检查。 查询数据库获取某个文件属于哪个软件包：\n```bash\npacman -Qo /path/to/file_name\n```\n\n13. 查询文件属于远程数据库中的哪个软件包：\n```bash\npacman -Fo /path/to/file_name\n```\n\n14. 要罗列所有不再作为依赖的软件包(孤立orphans)：\n```bash\npacman -Qdt\n```\n\n15. 要罗列所有明确安装而且不被其它包依赖的软件包：\n```bash\npacman -Qet\n```\n\n16. 要显示软件包的依赖树：\n```bash\npactree package_name\n```\n\n17. 检查一个安装的软件包被那些包依赖，可以使用 pkgtoolsAUR中的whoneeds:\n```bash\nwhoneeds package_name\n```\n- 或者pactree中使用-r:\n```bash\npactree -r package_name\n```\n\n## 数据库结构\npacman数据库通常位于 `/var/lib/pacman/sync`. 对于每一个在 `/etc/pacman.conf` 中指定的软件仓库， 这里都有一个一致的数据库。数据库文件夹里每个 `tar.gz` 文件都包含着一个仓库的软件包信息。例如which 包:\n```\n  % tree which-2.20-6\n  which-2.20-6\n  |-- depends\n  `-- desc\n```\n- 这个 depends 项列出了该软件的依赖包， 而desc有该包的介绍，例如文件大小和MD5值 。\n\n## 清理软件包缓存\n pacman 将下载的软件包保存在 `/var/cache/pacman/pkg/` 并且不会自动移除旧的和未安装版本的软件包，因此需要手动清理，以免该文件夹过于庞大。\n\n使用内建选项即可清除未安装软件包的缓存：\n```bash\npacman -Sc\n```\n\n- pacman 提供的 paccache 命令默认会删除近3个版本前的软件包\n\n```bash\npaccache -r\n```\n- Tip: 可以使用 pacman hooks 自动执行清理，这里是[参考示例](https://bbs.archlinux.org/viewtopic.php?pid=1694743#p1694743)。\n- 也可以自己设置保留最近几个版本：\n\n```bash\npaccache -rk 1\n```\n清理所有未安装包的缓存文件\n```bash\npaccache -ruk0\n```\n\n# 其它命令\n升级系统时安装其他软件包：\n```bash\npacman -Syu package_name1 package_name2 ...\n```\n\n下载包而不安装它：\n```bash\npacman -Sw package_name\n```\n安装一个本地包(不从源里下载）：\n```\npacman -U /path/to/package/package_name-version.pkg.tar.xz\n```\n\n要将本地包保存至缓存，可执行：\n```bash\npacman -U file://path/to/package/package_name-version.pkg.tar.xz\n```\n\n安装一个远程包（不在 pacman 配置的源里面）\n```sh\npacman -U http://www.example.com/repo/example.pkg.tar.xz\n```\n- 要禁用 `-S`, `-U` 和 `-R` 动作，可以使用 `-p` 选项.\n\n---\n**Via**\n- [Pacman](https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))","tags":["Linux","ArchLinux"],"categories":["Linux"]},{"title":"Linux 安装微信 QQ","path":"/posts/linux-WeChat-QQ.html","content":"Linux 安装 QQ WeChat Tim.\n<!--more-->\n# ArchLinux\n## 添加 archlinuxcn 源\n- 编辑 pacman.conf\n\n```sh\nvim /etc/pacman.conf\n```\n- 添加\n\n```sh\n[archlinuxcn]\nSigLevel = Optional TrustAll\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch\n```\n\n## 安装\n```sh\nsudo pacman -S wine\nsudo pacman -S deepin.com.qq.im\nsudo pacman -S deepin.com.qq.office\nsudo pacman -S deepin.com.wechat\nsudo pacman -S netease-cloud-music\n```\n- ArchLinux 系发行版包括 ArchLinux、Manjaro、Antergos 等.\n\n## 配置分辨率\n```bash\nenv WINEPREFIX=\"$HOME/.deepinwine/Deepin-WeChat\" winecfg\nenv WINEPREFIX=\"$HOME/.deepinwine/Deepin-TIM\" winecfg\nenv WINEPREFIX=\"$HOME/.deepinwine/Deepin-QQ\" winecfg\n```\n\n# Ubuntu\n## Deepin-wine 环境\n方法一\n```sh\ngit clone 'https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git\n# 克隆到本地，用图形界面的软件包管理器安装所有 deb 文件\n```\n方法二\n```sh\ngit clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git\nsudo sh ./install.sh\n# 克隆到本地,(授予可执行权限后)在终端中运行 install.sh .\n```\n\n## Deepin.com 应用容器\n- 自行到[阿里镜像](http://mirrors.aliyun.com/deepin/pool/non-free/d/)中下载想要的容器安装运行即可(容器建议使用命令安装)。\n- 推荐容器\n  - QQ:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/\n  - TIM:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/\n  - QQ轻聊版:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im.light/\n  - 微信:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/\n  - Foxmail:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.foxmail/\n  - 百度网盘:http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.baidu.pan/\n- Ubuntu 系发行版包括Ubuntu、LinuxMint、ZorinOS 等.\n\n---\n**参考**\n- [Deepin wine for ubuntu](https://github.com/wszqkzqk/deepin-wine-ubuntu)    \n- [多发行版通过！目前Linux上真正完美稳定的wine QQ方案](https://www.lulinux.com/archives/1319)","tags":["Linux","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"ArchLinux 安装及优化","path":"/posts/ArchLinux.html","content":"> ArchLinux 安装及优化配置。\n\n# 准备镜像\n[下载 ISO](https://www.archlinux.org/download/) 并使用 [Rufus](https://rufus.ie/) 或其他工具烧录镜像制作启动盘。Linux 下推荐用 DD 模式,开机选择烧录好的U盘进行引导进入安装。\n\n```sh\ndd bs=4M if=/home/download/archlinux.iso of=/dev/sdX  status=progress && sync\n```\n<!--more-->\n\n# 安装\n## 进行联网\n- WiFi 连接 \n\n```sh\nwifi-menu\n```\n\n- PPOE 连接\n\n```sh\npppoe-setup\n```\n\n- ADSL 连接\n\n```sh\nsystemctl start adsl\n```\n\n- 测试网络\n\n```sh\nping www.vitan.me\n```\n\n## 更新系统时钟\n```sh\ntimedatectl set-ntp true\n```\n\n## 更换国内源\n将 China 开头一下两行剪切到 ustc 最第一行，技巧(光标在 China 下，按2后 dd 最后 p 粘贴)\n```sh\nvim /etc/pacman.d/mirrorlist\n```\n\n##  分区\n### 分区方案\n\n|分区|大小|类型|\n|:---|:---|:---|\n|boot  | 512M | EFI System        |\n|swap  | 8G   | Linux Swap      |\n| /    | 75G  | Linux filesystem |\n| home | 65G  | Linux Homme |\n\n### 查看启动模式\n```sh\nls /sys/firmware/efi/efivars\n```\n如果提示不存在这个文件，那就说明我们的启动模式是 BIOS，否则就是 UEFI。BIOS 和 UEFI 的分区会有点不同，老铁们请移步查看 [archlinux wiki](https://wiki.archlinux.org/index.php/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))\n\n### MBR 分区(BIOS 分区)\n```sh\ncfdisk /dev/sdb # 进入分区\nnew # 新建分区，输入大小\ntype # 选择分区属性\nwrite # 执行分区\n```\n\n### GPT 分区(UEFI 分区)\n```sh\ngdisk /dev/sdb #不同电脑设备不同\ng # 建立gpt分区表:\nn # 添加一个分区\n提示让输入开始扇区(一个扇区512B，按自己要分区容量大小进行计算)\n输入2048,回车\n让输入结束扇区，由于一个扇区512B，要创建200M的分区,应该输入：+200M；\nw 保存并退出；\nlsblk # 查看分区列表\n```\n\n## 格式化\n```sh\nmkfs.vfat /dev/sdb1 # EFI分区  挂载在/mnt/boot/EFI\nmkswap -f /dev/sdb2 # 格式化 swap\nswapon /dev/sdb2  # swap分区\nmkfs.ext4 /dev/sdb3 # /分区\nmkfs.ext4 /dev/sdb4 # /home 分区\n```\n\n## 挂载分区\n### BIOS 引导\n```sh\nmount /dev/sdb3 /mnt # 根分区挂载到 /mnt 目录\nmkdir /mnt/home\nmount /dev/sdb4 /mnt/home # home 分区\nmkdir /mnt/boot # 在 /mnt 目录下新建 boot目录\nmount /dev/sdb1 /mnt/boot #将boot分区挂载在刚创建的/mnt/boot目录\n```\n\n### UEFI 引导\n```sh\nmount /dev/sdb3 /mnt # /分区\nmkdir /mnt/home\nmount /dev/sdb4 /mnt/home # home 分区\nmkdir -p /mnt/boot\nmount /dev/sdb1 /mnt/boot # EFI 分区\n```\n\n## 安装基本操作系统\n### 配置软件源\n将清华源移到第一行\n\n```sh\nvim /etc/pacman.d/mirrorlist\n```\n更新源\n```sh\npacman -Syy\n```\n\n### 基础包\n安装系统到 `/dev/sdb2` 即挂载点 `/mnt`\n\n```sh\npacstrap /mnt base linux linux-firmware base-devel\npacstrap /mnt NetworkManager vim\npacstrap /mnt base-devel # 开发基础包\n```\n\n### 配置基础系统\n- 生成 fstab 文件\n\n```sh\ngenfstab -U /mnt >> /mnt/etc/fstab\n```\n\n- 检查\n\n```sh\ncat /mnt/etc/fstab\n```\n\n## 切换到新系统\n```sh\narch-chroot /mnt\n```\n\n## 时区\n### 设置时区\n```sh\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n```\n\n### 硬件时间\n```sh\nhwclock --systohc\n```\n\n## 语言设置\n`vim /etc/locale.gen` 反注释 `en_US.UTF-8` 和 `zh_CN.UTF-8`\n```sh\n#生成 locale\nlocale-gen \n\n# 配置 locale.conf\necho 'LANG=zh_CN.UTF-8'  > /etc/locale.conf\n```\n\n## 无线网络\n安装相关包\n\n```sh\npacman -S iw wpa_supplicant dialog net-tools networkmanager dhcpcd\n```\n\n设置网络工具开机自启\n\n```sh\nsystemctl enable NetworkManager\nsystemctl enable dhcpcd\n```\n\n连接无线网络\n\n```sh\nwifi-menu\n```\n\n## 设置主机名\n```sh\necho Vitan-ArchLinux >> /etc/hostname\n```\n\n## 账号密码设置\n- 设置 root 密码\n\n```sh\npasswd\n```\n\n- 添加用户\n\n```sh\nuseradd -m -G wheel vitan\npasswd vitan # 修改密码\n```\n\n- sudo 权限\n\n```sh\npacman -S sudo\nvim /etc/sudoers\n```\n\n取消注释\n\n```sh\n%wheel ALL=(ALL) ALL\n```\n\n## 安装微码\n- Intel CPU\n\n```sh\npacman -S intel-ucode\n```\n\n- AMD CPU\n\n```sh\npacman -S amd-ucode\n```\n\n## 安装引导程序（不能漏）\n### UEFI 引导\n```sh\npacman -S grub efibootmgr\ngrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ArchLinux\ngrub-mkconfig -o /boot/grub/grub.cfg\n```\n### BIOS 引导\n注意第二条命令是安装系统的盘符，若安装在 /dev/sdb 就填 /dev/sdb，后不跟数数字\n```sh\npacman -S grub\ngrub-install /dev/sdb\ngrub-mkconfig -o /boot/grub/grub.cfg\n```\n\n## 退出 chroot 重启 (笔记本跳过)\n```sh\nexit # 退回安装环境#\numount -R  /mnt # 卸载新分区\nreboot # 重启\n```\n\n## 网络配置(重启后)\n有线连接\n```sh\nsystemctl enable dhcpcd\n```\n\n无线连接\n```sh\npacman -S iw wpa_supplicant dialog netctl\n```\n\nADSL 宽带连接\n```sh\npacman -S rp-pppoe# pppoe-setup\n```\n\n## 重启不能联网\n重启 dhcpcd\n```sh\nsystemctl enable dhcpcd\n```\n继续输入\n```sh\nip link\n```\n发现名称是ens33的网卡state 是down状态\n```sh\nip link set ens33 up # ifconfig ens33 up\n```\n\n# 安装桌面环境\n## Gnome 桌面\n```sh\nsudo pacman -S gnome #gnome桌面：\nsudo pacman -S gnome-tweak-tool #安装gnome桌面优化工具\nsudo pacman -S alacarte # 安装gnome桌面菜单编辑器\nsystemctl enable gdm #启用gnome窗口管理器服务\nsystemctl enable NetworkManager # 启用网络管理器服务\nreboot\n```\n\n## Deepin 桌面\n```sh\nsudo pacman -S deepin\nsudo pacman -S deepin-extra\nsudo pacman S bash-completion\nsudo pacman -S networkmanager\nsystemctl enable NetworkManager # 注意大小写\nsystemctl start NetworkManager\n```\n编辑\n```sh\nvim /etc/lightdm/lightdm.conf\n```\n修改如下\n```sh\ngreeter-session=lightdm-deepin-greeter\n```\n执行\n```sh\nsystemctl enable lightdm.service\n```\n\n## KDE Plasma 桌面\n```sh\nsudo pacman -S xorg\nsudo pacman -S xf86-input-synaptics #触摸板驱动\nsudo pacman -S ttf-dejavu wqy-microhei # 字体\nsudo pacman -S plasma kde-applications # 桌面及基本应用\nsudo pacman -S NetworkManager net-tools\nsudo pacman -S kde-l10n-zh_cn # KDE 中文包\nsudo pacman -S alsa-utils pulseaudio pulseaudio-alsa # 声音\n\nsystemctl enable sddm # 启用 sddm 显示管理器\nsystemctl enable NetworkManager # 启用网络管理\nsystemctl enable dhcpcd\n```\n\n# 后续优化\n## 配置源\n```sh\nsudo vim /etc/pacman.conf\n```\n1. 首先去掉 multilib 中两行的注释\n2. 在文档结尾处加入\n\n```sh\n[archlinuxcn]\nSigLevel = Optional TrustAll\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch\n```\n\n刷新pacman数据库\n```sh\nsudo pacman -Syy\n```\n\n## 驱动\n### 声卡\n```sh\nsudo pacman -S alsautils pulseaudio pulseaudio-alsa\n```\n\n### 显卡\n安装驱动\n```sh\nsudo pacman -S nvidia\nsudo pacman -S nvidia-settings\n```\n\n启动管理器编辑脚本(Plasma 桌面有效)\n```sh\nsudo vim /usr/share/sddm/scripts/Xsetup\n```\n\n添加\n```sh\nxrandr --setprovideroutputsource modesetting NVIDIA-0\nxrandr --auto\n```\n\n重启\n```sh\nreboot\n```\n\n获取显卡 PCI 地址\n```sh\nispci | grep -E \"VGA|3D\"\n```\n\n地址转换\n```sh\n01:00.0 --> 1:0:0 # 转换示例\n```\n\n配置 xorg.conf\n```sh\nsudo vim /etc/X11/xorg.conf\n# 确保 xorg 已安装\n```\n\n添加\n```sh\nSection \"Module\"\n\tLoad \"modesetting\"\nEndSection\n\nSection \"Device\"\n\tIdentifier \"nvidia'\"\n\tDriver \"nvidia\"\n\tBusID \"1:0:0\"\n\tOption \"AllowEmptyInitialConfiguration\"\nEndSection\n```\n# 必备软件\n## 输入法\n```sh\nsudo pacman -S fcitx fcitx-configtool\nsudo pacman -S fcitx-gtk2 fcitx-gtk3 fcitx-qt4 fcitx-qt5\nsudo pacman -S fcitx-sogoupinyin\n```\n\n### 配置\n```sh\nvim ~/.xprofile\n```\n添加\n```sh\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=\"@im=fcitx\"\n```\n\n桌面环境比较特殊，可能需要在 /etc/environmenet 后方也加入\n```sh\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=\"@im=fcitx\"\n```\n\n安装输入法\n```sh\nsudo pacman -S fcitx-sogoupinyin\n```\n- 可选\n1. fcitx-cloudpinyin \n2. fcitx-googlepinyin \n3. fcitx-libpinyin \n4. fcitx-sunpinyin\n5. fcitx-sogoupinyin\n\n## 字体\n```sh\nsudo pacman -S wqy-bitmapfont wqy-microhei \\\nwqy-zenhei adobe-source-code-pro-fonts \\\nadobe-source-han-sans-cn-fonts ttf-monaco\n```\n## 安装 yay 使用 aur\n```sh\nsudo pacman -S yay\n```\n- 以后可以使用 yay 安装aur中的软件了, yay 跟 pacman 使用方法一样.\n\n## 工具和常用软件\n工具\n```sh\nsudo pacman -S git net-tools tree vim\n```\n\n[微信QQ](https://vitan.me/2018/07/28/linux-WeChat-QQ/)\n\n科学上网\n```sh\nsudo pacman -S shadowsocks-qt5 proxychains-ng\n```\n- Proxychains 实现终端下任意应用代理\n\nWPS\n```sh\nsudo pacman -S ttf-wps-fonts\nsudo pacman -S wps-office\n```\n\nTelegram\n```sh\nsudo pacman -S telegram-desktop\n```\nGoogle Chrome\n```sh\nsudo pacman -S google-chrome\n```\n网易云音乐\n```sh\nsudo pacman -S netease-cloud-music\n```\n\nMailSpring\n```sh\nyay -S mailspring\nsudo pacman -S libsecret\n```\n\n迅雷\n```sh\nyay -S deepin-wine-thunderspeed\n```\n\n截图(Deppin)\n```sh\nyay -S deepin-screenshot\n```\n\nDocker\n```sh\nsudo pacman -S docker\nsudo pacman -S docker-compose\n```\n\nVisual Studio Code\n```sh\nsudo pacman -S visual-studio-code-bin\n```\n\n---\n**参考**\n- [ArchLinux安装图文教程](https://blog.csdn.net/r8l8q8/article/details/76516523)\n- [ArchLinux安装deepin桌面/常用软件流程文档](http://www.bilibili.com/read/cv123034)","tags":["Linux","ArchLinux"],"categories":["Linux"]},{"title":"删除 Linux EFI 分区","path":"/posts/删除eufi分区.html","content":"在 Win10 彻底删除 Linux  的  EFI 分区 及启动项的方法 。\n<!--more-->\n# 删除 EFI 分区\n- 使用 dispart\n1. 用管理员权限打开 cmd\n2. 输入 `diskpart`\n3. 利用 `list disk` 查询磁盘信息\n4. 这里我们 Ubuntu 装在磁盘1中，所以选择磁盘1, `select disk 1`\n5. 查看磁盘1下所有分区信息 `list partition`\n6. 根据分区大小这里选择分区6  `select partition 6`\n7. 删除 `delete partition override`\n\n# 删除 Linux 启动项\n- EFI 分区分配盘符\n1. 使用 diskpart\n2. `select disk 0` 即win10系统所在的磁盘\n3. 查看分区列表以确定具体分区 `list partition`\n3. 根据容量(这里是260MB)选择分区 `select partition 1`\n4. 为 Win10 的 EFI 分区分配盘符 `assign letter=F` 这里p为盘符，字母A~Z应该都可以(大小写无关，自动转成大写)，不要和已有的盘符重复即可。\n5. 用管理员权限打开记事本，然后通过记事本菜单栏里的`打开`来访问 F 盘，会发现P盘里有个EFI文件夹，打开直接删除ubuntu文件夹.\n6. 再回到 diskpart 删除EFI分区盘符F `remove letter=f`\n\n---\n**Via**\n- [彻底删除Ubuntu EFI分区及启动项](https://blog.csdn.net/mtllyb/article/details/78635757)","tags":["Linux","Windows","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Ubuntu 安装 shadowsocks-qt5","path":"/posts/Ubuntu18-SS-qt5.html","content":"Ubuntu 安装 shadowsocks-qt5\n<!--more-->\n# 16.04/17.04的安装\n```sh\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n```\n# 18.04的安装方法\n添加源\n```sh\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\n```\n- 作者还没有测试18.04,将源中的`bionic`改成`artful`\n\n编辑\n```sh\nsudo /etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list\n```\n\t\n```sh\nhttp://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic main # Before  \nhttp://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu artful main # After\n```\n\n安装\n```sh\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n```","tags":["Linux","Ubuntu"],"categories":["Linux"]},{"title":"Linux 常见目录","path":"/posts/LinuxDir.html","content":"Linux 常见目录\n<!--more-->\n\n|目录|解释|\n|:---|:---|\n|/|根目录|\n|/bin|命令保存目录（普通用户就可以读取的命令）|\n|/boot|启动目录，启动相关文件|\n|/dev|设备文件保存目录|\n|/etc|配置文件保存目录|\n|/home|普通用户的家目录|\n|/lib|系统库保存目录|\n|/mnt|系统挂载目录|\n|/media|挂载目录|\n|/root|超级用户的家目录|\n|/tmp|临时目录|\n|/sbin|命令保存目录(超级用户才能使用的目录)|\n|/proc|直接写入内存的|\n|/sys|将内核的一些信息映射，可供应用程序所用|\n|/usr|系统软件资源目录|\n|/usr/bin/|系统命令（普通用户）|\n|/usr/sbin/|系统命令（超级用户）|\n|/var|系统相关文档内容|\n|/var/log/|系统日志位置|\n|/var/spool/mail/|系统默认邮箱位置|\n|/var/lib/|默认安装的库文件目录|","tags":["Linux","ArchLinux","Ubuntu"],"categories":["Linux"]},{"title":"Github 隐藏的技巧","path":"/posts/GithubTips.html","content":"Github 中隐藏了很多可以提高效率的小技巧。\n<!--more-->\n# 快捷键\n## 全站中\n\n```\ns 定位到搜索框\n? 展示当前页面可用的快捷键\ng+n 查看通知\n```\n\n## 库快捷键\n```\ng+c 到代码库首页\ng+i 查看 issue\ng+p 查看 PR\ng+w 查看 Wiki\n```\n\n## 浏览代码\n```\nt 激活查找文件模式\nl 定位到行\nw 切换分支或tag\ny 将 URL 展开成正则形式\ni 显示或隐藏 diff 中的评论\n```\n## issues\n```\nc 创建一个 issue\n/ 定位到 issue 搜索框\nl 过滤或编辑标签\nm 过滤或编辑 milestone\na 过滤或编辑 assignee\nr 在回复中引用鼠标选中的文本\n```\n\n## 通知\n```\ne l y 标记为已读\nshift m 将帖子静音\n\n```\n# 仓库中\n## PR\n```\nr 在回复中引用鼠标选中的文本\no+enter 打开 issue\n```\n## Network Graph\n```\n方向键和 hjkl 与 Vim 中一样\nshift + 方向键或 hjkl 行动到头\n```\n\n# URL 后添加\n## 忽略空格: ?w=1\n在任意的 diff URL 添加`?w=1`用来整理缩进\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1ftctuu01vrj20f005kaac.jpg)\n\n## 查看某个作者的提交历史\n在 URL 中添加 `?author=username`例如：\n```bash\nhttps://github.com/rails/rails/commits/master?author=snowtraces\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1ftcu02qcwoj20cp0kota4.jpg)\n\n## 比较版本\n使用类似如下的 URL 比较分支\n```sh\nhttps://github.com/qutang/hexo-theme-cutie/compare/master...v2.1\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1ftcu7572zej20um05aq3i.jpg)\n\n- 也可以使用一下格式\n\n```bash\nhttps://github.com/rails/rails/compare/master@{1.day.ago}...master\nhttps://github.com/rails/rails/compare/master@{2014-10-04}...master\n```\n\n- 和派生仓库比较，加上派生仓库名作前缀即可\n\n```bash\nhttps://github.com/iVitan/hexo-theme-cutie/compare/master...qutang:master\n```\n\n## 高亮行\n在 URL 中加上`#L10`可以高亮第10行,或者你也可以直接点击行数。\n```sh\nhttps://github.com/iVitan/hexo-theme-cutie/blob/master/_config.yml#L10\n```\n\n- 多行高亮同样支持。你可以使用类似`#L10-L20`格式，或者在按住 shift 的同时点击\n\n```bash\nhttps://github.com/iVitan/hexo-theme-cutie/blob/master/_config.yml#L10-L20\n```\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1ftcuhwdriaj20fc08ft8x.jpg)\n\n## 合并请求的 diff 和 patch\n可以在 URL 后添加`.diff`和`.patch`以对应的模式查看合并请求\n\n# 快速引用\n## 引用评论\n- 可以选中别人的评论文字，然后按 `r`，这些内容会以引用的形式被复制在文本框中\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1ftcukae70tg20m80a7nfn.jpg)\n\n# 任务列表\n## To Do\n在工单或合并请求中，你可以使用任务列表语法：\n```bash\n- [ ] Be awesome\n- [ ] Do stuff\n- [ ] Sleep\n```\n\n- 勾选之后，会更新 Markdown\n\n```bash\n- [x] Be awesome\n- [x] Do stuff\n- [ ] Sleep\n```\n# 嵌入 GitHub\n- 网页上面嵌入你自己的GitHub仓库页面\n\n```\n<iframe src=\"https://ghbtns.com/github-btn.html?user=ivitan&amp;repo=ivitan.github.io&amp;type=watch&amp;count=true&amp;size=large\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"0\" width=\"156px\" height=\"30px\"></iframe>\n<iframe src=\"https://ghbtns.com/github-btn.html?user=ivitan&amp;repo=ivitan.github&amp;type=fork&amp;count=true&amp;size=large\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"0\" width=\"156px\" height=\"30px\"></iframe>\n```\n-  <iframe src=\"https://ghbtns.com/github-btn.html?user=ivitan&amp;repo=ivitan.github.io&amp;type=watch&amp;count=true&amp;size=large\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"0\" width=\"156px\" height=\"30px\"></iframe>\n-  <iframe src=\"https://ghbtns.com/github-btn.html?user=ivitan&amp;repo=ivitan.github.io&amp;type=fork&amp;count=true&amp;size=large\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"0\" width=\"156px\" height=\"30px\"></iframe>\n\n# 设置项目语言\nGitHub 会根据相关文件代码的数量来自动识别你这个项目，如果你需要自己指定项目语言，可以在项目的根目录下添加如下`.gitattributes`文件\n```bash\n*.html linguist-language=Python\n```\n\n---\n**参考**\n- [关于Git和Github你不知道的十件事](http://www.kuqin.com/shuoit/20151010/348440.html)\n- [少有人知的 GitHub 使用技巧](https://segmentfault.com/a/1190000000475547)\n- [GitHub 使用小技巧](https://blog.csdn.net/neilol/article/details/46568611)","tags":["Git","Github"],"categories":["Diary"]},{"title":"MySQL 基础语句","path":"/posts/MySQLbasic.html","content":"MySQL 基础语句\n<!--more-->\n# MySQL 语句的规范\n1. 关键字与函数名称全部大写\n2. 数据库名称、表名称、字段名称全部小写\n3. SQL语句必须以分号结尾\n\n# 数据类型\n数据类型是指列、存储过程参数、表达式和局部变量的数据特征,它决定了数据的存储格式,代表了不同的信息类型。\n\n## 字符型\n|列类型|存储需求|    \n|:---|:---|\n|CHAR(M)|M个字节,0<=M<=255|\n|VARCHAR(M)|L+1个字节,其中L<=M且0<=M<= 65535|\n|TINYTEXT|L+1个字节,其中L<2^8^|\n|TEXT|L+2个字节,其中L<2^16^|\n|MEDIUMTEXT|L+3个字节,其中L<2^24^|\n|LONGTEXT|L+4个字节,其中L<2^32^|\n|ENUM('value','value2',...)|1或2个字节,取决于枚举值的个数(最多65.535个值)|\n|SET('valuel','value2',...)|1、2、3、4或者8个字节,取决于set成员的数目(最多64个成员)|\n\n\n## 整型\n|数据类|型存储范围|字节|\n|:---|:---|:---|\n|TINYINT|有符号值:-128到127(-2^7^到2^7^-1)无符号值:0到255(0到2^8^ -1)|1|\n|SMALLINT|有符号值:-32768到32767(2^15^到2^15^-1)无符号值:0到65535 (0到2^16^-1)|2|\n|MEDIUMINT|有符号值:-8388608到8388607(-2^23^到2^23^-1)无符号值:0到16777215(0到2^24^-1)|3|\n|INT|有符号值:-2147483648到2147483647(-2^31^到2^31^-1)无符号值:0到4294967295(0到2^32^-1)|4|\n|BIGINT|有符号值:-9223372036854775808到9223373036854775807 (-2^63^到2^63^-1),无符号值:0到18446744073709551615(0到2^64^-1)|8|\n\n\n## 浮点型\n![Screenshot_20180712-142200.jpg](https://i.loli.net/2018/07/12/5b46f3cadd49b.jpg)\n\n## 日期时间型\n|列类型|存储需求|\n|:---|:---|\n|YEAE|1|\n|TIME|3|\n|DATE|3|\n|DATETIME|8|\n|TIMESTAMP|4|\n---\n\n# 语法\n## MySQL 登录\n```sql\nmysql -h 127.0.0.1  -u root -p\n```\n\n|参数|描述|\n|:---|:---|\n|-D,-database naime|打开指定数据库|\n|--delimiter = naime|指定分隔符|\n|-h,-host taine|服务器名称|\n|-p,--password [-name]|密码|\n|-p,--prot=#|端口号|\n|--prompt line|设置提示符|\n|-u,--user=name|用户名|\n|-V,--version|輸出版本信息并且退出|\n\n\n## 修改MySQL提示符\n1. 连接客户端时通过参数指定\n```sql\nmysql -uroot -proot --prompt 提示符\n```\n2.连接上客户端后,通过 prompt 命令修改\n```\nmysql>prompt 提示符\n```\n\n|参数|描述|\n|:---|:---|\n|\\D|完整的日期|\n|\\d|当前数据库|\n|\\h|服务器名称|\n|\\u|用户名称|\n\n\n# MySQL 常用语句\n```sql\n当前服务器版本\nSELECT VERSION();\n显示当前日期时间\nSELECT NOW();\n显示当前用户\nSELECT USER();\n```\n\n## 创建数据库\n```sql\nCREATE(DATABASE SCHEMA [IF NOT EXISTS] name\n\n[DEFAULT] CHARACTER SET [=] charset_name\n```\n\n## 查看当前服务器下的数据表列表\n```sql\nSHOW (DATABASES SCHEMAS}\n\n[LIKE 'pattern' | WHERE expr]\n```\n\n## 修改数据库\n```\nALTER {DATABASE SCHEMA} [db_name]\n\n[DEFAULT] CHARACTER SET [=] charset_name\n```\n\n## 删除数据库\n```sql\nDROP {DATABASE | SCHEMA} [IF EXISTS] db_name\n```\n\n# 表\n数据表(或称表)是数据库最重要的组成部分之一,是其他对象的基础。\n\n## 创建数据表\n```sql\nCREATE TABLE [IF NOT EXISTS] table_name(\ncolumn name data_type,\n...\n\t)\n```\n## 查看数据表列表\n```sql\nSHOW TABLES [FROM db name]\n[LIKE 'pattern' | WHERE expr]\n```\n```sql\nSHOW TABLES [FROM db name]\n```\n\n## 查看数据表结构\n```sql\nSHOW COLUMNS FROM table_name\n```\n\n## 插入记录\n```sql\nINSERT [INTO] table_name[(column_name...)] VALUES(val,...)\n```\n\n## 记录查找\n```sql\nSELECT expr,... FROM table_name\n```\n## 空值与非空\n1. NULL,字段值可以为空\n2. NOT NULL,字段值禁止为空\n\n## AUTO_INCREMENT\n自动编号,且必须与主键组合使用,默认情况下,起始值为1, 每次的增量为1.\n\n# 约束\n1. 约束保证数据的完整性和一致性。\n2. 约束分为表级约束和列级约束。\n\n## 约束类型包括:\n- NOT NULL (非空约束)\n- PRIMARY KEY (主键约束)\n- UNIQUE KEY (唯一约束)\n- DEFAULT (默认约束)\n- FOREIGN KEY (外键约束)\n\n## PRIMARY KEY 主键约束\n1. 每张数据表只能存在一个主键\n2. 主键保证记录的唯一性\n3. 主键自动为 NOT NULL\n\n## UNIQUE KEY 唯一约束\n1. 唯一约束可以保证记录的唯一性\n2. 唯一约束的字段可以为空值(NULL)\n3. 每张数据表可以存在多个唯一约束\n\n## DEFAULT 默认值\n- 当插入记录时,如果没有明确为字段赋值,则自动赋予默认值。\n```sql\nCREATE TABLE tb5{\nid SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\nusernate VARCHAR(20) NOT NUL UNIQUE KEY,\nsex ENIUM('1', '2',3') DEFAULT '3'\n```\n\n## FOREIGN KEY\n- 作用\n1. 保持数据一致性,完整性。\n2. 实现一对一或一对多关系。\n\n- 外键约束的要求\n\t1. 父表和子表必须使用相同的存储引擎,而且禁止使用临时表。\n\t2. 数据表的存储引擎只能为InnoDB。\n\t3. 外键列和参照列必须具有相似的数据类型。其中数字的长度\n\t或是否有符号位必须相同;而字符的长度则可以不同。\n\t4. 外键和参照列必须创建索引。如果外键列不存在索引的话,MySQL将自动创建索引。\n\n- 外键约束的参照操作\n\t1. CASCADE:从主表删除或更新且自动删除或更新子表中配的行\n\t2. SET NULL:从主表删除或更新行,并设置子表中的外键列为NULL。如果使用该选项,必须保证子表列没有指定NOT NULL\n\t3. RESTRICT: 拒绝对父表的删除或更新操作。\n\t4. NO ACTION:标准SQL的关键字,在MySQL中与RESTRICT相同\n\n- 表级约束与列级约束\n\t- 对一个数据列建立的约束,称为列级约束,\n\t- 对多个数据列建立的约束,称为表级约束,\n\t- 列级约束既可以在列定义时声明,也可以在列定义后声明,\n\t- 表级约束只能在列定义后声明.\n\n# 修改数据表\n## 添加列\n```sql\nALTER TABLE table_name ADD [COLUMN] colname\ncolumn_definition [FIRST | AFTER col_name]\n```\n\n## 添加多列\n```sql\nALTER TABLE table_name ADD [COLUMN]\n(col_name column_definitio,n...)\n```\n\n## 删除列\n```sql\nALTER TABLE table_name DROP [COLUMN] colname\n```\n\n## 添加主键约束\n```sql\nALTER TABLE table_name ADD [CONSTRAINT [symbol]]\nPRIMARY KEY [index_type](index_col namer...)\n```\n\n## 删除主键约束\n```sql\nALTER TABLE table_name DROP PRIMARY KEY\n```\n\n## 添加唯一约束\n```sql\nALTER TABLE table_name ADD [CONSTRAINT [symbol]]\nUNIQUE [INDEX|KEY] [index_name] [index_type]\n(index_col name,...)\n```\n\n## 删除唯一约束\n```sql\nALTER TABLE tbl_name DROP {INDEX|KEY} index_name\n```\n# 修改\n## 添加/删除默认约束\n```sql\nALTER TABLE table_name ALTER [COLUMN] column_name\n{SET DEFAULT literal | DROP DEFAULT}\n```\n\n## 删除外键约束\n```sql\nALTER TABLE table_name DROP FOREIGN KEY fk_symbol\n```\n\n## 修改列定义\n```sql\nALTER TABLE table_name MODIFY [COLUMN] col_name\ncolumn_definition [FIRST | AFTER col_name]\n```\n\n## 修改列名称\n```sql\nALTER TABLE tbl_name CHANGE [COLUMN] old_col_name\nnew col_name column_definition [FIRST | AFTER col_name]\n```\n\n## 数据表更名\n- 方法一\n```sql\nALTER TABLE table_name RENAME [TO[AS] new_tbl_name\n```\n- 方法二\n```sql\nRENAME TABLE tbl_name TO new_tbl_name\n[, tbl_name2 TO new_tb_name2]\n```\n# 基础语法\n## INSERT\n```sql\nINSERT [INTO] table_name [(column_name,...)) {VALUES | VALUE}\n({expr | DEFAULT,...),(...)....\n```\n```sql\nINSERT [INTO] table_name SET col_name={expr | DEFAULT},...\n```\n说明:与第一种方式的区别在于,此方法可以使用子查询(SubQuery)\n\n```sql\nINSERT [INTO] tbl_name [(col_name,...] SELECT...\n```\n说明:此方法可以将查询结果插入到指定数据表。\n\n## UPDATE\n- UPDATE 更新记录值(单表)\n```sql\nUPDATE [LOW_PRIORITY] [IGNORE] tabl_ reference SET\ncol_name1={expr1 | DEFAULT} [, col_name2={expr2 | DEFAULT}]...\n[WHERE where_condition]\n```\n\n##DELETE 删除记录(单表刪除)\n```sql\nDELETE FROM table_name [WHERE where_condition]\n```\n\n## SELECT\n```sql\nSELECT select_expr[,select_expr...]\n[\nFROM table_references\n[WHERE where_condition]\n[GROUP BY {col_name | position} [ASC | DESC],...]\n[HAVING where_condition]\n[ORDER BY {col_name | expr |  position) [ASC | DESC],...]\n[LIMIT {[offset,] row_count | row_count OFFSET offset}]\n]\n```\n### 以上选项含义\n- select_expr 查询表达式\n\t- 每一个表达式表示想要的一列,必须有至少一个。\n\t- 多个列之间以英文逗号分隔。\n\t- 星号(*)所有列。 table_name. *可以命名表的所有列。\n\t- 查询表达式可以使用[AS] alias_name为其赋予别名。\n\t- 别名可用于GROUP BY ORDER BY或HAVING子句。\n\n## WHERE 条件表达式\n1. 对记录进行过滤,如果没有指定WHERE子句,则显示所有记录。\n2. 在WHERE表达式中,可以使用MySQL支持的函数或运算符。\n\n## GROUP BY 查询结果分组\n```sql\n[GROUP BY {col_name position} [ASC | DESC],...]\n```\n\n## HAVING 条件分组\n```sql\n[HAVING where_condition]\n```\n\n## ORDER BY 对查询结果进行排序\n```sql\n[ORDER BY {col_name | expr | position} [ASC | DESC],..]\n```\n\n## LIMIT 限制查询结果返回的数量\n```sql\n[LIMIT {[offset,] row_count | row_count OFFSET offset}]\n```\n# 子查询\n子查询(Subquery)是指出现在其他SQL语句内的SELECT子句。\n```sql\nSELECT * FROM t1 WHERE coll = (SELECT col2 FROM t2);\n其中SELECT FROM t1,称为Outer Query/Inner Statement\nSELECT col2 FROM t2 ,称为SubQuery\n```\n\n- 子查询指嵌套在查询内部,且必须始终出现在圆括号内。\n- 子查询可以包含多个关键字或条件,\n\t* 如DISTINCT、GROUP BY、ORDER BY, LIMIT函数等。\n- 子查询的外层查询可以是:SELECT INSERT, UPDATE.SET或DO。\n\n\t1. 子查询返回值\n- 子查询可以返回标量、一行、一列或子查询。\n\t1. 使用比较运算符的子查询\n- 使用比较运算符的子查询\n\t* =, >, < >, <= <>. !>, <=>\n- 语法结构\n\t* operand comparison operator subquery\n\n# 用 ANY,SOME  或 ALL 修饰的比较运算符\n```sql\noperand comparison operator ANY (subquery)\noperand comparison operator SUM (subquery)\noperand comparison operator ALL (subquery)\n```\n- ANY、SOME、ALL关键字\n\n|运算符|ANY|SOME|ALL|\n|:---|:---|:---|:---|\n|>,>=|最小值|最小值|最大值|\n|<,<=|最大值|最大值|最小值|\n|=|任意值|任意值||\n|<>,!=|||任意值|","tags":["MySQL","SQL"],"categories":["Database"]},{"title":"Git 常用命令","path":"/posts/Git-common-command.html","content":"Git 常用命令\n<!--more-->\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/GitCmd.jpg)\n\n# 配置\n- 基础配置\n\n```sh\ngit config --global user.name \"Vitan\"\ngit config --global user.email \"ivitan95@gmail.com\"\nssh-keygen -t rsa -C \"ivitan95@gmail.com\"\ngit config --global color.ui true\ngit config --global alias.co checkout #别名\ngit config --global alias.ci commit\ngit config --global alias.st status\ngit config --global alias.br branch\ngit config --global core.editor \"vim\"\n# 设置Editor使用vim\ngit config --global core.quotepath false\n# 设置显示中文文件名\n```\n# 常用命令\n查看、添加、提交、删除、找回，重置修改文件\n```sh\ngit co  -- <file>\n# 抛弃工作区修改\ngit co  .\n# 抛弃工作区修改\n\ngit add <file>\n# 将工作文件修改提交到本地暂存区\ngit add .\n# 将所有修改过的工作文件提交暂存区\n\ngit rm <file>\n# 从版本库中删除文件\ngit rm <file> --cached\n# 从版本库中删除文件，但不删除文件\n\ngit reset <file>\n# 从暂存区恢复到工作文件\ngit reset -- .\n# 从暂存区恢复到工作文件\ngit reset --hard\n# 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改\n\ngit ci <file>\ngit ci .\ngit ci -a\n# 将git add, git rm和git ci等操作都合并在一起做\ngit ci -am \"some comments\"\ngit ci --amend\n# 修改最后一次提交记录\n\ngit revert <$id>\n# 恢复某次提交的状态，恢复动作本身也创建了一次提交对象\ngit revert HEAD\n# 恢复最后一次提交的状态\n```\n\n查看文件 diff\n```sh\ngit diff <file>\n# 比较当前文件和暂存区文件差异\ngit diff\ngit diff <$id1> <$id2>\n# 比较两次提交之间的差异\ngit diff <branch1>..<branch2>\n# 在两个分支之间比较\ngit diff --staged\n# 比较暂存区和版本库差异\ngit diff --cached\n# 比较暂存区和版本库差异\ngit diff --stat\n# 仅仅比较统计信息\n```\n\n查看提交记录\n```sh\ngit log\ngit log <file>\n# 查看该文件每次提交记录\ngit log -p <file>\n# 查看每次详细修改内容的diff\ngit log -p -2\n# 查看最近两次详细\n```\n\t- Mac 上可以使用 tig 代替 diff 和 log，brew install tig\n\n# 分支管理\n## 本地分支管理\n查看、切换、创建和删除分支\n```sh\ngit br -r\n# 查看远程分支\ngit br <new_branch>\n# 创建新的分支\ngit br -v\n# 查看各个分支最后提交信息\ngit br --merged\n# 查看已经被合并到当前分支的分支\ngit br --no-merged\n# 查看尚未被合并到当前分支的分支\n\ngit co <branch>\n# 切换到某个分支\ngit co -b <new_branch>\n# 创建新的分支，并且切换过去\ngit co -b <new_branch> <branch>\n# 基于branch创建新的new_branch\n\ngit co $id\n# 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除\ngit co $id -b <new_branch>\n# 把某次历史提交记录checkout出来，创建成一个分支\n\ngit br -d <branch>\n# 删除某个分支\ngit br -D <branch>\n# 强制删除某个分支 (未被合并的分支被删除的时候需要强制)\n```\n\n分支合并和 rebase\n```sh\ngit merge <branch>\n# 将branch分支合并到当前分支\ngit merge origin/master --no-ff\n# 不要Fast-Foward合并，这样可以生成merge提交\n\ngit rebase master <branch>\n# 将master rebase到branch，相当于：\n\ngit co <branch> && git rebase master && git co master && git merge <branch>\n```\n\n补丁管理 (方便在多台机器上开发同步时用)\n```\ngit diff > ../sync.patch # 生成补丁\ngit apply ../sync.patch # 打补丁\ngit apply --check ../sync.patch # 测试补丁能否成功\n```\n\n暂存管理\n```\ngit stash # 暂存\ngit stash list # 列所有stash\ngit stash apply # 恢复暂存的内容\ngit stash drop  # 删除暂存区\ngit stash clear\n```\n\n## 远程分支管理\n基础命令\n```sh\ngit pull\n# 抓取远程仓库所有分支更新并合并到本地\ngit pull --no-ff\n# 抓取远程仓库所有分支更新并合并到本地，不要快进合并\ngit fetch origin\n# 抓取远程仓库更新\ngit merge origin/master\n# 将远程主分支合并到本地当前分支\ngit co --track origin/branch\n# 跟踪某个远程分支创建相应的本地分支\ngit co -b <local_branch> origin/<remote_branch>\n# 基于远程分支创建本地分支，功能同上\n\ngit push\n# push所有分支\ngit push origin master\n# 将本地主分支推到远程主分支\ngit push -u origin master\n# 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)\ngit push origin <local_branch>\n# 创建远程分支， origin是远程仓库名\ngit push origin <local_branch>:<remote_branch>\n# 创建远程分支\ngit push origin :<remote_branch>\n#先删除本地分支(git br -d <branch>)，然后再push删除远程分支\n```\n\n远程仓库管理\n```sh\ngit remote -v\n# 查看远程服务器地址和仓库名称\ngit remote show origin\n# 查看远程服务器仓库状态\ngit remote add origin git@github:stormzhang/demo.git\n# 添加远程仓库地址\ngit remote set-url origin git@github.com:stormzhang/demo.git\n# 设置远程仓库地址(用于修改远程仓库地址\n```\n\n创建远程仓库\n```sh\ngit clone --bare robbin_site robbin_site.git\n# 用带版本的项目创建纯版本仓库\nscp -r my_project.git git@git.csdn.net:~\n# 将纯仓库上传到服务器上\n\nmkdir robbin_site.git && cd robbin_site.git && git --bare init\n# 在服务器创建纯仓库\ngit remote add origin git@github.com:robbin/robbin_site.git\n# 设置远程仓库地址\ngit push -u origin master\n# 客户端首次提交\ngit push -u origin develop\n# 首次将本地develop分支提交到远程develop分支，并且track\n\ngit remote set-head origin master\n# 设置远程仓库的HEAD指向master分支\n```\n\n- 也可以命令设置跟踪远程库和本地库\n\n```sh\ngit branch --set-upstream master origin/master\ngit branch --set-upstream develop origin/develop\n```\n---\n**Via**\n- [stormzhang](http://stormzhang.com/git/2014/01/27/git-common-command/)","tags":["Git","Github"],"categories":["Diary"]},{"title":"Hexo Cutie 主题 Markdown 语法","path":"/posts/post-typography-and-tags-test.html","content":"Hexo Cutie 主题 Markdown 语法# 安装文章使用 `hexo-renderer-markdown-it`作为渲染器,因此需要安装此渲染器以达到效果。```bash installationnpm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm i markdown-it-emoji --savenpm i markdown-it-mark --savenpm i markdown-it-deflist --savenpm i markdown-it-container --save```# 配置添加以下内容到站点的`_config.yml`.```yml _config.ymlmarkdown: render: html: true xhtmlOut: false breaks: false linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-deflist anchors: level: 2 collisionSuffix: 'v' permalink: false permalinkClass: header-anchor permalinkSymbol: \" \" permalinkBefore: false```# 使用---标题```markdown source code# h1 Heading 8-)h2 Headingh3 Headingh4 Headingh5 Headingh6 Heading```# h1 Heading 8-)h2 Headingh3 Headingh4 Headingh5 Headingh6 Heading水平分割线```markdown source code___---***```___---***排版替换```markdown source code(c) (C) (r) (R) (tm) (TM) (p) (P) +-test.. test... test..... test?..... test!....!!!!!! ???? ,,  -- ---\"Smartypants, double quotes\" and 'single quotes'```(c) (C) (r) (R) (tm) (TM) (p) (P) +-test.. test... test..... test?..... test!....!!!!!! ???? ,,  -- ---\"Smartypants, double quotes\" and 'single quotes'着重```markdown source code**This is bold text**__This is bold text__*This is italic text*_This is italic text_~~Strikethrough~~```**This is bold text**__This is bold text__*This is italic text*_This is italic text_~~Strikethrough~~引用```markdown source code> Blockquotes can also be nested...>> ...by using additional greater-than signs right next to each other...> > > ...or with spaces between arrows.```> Blockquotes can also be nested...>> ...by using additional greater-than signs right next to each other...> > > ...or with spaces between arrows.清单无序```markdown source code+ Create a list by starting a line with `+`, `-`, or `*`+ Sub-lists are made by indenting 2 spaces: - Marker character change forces new list start: * Ac tristique libero volutpat at + Facilisis in pretium nisl aliquet - Nulla volutpat aliquam velit+ Very easy!```+ Create a list by starting a line with `+`, `-`, or `*`+ Sub-lists are made by indenting 2 spaces: - Marker character change forces new list start: * Ac tristique libero volutpat at + Facilisis in pretium nisl aliquet - Nulla volutpat aliquam velit+ Very easy!有序```markdown source code1. Lorem ipsum dolor sit amet 1. Indented list 1. Another level 2. Indent2. Consectetur adipiscing elit3. Integer molestie lorem at massa```1. Lorem ipsum dolor sit amet 1. Indented list 1. Another level 2. Indent2. Consectetur adipiscing elit3. Integer molestie lorem at massa```markdown source code1. You can use sequential numbers...1. ...or keep all the numbers as `1.````1. You can use sequential numbers...1. ...or keep all the numbers as `1.`用偏移符号编号```markdown source code57. foo1. bar```57. foo1. bar代码```markdown source codeInline `code````Inline `code`代码缩进```markdown source code// Some comments line 1 of code line 2 of code line 3 of code``` // Some comments line 1 of code line 2 of code line 3 of code代码区块~~~markdown source code```Sample text here...```~~~```Sample text here...```语法高亮显示~~~markdown source code``` js sample.jsvar foo = function (bar) { return bar++;};console.log(foo(5));```~~~``` js sample.jsvar foo = function (bar) { return bar++;};console.log(foo(5));```表格```markdown source code Option  Description Description  Description  Description  Description  ------  ----------- -----------  -----------  -----------  -----------  data  path to data files to supply the data that will be passed into templates.  engine  engine to be used for processing templates. Handlebars is the default.  ext  extension to be used for dest files. ``` Option  Description  Description  Description  Description  Description  ------  -----------  -----------  -----------  -----------  -----------  data  path to data files to supply the data that will be passed into templates.  engine  engine to be used for processing templates. Handlebars is the default.  ext  extension to be used for dest files. 列右对齐``` markdown source code Option  Description  ------: -----------: data  path to data files to supply the data that will be passed into templates.  engine  engine to be used for processing templates. Handlebars is the default.  ext  extension to be used for dest files. ``` Option  Description  ------: -----------: data  path to data files to supply the data that will be passed into templates.  engine  engine to be used for processing templates. Handlebars is the default.  ext  extension to be used for dest files. 链接```markdown source codelink text```link text```markdown source codelink with title```link with title```markdown source codeAutoconverted link https://github.com/nodeca/pica (enabled linkify)```Autoconverted link https://github.com/nodeca/pica (enabled linkify)图片```markdown source code```与链接一样，图片也有脚注样式语法```markdown source code![Alt text][id]在文档的后面定义 URL 的位置[id]: https://octodex.github.com/images/dojocat.jpg  \"The Dojocat\"```![Alt text][id]在文档的后面定义 URL 的位置[id]: https://octodex.github.com/images/dojocat.jpg  \"The Dojocat\"插件`markdown-it` 渲染器完美支持syntax plugins。例如 configuration snippetEmojies```markdown source codeClassic markup: :wink: :crush: :cry: :tear: :laughing: :yum:Shortcuts (emoticons): :-) :-( 8-) ;)```Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:Shortcuts (emoticons): :-) :-( 8-) ;)上标 / 下标```markdown source codeSuperscript: 19^th^Subscript: H~2~O```Superscript: 19^th^Subscript: H~2~O\\<ins>```markdown source code++Inserted text++```++Inserted text++\\<mark>```markdown source code==Marked text==```==Marked text==脚注```markdown source codeFootnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup** and multiple paragraphs.[^second]: Footnote text.```Footnote 1 link[^first].Footnote 2 link[^second].Inline footnote^[Text of inline footnote] definition.Duplicated footnote reference[^second].[^first]: Footnote **can have markup** and multiple paragraphs.[^second]: Footnote text.定义列表```markdown source codeTerm 1: 定义 1带有延迟继续。.```Term 1: 定义 1带有延迟继续。```markdown source code第 2 项带有 * 内联标记 *: 定义 2 { some code, part of Definition 2 } Third paragraph of definition 2.```Term 2 with *inline markup*: Definition 2 { some code, part of Definition 2 } Third paragraph of definition 2._Compact style:_```markdown source codeTerm 1 ~ Definition 1Term 2 ~ Definition 2a ~ Definition 2b```Term 1 ~ Definition 1Term 2 ~ Definition 2a ~ Definition 2b缩略形式 / 缩写```markdown source code这是 HTML 缩写的例子。它转换成 “HTML”，但保留“xxxHTMLyy” 等完整的部分条目。*[HTML]：超文本标记语言```这是 HTML 缩写的例子。它转换成 “HTML”，但保留“xxxHTMLyy” 等完整的部分条目*[HTML]: Hyper Text Markup LanguageCustom containers::: warning*here be dragons*:::Hexo 内置标签引用，带作者名字```swig source codeDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.```Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.引用 Twitter```swig source codeNEW: DevDocs now comes with syntax highlighting. http://devdocs.io```NEW: DevDocs now comes with syntax highlighting. http://devdocs.io引用网络链接```swig source codeEvery interaction is both precious and an opportunity to delight.```Every interaction is both precious and an opportunity to delight.抽取引用```swig source codecontent```contentjsFiddle```swig source code```Gist```swig source code```iFrame```swig source code```新标签页打开链接```swig source code```Youtube```swig source code```---# 原文链接- Hexo Theme Cutie v2.0.12 Typography Demo","tags":["Hexo","Typography","Markdown"],"categories":["Diary"]},{"title":"Hexo 域名","path":"/posts/Hexo-Domain.html","content":"Hexo 独立域名\n<!-- more -->\n\n# 购买域名\n比较服务商可以到 [Nazhumi](https://www.nazhumi.com/) 查看比较。\n\n# 解析域名\n\n- 添加 A 记录\n\n```bash\nA @ 185.199.108.153\nA @ 185.199.109.153\nA @ 185.199.110.153\nA @ 185.199.111.153\n```\n\n- 添加 CNAME 记录\n\n```bash\nCNAME www ivitan.github.io\n```\n\n# 本地配置\n新建 CNAME 文件\n```bash\ncd blog\necho \"vitan.me\" > CNAME\n``` \n\n# Github 配置\n仓库设置\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20190808222520.png)\n\n---\n**参考**\n- [Hexo](https://hexo.io/zh-cn/docs/deployment#Netlify)","tags":["Linux","Windows","Hexo"],"categories":["Diary"]},{"title":"SQL 模式分解","path":"/posts/SQLmode.html","content":"# 关系模式\n关系模式R(U)的一个分解p={Ri(Ui)}满足U=∪{Ui}，模式分解必须是无损连接并且需要保持函数依赖\n\n<!--more-->\n无损连接\n\n`无损连接是指`某关系模式的事例r按照关系模式分解成多个关系r1,…,rk，若r1,…,rk的自然连接（Join操作）等于r，则称该模式分解是无损的.\n\n测试无损连接\n\nChase方法能够检测完全的无损连接，设有n个属性的模式R分解为k个模式Ri，有如下Chase过程：\n\n\t1. 构造一个k行n列的表格，每行对应一个模式Ri，每列对应一个属性Aj，若Aj在模式Ri中则表格[i][j]中填入aj，否则填入bij\n\t2. 扫描F中的每个FD X→Y\n\t3. 若表格中有两行在X分量上相等，在Y分量上不相等则修改Y：若Y的分量中是个是aj，则另一个也修改为aj\n\t4. 如果没有aj，则用其中一个bij替换另一个符号（i是所有b中最小的行数）\n\t5. 重复2、3、4一直到表格不能修改为止\n\t6. 若此时表格中有一行全是a，则该分解是无损连接的分解\n\n当模式分解是简单的二元分解时（即p={R1,R2}），p是无损连接的分解当且仅当下面FD之一成立：\n\n\t1. R1和R2两模式属性的交集 → R1与R2两模式属性的差集\n\t2. R1和R2两模式属性的交集 → R2与R1两模式属性的差集\n\n保持函数依赖\n\t\n保持函数依赖是指关系模式R的FD集F在分解后仍在数据库模式中保持不变，这是模式分解的第二个条件\n\n形式化的定义分解后F在模式Ri上的投影为：\n\nπRi(F)={X→Y|X→Y∈F+⋂X、Y⊂Ri}\n\n若分解p满足如下条件则称p**\\保持函数依赖**\\：\n\n![Screenshot_20180703-214805__01.jpg](https://i.loli.net/2018/07/03/5b3b7eba9112d.jpg)\n\n# 关系模式的范式\n含义\n范式xNF即是满足特定要求的模式，将低一级范式的关系模式通过模式分解转换为高一级范式的关系模式集合的过程叫做规范化\n\n范式从低级到高级依次为：1NF、2NF、3NF、BCNF、4NF、5NF，高一级的范式总是低一级范式的真子集\n\n根据关系模式R的不可约FD集F，可以画出节点是属性或属性集，边是由被依赖节点指向依赖节点的有向图来辅助分析关系模式，叫做函数依赖图\n\n1NF\n\n1NF要求关系模式R的每一个实例r均满足：r中的每一个元组t的每一个属性中只有一个值，这是关系模式的基本要求\n\n不满足1NF的关系模式有二义性！\n\n2NF\n\n假定：R只有一个候选码，且该候选码为主码\n\nR∈1NF且R的每一个非主属性（非候选码的其他属性）都完全函数依赖于主码时，R∈2NF\n\nA完全依赖于W是指：W→A且A不依赖于任何一个W的真子集X，W是主键也可能包括多个属性{X、Y}，非主属性A不能局部函数依赖于X或Y\n\n不满足2NF的关系模式可能存在［插入异常、删除异常、更新异常和数据冗余］，通过画出函数依赖图无损分解非2NF得到2NF，但2NF也不能完全消除上述问题\n\n3NF\n\n假定：R只有一个候选码，且该候选码为主码\n\nR∈2NF且R的每一个非主属性都不传递依赖于主码时，R∈3NF\n称A传递依赖于Y则有：Y→X，X→A，并且Y不依赖于X（即Y不等于X）、A不是X的子集\n\n不满足3NF的关系模式也可能存在［插入异常、删除异常、更新异常和数据冗余］，通过打破传递依赖链条，把关系模式分解成多个子关系模式\n\nBCNF\n\nBCNF是3NF处理R有多个候选码的扩展，当R有多个候选码时即使R∈3NF，也可能出现［插入异常、删除异常、更新异常和数据冗余］，这时需要分解为BCNF范式\n\n如果关系模式R的所有不平凡的、完全的函数依赖的决定因素（左边的属性集）都是候选码，则R∈BCNF\n若要求保持函数依赖和无损联接，则总可以达到3NF，但不一定满足BCNF；因为BCNF可以达到无损连接，但不一定保持函数依赖\n\n# 关系模式分解为范式的分解算法\n## 保持函数依赖地分解R到3NF\n算法步骤：\n求出R的最小函数依赖集F\n\t\n把所有不在F中出现的属性组成一个关系模式R’，并在U中去掉这些属性\n\t\n若F中存在X→A且XA=U，则算法结束输出{R’,R(U)}，否则继续下一步\n\n对F中的FD按相同的左部分组构成一个关系模式Ri(Ui)，Ui包括了该组FD涉及的所有属性\n\t\n去掉{Ri(Ui)}中属性集Ui是其他某个关系模式属性集Uj子集的关系模式Ri，得到最终的分解p={R1,R2,…,Rk,R’}，p能够保持函数依赖地把R分解到3NF\n\n## 无损连接且保持函数依赖地分解R到3NF\n算法步骤：\n1. 按算法(1)中步骤求出保持函数依赖的3NF分解，设q={R1,R2,…,Rk}\n2. 设X是R的主码，p={R1,R2,…,Rk,R(X)}\n3. 若X是q中某个Ri(Ui)属性集Ui的子集，则删除p中的R(X)\n4. 输出p，p能够无损连接且保持函数依赖地把R分解到3NF\n\n## 无损联接地分解R到BCNF\n算法步骤：\n1. p={R}\n2. 检查p中各关系模式是否满足BCNF，是则终止输出p\n3. 设p中S(Us)非BCNF，则必存在X→A且X不是S的候选码：S分解为S1(XA)和S2(Us-A)，把p中的S替换为S1、S2，跳转至第二步\n\n**参考**\n\n[数据库复习11——关系模式与范式](https://blog.csdn.net/u014030117/article/details/46697823)","tags":["SQL"],"categories":["Database"]},{"title":"SQL 关系代数表达式","path":"/posts/SQLrelAlg.html","content":"关系代数是关系数据库系统查询语言的理论基础。很有必要学习一下，有些是用代数表达式很方便的东西，用SQL写出来还是挺麻烦的，并不是想象当中那么直接。\n<!--more-->\n# 一、关系代数的9种操作\n 关系代数中包括了：并、交、差、乘、选择、投影、联接、除、自然联接等操作。\n\n五个基本操作\n并(∪)、差(-)、笛卡尔积(×)、选择(σ)、投影(π)\n\n四个组合操作\n1. 交(∩) \t2. 联接(等值联接) \t3. 自然联接(R⋈S) \t4. 除法(÷)\n\n注2：等值连接表示先做笛卡尔积(×)之后，对相应列进行选择或等值关联后的结果(仅筛选行、不筛选列)\n\n注2：自然连接表示两个关系中若有相同名称的属性，则自动作为关联条件，且仅列出一列\n\n补充各种符号\n1. 投影 π\n2. 选择 σ\n3. 重命名 ρ\n4. 自然连接 ⋈\n5. θ-连接和相等连接 \n6. 半连接 ⋉ , ⋊\n7. 反连接 ▷\n8. 除法 ÷\n9. 左外连接 ⟕\n10. 右外连接 ⟖\n11. 全外连接 ⟗\n\n# 二、关系代数表达式\n\n由关系代数运算经有限次复合而成的式子称为关系代数表达式。这种表达式的运算结果仍然是一个关系。可以用关系代数表达式表示对数据库的查询和更新操作。\n\n# 三、举例说明\n\n设教学数据库中有3个关系：\n\n学生关系S(SNO,SNAME,AGE,SEX)\n\n学习关系SC(SNO,CNO,GRADE)\n\n课程关系C(CNO,CNAME,TEACHER)\n\n1. 检索学习课程号为C2的学生学号与成绩\n```sql\nSELECT SNO,GRADE\n  FROM SC\nWHERE CNO='C2'\n```\n```\nπ SNO,GRADE(σCNO='C2'(SC))\n```\n2. 检索学习课程号为C2的学生学号与姓名\n```sql\nSELECT SC.SNO,S.SNAME\nFROM SC,S\nWHERE SC.SNO=S.SNO\nAND SC.CNO='C2'\n```\n```\nπ SNO,SNAME(σCNO='C2'(S⋈SC))\n此查询涉及S和SC，先进行自然连接，然后再执行选择投影操作。\n```\n```\nπ SNO,SNAME（S）cross（πSNO(σCNO='C2'(SC))）\n自然连接的右分量为\"学了C2课的学生学号的集合\"。\n此表达式比前一个表达式优化，执行起来要省时间、省空间。\n```\n3. 检索选修课程名为MATHS的学生学号与姓名\n```sql\nSELECT SC.SNO,S.SNAME\nFROM SC,S,C\nWHERE SC.SNO=S.SNO\nAND SC.CNO=C.CNO\nAND C.CNAME='MATHS'\n```\n```\nπ SNO,SANME(σCNAME='MATHS'(S⋈SC⋈C))\n```\n4. 检索选修课程号为C2或C4的学生学号\n```sql\nSELECT SNO\nFROM SC\nWHERE CNO='C2'\nOR CNO='C4'\n```\n```\nπ SNO(σ CNO='C2'∨CNO='C4'(SC))\n```\n5. 检索至少选修课程号为C2或C4的学生学号\n```sql\nSELECT SA.SNO\nFROM SC AS SA,SC AS SB\nWHERE SA.SNO=SB.SNO\nAND SA.CNO='C2'\nAND SB.CNO='C4'\n```\n```\nπ 1(σ1=4∧2='C2'∧5='C4'（SC×SC）)\n```\n6. 检索不学C2课的学生姓名与年龄\n```sql\nSELECT SNAME,AGE\nFROM S\nMINUS\nSELECT S.SNAME,S.AGE\nFROM SC,S\nWHERE SC.SNO=S.SNO\nAND SC.CNO='C2'\n```\n```\nπ SNAME,AGE（S）－πSNAME,AGE(σCNO='C2'（S⋈SC）)\n```\n7. 检索学习全部课程的学生姓名\n```\nπ SNO,CNO(SC)÷πCNO(C)\n先用除法取出选取所有课程的SNO集(除法可以理解为一个Filter)\nπ SNAME(S ⋈ (πSNO,CNO(SC)÷πCNO(C)))\n再关联S表取出SNAME\n```\n8. 检索所学课程包含S3所学课程的学生学号\n```\nπ SNO,CNO(SC)÷ πCNO(σSNO='S3'(SC)）\n同样运用了除法的特性\n```\n\n\n9. 将新课程元组('C10','PHYSICS','YU')插入到关系C中\n```sql\nINSERT INTO C VALUES('C10','PHYSICS','YU')\n```\n```\n(C∪('C10','PHYSICS','YU'))\n记住该符号的用法\n```\n10. 将学号S4选修课程号为C4的成绩改为85分\n```sql\nUPDATE SC SET GRADE=85\nWHERE SNO='S4'\nAND CNO='C4'\n```\n```\n（SC－（'S4','C4',?)∪('S4','C4',85)）\n先用'－'实现DELETE功能，再用'∪'实现INSERT功能\n注意使用?来表示检索时忽略该字段值\n```\n# 四、关系代数表达式的优化\n目的：\n为了系统在执行时既省时间又能提高效率。\n\n基本策略：\n先做选择，运用投影去除多余属性等等。\n\n优化算法：\n语法树(尽量提前做选择操作；在每个操作后，应做个投影操作，去掉不用的属性值)\n\n例如：\n1. π SNO,SNAME(σGRADE>60(S⋈SC)) 进行优化后转换为：2. π SNO,SNAME(πSNO,SNAME(S)⋈πSNO(σGRADE>60(SC)))\n--即提前做选择操作；在每个操作后，应做个投影操作，去掉不用的属性值\n\n又如：\n1. S(S#,SNAME,AGE,SEX)\n2. SC(S#,C#,GRADE)\n3. C(C#,CNAME,TEACHER)\n\nπ CNAME,TEACHER(σSEX='女'(S⋈SC⋈C)) 进行优化后转换为：\n\nπCNAME,TEACHER(C⋈πC#(πS#,C#(SC)⋈S#(σSEX='女'(S))))\n\n优化前和优化后的语法树如下所示：\n\n![syntax_tree_thumb.jpg](https://i.loli.net/2018/06/30/5b379215e6b8c.jpg)\n\n# 转载注明\n[数据库关系代数表达式学习](http://www.blogjava.net/decode360/archive/2009/04/15/292362.html)","tags":["SQL"],"categories":["Database"]},{"title":"SQL 补充练习题","path":"/posts/SQLexercise.html","content":"数据库单表查询\n\n<!--more-->\n\n# 一、实验目的\n\n1. 掌握SELECT语句的基本语法和查询条件表示方法；\n\n2. 掌握查询条件表达式和使用方法；\n\n3. 掌握GROUP BY 子句的作用和使用方法；\n\n4. 掌握HAVING子句的作用和使用方法；\n\n5. 掌握ORDER BY子句的作用和使用方法。\n\n# 二、实验环境\n\n已安装SQL Server 2005 企业版的计算机(13台)；\n\n具有局域网环境,有固定IP;\n\n# 三、实验学时\n\n2学时\n\n# 四、实验要求\n\n1. 了解数据库查询；\n\n2. 了解数据库查询的实现方式；\n\n3. 完成实验报告；\n\n# 五、实验内容及步骤\n\n以数据库原理实验6数据库中数据为基础，请使用T-SQL 语句实现以下操作：\n\n1. 列出所有不姓刘的所有学生；（not like）\n```sql\nselect *\nfrom s\nwhere 姓名 not like '刘%'\n```\n2. 列出姓“张”且全名为3个汉字的学生；(张__下滑线表示任意一个字符)\n```sql\nselect *\nfrom s\nwhere 姓名 like '张__'\n```\n3. 显示在2000年以后出生的学生的基本信息；\n```sql\nselect *\nfrom s\nwhere 年龄<=(2018-2000)\n```\n\n4. 查询出课程名含有“数据”字串的所有课程基本信息\n```sql\nselect *\nfrom c\nwhere 课程名 like '数据%'\n```\n\n5. 列出选修了‘101’课程的学生，按成绩的降序排列；\n```sql\nselect *\nfrom sc\nwhere 课程号='101'\norder by 成绩 desc\n```\n6. 列出课程表中全部信息，按先修课的升序排列；\n\n\n7. 按照出生年份升序显示所有学生的学号、姓名、性别、出生年份及所在系，在结果集中列标题分别指定为“学号，姓名，性别，出生年份，所在系”；\n```sql\nselect 学号,姓名,性别,(2018-年龄) as 出生年份,所在系\nfrom s\norder by 出生年份 asc\n```\n8. 按照院系降序显示所有学生的 “所在系，学号、姓名、性别、年龄”等信息，其中所在系按照以下规定显示：院系为CS显示为计算机系，院系为IS显示为信息系，院系为MA显示为数学系，院系为JZ显示为建筑系，其他显示为院系不明；参考例句\n```sql\nselect  姓名,所在系,学号,院系英文书写=case\nwhen 所在系='计算机系' then 'CS'\nwhen 所在系='信息系' then 'IS'\nwhen 所在系='艺术系' then 'AS'\nwhen 所在系='会计系' then 'KS'\nend\nfrom s\norder by 院系英文书写 DESC\n```\n\n显示所有院系（要求不能重复，不包括空值），并在结果集中增加一列字段“院系规模”，其中若该院系人数>=5则该字段值为“规模很大”，若该院系人数大于等于4小于5则该字段值为“规模一般”， 若该院系人数大于等于2小于4则该字段值为“规模稍小”，否则显示“规模很小”；（参考例句，同学们，适当增加、删除记录，观察结果）\n```sql\nselect 所在系,COUNT(学号) 人数,院系规模=case\nwhen COUNT(学号)>=7 then '大规模'\nwhen COUNT(学号)>=5 and  COUNT(学号)<7  then '中等'\nwhen COUNT(学号)<5 then '小规模'\nend\nfrom s\ngroup by 所在系\n```\n\n9. 按照课程号、成绩降序显示课程成绩在70-80之间的学生的学号、课程号及成绩；\n\n10. 显示学生信息表中的学生总人数及平均年龄，在结果集中列标题分别指定为“学生总人数，平均年龄”；\n\n11. 显示选修的课程数大于3的各个学生的选修课程数；\n\n12. 按课程号降序显示选修各个课程的总人数、最高成绩、最低成绩及平均成绩；\n\n13. 显示各个所在系男女生人数，其中在结果集中列标题分别指定为“所在系名称、男生人数、女生人数”；\n\n14. 列出有二门以上课程（含两门）不及格的学生的学号及该学生的平均成绩；\n\n\n\n# 六、出现问题及解决办法\n\n如：某些查询操作无法执行，如何解决？","tags":["SQL"],"categories":["Database"]},{"title":"Termux 高级终端使用配置","path":"/posts/Termux.html","content":"> [Termux](https://wiki.termux.com/wiki/Main_Page) 是一个 Android 下一个高级的终端模拟器, 开源且不需要 root, 支持 apt 管理软件包，十分方便安装软件包, 完美支持 Python PHP Ruby Go Nodejs MySQL 等。\n\n# 一键部署脚本\n```sh\nbash -c \"$(curl -fsSL https://raw.githubusercontent.com/ivitan/Shell/master/Termux/Termux.sh)\"\n```\n<!--more-->\n\n# 命令\n## 基本命令\n\n```sh\npkg search <query>  #搜索包\npkg install <package> #安装包\npkg uninstall <package> #卸载包\npkg reinstall <package> #重新安装包\npkg update  #更新源\npkg upgrade #升级软件包\npkg list-all #列出可供安装的所有包\npkg list-installed  #列出已经安装的包\npkg shoe <package>  #显示某个包的详细信息\npkg files <package>  #显示某个包的\n```\n\n## 安装 *.deb 文件\n\n```sh\ndpkg -i ./package.deb #安装\ndpkg --remove [package name] #卸载\ndpkg --remove [package name] #列出所有已安装的包\n```\n\n# 换源\n## 清华源\n\n```sh\nsed -i 's@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux stable main@' $PREFIX/etc/apt/sources.list\napt update && apt upgrade -y\n```\n\nhttps://mirrors.tuna.tsinghua.edu.cn/termux 代替原文中的 https://termux.net 保存退出\n```sh\nexport EDITOR=vim # 设置默认编辑器\napt edit-sources\n```\n \n## 官方其他源\n```sh\npkg install root-repo\npkg install x11-repo\npkg install unstable-repo\n```\n\n## [its-pointless](https://github.com/its-pointless/its-pointless.github.io)\n```sh\npkg install wget\n$PREFIX/bin/wget https://its-pointless.github.io/setup-pointless-repo.sh\nbash setup-pointless-repo.sh\n```\n- 库包括 gcc-7,gfortran，octave，r-cran（R语言），rustc，scipy 和许多游戏.\n\n## [Extra](https://github.com/thioshp/termux-extra-packages)\n```sh\n# 将PGP密钥添加到APT的密钥环中\npkg install dirmngr\napt-key adv --keyserver pool.sks-keyservers.net --recv 9D6D488416B493F0\n```\n### 手动下载公钥并添加它\n```sh\ncurl -LO https://raw.githubusercontent.com/xeffyr/termux-extra-packages/master/pubkey.asc\napt-key add pubkey.asc\n```\n- `apt edit-sources` 加入下方内容\n\n```sh\n# Xeffyr's Extra packages\ndeb https://termux.xeffyr.ml/ extra main x11\n```\n- 库有　OpenJDK\n\n# 修改启动问候语\n## 修改\n```sh\nvim $PREFIX/etc/motd\n```\n\t\n## 不显示\n```sh\ntouch ~/.hushlogin\n```\n\n# 恢复双层键盘\nTermux在 0.66 取消了双层键盘\n\n```sh\nmkdir $HOME/.termux\necho \"extra-keys = [['ESC','/','-','HOME','UP','END','PGUP'],['TAB','CTRL','ALT','LEFT','DOWN','RIGHT','PGDN']]\" >> $HOME/.termux/termux.properties\n```\n\n# 管理员权限 root 问题\n## 虚拟管理员(未root)\n\n```sh\npkg install proot\ntermux-chroot # 启动命令\n```\n- 模拟root环境的同时，还会模拟linux的文件路径。\n- 普通文件路径是【/data/data/com.termux/file/home】\n- 开启后的文件路径是【/home】\n\n## 真实管理员(已root)\n\n```sh\npkg install tsu\ntsu # 启动命令\n```\n- 执行后文件路径不变，因此可以进入手机的任何一个目录\n\n# 安装 SSH\n\n安装\n```sh\napt install openssh\n```\n\n## 设置 SSH Key\n配置账户信息\n\n```sh\ngit config --global user.name \"UserName\"\ngit config --global user.email \"email@example.com\"\n```\n\n## 创建 SSH Key\n\n```sh\nssh-keygen -t rsa -C \"email@example.com\"\n```\n\n## 复制 Key\n\n```sh\ncat ~/.ssh/id_rsa.pub\n```\n\n## 验证 SSH\n\n```sh\nssh -T git@github.com\n```\n\n## SSH 基础使用\n### 远程主机登录\n\n```sh\nssh root@host\nssh host\n#本地用户名与远程用户名一致，登录时可以省略用户名\nssh -p 2222 root@host\n# SSH 的默认端口是22，使用 p 参数，可以修改这个端口。\n```\n\n### 公钥登录\n\n```sh\nssh-copy-id user@host\n#将公钥传送到远程主机 host 上面\n```\n\n- 如果还是不行，就打开远程主机的 `/etc/ssh/sshd_config` 这个文件，检查下面几行前面\"#\"注释是否取掉。\n\n```sh\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile\n.ssh/authorized_keys\n```\n\n- 然后，重启远程主机的ssh服务。\n    + Ubuntu系统 service ssh restart\n    + Debian系统 /etc/init.d/ssh restart\n\n# Oh My ZSH\n```sh\napt install git zsh curl -y\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\nchsh -s zsh\n```\n\n# OpenJDK\n- JDK1.8\n    - [aarch64谷歌云盘](https://drive.google.com/file/d/1PdNqmLrhFlBoRlpCW-mC6CHbVS_Lva9D/view?usp=drivesdk)\n    - [aarch64百度云盘密码:ryea](https://pan.baidu.com/s/14T-2L2j3gZaxfbwkZxJxqg)\n- JDK1.9\n    - ~~[aarch64下载](https://drive.google.com/file/d/1U3o34Z3aI_g8mvkJ2gP3YfBB6aaQS1xK/view?usp=drivesdk)~~\n\n## 安装\n```sh\ncd storage/下载目录\ndpkg -i openjdk9_9.2017.8.20_aarch64.deb\n```\n\n## Java 8\n```sh\nwget https://github.com/ivitan/Shell/releases/download/Java/java8.deb -O ~/Java.deb\ndpkg -i ~/Java.deb\nrm -rf ~/Java.deb\n```\n\n# 安装 Nodejs\n```sh\npkg install nodejs\npkg install nodejs-lts\n```\n\n## 解决 npm 出现 npm err! cannot read property ‘length’ of undefined 问题\n\n- 复制下面内容\n\n```sh\n(require('os').cpus() || { length: 1 }).length\n```\n```sh\nvim ../usr/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js\n```\n\n- 修改如下\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/5b3044e8a329d.jpg)\n\n# 安装 Hexo\n```sh\nmkdir blog\ncd blog\nnpm install hexo-cli -g\nnpm init\nnpm install\nnpm install hexo-deployer-git\nhexo g      #生成静态文件\nhexo s      #启动 Hexo\nhexo d      #部署到 Github\nhexo new \"my blog\" #新建文章\nhexo s      #开启本地服务\nhexo clean  #清除 public\nnpm update -g #版本更新\n```\n\n# Mariadb(MySQL)\n```sh\npkg install mariadb\n```\n\n## 安装基本数据\n```sh\nmysql_install_db\n```\n\n- mysqld: Can't read dir ofソdata/data/com . termux/files/usr/e tc/my.cnf.d' (Errcode: 2 \"No such file or directory\") Fatal error in defaults handling. Program aborted\n\t- 先在`my.cnf`所在目录下新建`my.cnf.d`文件夹，然后执行`mysql_install_db`\n\n## 启动 Mariadb 服务\n\n```sh\nmysqld\n```\n- 启动mysql后，该回话便无法进行任何操作，需要左滑唤醒会话菜单，开启新的回话。而倘若不在一个会话里启动mysqld，而是直接运行mysql，则会2002错误。\n\n## 修改密码\n\n```sh\nmysql_secure_installation\n# 输入旧密码，空则直接回车\nSet root password? [Y/n] y\nNew password:\nRe-enter new password:# 两次输入新密码\n\nRemove anonymous users? [Y/n] Y #是否移除匿名用户\nDisallow root login remotely? [Y/n] n #是否不允许root远程登录\nRemove test database and access to it? [Y/n] n #是否移除test数据库\nReload privilege tables now? [Y/n] y #是否重新加载表的权限\n```\n\n## 登录 MySQL\n```sh\nmysql -uroot -p\nEnter password: ***apache2\n```\n\n- 或者使用\n\n```sh\nmysql -uroot -p******\n```\n\n# Python 环境部署\n## Python 2\n```sh\npkg install python2\n```\n\n## Python 3\n```sh\npkg install python\n```\n\n## 升级 pip 版本\n```sh\npython2 -m pip install --upgrade pip\npython -m pip install --upgrade pip\n```\n\npip 版本查看\n```sh\npip -v\npip3.6 -v\n```\n## ipython\nipython 是一个 python 的交互式 shell，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。学习 ipython 将会让我们以一种更高的效率来使用 python。\n先安装clang, 否则直接使用pip安装ipython会失败报错.\n\n- 安装\n\n```sh\npkg install clang\npip install ipython\npip3.6 install ipython\n```\n\n- 使用\n\n别使用`ipython`和`ipython2`进入`py2`和`py3`控制台:\n\n# PHP部署\n## 安装\n```sh\npkg install php # 可采用phpinfo进行测试\nphp -S 127.0.0.1:8080 -t www/\n```\n\n- 编写测试文件\n\n1. 在家目录下建一个www文件夹: `mkdir www`\n2. 在www文件夹下新建一个 `index.php` 文件, 其内容为\n\n```php index.php\n<?php phpinfo();?>\n```\n\n# Nmap(口扫描必备工具)\n```sh\npkg install nmap\n```\n\n# hydra\nHydra 是著名的黑客组织 THC 的一款开源暴力破解工具这是一个验证性质的工具，主要目的是：展示安全研究人员从远程获取一个系统认证权限。\n\n- 安装\n\n```sh\npkg install hydra\n```\n\n# sslscan\nSSLscan 主要探测基于 ssl 的服务，如 https。SSLscan 是一款探测目标服务器所支持的 SSL 加密算法工具。\n\n- 安装\n\n```sh\npkg install sslscan\n```\n\n# whatportis\nwhatportis 是一款可以通过服务查询默认端口，或者是通过端口查询默认服务的工具，简单易用。在渗透测试过程中，如果需要查询某个端口绑定什么服务器，或者某个应用绑定的默认端口，可以使用 whatportis 查询。\n\n- 安装\n\n```sh\npip2 install whatportis\n```\n\n# RouterSploit\nRouteSploit 框架是一款开源的路由器等嵌入式设备漏洞检测及利用框架。\n\n- 安装\n\n```sh\npip2 install requests\ngit clone https://github.com/reverse-shell/routersploit\ncd routersploit\npython2 rsf.py\n```\n\n# Slowloris 低带宽的 DoS 工具\n```sh\ngit clone https://github.com/gkbrk/slowloris.git\ncd slowloris\nchmod +x slowloris.py\n```\n---\n**参考**\n- [Termux Wike](https://wiki.termux.com/wiki/Package_Management)\n- [android上的终端——termux](http://www.liuxi.site/2018/05/16/android上的终端——termux/)\n- [Termux 高级终端安装使用配置教程](http://www.sqlsec.com/2018/05/termux.html)","tags":["Linux","Android","Termux"],"categories":["Diary"]},{"title":"SQL 检索练习题","path":"/posts/SQLselect.html","content":"检索，存储过程，触发器相关练习。\n<!--more-->\n\n|仓库号|城市|面积|\n|:---|:---|:---|\n|WH1 |北京 |370\n|WH2 |上海 |500|\n|WH3 |广州 |200|\n|WH4 |广州 |300|\n|WH5 |天津 |340|\n|WH6 |上海 |350|\n|WH7 |上海 |600|\n|WH8| 天津 |300|\n\n--------------------------------------------\n|职工号|仓库号|工资|\n|:---|:---|:---|\n|E1|WH2|2220|\n|E2|WH1|1810|\n|E3|WH2|1850|\n|E5|WH3|1530|\n|E6|WH1|1550|\n|E7|WH4|2300|\n|E8|WH4|2000|\n|E9|WH5|2050|\n|E10|WH5|1900|\n|E11|WH6|2100|\n|E12|WH7|1700|\n|E15|WH5|1780|\n|E16|WH1|1600|\n\n---------------------------------------------\n|职工号|供应商号|订购单号|订购日期|\n|:---|:---|:---|:---|\n|E3| S7| OR67| 2005-12-4|\n|E1| S4| OR73| 2006-4-1|\n|E7| S4| OR76| 2006-4-2|\n|E6| S6| OR77| 2006-1-21|\n|E3| S4| OR79| 2005-11-15|\n|E1| S6| OR80| 2006-2-1|\n|E3| S6| OR90| 2006-3-12|\n|E3| S3| OR91| 2006-3-2|\n-------------------------------------------------\n|供应商号|供应商名|地址|\n|:---|:----|:---|:---|\n|S3|振华电子厂|西安|\n|S4|华通电子公司|北京|\n|S6|607厂|郑州|\n|S7|爱华电子厂|北京|\n\n\n# 检索\n1. 检索在北京的供应商的名称。\n```sql\nselect 供应商名 from gys where 地址='北京'\n```\n2. 检索发给供应商S6的订购单号。\n```sql\nselect 订购单号 from dg where 供应商号='S6'\n```\n3. 检索出职工E6发给供应商S6的订购单信息。\n```sql\nselect * from dg where 职工号='E6'and 供应商号='S6'\n\n```\n4. 检索出向供应商S3发过订购单的职工的职工号和仓库号。\n```sql\nselect zg.职工号,仓库号 from dg join zg on zg.职工号=dg.职工号\n where 供应商号='S3'\n```\n5. 检索出目前与S3供应商没有联系的职工信息。\n```sql\nselect * from zg where 职工号 not in\n(select 职工号 from dg where 供应商号='S3')\n```\n6. 检索出目前没有任何订购单的供应商信息\n```sql\nselect * from gys where 供应商号 not in\n (select distinct 供应商号 from dg)\n```\n```sql\n SELECT * FROM gys WHERE NOT EXISTS \n( SELECT * FROM dg WHERE 供应商号=gys.供应商号 ) \n```\n7. 检索出和职工E1、E3都有联系的北京的供应商的信息。\n```sql\nselect * from gys where 地址='北京' \nand 供应商号 in\n(select 供应商号 from dg where 职工号='E1')\nand 供应商号 in\n(select 供应商号 from dg where 职工号='E3')\n```\n8. 检索出目前和华通电子公司有业务联系的每个职工的工资。\n```sql\nselect 职工号,工资 from zg where 职工号 in\n(select 职工号 from dg where 供应商号 in\n(select 供应商号 from gys where 供应商名='华通电子公司'))\n```\n9. 检索出与工资在1220元以下的职工没有联系的供应商名称。\n```sql\nselect 供应商名 from gys \nwhere 供应商号 not in\n(select 供应商号 from dg \nwhere 职工号 in\n(select 职工号 from zg where 工资<1220))\n```\n```sql\nselect 供应商名 from gys \nwhere 供应商号 not in \n(select 供应商号 from dg join zg on dg.职工号=zg.职工号\nwhere 工资>2250)\n```\n10. 检索出向S4供应商发出订购单的仓库所在的城市。\n```sql\nselect 城市 from ck where 仓库号 in\n(select 仓库号 from zg where 职工号 in\n(select 职工号 from dg where 供应商号='S4'))\n```\n11. 检索出在上海工作并且向S6供应商发出了订购单的职工号。\n```sql\nselect 职工号 from zg where 仓库号 in\n(select 仓库号 from ck where 城市='上海' and 职工号 in\n(select 职工号 from dg where 供应商号='S6'))\n```\n```sql\nselect dg.职工号 from zg join ck on zg.仓库号=ck.仓库号\njoin dg on zg.职工号=dg.职工号\nwhere 城市='上海' and 供应商号='S6'\n```\n12. 检索出在广州工作并且只向S6供应商发出了订购单的职工号。\n```sql\nselect 职工号 from zg where 仓库号 in\n(select 仓库号 from ck where 城市='广州' \nand 职工号 in\n(select 职工号 from dg where 供应商号='S6') \nand 职工号 not in\n(SELECT 职工号 FROM dg WHERE 供应商号!='S6'))\n```\n13. 检索出由工资多于1230元的职工向北京的供应商发出的订购单号。\n```sql\nselect 订购单号 from dg where 职工号 in\n(select 职工号 from zg where 工资>1230) and  供应商号 in\n(select 供应商号 from gys where 地址='北京')\n```\n```sql\nselect 订购单号 from dg where 职工号 in\n(select 职工号 from zg where 工资>2000)\nand 供应商号 in (\nselect 供应商号 from gys where 地址='北京')\n```\n14. 检索出仓库的个数\n```sql\nselect count(仓库号) from ck\n```\n15. 检索出有最大面积的仓库信息。\n```sql\nselect * from ck where ck.面积=(\nselect max(面积) from ck )\n```\n16. 检索出所有仓库的平均面积。\n```sql\nselect avg(面积) 平均面积  from ck\n```\n17. 检索出向S4供应商发出订购单的那些仓库的平均面积。\n```sql\nselect avg(面积) as 平均面积 from ck where 仓库号 in\n(select 仓库号 from zg where 职工号 in\n(select 仓库号 from dg where 供应商号='S4'))\n```\n```sql\nselect avg(面积) as 平均面积 from ck\nwhere 仓库号 in \n(select 仓库号 from zg join dg on zg.职工号=dg.职工号\nwhere 供应商号='S4')\n```\n18. 检索出每个城市的供应商个数。\n```sql\nselect 地址,count(*) from gys\ngroup by 地址\n```\n19. 检索出每个仓库中工资多于1220元的职工个数。\n```sql\nselect 仓库号,count(*) from zg where 工资>1220\n group by 仓库号\n```\n20. 检索出和面积最小的仓库有联系的供应商的个数。\n```sql\nselect count(供应商号) from gys where 供应商号 in\n(select 供应商号 from dg where 职工号 in\n(select 职工号 from zg where 仓库号 in\n(select 仓库号 from ck where 面积=\n(select min(面积) from ck))))\n```\n```sql\nselect count(供应商号) from dg where 职工号 in \n(select 职工号 from zg where 仓库号 in\n(select 仓库号 from ck where 面积=(select min(面积) from ck)))\n```\n21. 检索出工资低于本仓库平均工资的职工信息。\n```sql\nSELECT * FROM 职工 out WHERE 工资< \n(SELECT AVG(工资) FROM 职工 inne \nWHERE 仓库号=out.仓库号) \n```\n# 存储过程\n1. 创建一个存储过程P1，输入某个仓库号，查询对应仓库的\n信息。\n```sql\ncreate proc P1\n@ckh nvarchar(225) \nas\nselect * from ck where 仓库号=@ckh\n```\n```sql\nexec P1 'WH8'\n```\n\n2. 创建一个存储过程P2，输入某个仓库号，输出对应仓库的的职工人数。\n```sql\ncreate proc P2\n@ckh nvarchar(20)\nas\nselect count(职工号) 职工人数 from zg where 仓库号 = @ckh\ngroup by 仓库号\n```\n```sql\nexec P2 'WH1'\n```\n---------------------------------------------------\n```sql\nalter TRIGGER tri_salary\nON zhg FOR UPDATE\nAS\nSELECT * FROM INSERTED JOIN\nDELETED ON INSERTED.职工号 = DELETED.职工号\nIF UPDATE(工资)\nIF EXISTS(SELECT * FROM INSERTED JOIN\nDELETED ON INSERTED.职工号 = DELETED.职工号\nWHERE INSERTED.工资&lt;DELETED.工资)\nbegin\nprint(&#39;新工资值低于原工资，拒绝修改&#39;)\nROLLBACK\nend\n```\n```sql\nCREATE PROCEDURE countzhigong\n@ck char(20), @renshu int output\nAS\nSELECT @renshu = count(职工号)\nFROM ck left outer JOIN zhg ON ck.仓库号= zhg.仓库号\nWHERE ck.仓库号=@ck\nDeclare @re int\nExecute countzhigong &#39;wh2&#39;, @re output\nPrint @re\nSELECT *\nFROM ck left outer JOIN zhg ON ck.仓库号= zhg.仓库号\n\nSELECT * FROM zhg\n```\n------------------------------------------------\n# 创建、修改、删除触发器。\n1. 创建一个触发器zhigong1，在对职工表的工资属性修改时触发：每修改一个职工的工资，就检查新工资是否比原工资低，若是低，则恢复原工资而不做修改。\n```sql\ncreate trigger zhigong1\non zg for insert,update\nas\nselect * from inserted join deleted \non inserted.职工号=deleted.职工号\nif update(工资)\nif exists (select * from inserted join \ndeleted on inserted.职工号=deleted.职工号\nwhere inserted.工资<deleted.工资)\nrollback\n```\n```sql\nupdate zg set 工资='3000' where 职工号='E9'\n```\n2. 创建一个触发器zhigong2，在插入新的职工记录时触发：检查新职工记录的仓库号是否在仓库表的仓库号中存在，如果不存在就撤消插入操作。\n```sql\nalter trigger zhigong2\non zg for insert\nas\nselect * from inserted join deleted on inserted.职工号=deleted.职工号\nif not exists ( select 仓库号 from inserted where 仓库号 in (select 仓库号 from ck ))\nrollback\n```\n```sql\ninsert into zg values('E33','WH2','3000')\n```\n3. 删除以上两个触发器。\n```sql\ndrop trigger zhigong1,zhigong2\n```\n4. 创建一个触发器dinggou1，在对订购表进行插入操作时，输出该职工的所经手的订购单数目。\n```sql\ncreate  trigger  dinggou1\non dg for insert\nas\nselect dg.职工号,count(dg.订购单号) as 订购单数目\nfrom dg join inserted on dg.职工号=inserted.职工号\nwhere dg.职工号=inserted.职工号\ngroup by dg.职工号\n```\n```sql\ninsert into dg values\n('E1','S6','OR98','2018-01-21 00:00:00.000')\n```","tags":["SQL"],"categories":["Database"]},{"title":"Vim 插件&主题","path":"/posts/Vim-Vundle-Markdown.html","content":"Vim 插件 主题\n<!--more-->\n# SpaceVim\n```sh\ncurl -sLf https://spacevim.org/install.sh | bash\n```\n# Vundle 插件管理器\nVundle 是Vim bundle 的简称,是一个 Vim 插件管理器.\n\nVundle 允许你做\n\n1. 在.vimrc中跟踪和管理插件\n2. 安装特定格式的插件(a.k.a. scripts/bundle)\n3. 更新特定格式插件\n4. 通过插件名称搜索Vim scripts中的插件\n5. 清理未使用的插件\n6. 可以通过单一按键完成以上操作,详见[interactive mode](https://github.com/VundleVim/Vundle.vim/blob/v0.10.2/doc/vundle.txt#L319-L360)\n\n安装\n```git\ngit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim\n```\n\n- 配置\n1. 编辑\n\n```\nvim .vimrc\n```\n\n2. 添加下列内容\n\n```vim\nset nocompatible   \" be iMproved, required\nfiletype off   \" required\nset rtp+=~/.vim/bundle/Vundle.vim\ncall vundle#begin()\nPlugin 'VundleVim/Vundle.vim'\ncall vundle#end()   \" required\nfiletype plugin indent on  \" required\n```\n\n安装需要的插件\n\n- bash 下：\n\n```vim\nvim +PluginInstall +qall\n```\n\n- vim 下\n\n```vim\n:PluginInstall\n```\n\n# 安装 Markdown 插件\n修改vimrc配置文件,添加\n```\nPlugin 'godlygeek/tabular'\nPlugin 'plasticboy/vim-markdown'\n```\n\n下一步\n\n```bash\nvim\n:PluginInstall\n```\n# 安装 gruvbox 主题\n在 .vimrc 添加\n\n```vim\nPlugin 'morhetz/gruvbox'\nPlugin 'vim-airline/vim-airline'\n```\n\n配置主题\n```\nset bg=dark \"设置背景为黑色\ncolorscheme gruvbox \"设置主题为 gruvbox\nset guioptions=  \"去掉两边的scrollbar\nset guifont=Monaco:h17 \"设置字体和字的大小\n```\n# Vim-airline\n.vimrc 添加插件\n\n```vim\nPlugin 'vim-airline/vim-airline\nPlugin 'vim-airline/vim-airline-themes'\n```\n\n配置\n\n```vim\n    \"\" airline settings.\n    let g:airline_theme = 'simple'\n    let g:airline_powerline_fonts = 1\n\n    if !exists('g:airline_symbols')\n      let g:airline_symbols = {}\n    endif\n\n    let g:airline_left_sep = ''\n    let g:airline_left_alt_sep = ''\n    let g:airline_right_sep = ''\n    let g:airline_right_alt_sep = ''\n    let g:airline_symbols.branch = ''\n    let g:airline_symbols.readonly = ''\n    let g:airline_symbols.linenr = ''\n    let g:airline#extensions#tabline#enabled = 1\n    \" show absolute file path in status line\n    let g:airline_section_c = '%<%F%m %#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'\n    \" show tab number in tab line\n    let g:airline#extensions#tabline#tab_nr_type = 1\n```\n\n支持主题\n```\n    badwolf\n    base16\n    behelit\n    bubblegum\n    dark\n    durant\n    hybridline\n    hybrid\n    jellybeans\n    kalisi\n    kolor\n    laederon\n    light\n    lucius\n    luna\n    molokai\n    monochrome\n    murmur\n    papercolor\n    powerlineish\n    raven\n    serene\n    silver\n    simple\n    solarized\n    sol\n    term\n    tomorrow\n    ubaryd\n    understated\n    wombat\n    zenburn\n```\n\n# NERD Tree 文件浏览插件\n.vimrc 添加插件\n\n```vim\nPlugin 'scrooloose/nerdtree'\n```\n\n打开/关闭 NERD Tree\n\n```vim\n:NERDTreeToggle\n```\n\nNERD Tree 配置\n\n```vim\n\"当 vim 启动没指定文件时，自动打开 NERDTree\nautocmd StdinReadPre * let s:std_in=1\nautocmd VimEnter * if argc() == 0 && !exists(\"s:std_in\") | NERDTree | endif\n\"在 normal 下按 ,d 打开关闭文件浏览\nnmap ,d :NERDTreeToggle<CR>\n```\n使用技巧\n1. 按 `?`可以打开 NERD tree 帮助文档\n2. 按 `j` ,`k` 在 NERD tree上下移动,`<c-r>` 打开关闭文件夹或文件\n3. `:vsp` 在右侧打开一个分屏，`:sp` 在下面打开一个分屏\n4. `<c-w>j` ，`<c-w>k`, `<c-w>h`, `<c-w>l`按键分别向上、下、左、右分屏移动。 `<c-w>=`均分屏幕\n\n改默的切换分屏按键方式\n\n```vim\n\"--------- Split Mapping --------------------\"\nnmap <c-j> <c-w>j\nnmap <c-k> <c-w>k\nnmap <c-h> <c-w>h\nnmap <c-l> <c-w>l\n```\n\n- 官网文档\n[GitHub Repo](https://github.com/scrooloose/nerdtree)\n\n# .vimrc 配置文件\nvimrc\n\n```vim\n    \"设置行号显示\n    set number\n\n    \"将行号设置为相对行号\n    set relativenumber\n\n    \"显示标尺\n    set ruler\n\n    \" 编码\n    set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1\n    set fileencoding=utf-8\n    set encoding=utf-8\n    set fencs=utf-8,gbk,gb2312,gb18030\n\n    \"语法高亮\n    syntax enable\n    syntax on\n\n    \" 高亮\n    hi pythonSelf            ctermfg=174 guifg=#6094DB cterm=bold gui=bold\n    let python_highlight_all=1\n    syntax enable\n\n    \" 状态行颜色\n    highlight StatusLine guifg=SlateBlue guibg=Yellow\n    highlight StatusLineNC guifg=Gray guibg=White\n\n    \" 增强模式中的命令行自动完成操作\n    set wildmenu\n\n    \" 总是显示状态行\n    set laststatus=2\n\n    \"命令行补全参数\n    set wildmenu\n\n    \"设置tab键空4格\n    set tabstop=4\n\n    \"自动检测文件类型\n    filetype plugin indent on\n\n    \"开启自动缩进，智能缩进\n    set autoindent\n    set cindent\n    set smartindent\n    set shiftwidth=4\n\n    \"映射光标在窗口间移动的快捷键\n    nmap <C-H> <C-W>h\n    nmap <C-J> <C-W>j\n    nmap <C-K> <C-W>k\n    nmap <C-L> <C-W>l\n\n    \"插件安装列表\n    set nocompatible              \" be iMproved, required\n    filetype off                  \" required\n    set rtp+=~/.vim/bundle/Vundle.vim\n    call vundle#begin()\n    Plugin 'VundleVim/Vundle.vim'\n    Plugin 'morhetz/gruvbox'\n    Plugin 'vim-airline/vim-airline'\n    Plugin 'plasticboy/vim-markdown'\n    call vundle#end()            \" required\n    filetype plugin indent on    \" required\n\n    \"基本主题配置\n    set bg=dark    \t\t   \"设置背景为黑色\n    colorscheme gruvbox    \"设置主题为 gruvbox\n    set guioptions=        \"去掉两边的scrollbar\n    set guifont=Monaco:h17 \"设置字体和字的大小\n    set cuc\n    set cul\n    set incsearch\t\t  \"输入搜索内容时就显示搜索结果\n    set ignorecase\n    set hlsearch\t\t  \"搜索时高亮显示被找到的文本\n\n    \"airline settings.\n    let g:airline_theme = 'simple'\n    let g:airline_powerline_fonts = 1\n\n    if !exists('g:airline_symbols')\n      let g:airline_symbols = {}\n    endif\n\n    let g:airline_left_sep = ''\n    let g:airline_left_alt_sep = ''\n    let g:airline_right_sep = ''\n    let g:airline_right_alt_sep = ''\n    let g:airline_symbols.branch = ''\n    let g:airline_symbols.readonly = ''\n    let g:airline_symbols.linenr = ''\n    let g:airline#extensions#tabline#enabled = 1\n    \" show absolute file path in status line\n    let g:airline_section_c = '%<%F%m %#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'\n    \" show tab number in tab line\n    let g:airline#extensions#tabline#tab_nr_type = 1\n```\n---\n**参考**\n- [Vim](https://blog.csdn.net/zhangpower1993/article/details/52184581)\n- [Vundle](https://github.com/VundleVim/Vundle.vim)\n- [个性化 Vim](https://blog.csdn.net/u013950658/article/details/78211783))","tags":["Linux","Windows","Vim"],"categories":["Coding"]},{"title":"SQL 实现数据完整性约束","path":"/posts/SQLfull.html","content":"SQL实现数据完整性约束\n1. 数据完整性基本概念\n2. 实现声明完整性\n3. 实现过程完整性\n<!--more-->\n\n# 数据完整性基本概念\n意义\n数据的完整性是为了防止数据库中存在不符合语义的数据。\n这些加在数据库数据之上的语义约束条件就是数据完整性约束条件。\n这些约束条件作为表定义的一部分存储在数据库中。\nDBMS检查数据是否满足完整性条件的机制就称为完整性检查。\n\n## 完整性约束条件的作用对象\n列级约束\n1. 对数据类型的约束\n2. 对数据格式的约束\n3. 对取值范围或取值集合的约束\n4. 对空值的约束\n\n元组约束\n元组中各个字段之间的联系的约束，如：开始日期小于结束日期。\n\n关系约束\n是若干元组之间、关系之间的联系的约束。\n\n实现数据完整性的方法\n1. 一种是在定义表时声明数据完整性，称为声明完整性，\n2. 另一种是在服务器端编写触发器来实现，称为过程完整性。\n\n在执行对数据的增、删、改操作时，数据库管理系统自动检查用户定义的完整性约束条件。\n\n# 实现声明完整性\n## 主码约束\n原则\n1. 每个表只能有一个 `PRIMARY KEY` 约束\n2. 用 `PRIMARY KEY` 约束的列取值不能有重复，而且不允许有空值\n\n添加主码约束的语法格式\n```sql\nALTER TABLE 表名\nADD [ CONSTRAINT 约束名]\nPRIMARY KEY （<列名> [, … n] ）\n```\n\n例：对雇员表和工作表添加主码约束\n```sql\nALTER TABLE 雇员表\nADD  CONSTRAINT  PK_EMP\nPRIMARY KEY （雇员编号）\n```\n```sql\nALTER TABLE 工作表\nADD  CONSTRAINT  PK_JOB\nPRIMARY KEY （工作编号）\n```\n## UNIQUE 约束\n目的\n- 用于限制在一个列中不能有重复的值。\n- 用在事实上具有惟一性的属性列上，比如每个人的身份证号码、驾驶证号码等均不能有重复值。\n\n注意：\n- 允许有一个空值；\n- 在一个表中可以定义多个UNIQUE约束；\n- 可以在一个列或多个列上定义UNIQUE约束。\n\n添加UNIQUE约束的语法格式为：\n```sql\nALTER TABLE 表名\nADD [ CONSTRAINT 约束名]\nUNIQUE（<列名> [, … n] ）\n```\n例．为雇员表的“电话”列添加UNIQUE约束。\n```sql\nALTER TABLE 雇员表\nADD  CONSTRAINT  UK_SID\nUNIQUE（电话）\n```\n## FOREIGN KEY 外码约束\n目的\n- 实现引用完整性。\n- 外码所引用的列必须是有`PRIMARY KEY约束`或`UNIQUE约束`的列。\n\n添加FOREIGN KEY约束的语法格式为：\n```sql\nALTER TABLE 表名\nADD [ CONSTRAINT 约束名]\nFOREIGN KEY（<列名>）\nREFERENCES 引用表名（<列名>）\n```\n例．为雇员表的工作编号添加外码引用约束。\n```sql\nALTER TABLE 雇员\nADD CONSTRAINT FK_job_id\nFOREIGN KEY （工作编号）REFERENCES 工作表 （工作编号）\n```\n## DEFAULT 约束\n目的\n- 用于提供列的默认值。\n- 只有在向表中插入数据时才检查DEFAULT约束。\n\n添加DEFAULT约束的语法格式为：\n```sql\nALTER TABLE 表名\nADD [ CONSTRAINT 约束名 ]\nDEFAULT 默认值 FOR 列名\n```\n例．定义雇员表的工资的默认值为1000。\n```sql\nALTER TABLE 雇员\nADD CONSTRAINT  DF_SALARY\nDEFAULT  1000  FOR 工资\n```\n## CHECK 约束\n目的\n- 用于限制列的取值在指定的范围内，使数据库中存放的值都是有意义的。\n- 系统在执行`INSERT语句`和`UPDATE语句`时自动检查CHECK约束。\n- CHECK约束可约束同一个表中多个列之间的取值关系。\n\n添加CHECK约束的语法格式为：\n```sql\nALTER TABLE 表名\nADD [ CONSTRAINT 约束名 ]\nCHECK （逻辑表达式）\n```\n例1．限制雇员的工资必须大于等于200。\n```SQL\nALTER TABLE 雇员\nADD CONSTRAINT  CHK_Salary\nCHECK ( 工资 >= 200 )\n```\n例2．限制工资表的最低工资小于等于最高工资。\n```sql\nALTER TABLE 工作\nADD CONSTRAINT  CHK_Job_Salary\nCHECK( 最低工资 <= 最高工资 )\n```\n# 实现过程完整性\n简介\n\n过程完整性是指在服务器端通过编写实现约束的一段代码来实现数据完整性约束，这段代码就称为触发器。\n触发器是用编程的方法实现复杂的商业规则，它可以实现一般的数据完整性约束实现不了的复杂的完整性约束。\n\n事务基本概念\n`事务（Transaction）`是作为完整的工作单元执行的一系列操作。\n如果一个事务中的所有操作都成功，则事务成功，其对数据库的更改都会成为永久性的更改。\n如果事务中的任何一个操作失败，则整个事务失败，其中所完成的操作均被取消，所有对数据的更改均无效。\n\n事务的三种类型\n1. `自动提交事务` 每一条对数据的增、删、改语句都自动地构成了一个事务。\n2. `显式事务` 是用户定义的事务，有显式的开始 `（BEGIN TRANSACTION ）` 和结束标记（`COMMIT（正常结束)` 和 `ROLLBACK（异常结束）`）。\n3. `隐式事务` 事务的开始是隐式的，以前一个事务结束后的第一个SQL语句作为下一个事务的开始，但每个事务必须有显式的结束标记。SQL Server支持的是显式事务。\n\n# 触发器\n概念\n是一种特殊的存储过程，不需要由用户调用执行，而是当用户对表中的数据进行UPDATE、INSERT或DELETE操作时自动触发执行的。\n\n触发器通常用于保证业务规则和数据完整性，其主要优点是用户可以用编程的方法来实现复杂的处理逻辑和商业规则，增强了数据完整性约束的功能。\n\n触发器的优点\n1. 完成比CHECK约束更复杂的数据约束。\n2. 为保证数据库性能而维护的非规范化数据。\n3. 可实现复杂的商业规则。\n4. 触发器也可以评估数据修改前后的表状态，并根据其差异采取对策。\n\n创建触发器语法格式\n```SQL\nCREATE TRIGGER 触发器名称\nON 表名\n{ FOR | AFTER | INSTEAD OF }\n{ [ INSERT ] [ , ] [ DELETE ] [ , ]\n   [UPDATE ] }\nAS\n  SQL 语句 [ ... n ]\n```\n两个逻辑工作表\n- `DELETED表` 存储 `DELETE和UPDATE` 语句所影响的行的副本。\n- `INSERTED表`存储 `INSERT和UPDATE` 语句所影响的行的副本。\n\n## 示例\n创建限制最低工资必须大于等于400的触发器。\n```SQL\nCREATE TRIGGER tri_job_salary1\nON 工作表 FOR INSERT, UPDATE\nAS\nIF EXISTS( SELECT * FROM INSERTED\nWHERE 最低工资 < 400 )\nBEGIN\nPRINT '最低工资必须大于等于400'\nROLLBACK\nEND\n```\n创建实现限制最低工资必须小于最高工资的触发器。\n```sql\nCREATE TRIGGER tri_job_salary2\nON 工作表 FOR INSERT, UPDATE\nAS\nIF EXISTS(SELECT * FROM INSERTED\nWHERE 最低工资 >= 最高工资 )\nBEGIN\nPRINT '最低工资必须小于最高工资'\nROLLBACK\nEND\n```\n创建实现限制雇员的工资必须在工作表的相应工作的最低工资和最高工资之间。\n```SQL\nCREATE TRIGGER tri_emp_salary\nON 雇员表\nFOR INSERT, UPDATE\nAS\nIF EXISTS (SELECT * FROM INSERTED a\nJOIN 工作表 b ON a.工作编号 = b.工作编号\nWHERE 工资 NOT BETWEEN 最低工资\nAND 最高工资 )\nROLLBACK\n```\n## 限制更新数据的触发器\n限制将SC表中不及格学生的成绩改为及格。\n```sql\nCREATE TRIGGER tri_grade\nON SC FOR UPDATE\nAS\nIF UPDATE(Grade)\nIF EXISTS(SELECT * FROM INSERTED JOIN\nDELETED ON INSERTED.Sno = DELETED.Sno\nWHERE INSERTED.Grade >= 60\nAND DELETED.Grade < 60)\nROLLBACK\n```\n## 限制删除的触发器\n限制删除SC表中成绩不及格学生的修课记录。\n```sql\nCREATE TRIGGER tri_del_grade\nON SC FOR DELETE\nAS\nIF EXISTS(SELECT * FROM DELETED\nWHERE Grade < 60)\nROLLBACK\n```\n## 修改触发器定义\n语法格式为：\n```sql\nALTER TRIGGER 触发器名称\nON 表名\n{ FOR | AFTER | INSTEAD OF }\n{ [ INSERT ] [ , ] [ DELETE ] [ , ]\n   [UPDATE ] }\nAS\nSQL 语句 [ ... n ]\n```\n## 删除触发器\n语法格式为：\n```SQL\nDROP TRIGGER 触发器名 [ , ... n ]\n```\n例：删除tri_grade触发器。\n```sql\nDROP TRIGGER tri_grade\n```","tags":["SQL"],"categories":["Database"]},{"title":"SQL 锁与并发控制","path":"/posts/SQLlock.html","content":"SQL锁与并发控制\n<!--more-->\n# 并发问题\n如果对数据库进行操作的事务是一个接一个地进行，不会带来什么问题，但这样效率很低，所以常常需要同时执行多个事务，如果没有什么控制的话，这种同时执行多个事务的情况就会带来许多问题。\n\n错误的并发调度可能产生3种错误，又称为3类数据不一致。\n\n3类数据不一致\n\n- `丢失更新`（记忆诀窍：读与写之间被插足了）\n事务 T1 读取数据 A，然后对 A 进行运算修改，最后写回数据库。\n如果在 T1 读取和写回数据库之间，有其他事务修改了 A 值，就造成了丢失更新，因为 T1 是在旧的数据上进行的运算。\n- `脏读`（记忆诀窍：读被晃点了）\n事务 T1 修改了数据 A，然后事务 T2 读取了数据 A，然后事务 T1 回滚了事务。\n由于事务 T1 回滚了事务，所以数据 A 其实最终并没有被事务 T1 修改，也就是说事务 T2 读取了被丢掉的数据。\n- `不可重复读`（记忆诀窍：读与读之间被插足了）\n事务 T1 读取数据 A，然后做某些事，然后又读取数据 A。\n如果在两次读取之间，有其他事务对数据 A 进行了修改，那么就造成了同一事务中，两次读取数据 A 的值不同。\n\n# X锁和S锁\nX锁（exclusive locks，排他锁)\n\n如果事务 T 对数据 A 加了 X 锁，则：事务 T 可对数据 A 进行读取和修改；其他事务不能对数据 A 加任何锁，也不能读取和修改数据 A。\n\nS锁（share locks，共享锁)\n\n如果事务 T 对数据 A 加了 S 锁，则：事务 T 可对数据 A 进行读取，但不能修改；其他事务也能对数据 A 加 S 锁，但不能加 X 锁。\n\n## 封锁协议\n封锁协议\n\n1. `一级封锁协议`在事务 T 修改数据 A 之前，对数据 A 加上 X 锁，直到事务结束才释放，解决了丢失更新的问题。\n2. `二级封锁协议`在一级封锁协议的基础上，在事务 T 读取数据 A 之前，对数据 A 加上 S 锁，直到读取结束才释放，解决了脏读的问题。\n3. `三级封锁协议`在一级封锁协议的基础上，在事务 T 读取数据 A 之前，对数据 A 加上 S 锁，直到事务结束才释放，解决了不可重复读的问题。\n4. `两段封锁协议`对任何数据进行读写之前必须对该数据加锁，在释放一个封锁之后，事务不再申请和获得任何其他封锁，这样缩短了封锁时间，提高了并发性，同时解决了数据不一致的问题。\n\n事务可分为两个阶段\n\n1. 生长阶段：也称为扩展阶段（申请锁）在这个阶段事务获得所有需要的封锁，并且不释放任何锁。\n2. 收缩阶段:这阶段事务释放全部锁，并且也不能再获得任何锁。\n- 所有事物均遵从两段协议，则对这些事务的并发调度一定是可串行化的。反过来，在一个可串行调度中，不一定所有事物都遵从两段协议。所有事物都遵从两段协议，是可串行化调度的成分而不是必要条件。\n\n## 死锁\n产生死锁的原因\n\n1. 产生死锁的原因很多，举个例子：事务 T1 对数据 A 上了 X 锁，现在 T1 要读取数据 B；而另一方面，事务 T2 对数据 B 上了 X 锁，现在 T2 要读取数据 A。T1、T2 都需要对方已经锁定了的数据，相互等待对方释放，这就造成了死锁。\n死锁的解决与避免\n2. 数据库管理系统（比如 SQL Server）识别到死锁后，会选择互锁的事务中的一个来作为牺牲品，回滚并结束该事务，并抛出一条消息。\n\n现在的数据库管理系统都很优秀，死锁很少发生，但很少不代表不会发生，如果我们在事务中注意一下，又可以进一步减少死锁的发生。下面是 SQL Server 中避免死锁发生的建议：\n\n避免死锁发生的建议\n\n1. 按同一顺序访问对象。比如上述示例中 T1 和 T2 都应先访问数据 A，后访问数据 B，而不是一个先访问数据 A，一个先访问数据 B。\n2. 避免事务中的用户交互。比如事务中不要等待用户输入，因为这种交互可能造成事务执行时间变长，增大了与其他事务竞争资源的可能性。\n3. 保持事务简短并在一个批处理中。\n4. 使用低隔离级别。\n5. 使用绑定连接。使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。\n\n---\n**参考**\n- [锁与并发控制](http://www.cftea.com/c/2009/07/VD08RGMWET3Y1UCH.asp)","tags":["SQL"],"categories":["Database"]},{"title":"SQL 规范","path":"/posts/SQLstyle.html","content":"SQL规范，注意事项。\n<!--more-->\n# MySQL 常用的存储引擎\n数据引擎表\n|存储引擎|事务|锁粒度|主要应用|忌用|\n|:---|:---|:---|:---|:---|\n|MYISAM|不支持|支持并发插入的表级锁|SELECT,INSERT|读写操作频繁|\n|MRG_MYISAM|不支持|支持并发插入的表级锁|分段归档,数据仓库|数全局查找过多的场景|\n|Innodb|支持|支持MVCC的行级锁|事务处理|无|\n|Archive|不支持|行级锁|日志记录只支持insert,select|需要随机读取,更新,删除|\n|Ndb cluster|支持|行级锁|高可用性|大部份应用|\n\n\n# 表及字段的命名规则\n规则\n- 可读性原则\n  - 使用大写和小写来格式化的库对象名字以获得良好的可读性。\n    - 例如:使用CustAddress而不是Custaddress来提高可读性。(这里要注意有些DBMS系统对表名的大小写是敏感的)\n- 表意性原则\n  - 对象的名字应该能够描述它所标识的对象。\n    - 例如,对于表,表的名称应该能够体现表中存储的数据内容;对于存储过程,存储过程名称应该能够体现存储过程的功能。\n- 长名原则\n  - 尽可能少使用或者不使用缩写,\n    - 适用于数据库(DATABASE)名之外的任一对象。\n# 字段类型的选择原则\n原因\n列的数据类型一方面影响数据存储空间的开销,另一方面也会影响数据查询性能。当一个列可以选择多种数据类型时,应该优先考虑数字类型,其次是日期或二进制类型,最后是字符类型。对于相同级别的数据类型,应该优先选择占用空间小的数据类型。\n\n|列类型|存储空间|\n|:---:|:---:|\n|TINYINT|1字节|\n|SMALLINT|2个字节|\n|MEDIUMINT|3个字节|\n|INT|4个字节|\n|BIGINT|8个字节|\n|DATE|13个字节|\n|DATETIME|8个字节|\n|TIMESTAMP|4个字节|\n|CHAR(M)|M字节,1 <= M <= 255|\n|VARCHAR(M)|L+1字节,在此L <= M1 <= M <= 255|\n\n- 以上选择原则主要是从下面两个角度考虑\n  - 在对数据进行比较(查询条件、JOIN条件及排序)操作时:\n    同样的数据,字符处理往往比数字处理慢。\n  - 在数据库中,数据处理以页为单位,列的长度越小,利于性能提升。\n\n## char varchar 如何选择\n原则\n1. 如果列中要存储的数据长度差不多是一致的,则应该考虑用char;否则应该考虑用varchar。\n2. 如果列中的最大数据长度小于50Byte,则一般也考虑用char。(当然,如果这个列很少用,则基于节省空间和减少I/O的考虑,还是可以选择用varchar)\n3. 一般不宜定义大于50 Byte的char类型列。\n\n## decimal与float 如何选择\n原则:\n1. decimal用于存储精确数据,而float只能用于存储非精确数据。故精确数据只能选择用decimal类型。\n1. 由于float的存储空间开销一般比decimal小(精确到7位小数只需要4个字节,而精确到15位小数只需要8字节)故非精确数据优先选择float类型。\n\n## 时间类型如何存储\n使用int来存储时间字段的优缺点\n- 优点:字段长度比datetime小。\n- 缺点:使用不方便,要进行函数转换。\n- 限制\n  - 只能存储到2038-1-19 11:14:07即2^32 为2147483648\n  - 需要存储的时间粒度\n    - 年月日 小时 分 秒 周\n\n# 如何选择主键\n区分业务主键和数据库主键\n1. 业务主键用于标识业务数据,进行表与表之间的关联;数据库主键为了优化数据存储(Innodb会生成6个字节的隐含主键)\n1. 根据数据库的类型考虑主键是否要顺序增长\n  - 有些数据库是按主键的顺序逻辑存储的\n\n主键的字段类型所占空间要尽可能的小\n\n对于使用聚集索引方式存储的表,每个索引后都会附加主键信息。\n\n避免使用外键约束\n1. 降低数据导入的效率\n2. 增加维护成本\n3. 虽然不建议使用外键约束,但是相关联的列上一定要建立索引\n\n避免使用触发器\n:1. 降低数据导入的效率。\n2. 可能会出现意想不到的数据异常。\n3. 使业务逻辑变得复杂。\n\n# 关于预留字段\n原因\n1. 无法准确的知道预留字段的类型。\n2. 无法准确的知道预留字段中所存储的内容。\n3. 后期维护预留字段所要的成本,同增加一个字段所需要的成本是相同的。\n4. 严禁使用预留字段。","tags":["SQL"],"categories":["Database"]},{"title":"SQL 触发器","path":"/posts/SQLtrigger.html","content":"SQL触发器\n<!--more-->\n# 概念\n某一个表的一定的操作，触发某种条件，从而执行的一段程序。触发器是一个特殊的存储过程。\n\n常见的触发器有三种：分别应用于Insert , Update , Delete 事件。\n\n语法\n```sql\ncreate trigger 触发器名\non\nzg   -- 在zg表建立触发器\nfor insert,update  -- 为什么事件触发\nas   -- 事件触发后所要做的事情\nselect * from inserted\nselect * from deleted\nif exists (select * from ck where 仓库号 in (select 仓库号 from inserted))\ncommit\nelse\nrollback\n```\n ---\n```sql\nCREATE  TRIGGER trigger_name [BEFORE|AFTER] event_name\nON table_name\nBEGIN\n -- Trigger logic goes here....\nEND\n```\n\nDeleted 与 Inserted\n1. `Deleted`表存放由于执行Delete或Update语句而要从表中删除的所有行。\n2. `Inserted`表存放由于执行Insert或Update语句而要向表中插入的所有行。\n\n## UPDATE 操作上在表的一个或多个指定列上创建触发器(Trigger)\n语法\n```sql\n  CREATE  TRIGGER trigger_name [BEFORE|AFTER] UPDATE OF column_name\n  ON table_name\n  BEGIN\n   -- Trigger logic goes here....\n  END\n```\n# 触发器操作\n删除\n```sql\ndrop trigger trigger_name\n```\n修改\n```sql\nalter  trigger tri_ck_zg\non zg for insert,update\nas\nselect * from inserted\nselect * from deleted\nif exists (select * from ck where 仓库号 in (select 仓库号 from inserted))\ncommit\nelse\nrollback\n```\n列出触发器\n- 所有\n```sql\nSELECT name FROM sqlite_master\nWHERE type = 'trigger'\n```\n- 指定表\n```sql\nSELECT name FROM sqlite_master\nWHERE type = 'trigger' AND tbl_name = '表名'\n```\n\n# 习题\n成绩小于60的不可更改\n```sql\ncreate trigger tri_grade\non xkgx for update\nas\nselect * from inserted\nselect * from deleted\n\nif update(成绩)\nif exists(select * from deleted  where 成绩<60)\nrollback\n```\n- 验证\n```sql\nupdate xkgx set 成绩=80 where课程号='303' and  学号='S101101'\n```\n  ---\n  \n成绩小于60的不可更改\n```sql\ncreate trigger tri_grade\non xkgx for update\nas\nselect * from inserted\nselect * from deleted\n\nif update(成绩)\nif exists(select * from inserted join deleted on  inserted.学号=deleted.学号\nwhere inserted.成绩>=60 and deleted.成绩<60)\nrollback\n```","tags":["SQL"],"categories":["Database"]},{"title":"SQL 事务","path":"/posts/SQLtransaction.html","content":"SQL事务\n<!--more-->\n# 概念\n- 事务（Transaction）是指一个或多个更改数据库的扩展。例如，如果您正在创建一个记录或者更新一个记录或者从表中删除一个记录，那么您正在该表上执行事务。重要的是要控制事务以确保数据的完整性和处理数据库错误。\n- 事务（Transaction）是一个对数据库执行工作单元。事务（Transaction）是以逻辑顺序完成的工作单位或序列，可以是由用户手动操作完成，也可以是由某种数据库程序自动完成。\n\n# 事务的特点\n四个特点\n1. `原子性（Atomicity)`确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态。\n2. `一致性（Consistency)`确保数据库在成功提交的事务上正确地改变状态。\n3. `隔离性（Isolation)`使事务操作相互独立和透明。\n4. `持久性（Durability)`确保已提交事务的结果或效果在系统发生故障的情况下仍然存在。\n\n# 事务控制\n含义\n- `BEGIN TRANSACTION` 开始事务处理。\n- `COMMIT` 保存更改，或者可以使用 END TRANSACTION 命令。\n- `ROLLBACK` 回滚所做的更改。\n---\n- 事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的\n\n## BEGIN TRANSACTION 命令\n语法\n```sql\nBEGIN TRANSACTION\nREAD(A)\nA:=A-50\nWRITE(A)\nREAD(B)\nB:=B+50\nCOMMIT\n```\n- READ(X):把数据项X从数据库读出到事务的私有缓冲中\n- WRITE(X):把数据项X从事务的私有缓冲中写到数据库。\n\n## COMMIT 命令\n作用\n\nCOMMIT 命令用于保存事务对数据库所做的更改。会将自上次 COMMIT 命令或者 ROLLBACK 命令执行以来所有的事务都保存到数据库中。\n\n语法\n```sql\n  DELETE FROM S\n       WHERE SIZE=20\n  COMMIT\n```\n## ROLLBACK 命令\n作用\nROLLBACK 命令用于撤销尚未保存到数据库中的事务。只能撤销自上次 COMMIT 命令或者 ROLLBACK 命令执行以来的事务。\n\n语法\n```sql\nDELETE FROM S\nWHERE SIZE=20\nROLLBACK\n```\n\nROLLBACK 命令可以用于撤销一系列的事务\n- 回滚至某一保存点的语法如下所示：\n```sql\nROLLBACK TO SAVEPOINT_NAME\n```\n## SAVEPOINT 命令\n作用\nSAVEPOINT 是事务中的一个状态点，使得我们可以将事务回滚至特定的点，而不是将整个事务都撤销。\n\n语法\n```sql\nSAVEPOINT SAVEPOINT_NAME\n```\n- 该命令只能在事务语句之间创建保存点（SAVEPOINT）。\n\n\n## RELEASE SAVEPOINT 命令\n作用\nRELEASE SAVEPOINT 命令用于删除先前创建的保存点。\n\n语法\n```sql\nRELEASE SAVEPOINT SAVEPOINT_NAME\n```\n## SET TRANSACTION 命令\n作用\n: SET TRANSACTION 命令可以用来初始化数据库事务，指定随后的事务的各种特征。\n\n将某个事务指定为只读或者读写。\n```sql\nSET TRANSACTION [ READ WRITE | READ ONLY ]\n```\n\n# 存储过程使用事务\n实例一\n ```sql\nCreate Procedure  MyProcedure\nAS\nBegin\nSet    NOCOUNT    ON;\nSet XACT_ABORT ON;\nbegin   tran  ok  --开始一个事务OK\ndelete  from  rxqz  where qz=   'rx015 ' --删除数据\nsave   tran  bcd   --保存一个事务点命名为bcd\nupdate  sz  set   name='李丽s' where name= '李丽'--修改数据\nif  @@error<>0  --判断修改数据有没有出错\nbegin --如果出错\nrollback   tran  bcd  -- 回滚事务到BCD 的还原点\ncommit   tran  ok  --提交事务\nend\nelse  --没有出错\ncommit  tran ok --提交事务\nEnd\n```\n\n实例二\n```sql\ncreate proc 1\n@si chark20),@pi char(20),@Ji chark20),@shu int\ninsert into SPJ values(@si,@pi,@Ji,@shu)\nbdgin tran t1\nif exists (select * from p where Pno=@Pi)\ncommit tran t1\nelse\nrollback tran t1\n```\n---\n**参考**\n- [连接](http://wiki.jikexueyuan.com/project/sql/transactions.html)","tags":["SQL"],"categories":["Database"]},{"title":"SQL 视图","path":"/posts/SQLview.html","content":"SQL视图\n<!--more-->\n# 什么是视图\n解析\n- 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。\n- 视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。\n  - 注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。\n\n# SQL CREATE VIEW\n语法\n```sql\nCREATE VIEW view_name AS\nSELECT column_name(s)\nFROM table_name\nWHERE condition\n```\n- 注释：视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。\n\n## SQL CREATE VIEW 实例\n要求\n1. 可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。通过向视图添加函数、join 等等，我们可以向用户精确地提交我们希望提交的数据。\n2. 样本数据库 Northwind 拥有一些被默认安装的视图。视图 \"Current Product List\" 会从 Products 表列出所有正在使用的产品。这\n\n创建：\n```sql\n  CREATE VIEW [Current Product List] AS\n  SELECT ProductID,ProductName\n  FROM Products\n  WHERE Discontinued=No\n```\n- 查询上面这个视图：\n```sql\nSELECT * FROM [Current Product List]\n```\n- Northwind 样本数据库的另一个视图会选取 Products 表中所有单位价格高于平均单位价格的产品\n```sql\n  CREATE VIEW [Products Above Average Price] AS\n  SELECT ProductName,UnitPrice\n  FROM Products\n  WHERE UnitPrice>(SELECT AVG(UnitPrice) FROM Products)\n```\n- 查询上面这个视图：\n```sql\nSELECT * FROM [Products Above Average Price]\n```\n- 另一个来自 Northwind 数据库的视图实例会计算在 1997 年每个种类的销售总数。请注意，这个视图会从另一个名为 \"Product Sales for 1997\" 的视图那里选取数据：\n```sql\nCREATE VIEW [Category Sales For 1997] AS\nSELECT DISTINCT CategoryName,Sum(ProductSales) AS CategorySales\nFROM [Product Sales for 1997]\nGROUP BY CategoryName\n```\n- 查询上面这个视图：\n```sql\nSELECT * FROM [Category Sales For 1997]\n```\n- 也可以向查询添加条件。现在，我们仅仅需要查看 \"Beverages\" 类的全部销量：\n```sql\nSELECT * FROM [Category Sales For 1997]\nWHERE CategoryName='Beverages'\n```\n## SQL 更新视图\n语法\n```sql\nSQL CREATE OR REPLACE VIEW Syntax\nCREATE OR REPLACE VIEW view_name AS\nSELECT column_name(s)\nFROM table_name\nWHERE condition\n```\n- 现在，我们希望向 \"Current Product List\" 视图添加 \"Category\" 列。我们将通过下列 SQL 更新视图：\n```sql\nCREATE VIEW [Current Product List] AS\nSELECT ProductID,ProductName,Category\nFROM Products\nWHERE Discontinued=No\n```\n## SQL 撤销视图\nDROP VIEW\n```sql\nDROP VIEW Syntax\nDROP VIEW view_name\n```\n---\n**Via**\n- [来源](http://www.w3school.com.cn/sql/sql_view.asp)","tags":["SQL"],"categories":["Database"]},{"title":"SQL 存储过程练习","path":"/posts/SQlprocEx.html","content":"SQL储存过程练习题\n<!--more-->\n\n|仓库号|城市|面积|\n|:---|:---|:---|\n|WH1|北京|3700|\n|WH2|上海|5000|\n|WH3|广州|2000|\n|WH4|武汉|4000|\n|WH5|北京|3460|\n|WH6|珠海|3400|\n|WH7|珠海|5200|\n|WH8|广州|6300|\n\n---------------------\n\n|仓库号|职工号|\t工资|\n|:---|:---|:---|\n|WH2|E1|1220|\n|WH1|E3|2210|\n|WH2|E4|4250|\n|WH3|E6|1230|\n|WH1|E7|2250|\n|WH1|E8|1700|\n|WH2|E10|3000|\n|WH3|E11|4500|\n|WH6|E12|2300|\n|WH2|E13|3400|\n|WH3|E14|4500|\n|WH6|E15|4000|\n|WH2|E18|3600|\n\n----------------------------------\n\n|职工号|供应商号|订购数量|订购日期|\n|:---|:---|:---|:---:|\n|E3|S7|67|2010-12-4|\n|E1|S4|73|2010-4-1|\n|E7|S4|76|2010-4-2|\n|E6|S6|77|20010-1-21|\n|E3|S4|79|20010-10-15|\n|E1|S6|80|2009-2-1|\n|E3|S6|90|2010-3-12|\n|E3|S3|91|2009-3-2|\n|E10|S3|93|\t2010-10-26|\n\n---------------------------------\n\n|:---|:---|:---|\n|S3|振华电子厂|\t西安|\n|S4|华通电子公司|\t北京|\n|S6|607|厂郑州|\n|S7|爱华电子厂|\t北京|\n\n1. 基于以上的数据库，创建一个名为myproc的存储过程。该存储过程的功能是从职工表中查询哪些仓库的职工人数在3人以上，列出这些仓库的基本信息。\n```sql\ncreate proc myproc\nas\nselect * from ck where 仓库号 in\n(select 仓库号 from zg\ngroup by 仓库号\nhaving count(职工号)>3)\n```\n```sql\nexec myproc\n```\n2. 定义具有参数的存储过程。在以上数据库中，创建一个名为Myproc2的存储过程，该存储过程的功能是向仓库表中插入一条记录，新记录的值由参数提供。\n```sql\ncreate proc Myproc2\n@ckh char(20),@city char(20),@mji int\nas\ninsert into ck values(@ckh,@city,@mji)\n```\n```sql\nexec Myproc2 'WH33','新会','3000'\n```\n3. 定义带返回值的存储过程。在以上数据库中，创建一个名为Myproc3的存储过程，该存储过程的功能是从表中根据供应商号查询对应的供应商名和地址。\n```sql\nalter proc Myproc3\n@gysh char(20)\nas\nselect 供应商名,地址 from gys where 供应商号=@gysh\n```\n```sql\nexec Myproc3 'S3'\n```\n------------------------------------------------------------\n\n```sql\nCreate table  雇员表(\n雇员编号 char(10),\n雇员姓名 char(20),\n年龄 int\n)\n```\n```sql\nALTER TABLE 雇员表\nADD  CONSTRAINT  PK_EMP\nPRIMARY KEY （雇员编号）\n```\n```sql\nALTER TABLE 工作表\nADD  CONSTRAINT  PK_JOB\nPRIMARY KEY （工作编号）\n```\n```sql\nCreate table  雇员表(\n雇员编号 char(10) not null,\n雇员姓名 char(20),\n年龄 int\n)\n```\n```sql\nALTER TABLE 雇员表\nADD  CONSTRAINT  PK_EMP\nPRIMARY KEY (雇员编号)\n```\n```sql\nALTER TABLE 雇员表\nADD  CONSTRAINT  check_age\ncheck (年龄>=18 and 年龄<=60)\n```\n```sql\ncreate proc p6\n@bianhao char(10)\nas\ndelete from 雇员表\nwhere 雇员编号=@bianhao\nexec  p6 'q1'\nselect * from 雇员表\n```\n```sql\n  select * from ck\n```\n```sql\ncreate proc p7\n@chengshi char(20),@geshu int output\nas\nselect @geshu=COUNT(仓库号)\nfrom ck\nwhere 城市=@chengshi\n```\n```sql\ndeclare @jieshou int\nexec p7 '珠海',@jieshou output\nprint @jieshou\n```\n```sql\ncreate proc p8\n@ckhao char(10),@city char(10),@mianji float\nas\ninsert into ck\nvalues (@ckhao,@city,@mianji)\n```\n```sql\nexec p8 'WH10','增城',1000\n```\n```sql\nselect * from ck\n```\n# 存储过程使用事务\n实例\n```sql\nCreate Procedure  MyProcedure\nAS\nBegin\nSet    NOCOUNT    ON;\nSet XACT_ABORT ON;\nbegin   tran  ok  --开始一个事务OK\ndelete  from  rxqz  where qz=   'rx015 ' --删除数据\nsave   tran  bcd   --保存一个事务点命名为bcd\nupdate  sz  set   name='李丽s' where name= '李丽'--修改数据\nif  @@error<>0  --判断修改数据有没有出错\nbegin --如果出错\nrollback   tran  bcd  -- 回滚事务到BCD 的还原点\ncommit   tran  ok  --提交事务\nend\nelse  --没有出错\ncommit  tran ok --提交事务\nEnd\n```","tags":["SQL"],"categories":["Database"]},{"title":"SQL 各章练习题","path":"/posts/SQLtest.html","content":"SQL数据库原理练习题\n<!--more-->\n# 第一章 绪论\n## 一,选择题\n1. DBS是采用了数据库技术的计算机系统,DBS是一个集合体,包含数据库,计算机硬件,软件和( C ).\n\nA.系统分析员 B. 程序员 C. 数据库管理员 D. 操作员\n2. 数据库(DB),数据库系统(DBS)和数据库管理系统(DBMS)之间的关系是( A).\n\nA. DBS包括DB和DBMS B. DBMS包括DB和DBS\nC. DB包括DBS和DBMS D. DBS就是DB,也就是DBMS\n3. 下面列出的数据库管理技术发展的三个阶段中,没有专门的软件对数据进行管理的是( D).\nI.人工管理阶段\nII.文件系统阶段\nIII.数据库阶段\n\nA. I 和 II B. 只有 II\nC. II 和 III D. 只有 I\n4. 下列四项中,不属于数据库系统特点的是( C) .\n\nA. 数据共享 B. 数据完整性 C. 数据冗余度高 D. 数据独立性高\n5. 数据库系统的数据独立性体现在( B) .\n\nA.不会因为数据的变化而影响到应用程序\nB.不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序\nC.不会因为存储策略的变化而影响存储结构\nD.不会因为某些存储结构的变化而影响其他的存储结构\n6. 描述数据库全体数据的全局逻辑结构和特性的是( A) .\n\nA. 模式 B. 内模式 C. 外模式 D. 用户模式\n7. 要保证数据库的数据独立性,需要修改的是(C ) .\n\nA. 模式与外模式 B. 模式与内模式\nC. 三层之间的两种映射 D. 三层模式\n8. 要保证数据库的逻辑数据独立性,需要修改的是(A ) .\n\nA. 模式与外模式的映射 B. 模式与内模式之间的映射\nC. 模式 D. 三层模式\n9. 用户或应用程序看到的那部分局部逻辑结构和特征的描述是(C),它是模式的逻辑子集.\n\nA.模式 B. 物理模式 C. 子模式 D. 内模式\n10. 下述(D )不是DBA数据库管理员的职责 .\n\nA.完整性约束说明 B. 定义数据库模式\nC.数据库安全 D. 数据库管理系统设计\n\n选择题答案:\n\n(1) C (2) A (3) D (4) C (5) B\n(6) A (7) C (8) A (9) C (10) D\n## 二,简答题\n1. 试述数据,数据库,数据库系统,数据库管理系统的概念.\n\n`数据`:\n描述事物的符号记录称为数据.数据的种类有文字,图形,图象,声音,正文等等.数据与其语义是不可分的.\n\n解析:\n\n在现代计算机系统中数据的概念是广义的.早期的计算机系统主要用于科学计算,处理的数据是整数,实数,浮点数等传统数学中的数据等.现在计算机能存储和处理的对象十分广泛,表示这些对象的 数据也越来越复杂.\n数据与其语义是不可分的.500这个数字可以表示一件物品的价格是500元,也可以表示一个学术会议参加的人数有500人.还可以表示一袋奶粉重500克.\n\n`数据库`:\n数据库是长期储存在计算机内,有组织的,可共享的数据集合.数据库中的数据按一定的数据模型组织,描述和储存,具有较小的冗余度,较高的数据独立性和易扩展性,并可为各种用户共享.\n\n解析:简单地讲,数据数据库数据具有永久储存,有组织和可共享三个特点.\n数据模型是数据库的核心概念.每个数据库中数据的都是按照某一种数据模型来组织的.\n\n`数据库系统`:\n数据库系统(DBS)是指在计算机系统中引入数据库后的系统构成.数据库系统由数据库,数据库管理系统(及其开发工具),应用系统,数据库管理员构成.\n\n解析:\n\n数据库系统和数据库是两个概念.数据库系统是一个人-机系统,数据库是数据库系统的一个组成部分.但是在日常工作中人们常常把把数据库系统简称为数据库.希望读者能够从人们讲话或文章的上下文中区分\"数据库系统\"和\"数据库\".\n\n不要引起混淆.\n\n`数据库管理系统`:\n数据库管理系统(DBMS)是位于用户与操作系统之间的一层数据管理软件.用于科学地组织和存储数据,高效地获取和维护数据.DBMS主要功能包括数据定义功能,数据操纵功能,数据库的运行管理功能,数据库的建立和维护功能.\n\n解析:\n\nDBMS是一个大型复杂的软件系统.是计算机中的基础软件.目前,专门研制DBMS的厂商及其研制的DBMS产品很多.著名的有美国IBM公司的DB2关系数据库管理系统,IMS层次数据库管理系统;美国ORACLE公司的ORACLE关系数据库管理系统;SYBASE公司的SYBASE关系数据库管理系统;美国微软公司的SQL SERVER关系数据库管理系统等等.\n\n2. 使用数据库系统有什么好处\n使用数据库系统的好处是由数据库管理系统的特点或优点决定的.\n使用数据库系统的好处很多,例如可以大大提高应用开发的效率,方便用户的使用,减轻数据库系统管理人员维护的负担等.\n\n为什么有这些好处,可以结合第5题来回答.\n\n使用数据库系统可以大大提高应用开发的效率.因为在数据库系统中应用程序不必考虑数据的定义,存储和数据存取的具体路径,这些工作都由DBMS来完成.用一个通俗的比喻,使用了DBMS就如有了一个好参谋好助手,许多具体的技术工作都由这个助手来完成.开发人员就可以专注于应用逻辑的设计而不必为管理数据的许许多多复杂的细节操心.\n\n还有,当应用逻辑改变,数据的逻辑结构需要改变时,由于数据库系统提供了数据与程序之间的独立性.数据逻辑结构的改变是DBA的责任,开发人员不必修改应用程序,或者只需要修改很少的应用程序.从而既简化了应用程序的编制,又大大减少了应用程序的维护和修改.\n\n使用数据库系统可以减轻数据库系统管理人员维护系统的负担.因为DBMS在数据库建立,运用和维护时对数据库进行统一的管理和控制,包括数据的完整性,安全性,多用户并发控制,故障恢复等等都由DBMS执行.\n\n总之,使用数据库系统的优点是很多的,既便于数据的集中管理,控制数据冗余,可以提高数据的利用率和一致性,又有利于应用程序的开发和维护.读者可以在自己今后的工作中结合具体应用,认真加以体会和总结.\n\n3. 试述文件系统与数据库系统的区别和联系.\n文件系统与数据库系统的区别:\n\n文件系统面向某一应用程序,共享性差,冗余度大,独立性差,纪录内有结构,整体无结构,应用程序自己控制.\n\n数据库系统面向现实世界,共享性高,冗余度小,具有高度的物理独立性和一定的逻辑独立性,整体结构化,用数据模型描述,由数据库管理系统提供数据安全性,完整性,并发控制和恢复能力.\n\n读者可以参考《概论》书中表1.1 中的有关内容.\n\n文件系统与数据库系统的联系是:文件系统与数据库系统都是计算机系统中管理数据的软件.\n解析:\n\n文件系统是操作系统的重要组成部分,而DBMS是独立于操作系统的软件.但是DBMS是在操作系统的基础上实现的.数据库中数据的组织和存储是通过操作系统中文件系统来实现的.\n\n读者可以参考书中第十一章《数据库管理系统》.或者说,读者进一步学习数据库管理系统实现的有关课程(第十一章只是DBMS实现技术的概述)后可以对本题有深入的理解和全面的解答.因为DBMS的实现与操作系统中的文件系统是紧密相关的.例如,数据库实现的基础是文件,对数据库的任何操作最终要转化为对文件的操作.所以在DBMS实现中数据库物理组织的基本问题是如何利用或如何选择操作系统提供的基本的文件组织方法.这里我们就不具体展开了.\n\n4. 举出适合用文件系统而不是数据库系统的例子;再举出适合用数据库系统的应用例子.\n适用于文件系统而不是数据库系统的应用例子\n\n数据的备份,软件或应用程序使用过程中的临时数据存储一般使用文件比较合适.\n早期功能比较简单,比较固定的应用系统也适合用文件系统.\n适用于数据库系统而非文件系统的应用例子\n\n目前,几乎所有企业或部门的信息系统都以数据库系统为基础,都使用数据库.如一个工厂的管理信息系统(其中会包括许多子系统,如库存管理系统,物资采购系统,作业调度系统,设备管理系统,人事管理系统等等),还比如学校的学生管理系统,人事管理系统,图书馆的图书管理系统等等都适合用数据库系统.\n\n希望同学们能举出自己了解的应用例子.\n\n5. 试述数据库系统的特点.\n\n数据库系统的主要特点有:\n- 一,数据结构化\n数据库系统实现整体数据的结构化,这是数据库的主要特征之一,也是数据库系统与文件系统的本质区别.\n\n解析:\n\n注意这里\"整体\"两个字.在数据库系统中,数据不再针对某一个应用,而是面向全组织,具有整体的结构化.不仅数据是结构化的,而且数据的存取单位即一次可以存取数据的大小也很灵活.可以小到某一个数据项(如一个学生的姓名),大到一组记录(成千上万个学生记录).而在文件系统中,数据的存取单位只有一个:记录.如一个学生的完整记录.\n\n- 二. 数据的共享性高,冗余度低,易扩充\n\n数据库的数据不再面向某个应用而是面向整个系统,因此可以被多个用户,多个应用,用多种不同的语言共享使用.由于数据面向整个系统,是有结构的数据,不仅可以被多个应用共享使用,而且容易增加新的应用,这就使得数据库系统弹性大,易于扩充.\n\n解析:\n\n数据共享可以大大减少数据冗余,节约存储空间,同时还能够避免数据之间的不相容性与不一致性.\n\n所谓\"数据面向某个应用\"是指数据结构是针对某个应用设计的,只被这个应用程序或应用系统使用.可以说数据是某个应用的\"私有资源\".\n\n所谓\"弹性大\"是指系统容易扩充也容易收缩,即应用增加或减少时不必修改整个数据库的结构,或者只要做很少的修改.\n\n我们可以取整体数据的各种子集用于不同的应用系统,当应用需求改变或增加时,只要重新选取不同的子集或加上一部分数据便可以满足新的需求.\n三,数据独立性高\n\n数据独立性包括数据的物理独立性和数据的逻辑独立性.\n\n数据库管理系统的模式结构和二级映象功能保证了数据库中的数据具有很高的物理独立性和逻辑独立性.\n\n解析:\n\n所谓\"独立性\"即相互不依赖.数据独立性是指数据和程序相互不依赖.即数据的逻辑结构或物理结构改变了,程序不会跟着改变.数据与程序的独立,把数据的定义从程序中分离出去,加上数据的存取又由DBMS负责,简化了应用程序的编制,大大减少了应用程序的维护和修改.\n\n四,数据由DBMS统一管理和控制\n\n数据库的共享是并发的共享,即多个用户可以同时存取数据库中的数据甚至可以同时存取数据库中同一个数据.为此,DBMS必须提供统一的数据控制功能,包括数据的安全性保护,数据的完整性检查,并发控制和数据库恢复.\n\n解析:\n\nDBMS数据控制功能包括四个方面:\n\n数据的安全性保护:保护数据以防止不合法的使用造成的数据的泄密和破坏;\n\n数据的完整性检查:将数据控制在有效的范围内或保证数据之间满足一定的关系;\n\n并发控制:对多用户的并发操作加以控制和协调,保证并发操作的正确性;\n\n数据库恢复:当计算机系统发生硬件故障,软件故障,或者由于操作员的失误以及故意的破坏影响数据库中数据的正确性,甚至造成数据库部分或全部数据的丢失时,能将数据库从错误状态恢复到某一已知的正确状态(亦称为完整状态或一致状态).\n\n下面我们可以得到\"什么是数据库\"的一个定义:\n\n数据库是长期存储在计算机内有组织的大量的共享的数据集合.它可以供各种用户共享,具有最小冗余度和较高的数据独立性.DBMS在数据库建立,运用和维护时对数据库进行统一控制,以保证数据的完整性,安全性,并在多用户同时使用数据库时进行并发控制,在发生故障后对系统进行恢复.\n\n数据库系统的出现使信息系统从以加工数据的程序为中心转向围绕共享的数据库为中心的新阶段.\n\n\n\n6. 数据库管理系统的主要功能有哪些\n\n① 数据库定义功能;\n\n② 数据存取功能;\n\n③ 数据库运行管理;\n\n④ 数据库的建立和维护功能.\n\n7. 试述数据模型的概念,数据模型的作用和数据模型的三个要素.\n\n数据模型是数据库中用来对现实世界进行抽象的工具,是数据库中用于提供信息表示和操作手段的形式构架.\n\n一般地讲,数据模型是严格定义的概念的集合.这些概念精确地描述系统的静态特性,动态特性和完整性约束条件.因此数据模型通常由数据结构,数据操作和完整性约束三部分组成.\n\n① 数据结构:是所研究的对象类型的集合,是对系统的静态特性的描述.\n② 数据操作:是指对数据库中各种对象(型)的实例(值)允许进行的操作的集合,包括操作及有关的操作规则,是对系统动态特性的描述.\n③ 数据的约束条件:是完整性规则的集合,完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则,用以限定符合数据模型的数据库状态以及状态的变化,以保证数据的正确,有效,相容.\n\n解析:\n\n数据模型是数据库系统中最重要的概念之一.同学们必须通过《概论》的学习真正掌握\n\n数据模型的概念和作用.\n\n数据模型是数据库系统的基础.任何一个DBMS都以某一个数据模型为基础,或者说支持某一个数据模型.\n\n数据库系统中模型有不同的层次.根据模型应用的不同目的,可以将模型分成两类或说两个层次:一是概念模型,是按用户的观点来对数据和信息建模,用于信息世界的建模,强调语义表达能力,概念简单清晰;另一是数据模型,是按计算机系统的观点对数据建模,用于机器世界,人们可以用它定义,操纵数据库中的数据.一般需要有严格的形式化定义和一组严格定义了语法和语义的语言,并有一些规定和限制,便于在机器上实现.\n\n8. 试述概念模型的作用.\n概念模型实际上是现实世界到机器世界的一个中间层次.概念模型用于信息世界的建模,是现实世界到信息世界的第一层抽象,是数据库设计人员进行数据库设计的有力工具,也是数据库设计人员和用户之间进行交流的语言.\n9. 定义并解释概念模型中以下术语:\n实体,实体型,实体集,属性,码,实体联系图(E-R图)\n\n- `实体`:客观存在并可以相互区分的事物叫实体.\n- `实体型`:具有相同属性的实体具有相同的特征和性质,用实体名及其属性名集合来抽象和刻画同类实体称为实体型.\n- `实体集`:同型实体的集合称为实体集.\n- `属性`:实体所具有的某一特性,一个实体可由若干个属性来刻画.\n- `码`:唯一标识实体的属性集称为码.\n- `实体联系图`:E-R图提供了表示实体型,属性和联系的方法:\n- `实体型`:用矩形表示,矩形框内写明实体名.\n- `属性`:用椭圆形表示,并用无向边将其与相应的实体连接起来.\n- `联系`:用菱形表示,菱形框内写明联系名,并用无向边分别与有关实体连接起来,同时在无向边旁标上联系的类型(1 : 1,1 : n或m : n).\n\n10. 试给出三个实际部门的E-R图,要求实体型之间具有一对一,一对多,多对多各种不同的联系.\n\n# 第二章 关系数据库\n\n## 一.选择题\n1. 下面的选项不是关系数据库基本特征的是(A ).\n\nA.不同的列应有不同的数据类型\nB.不同的列应有不同的列名\nC.与行的次序无关\nD.与列的次序无关\n2. 一个关系只有一个(D) .\n\nA.候选码 B. 外码 C. 超码 D. 主码\n3. 关系模型中,一个码是(C ).\n\nA.可以由多个任意属性组成\nB.至多由一个属性组成\nC.可有多个或者一个其值能够唯一表示该关系模式中任何元组的属性组成\nD.以上都不是\n4. 现有如下关系:\n患者(患者编号,患者姓名,性别,出生日起,所在单位)\n\n医疗(患者编号,患者姓名,医生编号,医生姓名,诊断日期,诊断结果)\n其中,医疗关系中的外码是(A ).\n\nA. 患者编号 B. 患者姓名\nC. 患者编号和患者姓名 D. 医生编号和患者编号\n5. 现有一个关系:借阅(书号,书名,库存数,读者号,借期,还期),假如同一本书允许一个读者多次借阅,但不能同时对一种书借多本,则该关系模式的外码是( D).\n\nA. 书号 B. 读者号\nC. 书号+读者号 D. 书号+读者号+借期\n6. 关系模型中实现实体间 N:M 联系是通过增加一个(A ) .\n\nA.关系实现 B. 属性实现 C. 关系或一个属性实现 D. 关系和一个属性实现\n7. 关系代数运算是以( C)为基础的运算 .\n\nA. 关系运算 B. 谓词演算 C. 集合运算 D. 代数运算\n8. 关系数据库管理系统应能实现的专门关系运算包括( B).\n\nA. 排序,索引,统计 B. 选择,投影,连接\nC. 关联,更新,排序 D. 显示,打印,制表\n9. 五种基本关系代数运算是( A).\n\nA.∪-×σπ\nB.∪-σπ\nC.∪∩×σπ\nD.∪∩σπ\n10. 关系代数表达式的优化策略中,首先要做的是(B ) .\n\nA.对文件进行预处理  B.尽早执行选择运算\nC.执行笛卡尔积运算  D.投影运算\n11. 关系数据库中的投影操作是指从关系中(B ) .\n\nA.抽出特定记录 B. 抽出特定字段\nC.建立相应的影像 D. 建立相应的图形\n12. 从一个数据库文件中取出满足某个条件的所有记录形成一个新的数据库文件的操作是(C )操作 .\n\nA.投影 B. 联接 C. 选择 D. 复制\n13. 关系代数中的联接操作是由(B )操作组合而成 .\n\nA.选择和投影 B. 选择和笛卡尔积\nC.投影,选择,笛卡尔积 D. 投影和笛卡尔积\n14. 自然联接是构成新关系的有效方法.一般情况下,当对关系R和S是用自然联接时,要求R和S含有一个或者多个共有的(C).\n\nA.记录 B. 行 C. 属性 D. 元组\n15. 假设有关系R和S,在下列的关系运算中,(D )运算不要求:\"R和S具有相同的元数,且它们的对应属性的数据类型也相同\" .\n\nA.R∩S B. R∪S C. R-S D. R×S\n16. 假设有关系R和S,关系代数表达式R-(R-S)表示的是(A ).\n\nA.R∩S B. R∪S C. R-S D. R×S\n17. 下面列出的关系代数表达是中,那些式子能够成立( C) .\nⅰ. σf1 ( σf2 (E)) = σf1∧f2 (E)\nⅱ. E1∞E2 = E2∞E1\nⅲ. (E1∞E2)∞E3 = E1∞ (E2∞E3)\nⅳ. σf1 ( σf2 (E)) =σf2 ( σf1(E))\n\nA.全部 B. ⅱ和ⅲ C. 没有 D. ⅰ和ⅳ\n18. 下面四个关系表达式是等价的,是判别它们的执行效率( A) .\nE1 =πA (σ B=C ∧ D=E′ (R×S) )\nE2 =πA (σ B=C (R× σD=E′ (S) )\nE3 =πA (R∞B=CσD=E′(S) )\nE3 =πA (σD=E′ (R∞B=C S) )\n\nA. E3最快 B. E2最快 C. E4最快 D. E1最快\n19. 有关系SC(S_ID,C_ID,AGE,SCORE),查找年龄大于22岁的学生的学号和分数,正确的关系代数表达式是(D) .\nⅰ. πS_ID,SCORE (σ age>22 (SC) )\nⅱ. σ age>22 (πS_ID,SCORE (SC) )\nⅲ. πS_ID,SCORE (σ age>22 (πS_ID,SCORE,AGE (SC) ) )\n\nA.ⅰ和 ⅱ B. 只有ⅱ正确 C. 只有 ⅰ正确 D. ⅰ和ⅲ正确\n\n选择题答案:\n(1) A (2) D (3) C (4) A (5) D\n(6) A (7) C (8) B (9) A (10) B\n(11) B (12) C (13) B (14) C (15)D\n(16) A (17) C (18) A (19) D\n\n## 二,简答题\n\n1. 试述关系模型的三个组成部分.\n2. 试述关系数据语言的特点和分类.\n3. 设有一个SPJ数据库,包括S,P,J,SPJ四个关系模式:\nS( SNO,SNAME,STATUS,CITY);\n\nP(PNO,PNAME,COLOR,WEIGHT);\n\nJ(JNO,JNAME,CITY);\n\nSPJ(SNO,PNO,JNO,QTY);\n\n供应商表S由供应商代码(SNO),供应商姓名(SNAME),供应商状态(STATUS),供应商所在城市(CITY)组成;零件表P由零件代码(PNO),零件名(PNAME),颜色(COLOR),重量(WEIGHT)组成;工程项目表J由工程项目代码(JNO),工程项目名(JNAME),工程项目所在城市(CITY)组成;供应情况表SPJ由供应商代码(SNO),零件代码(PNO),工程项目代码(JNO),供应数量(QTY)组成,表示某供应商供应某种零件给某工程项目的数量为QTY.\n\n试用关系代数完成如下查询:\n\n(1) 求供应工程J1零件的供应商号码SNO;\n\n(2) 求供应工程J1零件P1的供应商号码SNO;\n\n(3) 求供应工程J1零件为红色的供应商号码SNO;\n\n(4) 求没有使用天津供应商生产的红色零件的工程号JNO;\n\n(5) 求至少用了供应商S1所供应的全部零件的工程号JNO.\n\n4. 定义并理解下列术语,说明它们之间的联系与区别:\n\n(1). 域,笛卡尔积,关系,元组,属性\n(2). 主码,候选码,外码\n(3). 关系模式,关系,关系数据库\n\n5. 试述关系模型的完整性规则.在参照完整性中,为什么外码属性的值有时也可以为空 什么情况下才可以为空\n\n6. 试述等值连接与自然连接的区别和联系.\n\n7. 关系代数的基本运算有哪些\n\n8. 试用关系代数的基本运算来表示其他运算.\n\n# 第三章 SQL语言\n\n## 一,选择题\n\n1. SQL语言是(B)的语言,容易学习 .\n\nA. 过程化 B. 非过程化\nC. 格式化 D. 导航式\n\n2. SQL语言的数据操纵语句包括SELECT,INSERT,UPDATE,DELETE等.其中最重要的,也是使用最频繁的语句是(A) .\n\nA. SELECT B. INSERT\nC. UPDATE D. DELETE\n3. 在视图上不能完成的操作是( C) .\n\nA. 更新视图 B. 查询\nC. 在视图上定义新的表 D. 在视图上定义新的视图\n4. SQL语言集数据查询,数据操纵,数据定义和数据控制功能于一体,其中,CREATE,DROP,ALTER语句是实现哪种功能(C ).\n\nA. 数据查询 B. 数据操纵\nC. 数据定义 D. 数据控制\n5. SQL语言中,删除一个视图的命令是( B).\n\nA.DELETE B.DROP C.CLEAR D.REMOVE\n6. 在SQL语言中的视图VIEW是数据库的( A) .\n\nA. 外模式 B. 模式 C. 内模式 D. 存储模式\n7. 下列的SQL语句中,( D)不是数据定义语句.\n\nA. CREATE TABLE B. DROP VIEW\nC. CREATE VIEW D. GRANT\n8. 若要撤销数据库中已经存在的表S,可用(C ).\n\nA. DELETE TABLE S B. DELETE S\nC. DROP TABLE S D. DROP S\n9. 若要在基本表S中增加一列CN(课程名),可用( C).\n\nA. ADD TABLE S(CN CHAR(8))\nB. ADD TABLE S ALTER(CN CHAR(8))\nC. ALTER TABLE S ADD(CN CHAR(8))\nD. ALTER TABLE S (ADD CN CHAR(8))\n10. 学生关系模式 S( S#,Sname,Sex,Age),S的属性分别表示学生的学号,姓名,性别,年龄.要在表S中删除一个属性\"年龄\",可选用的SQL语句是(B ).\n\nA. DELETE Age from S\nB. ALTER TABLE S DROP Age\nC. UPDATE S Age\nD. ALTER TABLE S 'Age'\n11. 有关系S(S#,SNAME,SAGE),C(C#,CNAME),SC(S#,C#,GRADE).其中S#是学生号,SNAME是学生姓名,SAGE是学生年龄, C#是课程号,CNAME是课程名称.要查询选修\"ACCESS\"课的年龄不小于20的全体学生姓名的SQL语句是SELECT SNAME FROM S,C,SC WHERE子句.这里的WHERE子句的内容是(A).\n\nA. S.S# = SC.S# and C.C# = SC.C# and SAGE>=20 and CNAME='ACCESS'\nB. S.S# = SC.S# and C.C# = SC.C# and SAGE in>=20 and CNAME in 'ACCESS'\nC. SAGE in>=20 and CNAME in 'ACCESS'\nD. SAGE>=20 and CNAME=' ACCESS'\n12. 设关系数据库中一个表S的结构为S(SN,CN,grade),其中SN为学生名,CN为课程名,二者均为字符型;grade为成绩,数值型,取值范围0-100.若要把\"张二的化学成绩80分\"插入S中,则可用( D).\n\nA. ADD INTO S VALUES('张二','化学','80')\nB. INSERT INTO S VALUES('张二','化学','80')\nC. ADD INTO S VALUES('张二','化学',80)\nD. INSERT INTO S VALUES('张二','化学',80)\n13. 设关系数据库中一个表S的结构为:S(SN,CN,grade),其中SN为学生名,CN为课程名,二者均为字符型;grade为成绩,数值型,取值范围0-100.若要更正王二的化学成绩为85分,则可用( A) .\n\nA. UPDATE S SET grade=85 WHERE SN='王二' AND CN='化学'\nB. UPDATE S SET grade='85' WHERE SN='王二' AND CN='化学'\nC. UPDATE grade=85 WHERE SN='王二' AND CN='化学'\nD. UPDATE grade='85' WHERE SN='王二' AND CN='化学'\n14. 在SQL语言中,子查询是(D) .\n\nA. 返回单表中数据子集的查询语言\nB. 选取多表中字段子集的查询语句\nC. 选取单表中字段子集的查询语句\nD. 嵌入到另一个查询语句之中的查询语句\n15. SQL是一种(C )语言.\n\nA. 高级算法 B. 人工智能\nC. 关系数据库 D. 函数型\n16. 有关系S(S#,SNAME,SEX),C(C#,CNAME),SC(S#,C#,GRADE).其中S#是学生号,SNAME是学生姓名,SEX是性别, C#是课程号,CNAME是课程名称.要查询选修\"数据库\"课的全体男生姓名的SQL语句是SELECT SNAME FROM S,C,SC WHERE子句.这里的WHERE子句的内容是( A).\n\nA.S.S# = SC.S# and C.C# = SC.C# and SEX='男' and CNAME='数据库'\nB.S.S# = SC.S# and C.C# = SC.C# and SEX in'男'and CNAME in'数据库'\nC.SEX '男' and CNAME ' 数据库'\nD.S.SEX='男' and CNAME=' 数据库'\n\n17. 若用如下的SQL语句创建了一个表SC:\nCREATE TABLE SC (S# CHAR(6) NOT NULL,C# CHAR(3) NOT NULL,SCORE INTEGER,NOTE CHAR(20));向SC表插入如下行时,( B)行可以被插入 .\n\nA.('201009','111',60,必修)\nB.('200823','101',NULL,NULL)\nC.(NULL,'103',80,'选修')\nD.('201132',NULL,86,' ')\n18. 假设学生关系S(S#,SNAME,SEX),课程关系C(C#,CNAME),学生选课关系SC(S#,C#,GRADE).要查询选修\"Computer\"课的男生姓名,将涉及到关系( D).\n\nA. S B. S,SC C. C,SC D. S,C,SC\n\n选择题答案:\n(1) B (2) A (3) C (4) C (5) B\n(6) A (7) D (8) C (9) C (10) B\n(11) A (12) D (13) A (14) D (15) C\n(16) A (17) B (18) D\n\n## 二,简答题\n1. 试述SQL语言的特点.\n\n答:\n\n1) 综合统一. SQL语言集数据定义语言DDL,数据操纵语言DML,数据控制语言DCL的功能于一体.\n\n2) 高度非过程化.用SQL语言进行数据操作,只要提出\"做什么\",而无须指明\"怎么做\",因此无需了解存取路径,存取路径的选择以及SQL语句的操作过程由系统自动完成.\n\n3) 面向集合的操作方式.SQL语言采用集合操作方式,不仅操作对象,查找结果可以是元组的集合,而且一次插入,删除,更新操作的对象也可以是元组的集合.\n\n4) 以同一种语法结构提供两种使用方式.SQL语言既是自含式语言,又是嵌入式语言.作为自含式语言,它能够独立地用于联机交互的使用方式,也能够嵌入到高级语言程序中,供程序员设计程序时使用.\n\n5) 语言简捷,易学易用.\n\n2. 试述SQL的定义功能.\n\n答:\n\nSQL的数据定义功能包括定义表,定义视图和定义索引.\n\nSQL语言使用CREATE TABLE语句定义建立基本表,;ALTER TABLE语句修改基本表定义,DROP TABLE语句删除基本表;建立索引使用CREATE INDEX语句建立索引, DROP INDEX语句删除索引表;SQL语言使用CREATE VIEW命令建立视图,DROP VIEW语句删除视图.\n3. 用SQL语句建立第3章习题3中的四个表.\n\n答:\n\n对于S表:S( SNO,SNAME,STATUS,CITY);\n\n建S表\n```swl\nCREATE TABLE S\n(SNO CHAR(3),\nSNAME CHAR(10)\nSTATUS CHAR(2)\nCITY CHAR(10))\n```\nP(PNO,PNAME,COLOR,WEIGHT);\n\n建P表\n```sql\nCREATE TABLE P\n(PNO CHAR(3),\nPNAME CHAR(10),\nCOLOR CHAR(4),\nWEIGHT INT);\nJ(JNO,JNAME,CITY);\n```\n建J表\n```sql\nCREATE TABLE J\n(JNO CHAR(3),\nJNAME CHAR(10)\nCITY CHAR(10))\n```\nSPJ(SNO,PNO,JNO,QTY)\n\n建SPJ表\n```sql\nCREATE TABLE SPJ\n(SNO CHAR(3),\nPNO CHAR(3),\nJNO CHAR(3),\nQTY INT);\n```\n4. 针对上题中建立的四个表试用SQL语言完成第3章习题3中的查询.\n\n答:\n\n(1) 求供应工程J1零件的供应商号码SNO;\n\n```sql\nSELECT SNO\nFROM SPJ\nWHERE JNO='J1';\n```\n(2) 求供应工程J1零件P1的供应商号码SNO;\n```sql\nSELECT SNO\nFROM SPJ\nWHERE JNO='J1'\nAND PNO='P1';\n```\n(3) 求供应工程J1零件为红色的供应商号码SNO;\n```sql\nSELECT SNO\nFROM SPJ\nWHERE JNO='J1'\nAND PNO IN\n(SELECT PNO\nFROM P\nWHERE COLOR='红');\n```\n或\n```sql\nSELECT SNO\nFROM SPJ,P\nWHERE JNO='J1'\nAND SPJ.PNO=P.PNO\nAND COLOR='红';\n```\n(4) 求没有使用天津供应商生产的红色零件的工程号JNO;\n解析:\n用SQL语言表示如下:\n```sql\nSELECT JNO\nFROM J\nWHERE NOT EXISTS\n(SELECT *\nFROM SPJ\nWHERE SPJ.JNO=J.JNO\nAND SNO IN\n(SELECT SNO\nFROM S\nWHERE CITY='天津')\nAND PNO IN\n(SELECT PNO\nFROM P\nWHERE COLOR='红'));\n```\n或\n```sql\nSELECT JNO\nFROM J\nWHERE NOT EXISTS\n(SELECT *1\nFROM SPJ, S, P\nWHERE SPJ.JNO=J.JNO\nAND SPJ.SNO=S.SNO\nAND SPJ.PNO=P.PNO\nAND S.CITY='天津'\nAND P. COLOR='红');\n```\n注意:从 J 表入手,以包含那些尚未使用任何零件的工程号.\n\n(5) 求至少用了供应商S1所供应的全部零件的工程号JNO .\n\n解析:\n用SQL语言表示如下:\n```sql\nSELECT DISTINCT JNO\nFROM SPJ SPJZ\nWHERE NOT EXISTS\n(SELECT *\nFROM SPJ SPJX\nWHERE SNO='S1'\nAND NOT EXISTS\n(SELECT *\nFROM SPJ SPJY\nWHERE SPJY.PNO=SPJX.PNO\nAND SPJY.JNON=SPJZ.JNO\nAND SPJY.SNO='S1'));\nAND SPJY.SNO='S1' ));\n```\n5. 针对习题3中的四个表试用SQL语言完成以下各项操作:\n\n(1) 找出所有供应商的姓名和所在城市.\n\n(2) 找出所有零件的名称,颜色,重量.\n\n(3) 找出使用供应商S1所供应零件的工程号码.\n\n(4) 找出工程项目J2使用的各种零件的名称及其数量.\n\n(5) 找出上海厂商供应的所有零件号码.\n\n(6) 找出使用上海产的零件的工程名称.\n\n(7) 找出没有使用天津产的零件的工程号码.\n\n(8) 把全部红色零件的颜色改成蓝色.\n\n(9) 由S5供给J4的零件P6改为由S3供应,请作必要的修改.\n\n(10) 从供应商关系中删除S2的记录,并从供应情况关系中删除相应的记录.\n\n(11) 请将 (S2,J6,P4,200) 插入供应情况关系.\n\n答:\n\n(1) 找出所有供应商的姓名和所在城市.\n```sql\nSELECT SNAME, CITY\nFROM S;\n```\n(2) 找出所有零件的名称,颜色,重量.\n```sql\nSELECT PNAME, COLOR, WEIGHT\nFROM P\n```\n(3) 找出使用供应商S1所供应零件的工程号码.\n```sql\nSELECT JNO\nFROM SPJ\nWHERE SNO='S1'\n```\n(4) 找出工程项目J2使用的各种零件的名称及其数量.\n```sql\nSELECT P.PNAME, SPJ.QTY\nFROM P, SPJ\nWHERE P.PNO=SPJ.PNO\nAND SPJ.JNO='J2';\n```\n(5) 找出上海厂商供应的所有零件号码.\n```sql\nSELECT DISTINCT PNO\nFROM SPJ\nWHERE SNO IN\n(SELECT SNO\nFROM S\nWHERE CITY='上海');\n```\n(6) 找出使用上海产的零件的工程名称.\n```sql\nSELECT JNAME\nFROM J, SPJ, S\nWHERE J. JNO=SPJ. JNO\nAND SPJ. SNO=S.SNO\nAND S.CITY='上海';\n```\n或\n```sql\nSELECT JNAME\nFROM J\nWHERE JNO IN\n(SELECT JNO\nFROM SPJ, S\nWHERE SPJ. SNO=S.SNO\nAND S.CITY='上海');\n```\n(7) 找出没有使用天津产的零件的工程号码.\n```sql\nSELECT JNO\nFROM J\nWHERE NOT EXISTS\n(SELECT *\nFROM SPJ\nWHERE SPJ.JNO=J.JNO AND SNO IN\n(SELECT SNO\nFROM S\nWHERE CITY='天津'))\n```\n或\n```sql\nSELECT JNO\nFROM J\nWHERE NOT EXISTS\n(SELECT *1\nFROM SPJ, S\nWHERE SPJ.JNO=J.JNO AND SPJ.SNO=S.SNO AND S.CITY='天津')\n```\n(8) 把全部红色零件的颜色改成蓝色.\n```sql\nUPDATE P\nSET COLOR='蓝'\nWHERE COLOR='红'\n```\n(9) 由S5供给J4的零件P6改为由S3供应,请作必要的修改.\n```sql\nUPDATE SPJ\nSET SNO='S3'\nWHERE SNO='S5' AND JNO='J4' AND PNO='P6'\n```\n(10) 从供应商关系中删除S2的记录,并从供应情况关系中删除相应的记录.\n```sql\nDELETE\nFROM SPJ\nWHERE SNO='S2'\n```\n或\n```sql\nDELETE\nFROM S\nWHERE SNO='S2'\n```\n解析:注意删除顺序,应该先从SPJ表中删除供应商S2所供应零件的记录,然后从从S表中删除S2.\n\n(11) 请将 (S2,J6,P4,200) 插入供应情况关系.\n```sql\nINSERT INTO SPJ(SNO, JNO, PNO, QTY)\nVALUES (S2,J6,P4,200);\n```\n或\n```sql\nINSERT INTO SPJ\nVALUES (S2,P4,J6,200);\n```\n6. 什么是基本表 什么是视图 两者的区别和联系是什么\n\n答:\n\n基本表是本身独立存在的表,在SQL中一个关系就对应一个表.\n\n视图是从一个或几个基本表导出的表.视图本身不独立存储在数据库中,是一个虚表.即数据库中只存放视图的定义而不存放视图对应的数据,这些数据仍存放在导出视图的基本表中.视图在概念上与基本表等同,用户可以如同基本表那样使用视图,可以在视图上再定义视图.\n\n7. 试述视图的优点.\n\n答:\n\n(1) 视图能够简化用户的操作.\n\n(2) 视图使用户能以多种角度看待同一数据.\n\n(3) 视图对重构数据库提供了一定程度的逻辑独立性.\n\n(4) 视图能够对机密数据提供安全保护.\n\n8. 所有的视图是否都可以更新 为什么\n\n答:\n\n不是.视图是不实际存储数据的虚表,因此对视图的更新,最终要转换为对基本表的更新.因为有些视图的更新不能唯一地有意义地转换成对相应基本表的更新,所以,并不是所有的视图都是可更新的.如《概论》3.5.1中的视图S_G(学生的学号及他的平均成绩)\n```sql\nCREAT VIEW S_G(Sno,Gavg)\nAS SELECT Sno,AVG(Grade)\nFROM SC\nGROUP BY Sno;\n```\n要修改平均成绩,必须修改各科成绩,而我们无法知道哪些课程成绩的变化导致了平均成绩的变化.\n9. 哪类视图是可以更新的,哪类视图是不可更新的 各举一例说明.\n答:\n\n基本表的行列子集视图一般是可更新的.如《概论》3.5.3中的例1.\n若视图的属性来自集函数,表达式,则该视图肯定是不可以更新的.\n\n如《概论》3.5.3中的S_G视图.\n10. 试述某个你熟悉的实际系统中对视图更新的规定.\n\n答:(略)\n\n解析:不同的系统对视图更新的规定是不同的,读者必须了解你所用系统对视图更新的规定.\n11. 请为三建工程项目建立一个供应情况的视图,包括供应商代码(SNO),零件\n代码(PNO),供应数量(QTY).针对该视图完成下列查询:\n\n(1) 找出三建工程项目使用的各种零件代码及其数量.\n(2) 找出供应商S1的供应情况.\n\n答:建视图:\n```sql\nCREATE VIEW V_SPJ AS\nSELECT SNO, PNO, QTY\nFROM SPJ\nWHERE JNO=\n(SELECT JNO\nFROM J\nWHERE JNAME='三建');\n```\n对该视图查询:\n\n(1) 找出三建工程项目使用的各种零件代码及其数量.\n```sql\nSELECT PNO, QTY\nFROM V_SPJ;\n```\n(2) 找出供应商S1的供应情况.\n```sql\nSELECT PNO, QTY /* S1供应三建工程的零件号和对应的数量*/\nFROM V_SPJ\nWHERE SNO='S1';\n```\n# 第四章 关系系统及其优化\n\n## 一,选择题\n\n1. 概念模型是现实世界的第一层抽象,这一类最著名的模型是(D) .\n\nA.层次模型 B. 关系模型 C. 网状模型 D. 实体-关系模型\n2. 区分不同实体的依据是( B) .\n\nA. 名称 B. 属性 C. 对象 D. 概念\n3. 关系数据模型是目前最重要的一种数据模型,它的三个要素分别为(B).\n\nA.实体完整,参照完整,用户自定义完整\nB.数据结构,关系操作,完整性约束\nC.数据增加,数据修改,数据查询\nD.外模式,模式,内模式\n4. 在(A )中一个结点可以有多个双亲,节点之间可以有多种联系.\n\nA.网状模型 B. 关系模型\nC.层次模型 D. 以上都有\n5. (B )的存取路径对用户透明,从而具有更高的数据独立性,更好的安全保密性,\n也简化了程序员的工作和数据库开发建立的工作.\n\nA.网状模型 B. 关系模型\nD.层次模型 D. 以上都有\n6. 在关系数据库中,要求基本关系中所有的主属性上不能有空值,其遵守的约束规则是( C) .\n\nA.数据依赖完整性规则 B. 用户定义完整性规则\nC.实体完整性规则 D. 域完整性规则\n\n选择题答案:\n(1) D (2) B (3) B (4) A (5) B (6) C\n\n## 二,简答题\n\n1. 试述关系模型的三个组成部分.\n\n答:关系模型由关系数据结构,关系操作集合和关系完整性约束三部分组成.\n\n2. 试述关系数据语言的特点和分类.\n\n答:关系数据语言可以分为三类:\n\n关系代数语言 例如ISBL\n\n关系演算语言 (元组关系演算语言 例如APLHA,QUEL 和 域关系演算语言 例如QBE)\n\n具有关系代数和关系演算双重特点的语言 例如SQL\n\n这些关系数据语言的共同特点是,具有完备的表达能力,是非过程化的集合操作语言,功能强,能够嵌入高级语言中使用.\n\n3. 定义并理解下列术语,说明它们之间的联系与区别:\n\n(1) 域,关系,元组,属性\n\n答:\n\n域:域是一组具有相同数据类型的值的集合.\n\n关系:在域D1,D2,…,Dn上笛卡尔积D1×D2×…×Dn的子集称为关系,表示为R(D1,D2,…,Dn)\n\n元组:关系中的每个元素是关系中的元组.\n\n属性:关系也是一个二维表,表的每行对应一个元组,表的每列对应一个域.由于域可以相同,为了加以区分,必须对每列起一个名字,称为属性(Attribute).\n\n(2) 主码,候选码,外部码\n\n答:\n\n`候选码`:若关系中的某一属性组的值能唯一地标识一个元组,则称该属性组为候选码(Candidate key).\n\n`主码`:若一个关系有多个候选码,则选定其中一个为主码(Primary key).\n`外部码`:设F是基本关系R的一个或一组属性,但不是关系R的码,如果F与基本关系S的主码Ks相对应,则称F是基本关系R的外部码(Foreign key),简称外码.\n\n基本关系R称为参照关系(Referencing relation),基本关系S称为被参照关系(Referenced relation)或目标关系(Target relation).关系R和S可以是相同的关系.\n\n(3) 关系模式,关系,关系数据库\n\n关系模式:关系的描述称为关系模式(Relation Schema).它可以形式化地表示为:R(U,D,dom,F)\n\n其中R为关系名,U为组成该关系的属性名集合,D为属性组U中属性所来自的域,dom为属性向域的映象集合,F为属性间数据的依赖关系集合.\n\n关系:在域D1,D2,…,Dn上笛卡尔积D1×D2×…×Dn的子集称为关系,表示为R(D1,D2,…,Dn)\n\n关系是关系模式在某一时刻的状态或内容.关系模式是静态的,稳定的,而关系是动态的,随时间不断变化的,因为关系操作在不断地更新着数据库中的数据.\n\n`关系数据库`:关系数据库也有型和值之分.关系数据库的型也称为关系数据库模式,是对关系数据库的描述,它包括若干域的定义以及在这些域上定义的若干关系模式.关系数据库的值是这些关系模式在某一时刻对应的关系的集合,通常就称为关系数据库.\n\n4. 试述关系模型的完整性规则.在参照完整性中,为什么外部码属性的值也可以为空 什么情况下才可以为空\n\n答:\n\n关系模型的完整性规则是对关系的某种约束条件.关系模型中可以有三类完整性约束:实体完整性,参照完整性和用户定义的完整性.\n其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件,被称作是关系的两个不变性,应该由关系系统自动支持.\n\n(1) 实体完整性规则:若属性A是基本关系R的主属性,则属性A不能取空值.\n\n(2) 参照完整性规则:若属性(或属性组)F是基本关系R的外码,它与基本关系S的主码Ks相对应(基本关系R和S不一定是不同的关系),则对于R中每个元组在F上的值必须为:\n- 或者取空值(F的每个属性值均为空值);\n- 或者等于S中某个元组的主码值.\n\n(3) 用户定义的完整性是针对某一具体关系数据库的约束条件.它反映某一具体应用所涉及的数据必须满足的语义要求.\n\n在参照完整性中,外部码属性的值可以为空,它表示该属性的值尚未确定.但前提条件是该外部码属性不是其所在关系的主属性.\n\n例如,在下面的\"学生\"表中,\"专业号\"是一个外部码,不是学生表的主属性,可以为空.其语义是,该学生的专业尚未确定.\n\n学生(学号,姓名,性别,专业号,年龄)\n专业(专业号,专业名)\n\n而在下面的\"选修\"表中的\"课程号\"虽然也是一个外部码属性,但它又是\"选修\"表的主属性,所以不能为空.因为关系模型必须满足实体完整性.\n\n课程(课程号,课程名,学分)\n选修(学号,课程号,成绩)\n\n5. 等值连接与自然连接的区别是什么\n\n答:\n\n连接运算中有两种最为重要也最为常用的连接,一种是等值连接(equi-join),另一种是自然连接(Natural join).θ为\"=\"的连接运算称为等值连接.\n它是从关系R与S的笛卡尔积中选取A,B属性值相等的那些元组.即等值连接为:RA=BS={ tr ts| tr∈R ∧ ts∈S ∧ tr[A] = ts[B] }\n\n自然连接(Natural join)是一种特殊的等值连接,它要求两个关系中进行比较的分量必须是相同的属性组,并且要在结果中把重复的属性去掉.即若R和S具有相同的属性组B,则自然连接可记作:RS={ tr ts| tr∈R ∧ ts∈S ∧ tr[B] = ts[B] }\n\n## 第五章 关系数据理论\n\n## 一,选择题\n1. 为了设计出性能较优的关系模式,必须进行规范化,规范化主要的理论依据是(A ) .\n\nA. 关系规范化理论 B. 关系代数理论\nC.数理逻辑 D. 关系运算理论\n2. 规范化理论是关系数据库进行逻辑设计的理论依据,根据这个理论,关系数据库中的关系必须满足:每一个属性都是(B ) .\n\nA. 长度不变的 B. 不可分解的\nC.互相关联的 D. 互不相关的\n3. 已知关系模式R(A,B,C,D,E)及其上的函数相关性集合F={A→D,B→C ,E→A },该关系模式的候选关键字是( B) .\n\nA. AB B. BE\nC. CD D. DE\n4. 设学生关系S(SNO,SNAME,SSEX,SAGE,SDPART)的主键为SNO,学生选课关系SC(SNO,CNO,SCORE)的主键为SNO和CNO,则关系R(SNO,CNO,SSEX,SAGE,SDPART,SCORE)的主键为SNO和CNO,其满足( A).\n\nA. 1NF B.2NF    C. 3NF D. BCNF\n5. 设有关系模式W(C,P,S,G,T,R),其中各属性的含义是:C表示课程,P表示教师,S表示学生,G表示成绩,T表示时间,R表示教室,根据语义有如下数据依赖集:D={ C→P,(S,C)→G,(T,R)→C,(T,P)→R,(T,S)→R },关系模式W的一个关键字是( D) .\n\nA. (S,C) B. (T,R)   C. (T,P) D. (T,S)\n6. 关系模式中,满足2NF的模式(B) .\n\nA. 可能是1NF B. 必定是1NF\nC. 必定是3NF D. 必定是BCNF\n7. 关系模式R中的属性全是主属性,则R的最高范式必定是(C ) .\n\nA. 1NF B. 2NF   C. 3NF D. BCNF\n8. 消除了部分函数依赖的1NF的关系模式,必定是(B ) .\n\nA. 1NF B. 2NF   C. 3NF D. BCNF\n9. 如果A->B ,那么属性A和属性B的联系是( B) .\n\nA. 一对多 B. 多对一 C.多对多 D. 以上都不是\n10. 关系模式的候选关键字可以有1个或多个,而主关键字有( C) .\n\nA. 多个 B. 0个  C. 1个 D. 1个或多个\n\n11. 候选关键字的属性可以有( D) .\n\nA. 多个 B. 0个  C. 1个 D. 1个或多个\n12. 关系模式的任何属性( A) .\n\nA. 不可再分 B. 可以再分\nC. 命名在关系模式上可以不唯一 D. 以上都不是\n13. 设有关系模式W(C,P,S,G,T,R),其中各属性的含义是:C表示课程,P表示教师,S表示学生,G表示成绩,T表示时间,R表示教室,根据语义有如下数据依赖集:D={ C→P,(S,C)→G,(T,R)→C,(T,P)→R,(T,S)→R },若将关系模式W分解为三个关系模式W1(C,P),W2(S,C,G),W2(S,T,R,C),则W1的规范化程序最高达到( D) .\n\nA. 1NF B.2NF    C. 3NF D. BCNF\n14. 在关系数据库中,任何二元关系模式的最高范式必定是(D ) .\n\nA. 1NF B.2NF    C. 3NF D. BCNF\n15. 在关系规范式中,分解关系的基本原则是(B ).\nI.实现无损连接\nII.分解后的关系相互独立\nIII.保持原有的依赖关系\n\nA. Ⅰ和Ⅱ B. Ⅰ和Ⅲ C. Ⅰ D. Ⅱ\n16. 不能使一个关系从第一范式转化为第二范式的条件是( B).\n\nA.每一个非属性都完全函数依赖主属性\nB.每一个非属性都部分函数依赖主属性\nC.在一个关系中没有非属性存在\nD.主键由一个属性构成\n17. 任何一个满足2NF但不满足3NF的关系模式都不存在(D ).\n\nA.主属性对键的部分依赖\nB.非主属性对键的部分依赖\nC.主属性对键的传递依赖\nD.非主属性对键的传递依赖\n18. 设数据库关系模式R=(A,B,C,D,E),有下列函数依赖:A→BC,D→E,C→D;下述对R的分解中,哪些分解是R的无损连接分解( B) .\nI.(A,B,C)(C,D,E)\nII.(A,B)(A,C,D,E)\nIII.(A,C)(B,C,D,E)\nIV.(A,B)(C,D,E)\n\nA.只有Ⅳ B. Ⅰ和Ⅱ C. Ⅰ,Ⅱ和Ⅲ D. 都不是\n19. 设U是所有属性的集合,X,Y,Z都是U的子集,且Z=U-X-Y.下面关于多值依赖的叙述中,不正确的是( C).\n\nA.若X→→Y,则X→→Z        B.若X→Y,则X→→Y\nC.若X→→Y,且Y′∈Y,则X→→Y′     D.若Z=∮,则X→→Y\n20. 若关系模式R(U,F)属于3NF,则(C ).\n\nA. 一定属于BCNF\nB. 消除了插入的删除异常\nC. 仍存在一定的插入和删除异常\nD. 属于BCNF且消除了插入和删除异常\n21. 下列说法不正确的是(C ).\n\nA. 任何一个包含两个属性的关系模式一定满足3NF\nB. 任何一个包含两个属性的关系模式一定满足BCNF\nC. 任何一个包含三个属性的关系模式一定满足3NF\nD. 任何一个关系模式都一定有码\n22. 设关系模式R(A,B,C),F是R上成立的FD集,F={B→C},则分解P={AB,BC}相对于F( A).\n\nA. 是无损联接,也是保持FD的分解\nB. 是无损联接,也不保持FD的分解\nC. 不是无损联接,但保持FD的分解\nD. 既不是无损联接,也不保持FD的分解\n23. 关系数据库规范化是为了解决关系数据库中( A)的问题而引入的.\n\nA. 插入,删除和数据冗余\nB. 提高查询速度\nC. 减少数据操作的复杂性\nD. 保证数据的安全性和完整性\n24. 关系的规范化中,各个范式之间的关系是( A) .\n\nA. 1NF∈2NF∈3NF\nB. 3NF∈2NF∈1NF\nC. 1NF=2NF=3NF\nD. 1NF∈2NF∈BCNF∈3NF\n25. 数据库中的冗余数据是指可(D)的数据 .\n\nA. 容易产生错误 B. 容易产生冲突\nC. 无关紧要     D. 由基本数据导出\n26. 学生表(id,name,sex,age,depart_id,depart_name),存在函数依赖是id→name,sex,age,depart_id;dept_id→dept_name,其满足( B).\n\nA. 1NF B. 2NF   C. 3NF D. BCNF\n27. 设有关系模式R(S,D,M),其函数依赖集:F={S→D,D→M},则关系模式R的规范化程度最高达到(B ).\n\nA. 1NF B. 2NF   C. 3NF D. BCNF\n28. 设有关系模式R(A,B,C,D),其数据依赖集:F={(A,B)→C,C→D},则关系模式R的规范化程度最高达到( B).\n\nA. 1NF B. 2NF   C. 3NF D. BCNF\n29. 下列关于函数依赖的叙述中,哪一条是不正确的(B ).\n\nA.由X→Y,Y→Z,则X→YZ  B.由X→YZ,则X→Y, Y→Z\nC.由X→Y,WY→Z,则XW→Z D.由X→Y,Z∈Y,则X→Z\n30. X→Y,当下列哪一条成立时,称为平凡的函数依赖(B ).\n\nA. X∈Y B. Y∈X   C. X∩Y=∮ D. X∩Y≠∮\n31. 关系数据库的规范化理论指出:关系数据库中的关系应该满足一定的要求,最起码的要求是达到1NF,即满足( D).\n\nA.每个非主键属性都完全依赖于主键属性\nB.主键属性唯一标识关系中的元组\nC.关系中的元组不可重复\nD.每个属性都是不可分解的\n32. 根据关系数据库规范化理论,关系数据库中的关系要满足第一范式,部门(部门号,部门名,部门成员,部门总经理)关系中,因哪个属性而使它不满足第一范式(B).\n\nA. 部门总经理 B. 部门成员 C. 部门名 D. 部门号\n33. 有关系模式A(C,T,H,R,S),其中各属性的含义是:\n\nC:课程 T:教员 H:上课时间 R:教室 S:学生\n根据语义有如下函数依赖集:\n\nF={C→T,(H,R)→C,(H,T)RC,(H,S)→R}\n\n(1) 关系模式A的码是(B ).\n\nA. C B.(H,S) C.(H,R) D.(H,T)\n\n(2) 关系模式A的规范化程度最高达到( B).\n\nA. 1NF B. 2NF C. 3NF D. BCNF\n\n(3) 现将关系模式A分解为两个关系模式A1(C,T),A2(H,R,S),则其中A1的规范化程度达到(D ).\n\nA. 1NF B. 2NF C. 3NF D. BCNF\n\n选择题答案:\n(1) A (2) B (3) B (4) A (5) D\n(6) B (7) C (8) B (9) B (10) C\n(11) D (12) A (13) D (14) D (15) B\n(16) B (17) D (18) B (19) C (20) C\n(21) C (22) A (23) A (24) A (25) D\n(26) B (27) B (28) B (29) B (30) B\n(31) D (32) B (33) B B D\n\n# 二,简答题\n1. 理解并给出下列术语的定义:\n\n函数依赖,部分函数依赖,完全函数依赖,候选码,主码, 外码,全码.\n\n解析:\n\n解答本题不能仅仅把《概论》上的定义写下来.关键是真正理解和运用这些概念.\n\n答:\n\n`函数依赖`:设R (U)是一个关系模式,U是R的属性集合,X和Y是U的子集.对于R (U)的任意一个可能的关系r,如果r中不存在两个元组,它们在X上的属性值相同, 而在Y上的属性值不同, 则称\"X函数确定Y\"或\"Y函数依赖于X\",记作X→Y.\n\n解析:\n\n1) 函数依赖是最基本的一种数据依赖,也是最重要的一种数据依赖.\n\n2) 函数依赖是属性之间的一种联系,体现在属性值是否相等.由上面的定义可以知道,如果X→Y,则r中任意两个元组,若它们在X上的属性值相同,那么在Y上的属性值一定也相同.\n\n3) 我们要从属性间实际存在的语义来确定他们之间的函数依赖,即函数依赖反映了(描述了)现实世界的一种语义.\n\n4) 函数依赖不是指关系模式R的在某个时刻的关系(值)满足的约束条件,而是指R任何时刻的一切关系均要满足的约束条件.\n\n答:\n\n完全函数依赖,部分函数依赖:在R(U)中,如果X→Y,并且对于X的任何一个真子集X,都有X′→Y,则称Y对X完全函数依赖;若X→Y,但Y不完全函数依赖于X,则称Y对X部分函数依赖;\n\n`候选码`,`主码`: 设K为R(U,F)中的属性或属性组合,若K → U则K为R的候选码.若候选码多于一个,则选定其中的一个为主码.\n答:\n\n`外码`:关系模式R中属性或属性组X并非R的码,但X是另一个关系模式的码,则称X是R的外部码也称外码.\n\n`全码`:整个属性组是码,称为全码(All-key).\n\n2. 建立一个关于系,学生,班级,学会等诸信息的关系数据库.\n\n描述学生的属性有:学号,姓名,出生年月,系名,班号,宿舍区.\n\n描述班级的属性有:班号,专业名,系名,人数,入校年份.\n\n描述系的属性有:系名,系号,系办公室地点,人数.\n\n描述学会的属性有:学会名,成立年份,地点,人数.\n\n有关语义如下:一个系有若干专业,每个专业每年只招一个班,每个班有若干学生.一个系的学生住在同一宿舍区.每个学生可参加若干学会,每个学会有若干学生.学生参加某学会有一个入会年份.\n\n请给出关系模式,写出每个关系模式的极小函数依赖集,指出是否存在传递函数依赖,对于函数依赖左部是多属性的情况讨论函数依赖是完全函数依赖,还是部分函数依赖.\n\n指出各关系的候选码,外部码,有没有全码存在\n\n答:\n\n关系模式: 学生S(S#,SN,SB,DN,C#,SA)\n\n班级C(C#,CS,DN,CNUM,CDATE)\n\n系 D(D#,DN,DA,DNUM)\n\n学会P(PN,DATE1,PA,PNUM)\n\n学生--学会SP(S#,PN,DATE2)\n\n其中,S#—学号,SN—姓名,SB—出生年月,SA—宿舍区\n\nC#—班号,CS—专业名,CNUM—班级人数,CDATE—入校年份\n\nD#—系号,DN—系名,DA—系办公室地点,DNUM—系人数\n\nPN—学会名,DATE1—成立年月,PA—地点,PNUM—学会人数,DATE2—入会年份\n\n每个关系模式的极小函数依赖集:\n\nS:S#→SN,S#→SB,S#→C#,C#→DN,DN→SA\n\nC:C#→CS,C#→CNUM,C#→CDATE,CS→DN,(CS,CDATE)→C#\n\nD:D#→DN,DN→D#,D#→DA,D#→DNUM\n\nP:PN→DATE1,PN→PA,PN→PNUM\n\nSP:(S#,PN)→DATE2\n\nS中存在传递函数依赖: S#→DN, S#→SA, C#→SA\n\nC中存在传递函数依赖:C#→DN\n\n(S#,PN)→DATE2 和(CS,CDATE)→C# 均为SP中的函数依赖,是完全函数依赖\n\n关系 候选码 外部码 全码\n\nS S# C#,DN 无\n\nC C#,(CS,CDATE) DN 无\n\nD D#和DN 无 无\n\nP PN 无 无\n\nSP (S#,PN) S#,PN 无\n\n3. 试由Armostrong公理系统推导出下面三条推理规则:\n\n(1) 合并规则:若X→Z,X→Y,则有X→YZ\n\n(2) 伪传递规则:由X→Y,WY→Z有XW→Z\n\n(3) 分解规则:X→Y,Z 包含于 Y,有X→Z\n\n证:\n\n(1) 已知X→Z,由增广律知XY→YZ,又因为X→Y,可得XX→XY→YZ,最后根据传递律得X→YZ.\n(2) 已知X→Y,据增广律得XW→WY,因为WY→Z,所以XW→WY→Z,通过传递律可知XW→Z.\n(3) 已知Z 包含于 Y,根据自反律知Y→Z,又因为X→Y,所以由传递律可得X→Z.\n\n4. 试举出三个多值依赖的实例.\n答:\n\n(1) 关系模式MSC(M,S,C)中,M表示专业,S表示学生,C表示该专业的必修课.假设每个专业有多个学生,有一组必修课.设同专业内所有学生的选修的必修课相同,实例关系如下.按照语义对于M的每一个值M i,S有一个完整的集合与之对应而不问C取何值,所以M→→S.由于C与S的完全对称性,必然有M→→C成立.\n\n```\nM S C\nM 1 S1 C1\nM 1 S1 C2\nM 1 S2 C1\nM 1 S2 C2\n…… …… ……\n```\n\n(2) 关系模式ISA(I,S,A)中,I表示学生兴趣小组,S表示学生,A表示某兴趣小组的活动项目.假设每个兴趣小组有多个学生,有若干活动项目.每个学生必须参加所在兴趣小组的所有活动项目,每个活动项目要求该兴趣小组的所有学生参加.\n按照语义有I→→S,I→→A成立.\n\n(3) 关系模式RDP(R,D,P)中,R表示医院的病房,D表示责任医务人员,P表示病人.假设每个病房住有多个病人,有多个责任医务人员负责医治和护理该病房的所有病人.按照语义有R→→D,R→→P成立.\n\n5. 下面的结论哪些是正确的,哪些是错误的 对于错误的结论请给出理由或给出一个反例说明之.\n```\n(1) 任何一个二目关系都是属于3NF的.√\n(2) 任何一个二目关系都是属于BCNF的.√\n(3) 任何一个二目关系都是属于4NF的.√\n(5) 若R.A→R.B,R.B→R.C,则R.A→R.C √\n(6) 若R.A→R.B,R.A→R.C,则R.A→R.(B, C) √\n(7) 若R.B→R.A,R.C→R.A,则R.(B, C)→R.A √\n(8) 若R.(B, C)→R.A,则R.B→R.A,R.C→R.A ×\n反例:关系模式 SC(S#,C#,G) (S#,C#)→G,但是S# → G,C#→G\n```\n# 第六章 数据库设计\n## 一,选择题\n1. 数据流程图是用于描述结构化方法中(D )阶段的工具.\n\nA. 概要设计 B. 可行性分析\nC. 程序编码 D. 需求分析\n2. 数据库设计中,用E-R图赖描述信息结构但不涉及信息在计算机中的表示,这是数据库设计的( C).\n\nA. 需求分析阶段 B. 逻辑设计阶段\nC. 概念设计阶段 D. 物理设计阶段\n3. 在数据库设计中,将E-R图转换成关系数据模型的过程属于(B ).\n\nA. 需求分析阶段 B. 逻辑设计阶段\nC. 概念设计阶段 D. 物理设计阶段\n4. 子模式DDL是用来描述( B).\n\nA. 数据库的总体逻辑结构 B. 数据库的局部逻辑结构\nC. 数据库的物理存储结构 D. 数据库的概念结构\n5. 数据库设计的概念设计阶段,表示概念结构的常用方法和描述工具是(C).\n\nA.层次分析法和层次结构图\nB.数据流程分析法和数据流程图\nC.实体联系法和实体联系图\nD.结构分析法和模块结构图\n6. 在E-R模型向关系模型转换时,M:N的联系转换为关系模式时,其关键字是(C ).\n\nA.M端实体的关键字\nB.N端实体的关键字\nC.M,N端实体的关键字组合\nD.重新选取其他属性\n7. 某学校规定,每一个班级最多有50名学生,至少有10名学生;每一名学生必须属于一个班级.在班级与学生实体的联系中,学生实体的基数是( B) .\n\nA. (0,1) B. (1,1)\nC. (1,10) D. (10,50)\n8. 在关系数据库设计中,设计关系模式是数据库设计中(A )阶段的任.\n\nA. 逻辑设计阶段 B. 概念设计阶段\nC. 物理设计阶段 D. 需求分析阶段\n9. 关系数据库的规范化理论主要解决的问题是(A ).\n\nA.如何构造合适的数据逻辑结构\nB.如何构造合适的数据物理结构\nC.如何构造合适的应用程序界面\nD.如何控制不同用户的数据操作权限\n10. 数据库设计可划分为七个阶段,每个阶段都有自己的设计内容,\"为哪些关系,在哪些属性上,键什么样的索引\"这一设计内容应该属于( C)设计阶段.\n\nA. 概念设计 B. 逻辑设计\nC. 物理设计 D. 全局设计\n11. 假设设计数据库性能用\"开销\",即时间,空间及可能的费用来衡量,则在数据库应用系统生存期中存在很多开销.其中,对物理设计者来说,主要考虑的是( C).\n\nA. 规划开销 B. 设计开销\nC. 操作开销 D. 维护开销\n12. 数据库物理设计完成后,进入数据库实施阶段,下述工作中,(D )一般不属于实施阶段的工作.\n\nA. 建立库结构 B. 系统调试\nC. 加载数据 D. 扩充功能\n13. 从ER图导出关系模型时,如果实体间的联系是M:N的,下列说法中正确的是(C ).\n\nA.将N方关键字和联系的属性纳入M方的属性中\nB.将M方关键字和联系的属性纳入N方的属性中\nC.增加一个关系表示联系,其中纳入M方和N方的关键字\nD.在M方属性和N方属性中均增加一个表示级别的属性\n14. 在ER模型中,如果有3个不同的实体集,3个M:N联系,根据ER模型转换为关系模型的规则,转换为关系的数目是(C ).\n\nA. 4 B. 5   C. 6 D. 7\n\n选择题答案:\n(1) D (2) C (3) B (4) B (5) C\n(6) C (7) B (8) A (9) A (10) C\n\n(11) C (12) D (13) C (14) C\n\n## 二,简答题\n1. 试述数据库设计过程.\n\n解析\n\n希望同学能够认真阅读《概论》的内容,了解并掌握数据库设计过程.这里只概要列出数据库设计过程的六个阶段:\n\n1) 需求分析\n\n2) 概念结构设计\n\n3) 逻辑结构设计\n\n4) 数据库物理设计\n\n5) 数据库实施\n\n6) 数据库运行和维护\n\n这是一个完整的实际数据库及其应用系统的设计过程.不仅包括设计数据库本身,还包括数据库的实施,数据库运行和维护.\n设计一个完善的数据库应用系统往往是上述六个阶段的不断反复.\n\n2. 试述数据库设计过程的各个阶段上的设计描述.\n\n解析:这是进一步了解数据库设计的具体内容.设计描述是指在各个阶段体现设计内容,描述设计结果的各种文档,程序.\n\n答:\n\n各阶段的设计要点如下:\n\n1) 需求分析:准确了解与分析用户需求(包括数据与处理).\n\n2) 概念结构设计:通过对用户需求进行综合,归纳与抽象,形成一个独立于具体DBMS的概念模型.\n\n3) 逻辑结构设计:将概念结构转换为某个DBMS所支持的数据模型,并对其进行优化.\n\n4) 数据库物理设计:为逻辑数据模型选取一个最适合应用环境的物理结构(包括存储结构和存取方法).\n\n5) 数据库实施:设计人员运用DBMS提供的数据语言,工具及宿主语言,根据逻辑设计和物理设计的结果建立数据库,编制与调试应用程序,组织数据入库,并进行试运行.\n\n6) 数据库运行和维护:在数据库系统运行过程中对其进行评价,调整与修改.\n\n3. 试述数据库设计过程中结构设计部分形成的数据库模式.\n\n答:\n\n数据库结构设计的不同阶段形成数据库的各级模式,即:\n\n在概念设计阶段形成独立于机器特点,独立于各个DBMS产品的概念模式,在本篇中就是E-R图;\n\n在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型,如关系模型,形成数据库逻辑模式;然后在基本表的基础上再建立必要的视图(View),形成数据的外模式;\n\n在物理设计阶段,根据DBMS特点和处理的需要,进行物理存储安排,建立索引,形成数据库内模式.\n\n概念模式是面向用户和设计人员的,属于概念模型的层次;逻辑模式,外模式,内模式是DBMS支持的模式,属于数据模型的层次.可以在DBMS中加以描述和存储.\n\n4. 试述数据库设计的特点.\n\n答:\n数据库设计既是一项涉及多学科的综合性技术又是一项庞大的工程项目\n\n其主要特点有:\n\n1) 数据库建设是硬件,软件和干件(技术与管理的界面)的结合.\n\n2) 从软件设计的技术角度看,数据库设计应该和应用系统设计相结合,也就是说,整个设计过程中要把结构(数据)设计和行为(处理)设计密切结合起来.\n\n5. 需求分析阶段的设计目标是什么 调查的内容是什么\n\n答:\n\n需求分析阶段的设计目标是通过详细调查现实世界要处理的对象(组织,部门,企业等),充分了解原系统(手工系统或计算机系统)工作概况,明确用户的各种需求,然后在此基础上确定新系统的功能.\n\n调查的内容是\"数据\"和\"处理\",即获得用户对数据库的如下要求:\n\n(1) 信息要求.指用户需要从数据库中获得信息的内容与性质.由信息要求可以导出数据要求,即在数据库中需要存储哪些数据.\n\n(2) 处理要求.指用户要完成什么处理功能,对处理的响应时间有什么要求,处理方式是批处理还是联机处理.\n\n(3) 安全性与完整性要求.\n\n6. 数据字典的内容和作用是什么\n\n答:\n\n数据字典是系统中各类数据描述的集合.数据字典的内容通常包括:数据项,数据结构,数据流,数据存储,处理过程五个部分\n\n\n其中数据项是数据的最小组成单位,若干个数据项可以组成一个数据结构.数据字典通过对数据项和数据结构的定义来描述数据流,数据存储的逻辑内容.\n\n数据字典的作用:\n\n数据字典是关于数据库中数据的描述,在需求分析阶段建立,是下一步进行概念设计的基础,并在数据库设计过程中不断修改,充实,完善.\n\n(注意,数据库设计阶段形成的数据字典与后面讲到的数据字典不同,后者是DBMS关于数据库中数据的描述,当然两者是有联系的).\n\n7. 什么是数据库的概念结构 试述其特点和设计策略.\n\n答:概念结构是信息世界的结构,即概念模型,其主要特点是:\n\n(1) 能真实,充分地反映现实世界,包括事物和事物之间的联系,能满足用户对数据的处理要求.是对现实世界的一个真实模型.\n\n(2) 易于理解,从而可以用它和不熟悉计算机的用户交换意见,用户的积极参与是数据库的设计成功的关键.\n\n(3) 易于更改,当应用环境和应用要求改变时,容易对概念模型修改和扩充.\n\n(4) 易于向关系,网状,层次等各种数据模型转换.\n\n概念结构的设计策略通常有四种:\n\n`自顶向下`.即首先定义全局概念结构的框架,然后逐步细化;\n\n`自底向上`.即首先定义各局部应用的概念结构,然后将它们集成起来,得到全局概念\n结构;\n\n`逐步扩张`.首先定义最重要的核心概念结构,然后向外扩充,以滚雪球的方式逐步生\n成其他概念结构,直至总体概念结构;\n\n`混合策略`.即将自顶向下和自底向上相结合,用自顶向下策略设计一个全局概念结构的框架,以它为骨架集成由自底向上策略中设计的各局部概念结构.\n\n8. 什么叫数据抽象 试举例说明.\n\n答:\n\n数据抽象是对实际的人,物,事和概念进行人为处理,抽取所关心的共同特性,忽略非本质的细节,并把这些特性用各种概念精确地加以描述,这些概念组成了某种模型.\n\n如分类这种抽象是:定义某一类概念作为现实世界中一组对象的类型.这些对象具有某些共同的特性和行为.它抽象了对象值和型之间的\"is member of\"的语义.在E-R模型中,实体型就是这种抽象.例如在学校环境中,李英是老师,表示李英是教师类型中的一员,则教师是实体型,李英是教师实体型中的一个实体值,具有教师共同的特性和行为:在某个系某个专业教学,讲授某些课程,从事某个方向的科研.\n\n9. 试述数据库概念结构设计的重要性和设计步骤.\n\n答:\n\n重要性:数据库概念设计是整个数据库设计的关键,将在需求分析阶段所得到的应用需求首先抽象为概念结构,以此作为各种数据模型的共同基础,从而能更好地,更准确地用某一DBMS实现这些需求.\n\n设计步骤:\n\n概念结构的设计方法有多种,其中最经常采用的策略是自底向上方法,该方法的设计步\n骤通常分为两步:\n\n第1步是抽象数据并设计局部视图,第2步是集成局部视图,得到全局的概念结构\n\n10. 什么是E-R图 构成E-R图的基本要素是什么\n\n答:\nE-R图为实体-联系图,提供了表示实体型,属性和联系的方法,用来描述现实世界的概念模型.\n\n构成E-R图的基本要素是实体型,属性和联系,其表示方法为:\n\n实体型:用矩形表示,矩形框内写明实体名;\n\n属性:用椭圆形表示,并用无向边将其与相应的实体连接起来;\n\n联系:用菱形表示,菱形框内写明联系名,并用无向边分别与有关实体连接起来,同时在无向边旁标上联系的类型(1 : 1,1 : n或m : n).\n\n11. 为什么要视图集成 视图集成的方法是什么\n\n答:\n\n在对数据库系统进行概念结构设计时一般采用自底向上的设计方法,把繁杂的大系统分解子系统.首先设计各个子系统的局部视图,然后通过视图集成的方式将各子系统有机的融合起来,综合成一个系统的总视图.这样设计清晰,由简到繁.由于数据库系统是从整体角度看待和描述数据的,因此数据不再面向某个应用而是整个系统.因此必须进行视图集成,使得数据库能被全系统的多个用户,多个应用共享使用.\n\n一般说来,视图集成可以有两种方式:\n- 多个分E-R图一次集成;\n- 逐步集成,用累加的方式一次集成两个分E-R图.\n\n无论采用哪种方式,每次集成局部E-R图时都需要分两步走:\n\n(1) 合并.解决各分E-R图之间的冲突,将各分E-R图合并起来生成初步E-R图.\n\n(2) 修改和重构.消除不必要的冗余,生成基本E-R图.\n\n12. 什么是数据库的逻辑结构设计 试述其设计步骤.\n\n答:\n\n数据库的逻辑结构设计就是把概念结构设计阶段设计好的基本E-R图转换为与选用的DBMS产品所支持的数据模型相符合的逻辑结构.\n\n设计步骤为:\n- 将概念结构转换为一般的关系,网状,层次模型;\n- 将转换来的关系,网状,层次模型向特定DBMS支持下的数据模型转换\n- 对数据模型进行优化.\n\n13. 试述把E-R图转换为DBTG模型和关系模型的转换规则.\n\n答:\n\nE-R图向DBTG模型的转换规则:\n1) 每个实体型转换为记录型,实体的属性转换为记录的数据项;\n2) 实体型之间1:n(n≥1)的联系转换为一个系,没有任何联系的实体型转换为奇异系;\n3) K(K≥2)个实体型之间多对多的联系,引入一个连结记录,形成K个实体型和连结记录之间的K个系.连结记录的属性由诸首记录的码及联系属性所组成;\n4) 同一实体型内的1:n,n:m联系,引入连结记录,转换为两个系.\n\n解析\n\n根据我国实际情况,网状,层次数据库系统已很少使用,因此《概论》第三版把它们删去了,有关的主要概念放在第一章数据模型中介绍.对于DBTG模型的许多概念也介绍得很简单.本题的内容已经超出了书上的内容,同学们只要了解就可以了.但是,下面E-R图向关系模型的转换规则要求同学必须掌握,并且能够举一反三.\n\n答:\n\nE-R图向关系模型的转换规则:\n\n一个实体型转换为一个关系模式.实体的属性就是关系的属性,实体的码就是关系的码.\n\n对于实体间的联系则有以下不同的情况:\n\n(1) 一个1:1联系可以转换为一个独立的关系模式,也可以与任意一端对应的关系模式合并.如果转换为一个独立的关系模式,则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性,每个实体的码均是该关系的候选码.如果与某一端实体对应的关系模式合并,则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性.\n\n(2) 一个1:n联系可以转换为一个独立的关系模式,也可以与n端对应的关系模式合并.如果转换为一个独立的关系模式,则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性,而关系的码为n端实体的码.\n\n(3) 一个m:n联系转换为一个关系模式.与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性,各实体码的组合组成该关系的码,或码的一部分.\n\n(4) 三个或三个以上实体间的一个多元联系可以转换为一个关系模式.与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性,而关系的码为各实体码的组合.\n\n(5) 具有相同码的关系模式可合并.\n14. 你能给出由E-R图转换为IMS模型的转换规则吗\n\n答:\n\nE-R图向IMS模型的转换规则:\n\n1)每个实体型转换为记录型,实体的属性转换为记录的数据项;\n\n2)实体型之间1:n(n≥1)的联系转换记录型之间的有向边;\n\n3)实体型之间m:n(m>1,n>1)的联系则分解成一对多联系,再根据2)转换;\n\n4)K(K≥2)个实体型之间多对多的联系,可先转换成多对两个实体型之间的联系,再根据3)转换.\n\n解析\n\nIMS是IBM公司的层次数据库管理系统.IMS模型是层次模型.E-R图向IMS模型转换的另一种方法是,先把E-R图转换为网状模型,再利用IMS逻辑数据库LDB的概念来表示网状模型.详细方法这里从略.\n\n# 第七章 数据库恢复技术\n## 一,选择题\n1. 一个事务的执行,要么全部完成,要么全部不做,一个事务中对数据库的所有操作都是一个不可分割的操作序列的属性是(A ) .\n\nA. 原子性 B. 一致性\nC. 独立性 D. 持久性\n\n2. 表示两个或多个事务可以同时运行而不互相影响的是( C).\n\nA. 原子性 B. 一致性\nC. 独立性 D. 持久性\n3. 事务的持续性是指( B)\n\nA.事务中包括的所有操作要么都做,要么都不做.\nB.事务一旦提交,对数据库的改变是永久的.\nC.一个事务内部的操作对并发的其他事务是隔离的.\nD.事务必须是使数据库从一个一致性状态变到另一个一致性状态.\n4. SQL语言中的COMMIT语句的主要作用是( C).\n\nA. 结束程序 B. 返回系统\nC. 提交事务 D. 存储数据\n5. SQL语言中用( B)语句实现事务的回滚\n\nA. CREATE TABLE B. ROLLBACK\nC. GRANT和REVOKE D. COMMIT\n6. 若系统在运行过程中,由于某种硬件故障,使存储在外存上的数据部分损失或全部损失,这种情况称为(A).\n\nA. 介质故障 B. 运行故障\nC. 系统故障 D. 事务故障\n7. 在DBMS中实现事务持久性的子系统是( D ).\n\nA. 安全管理子系统 B. 完整性管理子系统\nC. 并发控制子系统 D. 恢复管理子系统\n8. 后援副本的作用是( C ).\n\nA. 保障安全性 B. 一致性控制\nC. 故障后的恢复 D. 数据的转储\n9. 事务日志用于保存( C )\n\nA. 程序运行过程 B. 程序的执行结果\nC. 对数据的更新操作 D. 数据操作\n10. 数据库恢复的基础是利用转储的冗余数据.这些转储的冗余数据包括( C).\n\nA. 数据字典,应用程序,审计档案,数据库后备副本\nB. 数据字典,应用程序,审计档案,日志文件\nC. 日志文件,数据库后备副本\nD. 数据字典,应用程序,数据库后备副本\n\n选择题答案:\n(1) A (2) C (3) B (4) C (5) B\n(6) A (7) D (8) C (9) C (10) C\n\n## 二,简答题\n1. 试述事务的概念及事务的四个特性.\n\n答:\n\n事务是用户定义的一个数据库操作序列,这些操作要么全做要么全不做,是一个不可分割的工作单位.\n\n事务具有四个特性:原子性(Atomicity),一致性(Consistency),隔离性(Isolation)和持续性(Durability).这个四个特性也简称为ACID特性.\n\n`原子性`:事务是数据库的逻辑工作单位,事务中包括的诸操作要么都做,要么都不做.\n\n`一致性`:事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态.\n\n`隔离性`:一个事务的执行不能被其他事务干扰.即一个事务内部的操作及使用的数据对其他并发事务是隔离的,并发执行的各个事务之间不能互相干扰.\n\n`持续性`:持续性也称永久性(Permanence),指一个事务一旦提交,它对数据库中数据的改变就应该是永久性的.接下来的其他操作或故障不应该对其执行结果有任何影响.\n\n2. 为什么事务非正常结束时会影响数据库数据的正确性,请列举一例说明之.\n答:\n\n事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态.如果数据库系统运行中发生故障,有些事务尚未完成就被迫中断,这些未完成事务对数据库所做的修改有一部分已写入物理数据库,这时数据库就处于一种不正确的状态,或者说是不一致的状态.\n\n例如某工厂的库存管理系统中,要把数量为Q的某种零件从仓库1移到仓库2存放.\n则可以定义一个事务T,T包括两个操作;Q1=Q1-Q,Q2=Q2+Q.如果T非正常终止时只做了第一个操作,则数据库就处于不一致性状态,库存量无缘无故少了Q.\n\n3. 数据库中为什么要有恢复子系统 它的功能是什么\n\n答:\n\n因为计算机系统中硬件的故障,软件的错误,操作员的失误以及恶意的破坏是不可避免的,这些故障轻则造成运行事务非正常中断,影响数据库中数据的正确性,重则破坏数据库,使数据库中全部或部分数据丢失,因此必须要有恢复子系统.\n\n恢复子系统的功能是:把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态).\n\n4. 数据库运行中可能产生的故障有哪几类 哪些故障影响事务的正常执行 哪些故障破坏数据库数据\n\n答:数据库系统中可能发生各种各样的故障,大致可以分以下几类:\n\n(1) 事务内部的故障;\n\n(2) 系统故障;\n\n(3) 介质故障;\n\n(4) 计算机病毒.\n\n事务故障,系统故障和介质故障影响事务的正常执行;介质故障和计算机病毒破坏数据库数据.\n\n5.据库恢复的基本技术有哪些\n\n答:\n\n数据转储和登录日志文件是数据库恢复的基本技术.\n\n当系统运行过程中发生故障,利用转储的数据库后备副本和日志文件就可以将数据库恢复到故障前的某个一致性状态.\n\n6. 数据库转储的意义是什么 试比较各种数据转储方法.\n\n答:\n\n数据转储是数据库恢复中采用的基本技术.所谓转储即DBA定期地将数据库复制到磁带或另一个磁盘上保存起来的过程.当数据库遭到破坏后可以将后备副本重新装入,将数据库恢复到转储时的状态.\n\n`静态转储`:在系统中无运行事务时进行的转储操作.静态转储简单,但必须等待正运行的用户事务结束才能进行.同样,新的事务必须等待转储结束才能执行.显然,这会降低数据库的可用性.\n\n`动态转储`:指转储期间允许对数据库进行存取或修改.动态转储可克服静态转储的缺点,它不用等待正在运行的用户事务结束,也不会影响新事务的运行.但是,转储结束时后援副本上的数据并不能保证正确有效.因为转储期间运行的事务可能修改了某些数据,使得后援副本上的数据不是数据库的一致版本.为此,必须把转储期间各事务对数据库的修改活动登记下来,建立日志文件(log file).这样,后援副本加上日志文件就能得到数据库某一时刻的正确状态.转储还可以分为海量转储和增量转储两种方式.\n\n`海量转储`是指每次转储全部数据库.增量转储则指每次只转储上一次转储后更新过的数据.从恢复角度看,使用海量转储得到的后备副本进行恢复一般说来更简单些.但如果数据库很大,事务处理又十分频繁,则增量转储方式更实用更有效.\n\n7. 什么是日志文件 为什么要设立日志文件\n\n答:\n(1) 日志文件是用来记录事务对数据库的更新操作的文件.\n\n(2) 设立日志文件的目的是: 进行事务故障恢复;进行系统故障恢复;协助后备副本进行介质故障恢复.\n\n8. 登记日志文件时为什么必须先写日志文件,后写数据库\n\n答:\n\n把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作.有可能在这两个操作之间发生故障,即这两个写操作只完成了一个.\n\n如果先写了数据库修改,而在运行记录中没有登记这个修改,则以后就无法恢复这个修改了.如果先写日志,但没有修改数据库,在恢复时只不过是多执行一次UNDO操作,并不会影响数据库的正确性.所以一定要先写日志文件,即首先把日志记录写到日志文件中,然后写数据库的修改.\n\n9. 针对不同的故障,试给出恢复的策略和方法.(即如何进行事务故障的恢复 系统故障的恢复 介质故障恢复 )\n\n答:\n\n事务故障的恢复:\n\n事务故障的恢复是由DBMS自动完成的,对用户是透明的.\n\nDBMS执行恢复步骤是:\n\n(1) 反向扫描文件日志(即从最后向前扫描日志文件),查找该事务的更新操作.\n\n(2) 对该事务的更新操作执行逆操作.即将日志记录中\"更新前的值\"写入数据库.\n\n(3) 继续反向扫描日志文件,做同样处理.\n\n(4) 如此处理下去,直至读到此事务的开始标记,该事务故障的恢复就完成了.\n\n答:\n\n系统故障的恢复:\n\n系统故障可能会造成数据库处于不一致状态:\n\n一是未完成事务对数据库的更新可能已写入数据库;\n\n二是已提交事务对数据库的更新可能还留在缓冲区,没来得及写入数据库.\n\n因此恢复操作就是要撤销(UNDO)故障发生时未完成的事务,重做(REDO)已完成的事务.\n\n系统的恢复步骤是:\n\n(1) 正向扫描日志文件,找出在故障发生前已经提交的事务队列(REDO队列)和未完成的事务队列(UNDO队列).\n\n(2) 对撤销队列中的各个事务进行UNDO处理.\n进行UNDO处理的方法是,反向扫描日志文件,对每个UNDO事务的更新操作执行逆操作,即将日志记录中\"更新前的值\"(Before Image)写入数据库.\n\n(3) 对重做队列中的各个事务进行REDO处理.\n\n进行REDO处理的方法是:正向扫描日志文件,对每个REDO事务重新执行日志文件登记的操作.即将日志记录中\"更新后的值\"(After Image)写入数据库.\n\n解析:\n在第(1)步中如何找出REDO队列和UNDO队列 请大家思考一下.\n\n下面给出一个算法:\n\n1) 建立两个事务队列:\n\nUNDO-LIST: 需要执行undo操作的事务集合;\n\nREDO-LIST: 需要执行redo操作的事务集合;\n\n两个事务队列初始均为空.\n\n2) 从日志文件头开始,正向扫描日志文件\n\n· 如有新开始(遇到Begin Transaction)的事务Ti,把Ti暂时放入UNDO-LIST队列;\n· 如有提交的事务(遇到End Transaction)Tj,把Tj从UNDO-LIST队列移到REDO-LIST队列;\n直到日志文件结束\n\n答:\n\n介质故障的恢复:\n\n介质故障是最严重的一种故障.\n\n恢复方法是重装数据库,然后重做已完成的事务.具体过程是:\n\n(1) DBA装入最新的数据库后备副本(离故障发生时刻最近的转储副本),使数据库恢复到转储时的一致性状态.\n\n(2) DBA装入转储结束时刻的日志文件副本\n\n(3) DBA启动系统恢复命令,由DBMS完成恢复功能,即重做已完成的事务.\n\n解析\n\n1) 我们假定采用的是静态转储,因此第(1)步装入数据库后备副本便可以了.\n2) 如果采用的是静动态转储,第(1)步装入数据库后备副本还不够,还需同时装入转储开始时刻的日志文件副本,经过处理后才能得到正确的数据库后备副本.\n3) 第(2)步重做已完成的事务的算法是:\na. 正向扫描日志文件,找出故障发生前已提交的事务的标识,将其记入重做队列\nb. 再一次正向扫描日志文件,对重做队列中的所有事务进行重做处理.即将日志记录中\"更新后的值\"写入数据库.\n\n10. 具有检查点的恢复技术有什么优点\n\n答:\n\n利用日志技术进行数据库恢复时,恢复子系统必须搜索日志,确定哪些事务需要REDO,哪些事务需要UNDO.一般来说,需要检查所有日志记录.这样做有两个问题:\n\n一是搜索整个日志将耗费大量的时间.\n\n二是很多需要REDO处理的事务实际上已经将它们的更新操作结果写到数据库中了,恢复子系统又重新执行了这些操作,浪费了大量时间.\n\n检查点技术就是为了解决这些问题.\n\n11. 试述使用检查点方法进行恢复的步骤.\n\n答:\n\n① 从重新开始文件中找到最后一个检查点记录在日志文件中的地址,由该地址在日志文件中找到最后一个检查点记录.\n\n② 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST.\n\n这里建立两个事务队列:\n· UNDO-LIST: 需要执行undo操作的事务集合;\n· REDO-LIST: 需要执行redo操作的事务集合;\n把ACTIVE-LIST暂时放入UNDO-LIST队列,REDO队列暂为空.\n\n③ 从检查点开始正向扫描日志文件\n\n· 如有新开始的事务Ti,把Ti暂时放入UNDO-LIST队列;\n\n· 如有提交的事务Tj,把Tj从UNDO-LIST队列移到REDO-LIST队列,直到日志文件结束;\n\n④ 对UNDO-LIST中的每个事务执行UNDO操作, 对REDO-LIST中的每个事务执行REDO操作.\n\n12. 什么是数据库镜像 它有什么用途\n\n答:\n\n数据库镜像即根据DBA的要求,自动把整个数据库或者其中的部分关键数据复制到另一个磁盘上.每当主数据库更新时,DBMS自动把更新后的数据复制过去,即DBMS自动保证镜像数据与主数据的一致性.\n\n数据库镜像的用途有:\n\n一是用于数据库恢复.当出现介质故障时,可由镜像磁盘继续提供使用,同时DBMS自动利用镜像磁盘数据进行数据库的恢复,不需要关闭系统和重装数据库副本.\n二是提高数据库的可用性.在没有出现故障时,当一个用户对某个数据加排它锁进行修改时,其他用户可以读镜像数据库上的数据,而不必等待该用户释放锁.\n\n13. 试述你了解的某一个实际的DBMS产品中采用的恢复策略.\n答:\n\n下面简单介绍一下Oracle的恢复技术:\n\nOracle中恢复机制也采用了转储和登记日志文件两个技术.\n\nOracle向DBA提供了多种转储后备副本的方法,如文件拷贝,利用Oracle的Export实用程序,用SQL命令Spool以及自己编程实现等.相应地,Oracle也提供了多种重装后备副本的方法,如文件拷贝,利用Oracle的Import实用程序,利用SQL * LOADER以及自己编程实现等.\n\n在Oracle 早期版本(V.5)中,日志文件以数据块为单位,也就是说,Oracle的恢复操作是基于数据块的,不是基于操作的.Oracle中记录数据库更新前的旧值的日志文件称为数据库前像文件(Before Image,简称BI文件),记录数据库更新后的新值的日志文件称为数据库的后像文件(After Image,简称AI文件).BI文件是必须配置的,AI文件是可以任选的.\n\nOracle7为了能够在出现故障时更有效地恢复数据,也为了解决读\"脏\"数据问题,提供了REDO日志文件和回滚段(Rollback Segment).REDO日志文件中记录了被更新数据的前像和后像.回滚段记录更新数据的前像,设在数据库缓冲区中.在利用日志文件进行故障恢复时,为减少扫描日志文件的遍数,Oracle7首先扫描REDO日志文件,重做所有操作,包括未正常提交的事务的操作,然后再根据回滚段中的数据,撤销未正常提交的事务的操作.\n\n详细技术希望同学自己设法了解Oracle最新版本的介绍,例如通过INTERNET访问Oracle公司的网站.也可以了解其他DBMS厂商的产品情况.\n\n14. 试用恢复的基本技术设计一个恢复子系统,给出这个子系统的恢复策略,包括:\n\n(a) 当产生某一类故障时如何恢复数据库的方法;\n\n(b) 日志文件的结构;\n\n(c) 登记日志文件的方法;\n\n(d) 利用日志文件恢复事务的方法;\n\n(e) 转储的类型;\n\n(f) 转储的后备副本和日志文件如何配合使用.\n\n解析\n\n这是一个大作业.可以综合复习和运用学到的知识.设计一个恢复子系统\n\n例如,日志文件的结构你可以记录为单位,也可以以数据块为单位.不同的日志文件结构,登记的日志内容,日志文件恢复事务的方法也就不同了.\n\n对于研究生,还应该上机模拟实现你设计的恢复子系统.\n\n# 第八章 数据库并发控制\n\n## 一,选择题\n1. 为了防止一个用户的工作不适当地影响另一个用户,应该采取(D) .\n\nA. 完整性控制 B. 访问控制\nC. 安全性控制 D. 并发控制\n2. 解决并发操作带来的数据不一致问题普遍采用( A)技术.\n\nA. 封锁 B. 存取控制\nC. 恢复 D. 协商\n3. 下列不属于并发操作带来的问题是( C).\n\nA. 丢失修改 B. 不可重复读\nC. 死锁 D. 脏读\n4. DBMS普遍采用(C )方法来保证调度的正确性 .\n\nA. 索引 B. 授权\nC. 封锁 D. 日志\n5. 事务T在修改数据R之前必须先对其加X锁,直到事务结束才释放,这是(A ) .\n\nA. 一级封锁协议 B. 二级封锁协议\nC. 三级封锁协议 D. 零级封锁协议\n6. 如果事务T获得了数据项Q上的排他锁,则T对Q( C) .\n\nA. 只能读不能写 B. 只能写不能读\nC. 既可读又可写 D. 不能读也不能写\n7. 设事务T1和T2,对数据库中地数据A进行操作,可能有如下几种情况,请问哪一种不会发生冲突操作(D ) .\n\nA. T1正在写A,T2要读A\nB. T1正在写A,T2也要写A\nC. T1正在读A,T2要写A\nD. T1正在读A,T2也要读A\n8. 如果有两个事务,同时对数据库中同一数据进行操作,不会引起冲突的操作是( D) .\n\nA. 一个是DELETE,一个是SELECT\nB. 一个是SELECT,一个是DELETE\nC. 两个都是UPDATE\nD. 两个都是SELECT\n9. 在数据库系统中,死锁属于(B ).\n\nA. 系统故障 B. 事务故障\nC. 介质故障 D. 程序故障\n\n选择题答案:\n(1) D (2) A (3) C (4) C (5) A\n(6) C (7) D (8) D (9) B\n\n## 二,简答题\n\n1. 在数据库中为什么要并发控制\n\n答:\n数据库是共享资源,通常有许多个事务同时在运行.\n当多个事务并发地存取数据库时就会产生同时读取和/或修改同一数据的情况.若对并发操作不加控制就可能会存取和存储不正确的数据,破坏数据库的一致性.所以数据库管理系统必须提供并发控制机制.\n\n2. 并发操作可能会产生哪几类数据不一致 用什么方法能避免各种不一致的情况\n\n答:\n\n并发操作带来的数据不一致性包括三类:丢失修改,不可重复读和读\"脏\"数据.\n\n1) 丢失修改(Lost Update)\n两个事务T1和T2读入同一数据并修改,T2提交的结果破坏了(覆盖了)T1提交的结果,导致T1的修改被丢失.\n2) 不可重复读(Non-Repeatable Read)\n不可重复读是指事务T1读取数据后,事务T2执行更新操作,使T1无法再现前一次读取结果.\n3) 读\"脏\"数据(Dirty Read)\n读\"脏\"数据是指事务T1修改某一数据,并将其写回磁盘,事务T2读取同一数据后,T1由于某种原因被撤销,这时T1已修改过的数据恢复原值,T2读到的数据就与数据库中的数据不一致,则T2读到的数据就为\"脏\"数据,即不正确的数据.\n避免不一致性的方法和技术就是并发控制.最常用的并发控制技术是封锁技术.\n也可以用其他技术,例如在分布式数据库系统中可以采用时间戳方法来进行并发控制.\n\n3. 什么是封锁\n\n答:\n封锁就是事务T在对某个数据对象例如表,记录等操作之前,先向系统发出请求,对其加锁.加锁后事务T就对该数据对象有了一定的控制,在事务T释放它的锁之前,其他的事务不能更新此数据对象.\n\n封锁是实现并发控制的一个非常重要的技术.\n\n4. 基本的封锁类型有几种 试述它们的含义.\n\n答:\n基本的封锁类型有两种: 排它锁(Exclusive Locks,简称X锁) 和共享锁(Share Locks,简称S锁).\n\n排它锁又称为写锁.若事务T对数据对象A加上X锁,则只允许T读取和修改A,其他任何事务都不能再对A加任何类型的锁,直到T释放A上的锁.这就保证了其他事务在T释放A上的锁之前不能再读取和修改A.\n\n共享锁又称为读锁.若事务T对数据对象A加上S锁,则事务T可以读A但不能修改A,其他事务只能再对A加S锁,而不能加X锁,直到T释放A上的S锁.这就保证了其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改.\n\n5. 什么是封锁协议 不同级别的封锁协议的主要区别是什么\n\n答:\n\n在运用封锁技术对数据加锁时,要约定一些规则.例如,在运用X锁和S锁对数据对象加锁时,要约定何时申请X锁或S锁,何时释放封锁等.这些约定或者规则称为封锁协议(Locking Protocol).对封锁方式约定不同的规则,就形成了各种不同的封锁协议.不同级别的封锁协议,例如《概论》中介绍的三级封锁协议,三级协议的主要区别在于什么操作需要申请封锁,何时申请封锁以及何时释放锁(即持锁时间的长短).\n\n一级封锁协议:事务T在修改数据R之前必须先对其加X锁,直到事务结束才释放.\n\n二级封锁协议:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁,读完后即可释放S锁.\n\n三级封锁协议:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁,直到事务结束才释放.\n\n6. 不同封锁协议与系统一致性级别的关系是什么\n\n答:\n不同的封锁协议对应不同的一致性级别.\n\n一级封锁协议可防止丢失修改,并保证事务T是可恢复的.在一级封锁协议中,对读数据是不加S锁的,所以它不能保证可重复读和不读\"脏\"数据.\n\n二级封锁协议除防止了丢失修改,还可进一步防止读\"脏\"数据.在二级封锁协议中,由于读完数据后立即释放S锁,所以它不能保证可重复读.\n\n在三级封锁协议中,无论是读数据还是写数据都加长锁,即都要到事务结束时才释放封锁.所以三级封锁协议除防止了丢失修改和不读\"脏\"数据外,还进一步防止了不可重复读.\n\n7. 试述活锁的产生原因和解决方法.\n\n答:\n\n活锁产生的原因:当一系列封锁不能按照其先后顺序执行时,就可能导致一些事务无限期等待某个封锁,从而导致活锁.\n\n避免活锁的简单方法是采用先来先服务的策略.当多个事务请求封锁同一数据对象时,封锁子系统按请求封锁的先后次序对事务排队,数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁.\n\n8. 请给出预防死锁的若干方法.\n\n答:\n\n在数据库中,产生死锁的原因是两个或多个事务都已封锁了一些数据对象,然后又都请求已被其他事务封锁的数据加锁,从而出现死等待.\n\n防止死锁的发生其实就是要破坏产生死锁的条件.预防死锁通常有两种方法:\n(1)一次封锁法\n\n要求每个事务必须一次将所有要使用的数据全部加锁,否则就不能继续执行.\n(2)顺序封锁法\n\n预先对数据对象规定一个封锁顺序,所有事务都按这个顺序实行封锁.\n不过,预防死锁的策略不大适合数据库系统的特点.\n\n9. 请给出检测死锁发生的一种方法,当发生死锁后如何解除死锁\n\n答:\n\n数据库系统一般采用允许死锁发生,DBMS检测到死锁后加以解除的方法.\nDBMS中诊断死锁的方法与操作系统类似,一般使用超时法或事务等待图法.\n\n超时法是:如果一个事务的等待时间超过了规定的时限,就认为发生了死锁.超时法实现简单,但有可能误判死锁,事务因其他原因长时间等待超过时限时,系统会误认为发生了死锁.若时限设置得太长,又不能及时发现死锁发生.\n\nDBMS并发控制子系统检测到死锁后,就要设法解除.通常采用的方法是选择一个处理死锁代价最小的事务,将其撤消,释放此事务持有的所有锁,使其他事务得以继续运行下去.当然,对撤销的事务所执行的数据修改操作必须加以恢复.\n\n10. 什么样的并发调度是正确的调度\n\n答:\n\n可串行化(Serializable)的调度是正确的调度.\n\n可串行化的调度的定义:多个事务的并发执行是正确的,当且仅当其结果与按某一次序串行地执行它们时的结果相同,我们称这种调度策略为可串行化的调度.\n\n11. 试述两段锁协议的概念.\n\n答:\n\n两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁.在对任何数据进行读,写操作之前,首先要申请并获得对该数据的封锁; 在释放一个封锁之后,事务不再申请和获得任何其他封锁.\n\n\"两段\"的含义是,事务分为两个阶段:\n\n第一阶段是获得封锁,也称为扩展阶段.在这阶段,事务可以申请获得任何数据项上的任何类型的锁,但是不能释放任何锁.\n\n第二阶段是释放封锁,也称为收缩阶段.在这阶段,事务释放已经获得的锁,但是不能再申请任何锁.\n\n12. 为什么要引进意向锁 意向锁的含义是什么\n\n答:\n\n引进意向锁是为了提高封锁子系统的效率.该封锁子系统支持多种封锁粒度.\n\n原因是:在多粒度封锁方法中一个数据对象可能以两种方式加锁—显式封锁和隐式封锁.因此系统在对某一数据对象加锁时不仅要检查该数据对象上有无(显式和隐式)封锁与之冲突;还要检查其所有上级结点和所有下级结点,看申请的封锁是否与这些结点上的(显式和隐式)封锁冲突;显然,这样的检查方法效率很低.为此引进了意向锁.\n\n意向锁的含义是:对任一结点加锁时,必须先对它的上层结点加意向锁.\n\n例如事务T要对某个元组加X锁,则首先要对关系和数据库加IX锁.换言之,对关系和数据库加IX锁,表示它的后裔结点—某个元组拟(意向)加X锁.\n\n引进意向锁后,系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了.例如,事务T要对关系R加X锁时,系统只要检查根结点数据库和R本身是否已加了不相容的锁(如发现已经加了IX,则与X冲突),而不再需要搜索和检查R中的每一个元组是否加了X锁或S锁.\n\n13. 试述常用的意向锁:IS锁,IX锁,SIX锁,给出这些锁的相容矩阵.\n\n答:\n\nIS锁\n\n如果对一个数据对象加IS锁,表示它的后裔结点拟(意向)加S锁.例如,要对某个元组加S锁,则要首先对关系和数据库加IS锁\n\nIX锁\n\n如果对一个数据对象加IX锁,表示它的后裔结点拟(意向)加X锁.例如,要对某个元组加X锁,则要首先对关系和数据库加IX锁.\n\nSIX锁\n\n如果对一个数据对象加SIX锁,表示对它加S锁,再加IX锁,即SIX = S + IX.\n相容矩阵(略)\n\n14. 理解并解释下列术语的含义:封锁,活锁,死锁,排它锁,共享锁,并发事务的调度,可串行化的调度,两段锁协议.\n\n答:(略,已经在上面有关习题中解答)\n\n25. 试述你了解的某一个实际的DBMS产品的并发控制机制.\n\n答:(略,参见《概论》第8节,简单介绍了有关Oracle的并发控制机制.)\n\n\n# 第九章 数据库安全性\n\n## 一,选择题\n1. 以下( D)不属于实现数据库系统安全性的主要技术和方法.\n\nA. 存取控制技术 B. 视图技术\nC. 审计技术 D. 出入机房登记和加锁\n2. SQL中的视图提高了数据库系统的(D ).\n\nA. 完整性 B. 并发控制\nC. 隔离性 D. 安全性\n3. SQL语言的GRANT和REMOVE语句主要是用来维护数据库的(C )\n\nA. 完整性 B. 可靠性\nC. 安全性 D. 一致性\n4. 在数据库的安全性控制中,授权的数据对象的( A),授权子系统就越灵活.\n\nA. 范围越小 B. 约束越细致\nC. 范围越大 D. 约束范围大\n\n选择题答案:\n(1) D (2) D (3) C (4) A\n\n## 三,简答题\n1. 什么是数据库的安全性\n\n答:数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露,更改或破坏.\n2. 数据库安全性和计算机系统的安全性有什么关系\n\n答:\n\n安全性问题不是数据库系统所独有的,所有计算机系统都有这个问题.只是在数据库系统中大量数据集中存放,而且为许多最终用户直接共享,从而使安全性问题更为突出.\n系统安全保护措施是否有效是数据库系统的主要指标之一.\n\n数据库的安全性和计算机系统的安全性,包括操作系统,网络系统的安全性是紧密联系,相互支持的,\n3. 试述实现数据库安全性控制的常用方法和技术.\n\n答:\n\n实现数据库安全性控制的常用方法和技术有:\n1) 用户标识和鉴别:该方法由系统提供一定的方式让用户标识自己的名字或身份.每次用户要求进入系统时,由系统进行核对,通过鉴定后才提供系统的使用权.\n2) 存取控制:通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库,所有未被授权的人员无法存取数据.例如C2级中的自主存取控制(DAC),B1级中的强制存取控制(MAC);\n3) 视图机制:为不同的用户定义视图,通过视图机制把要保密的数据对无权存取的用户隐藏起来,从而自动地对数据提供一定程度的安全保护.\n4)审计:建立审计日志,把用户对数据库的所有操作自动记录下来放入审计日志中, DBA可以利用审计跟踪的信息,重现导致数据库现有状况的一系列事件,找出非法存取数据的人,时间和内容等.\n5) 数据加密:对存储和传输的数据进行加密处理,从而使得不知道解密算法的人无法获知数据的内容.\n\n具体内容请参见《概论》9.2.\n\n4. 什么是数据库中的自主存取控制方法和强制存取控制方法\n\n答:\n自主存取控制方法:定义各个用户对不同数据对象的存取权限.当用户对数据库访问时首先检查用户的存取权限.防止不合法用户对数据库的存取.\n\n强制存取控制方法:每一个数据对象被(强制地)标以一定的密级,每一个用户也被(强制地)授予某一个级别的许可证.系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象.\n\n解析:\n\n自主存取控制中自主的含义是:用户可以将自己拥有的存取权限\"自主\"地授予别人.即用户具有一定的\"自主\"权.\n5. SQL语言中提供了哪些数据控制(自主存取控制)的语句 请试举几例说明它们的使用方法.\n答:\nSQL中 的自主存取控制是通过GRANT 语句和 REVOKE 语句来实现的.如:\nGRANT SELECT, INSERT ON Student TO 王平 WITH GRANT OPTION;\n就将Student表的SELECT和INSERT权限授予了用户王平,后面的\"WITH GRANT OPTION\"子句表示用户王平同时也获得了\"授权\"的权限,即可以把得到的权限继续授予其他用户.\n```sql\nREVOKE INSERT ON Student FROM 王平 CASCADE;\n```sql\n就将Student表 的INSERT权限从用户王平处收回,选项 CASCADE 表示,如果用户王平将 Student 的 INSERT 权限又转授给了其他用户,那么这些权限也将从其他用户处收回.\n\n6. 今有两个关系模式:\n\n职工(职工号,姓名,年龄,职务,工资,部门号)\n\n部门(部门号,名称,经理名,地址,电话号)\n\n请用SQL的GRANT和REVOKE语句(加上视图机制)完成以下授权定义或存取控制功能:\n\n(a) 用户王明对两个表有SELECT权力;\n```sql\nGRANT SELECT ON 职工,部门\nTO 王明;\n```\n(b) 用户李勇对两个表有INSERT和DELETE权力;\n```sql\nGRANT INSERT,DELETE ON 职工,部门 TO 李勇\n```\n(c) 每个职工只对自己的记录有SELECT权力;\n```sql\nGRANT SELECT ON 职工 WHEN USER()= NAME TO ALL\n```\n这里假定系统的GRANT语句支持WHEN子句和USER()的使用.用户将自己的名字作为ID.注意,不同的系统这些扩展语句可能是不同的.读者应该了解你使用的DBMS产品的扩展语句.\n\n(d) 用户刘星对职工表有SELECT权力,对工资字段具有更新权力;\n```sql\nGRANT SELECT,UPDATE(工资) ON 职工\nTO 刘星;\n```\n(e) 用户张新具有修改这两个表的结构的权力;\n```sql\nGRANT ALTER TABLE ON 职工,部门\nTO 张新;\n```\n(f) 用户周平具有对两个表所有权力(读,插,改,删数据),并具有给其他用户授权的权力;\n```sql\nGRANT ALL PRIVILIGES ON 职工,部门 TO 周平 WITH GRANT OPTION;\n```\n(g) 用户杨兰具有从每个部门职工中SELECT最高工资,最低工资,平均工资的权力,他不能查看每个人的工资.\n答:\n首先建立一个视图.然后对这个视图定义杨兰的存取权限.\n```sql\nCREATE VIEW 部门工资 AS\nSELECT 部门.名称,MAX(工资),MIN(工资),AVG(工资)\nFROM 职工,部门\nWHERE 职工.部门号 = 部门. 部门号\nGROUP BY 职工.部门号;\nGRANT SELECT ON 部门工资 TO 杨兰;\n```\n7. 把习题8中(a)~(g) 的每一种情况,撤销各用户所授予的权力.\n答:\n\n(a)\n```sql\nREVOKE SELECT ON 职工,部门\nFROM 王明\n```\n(b)\n```sql\nREVOKE INSERT,DELETE ON 职工,部门\nFROM 李勇;\n```\n(c)\n```sql\nREOVKE SELECT ON 职工\nWHEN USER()= NAME\nFROM ALL;\n```\n这里假定用户将自己的名字作为ID,且系统的REOVKE语句支持WHEN子句,系统也支持USER()的使用.\n\n(d)\n```sql\nREVOKE SELECT,UPDATE ON 职工\nFROM 刘星;\n```\n(e)\n```\nREVOKE ALTER TABLE ON 职工,部门\nFROM 张新\n```\n(f)\n```sql\nREVOKE ALL PRIVILIGES ON 职工,部门\nFROM 周平;\n```\n(g)\n```\nREVOKE SELECT ON 部门工资\nFROM 杨兰;\nDROP VIEW 部门工资;\n```\n8. 为什么强制存取控制提供了更高级别的数据库安全性\n\n答:\n\n强制存取控制(MAC)是对数据本身进行密级标记,无论数据如何复制,标记与数据是一个不可分的整体,只有符合密级标记要求的用户才可以操纵数据,从而提供了更高级别的安全性.\n\n9. 理解并解释MAC机制中主体,客体,敏感度标记的含义.\n\n答:\n\n主体是系统中的活动实体,既包括DBMS所管理的实际用户,也包括代表用户的各进程.\n客体是系统中的被动实体,是受主体操纵的,包括文件,基表,索引,视图等.\n对于主体和客体,DBMS为它们每个实例(值)指派一个敏感度标记(Label).敏感度标记被分成若干级别,例如绝密(Top Secret),机密(Secret),可信(Confidential),公开(Public)等.主体的敏感度标记称为许可证级别(Clearance Level),客体的敏感度标记称为密级(Classification Level).\n\n10. 什么是数据库的审计功能,为什么要提供审计功能\n\n答:\n\n审计功能是指DBMS的审计模块在用户对数据库执行操作的同时把所有操作自动记录到系统的审计日志中.\n\n因为任何系统的安全保护措施都不是完美无缺的,蓄意盗窃破坏数据的人总可能存在.利用数据库的审计功能,DBA可以根据审计跟踪的信息,重现导致数据库现有状况的一系列事件,找出非法存取数据的人,时间和内容等.\n\n11. 统计数据库中存在何种特殊的安全性问题\n\n答:\n\n统计数据库允许用户查询聚集类型的信息,如合计,平均值,最大值,最小值等,不允许查询单个记录信息.但是,人们可以从合法的查询中推导出不合法的信息,即可能存在隐蔽的信息通道,这是统计数据库要研究和解决的特殊的安全性问题.\n\n12. 试述你了解的某一个实际的DBMS产品的安全性措施.\n\n答:\n\n不同的DBMS产品以及同一产品的不同版本的安全措施各不相同,仁者见仁,智者见智,请读者自己了解.《概论》上9.4 简单介绍了有关ORACLE数据库的安全性措施.\n\n# 第十章 数据库完整性\n## 一,选择题\n1. 完整性检查和控制的防范对象( A),防止它们进入数据库.(C)安全性控制的防范对象是(B ),防止他们对数据库数据的存取.(D)\n\nA. 不合语义的数据 B. 非法用户\nC. 不正确的数据 D. 非法操作\n2. 下述哪个是SQL语言中的数据控制命令( A).\n\nA. GRANT B. COMMIT\nC. UPDATE D. SELECT\n3. 下述SQL语言中的权限,哪一个允许用户定义新关系时,引用其他关系的主码作为外码( C).\n\nA. INSERT B. DELETE\nC. REFERENCES D. SELECT\n\n选择题答案:\n(1) A C B D (2) A (3) C\n\n## 二,简答题\n1. 什么是数据库的完整性\n答:\n数据库的完整性是指数据的正确性和相容性.\n\n2. 数据库的完整性概念与数据库的安全性概念有什么区别和联系\n答:\n数据的完整性和安全性是两个不同的概念,但是有一定的联系.\n\n前者是为了防止数据库中存在不符合语义的数据,防止错误信息的输入和输出,即所谓垃圾进垃圾出(Garbage In Garbage Out)所造成的无效操作和错误结果.\n后者是保护数据库防止恶意的破坏和非法的存取.\n\n也就是说,安全性措施的防范对象是非法用户和非法操作,完整性措施的防范对象是不合语义的数据.\n\n3. 什么是数据库的完整性约束条件 可分为哪几类\n答:\n完整性约束条件是指数据库中的数据应该满足的语义约束条件.\n一般可以分为六类:\n\n静态列级约束,静态元组约束,静态关系约束,动态列级约束,动态元组约束,动态关系约束.\n\n静态列级约束是对一个列的取值域的说明,包括以下几方面:\n1. 对数据类型的约束,包括数据的类型,长度,单位,精度等\n2. 对数据格式的约束\n3. 对取值范围或取值集合的约束.\n4. 对空值的约束\n5. 其他约束\n\n静态元组约束就是规定组成一个元组的各个列之间的约束关系,静态元组约束只局限在单个元组上.\n\n静态关系约束是在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束.常见的静态关系约束有:\n1. 实体完整性约束.\n2. 参照完整性约束.\n3. 函数依赖约束.\n\n动态列级约束是修改列定义或列值时应满足的约束条件,包括下面两方面:\n1. 修改列定义时的约束\n2. 修改列值时的约束\n\n动态元组约束是指修改某个元组的值时需要参照其旧值,并且新旧值之间需要满足某种约束条件.\n\n动态关系约束是加在关系变化前后状态上的限制条件,例如事务一致性,原子性等约束条件.\n\n详细内容可以参见《概论》10.1中的介绍.\n\n4. DBMS的完整性控制机制应具有哪些功能\n\n答:\nDBMS的完整性控制机制应具有三个方面的功能:\n1) 定义功能,即提供定义完整性约束条件的机制.\n2) 检查功能,即检查用户发出的操作请求是否违背了完整性约束条件.\n3) 违约反应:如果发现用户的操作请求使数据违背了完整性约束条件,则采取一定的动作来保证数据的完整性.\n\n5. RDBMS在实现参照完整性时需要考虑哪些方面\n\n答:\nRDBMS在实现参照完整性时需要考虑以下几个方面:\n1) 外码是否可以接受空值\n\n2) 删除被参照关系的元组时的考虑,这时系统可能采取的作法有三种:\n\na) 级联删除(CASCADES);\nb) 受限删除(RESTRICTED);\nc) 置空值删除(NULLIFIES)\n\n3) 在参照关系中插入元组时的问题,这时系统可能采取的作法有:\na) 受限插入\nb) 递归插入\n\n4) 修改关系中主码的问题\n\n一般是不能用UPDATE语句修改关系主码的.如果需要修改主码值,只能先删除该元组,然后再把具有新主码值的元组插入到关系中.\n\n如果允许修改主码,首先要保证主码的唯一性和非空,否则拒绝修改.然后要区分是参照关系还是被参照关系.\n\n详细讨论可以参见《概论》10.2.\n\n6. 假设有下面两个关系模式:\n\n职工(职工号,姓名,年龄,职务,工资,部门号),其中职工号为主码;\n\n部门(部门号,名称,经理名,电话),其中部门号为主码;\n\n用SQL语言定义这两个关系模式,要求在模式中完成以下完整性约束条件的定义:\n定义每个模式的主码;定义参照完整性;定义职工年龄不得超过60岁.\n\n答\n```sql\nCREATE TABLE DEPT\n(Deptno NUMBER(2),\nDeptname VARCHAR(10),\nManager VARCHAR(10),\nPhoneNumber Char(12)\nCONSTRAINT PK_SC PRIMARY KEY (Deptno));\nCREATE TABLE EMP(Empno NUMBER(4),\nEname VARCHAR(10),\nAge NUMBER(2),\nCONSTRAINT C1 CHECK (Age《=60),\nJob VARCHAR(9),\nSal NUMBER(7,2),\nDeptno NUMBER(2),\nCONSTRAINT FK_DEPTNO\nFOREIGN KEY (Deptno)\nREFERENCES DEPT(Deptno));\n```\n7. 关系系统中,当操作违反实体完整性,参照完整性和用户定义的完整性约束条件时,一般是如何分别进行处理的\n\n答:\n\n对于违反实体完整性和用户定义的完整性的操作一般都采用拒绝执行的方式进行处理.而对于违反参照完整性的操作,并不都是简单地拒绝执行,有时要根据应用语义执行一些附加的操作,以保证数据库的正确性.具体的处理可以参见上面第5题或《概论》10.2中相应部分.\n\n8. 试述你了解的某一个实际的DBMS产品的完整性控制策略.\n\n答:\n\n不同的DBMS产品以及同一产品的不同版本的完整性控制策略各不相同,读者要去了解某一个DBMS产品的完整性控制策略.\n\n《概论》上10.3 简单介绍了有关ORACLE数据库的完整性控制策略.\n\n# 第十二章 数据库技术新发展\n1. 试述数据库技术的发展过程.\n\n答案要点:\n1) 数据模型是数据库系统的核心和基础.数据库技术的三个发展阶段应该按照数据模型的进展来界定.按照数据模型的进展,数据库技术可以相应地分为三个发展阶段.\n2) 数据模型的发展经历了格式化数据模型(包括层次数据模型和网状数据模型),关系数据模型两个阶段,以面向对象数据模型为代表的非传统数据模型的阶段.\n3) 同学们可以从每一代数据库系统的主要特征,代表性系统,主要成就,优点和不足来了解数据库技术的发展过程.\n\n层次数据库系统和网状数据库系统的数据模型虽然分别为层次模型和网状模型,但实质上层次模型是网状模型的特例.它们都是格式化模型.它们从体系结构,数据库语言到数据存储管理均具有共同特征,是第一代数据库系统.\n\n关系数据库系统支持关系模型.关系模型不仅简单,清晰,而且有关系代数作为语言模型,有关系数据理论作为理论基础.因此,关系数据库系统具有形式基础好,数据独立性强,数据库语言非过程化等特色,标志着数据库技术发展到了第二代.\n\n第二代数据库系统的数据模型虽然描述了现实世界数据的结构和一些重要的相互联系,但是仍不能捕捉和表达数据对象所具有的丰富而重要的语义,因此尚只能属于语法模型.\n\n第三代的数据库系统将是以更加丰富的数据模型和更强大的数据管理功能为特征,从而满足传统数据库系统难以支持的新的应用要求.\n\n2. 当前数据库技术发展的主要特征是什么\n\n答案要点:\n\n新一代数据库技术的特点是:\n\n(1) 面向对象的方法和技术对数据库发展的影响最为深远,数据库研究人员借鉴和吸收了面向对象的方法和技术,提出了面向对象数据模型(简称对象模型).该模型克服了传统数据模型的局限性,促进了数据库技术在一个新的技术基础上继续发展.\n\n(2) 数据库技术与多学科技术的有机结合,计算机领域中其他新兴技术的发展对数据库技术产生了重大影响.传统的数据库技术和其他计算机技术如,网络通信技术,人工智能技术,面向对象程序设计技术,并行计算技术移动计算技术等的互相结合,互相渗透,使数据库中新的技术内容层出不穷.\n\n(3) 面向应用领域的数据库技术的研究在传统数据库系统基础上,结合各个应用领域的特点,研究适合该应用领域的数据库技术,如数据仓库,工程数据库,统计数据库,科学数据库,空间数据库,地理数据库等,这是当前数据库技术发展的又一重要特征.\n\n解析\n我们可以用一个三维空间的视图,比较清晰地从数据模型,新技术内容,应用领域三个方面描述新一代数据库系统及其相互关系.\n\n3. 试述第一,二代数据库系统的主要成就.\n\n答案要点:\n\n第一代数据库系统指层次和网状数据库系统,其代表是:\n\n(1) 1969年IBM公司研制的层次模型的数据库管理系统IMS.\n\n(2) 美国数据库系统语言协商会CODASYL下属的数据库任务组DBTG对数据库方法进行了系统的研究,探讨,于20世纪60年代末70年代初提出了若干DBTG报告.DBTG 报告确定并建立了数据库系统的许多概念,方法和技术.DBTG所提议的方法是基于网状结构的.它是数据库网状模型的典型代表.在DBTG方法和思想的指引下数据库系统的实现技术不断成熟,开发了许多商品化的数据库管理系统,它们都是基于网状模型或层次模型的.\n\n可以说,层次数据库是数据库系统的先驱,而网状数据库则是数据库概念,方法,技术的奠基.它们是数据库技术中研究得最早的两种数据库系统.支持关系数据模型的关系数据库系统是第二代数据库系统.\n\n20世纪70年代是关系数据库理论研究和原型开发的时代,.其中以IBM San Jose研究室开发的System R和Berkeley大学研制的INGRES为典型代表.经过大量的高层次的研究和开发取得了一系列的成果,.主要是:\n\n(1) 奠定了关系模型的理论基础,给出了人们一致接受的关系模型的规范说明.\n\n(2) 研究了关系数据语言,有关系代数,关系演算,SQL语言及QBE等.这些描述性语言一改以往程序设计语言和网状,层次数据库系统中数据库语言的风格,以其易学易懂的优点得到了最终用户的喜爱,为20世纪80年代数据库语言标准化打下了基础.\n\n(3) 研制了大量的RDBMS的原型,攻克了系统实现中查询优化,并发控制,故障恢复等一系列关键技术.不仅大大丰富了DBMS实现技术和数据库理论,更重要的是促进了RDBMS产品的蓬勃发展和广泛应用.\n\n在计算机领域中把20世纪70年代称为数据库时代.20世纪80年代几乎所有新开发的系统均是关系的.关系数据库系统从实验室走向了社会,数据库技术日益广泛地应用到企业管理,情报检索,辅助决策等各个方面,成为实现和优化信息系统的基础和基本技术.\n\n4. 第三代数据库系统的主要特点是什么\n\n答:\n经过多年的研究和讨论,对第三代数据库系统的基本特征已有了共识.\n\n(1)第三代数据库系统应支持数据管理,对象管理和知识管理,除提供传统的数据管理服务外,第三代数据库系统将支持更加丰富的对象结构和规则,应该集数据管理,对象管理和知识管理为一体.由此可以导出第三代数据库系统必须支持OO数据模型.\n\n(2)第三代数据库系统必须保持或继承第二代数据库系统的技术,第三代数据库系统应继承第二代数据库系统已有的技术,.如第二代数据库系统的非过程化数据存取方式和数据独立性.不仅能很好的支持对象管理和规则管理,而且能更好地支持原有的数据管理,支持多数用户需要的即席查询等.\n\n(3)第三代数据库系统必须对其他系统开放数据库系统的开放性表现在:支持数据库语言标准;在网络上支持标准网络协议;系统具有良好的可移植性,可连接性,可扩展性和可互操作性等.\n\n5. 试述数据模型在数据库系统发展中的作用和地位.\n\n答案要点:\n1) 数据模型是数据库系统的核心和基础.\n2) 数据库的发展集中表现在数据模型的发展.\n\n6. 请用实例阐述数据库技术与其他学科的技术相结合的成果.\n答案要点:\n\n数据库技术与其他学科的内容相结合,是新一代数据库技术的一个显著特征,涌现出各种新型的数据库系统.例如:\n\n- 数据库技术与分布处理技术相结合,出现了分布式数据库系统;\n- 数据库技术与并行处理技术相结合,出现了并行数据库系统;\n- 数据库技术与人工智能技术相结合,出现了知识库系统和主动数据库系统;\n- 数据库技术与多媒体技术相结合,出现了多媒体数据库系统;\n- 数据库技术与模糊技术相结合,出现了模糊数据库系统; 等等.\n\n7. 请阐述以下数据库系统的主要概念,研究的主要问题及其发展过程:\n\n分布式数据库系统,并行数据库系统,主动数据库系统,多媒体数据库系统,模糊数据库系统.\n\n答案要点:\n\n下面仅仅给出有关概念,它们研究的主要问题及其发展过程请参见教科书《概论》.\n\n分布式数据库系统:分布式数据库是由一组数据组成的,这组数据分布在计算机网络的不同计算机上,网络中的每个结点具有独立处理的能力(称为场地自治),可以执行局部应用.同时,每个结点也能通过网络通信子系统执行全局应用.\n\n并行数据库系统:并行数据库系统是在并行机上运行的具有并行处理能力的数据库系统.并行数据库系统是数据库技术与并行计算技术相结合的产物.\n\n主动数据库系统:主动数据库是相对于传统数据库的被动性而言的.主动数据库能根据数据库的当前状态,主动适时地做出反应,执行某些操作,向用户提供有关信息.主动数据库是传统数据库技术与人工智能技术,面向对象技术相结合的产物.\n\n多媒体数据库系统:可实现对格式化和非格式化的多媒体数据的存储,管理和查询的数据库系统.\n\n模糊数据库系统:存储,组织,管理和操作模糊数据的数据库系统.\n\n8. 试述数据仓库的产生背景.\n\n答案要点:\n\n1) 数据库技术的发展和广泛应用使许多部门,企业积累了大量的原始数据,这些数据是宝贵的资源\n2) 对这些数据的分析和利用可以了解企业运行的情况,发现存在的问题,预测未来的趋势.\n3) 数据库系统作为数据管理的先进技术已经成功用于事务处理.但是它\n\n对分析处理的支持一直不能令人满意,具体表现在:\n(1) 分析处理时性能低.\n(2) 分析的数据对象分散,而且不一致,即缺乏对数据的清洗,集成能力.\n(3) 事务处理系统不具备动态集成的能力.\n(4) 系统缺乏对历史数据的有效组织和存储能力,而分析方法必须以大量的历史数据为依托.\n(5) 在事务处理系统中存储的是细节数据,不适合进行分析处理,而事务处理系统又不具备对数据的综合能力.\n\n总之,DSS对数据在空间和时间的广度上都有了更高的要求,.而事务处理环境难以满足这些要求.在事务型环境中直接构建分析型应用是一种失败的尝试.数据仓库正是为了构建这种新的分析处理环境而出现的一种数据存储和组织技术.但是数据仓库的主要驱动力并不是过去的缺点,而是市场商业经营行为的改变,市场竞争要求捕获和分析事务级的业务数据.\n\n\n\n9. 数据仓库数据的基本特征是什么\n\n答案要点:四个基本特征是:\n\n· 数据仓库的数据是面向主题的\n· 数据仓库的数据是集成的\n· 数据仓库的数据是不可更新的\n· 数据仓库的数据是随时间不断变化的\n\n10. 什么是联机分析处理 什么是数据挖掘\n\n答案要点:\n\n联机分析处理OLAP是以海量数据为基础的复杂分析技术.\n\nOLAP支持各级管理决策人员从不同的角度,快速灵活地对数据仓库中的数据进行复杂查询和多维分析处理,并且能以直观易懂的形式将查询和分析结果提供给决策人员,以方便他们及时掌握企业内外的情况,辅助各级领导进行正确决策,提高企业的竞争力\n\n数据挖掘是从超大型数据库(VLDB)或数据仓库中发现并提取隐藏在内的模式的过程,这些模式是有效的,新颖的,有潜在使用价值的和易于理解的.目的是帮助决策者寻找数据间潜在的关联,发现经营者被忽略的要素,而这些要素对预测趋势,决策行为也许是十分有用的信息.\n\n11. 基于数据库技术的DSS解决方案是什么\n\n答:\n\n基于数据库技术的DSS的解决方案是: DW+OLAP+DM DSS的可行方案\n\n数据仓库,联机分析处理和数据挖掘是作为三种独立的信息处理技术出现的.数据仓库用于数据的存储和组织,OLAP集中于数据的分析,数据挖掘则致力于知识的发现.由于这三种技术内在的联系性和互补性,将它们结合起来是一种新的DSS构架.是DSS有效而可操作的整体解决方案.\n\n12. 什么是工程数据库\n\n答:\n\n工程数据库是一种能存储和管理各种工程设计图形和工程设计文档,并能为工程设计提供各种服务的数据库.\n主要应用于CAD/CAM,CIM,CASE等工程应用领域.\n\n工程数据库中,由于传统的数据模型难以满足工程应用的要求,需要运用新的模型技术,如扩展的关系模型,语义模型,面向对象的数据模型.\n\n工程数据库管理系统的功能与传统数据库管理系统有很大不同.\n\n13. 什么是统计数据库\n\n答:\n\n统计数据库是一种用来对统计数据进行存储,统计,分析的数据库系统.\n\n统计数据具有层次型特点,但并不完全是层次型结构.统计数据也有关系型特点,但关系型也不完全满足需要.统计数据具有一些特殊的性质,例如:\n\n1) 分类属性和统计属性\n2) 多维性\n3) 分类属性的层次结构\n4) 微数据和宏数据之分\n\n统计数据库中常用的操作有:抽样,邻近搜索,估计与插值,转置,聚集及复杂的分析操作.这些操作不同于关系数据库中传统的查询,增加,删除,修改操作.人们希望能从DMBS一级来支持以上的数据特性和操作.因此,研究和发展了统计数据库技术.\n\n统计数据库在安全性方面有特殊的要求,要防止某些用户在统计数据库中利用对统计数据(如综合数据)的合法查询推导出该用户无权了解的某一个体的具体数据.\n\n14. 什么是空间数据库\n\n答:\n\n空间数据库系统是描述,存储和处理空间数据及其属性数据的数据库系统.\n\n空间数据是用于表示空间物体的位置,形状,大小和分布特征等诸方面信息的数据.\n\n空间数据的特点是不仅包括物体本身的空间位置及状态信息,还包括表示物体的空间关系(即拓扑关系)的信息.\n\n空间数据库是随着地理信息系统(GIS)的开发和应用而发展起来的数据库新技术.目前,空间数据库系统不是独立存在的系统,它是和应用紧密结合,大多数作为地理信息系统的基础和核心的形式出现.\n\n空间数据库的研究涉及计算机科学,地理学,地图制图学,摄影测量与遥感,图像处理等多个学科.空间数据库技术研究的主要内容包括:\n1) 空间数据模型\n2) 空间数据查询语言\n3) 空间数据库管理系统\n\n等等.\n\n# 第十三章 面向对象程数据库系统\n1. 面向对象程序设计的基本思想是什么 它的主要特点是什么\n\n答案要点:\n\n面向对象程序设计的基本思想是封装和可扩展性.\n\n封装的特点:\n\n面向对象程序设\n\n计就是把数据结构和数据结构上的操作算法封装在一个对象之中.\n\n对象是以对象名封装的数据结构和可施加在这些数据上的私有操作.对象的数据结构描述了对象的状态,对象的操作是对象的行为.\n\n面向对象程序设计中,操作名列在封装对象的界面上,当其他对象要启动它的某个操作时,以操作名发一条消息,该对象接受消息,操作动作起来,完成对私有数据的加工.当一个面向对象的程序运行完毕时,各对象也就达到了各自的终态.输入,输出也由对象自己完成.\n\n这种全封装的计算实体给软件带来了模块性,安全性等显著优点.因为它基本没有数据耦合,对象间没有因操作而产生的边界效应,出了错可以很快找到原因,所以易于维护和修改.\n\n可扩展性的特点:\n\n面向对象程序设计的可扩展性体现在继承性和行为扩展两个方面.\n因为对象具有一种层次关系.每个对象可以有子对象.子对象可以继承父对象(及其祖先对象)的数据结构和操作,继承的部分就可以重用.\n另一方面子对象还可以增加新的数据结构和新的操作.新增加的部分就是子对象对父对象发展的部分.\n\n面向对象程序设计的行为扩展是指可以方便地增加程序代码来扩展对象的行为而不会影响该对象上的其他操作.\n\n2. 定义并解释OO模型中以下核心概念: 对象与对象标识,封装,类,类层次.\n\n答案要点:\n\n1) 对象与对象标识OID\n\n现实世界的任一实体被模型化为一个对象,每个对象有一个唯一的标识,称为对象标识.\n\n2) 封装\n\n每一个对象是其状态与行为的封装,其中状态是该对象一系列属性值的集合,而行为是在对象状态上操作的集合,操作也称为方法.\n3) 类\n\n共享同样属性和方法集的所有对象构成了一个对象类简称类,一个对象是某一类的一个实例.类的属性的定义域可以是任何类,即可以是基本类也可以是包含属性和方法的一般类,还也可是这个类自身.\n4) 类层次\n\n在一个面向对象数据库模式中,可以定义一个类(如C1)的子类(如C2),类C1称为类C2的超类(或父类).子类(如C2)还可以再定义子类(如C3).这样,面向对象数据库模式的一组类形成一个有限的层次结构,称为类层次.\n\n3.OO模型中对象标识与关系模型中的\"码\"有什么区别\n\n答案要点:\n\n对象标识具有永久持久性.一个对象一经产生系统就给它赋于一个在全系统中唯一的对象标识符,直到它被删除.对象标识是由系统统一分配的,用户不能对对象标识符进行修改.对象标识是稳定的,独立于值的,它不会因为对象中某个值的修改而改变.\n\n关系模型中的\"码\"是值标识,不具有永久持久性,只具有程序内持久性.码是由用户建立的,用来区分关系的不同元组.\n\n4.什么是单继承 什么是多重继承 继承性有什么优点\n\n答案要点:\n\n若一个子类只能继承一个超类的特性(包括属性,方法和消息),这种继承称为单继承;若一个子类能继承多个超类的特性,这种继承称为多重继承.\n\n继承性优点:\n1) 它是建模的有力工具,提供了对现实世界简明而精确的描述.\n2) 它提供了信息重用机制.由于子类可以继承超类的特性,这就可以避免许多重复定义.\n\n5. 什么是操作的重载 在OODB中为什么要滞后联编\n\n答案要点:\n在OO模型中对于同一个操作,可以按照类的不同,重新定义操作的实现,这称为操作的重载.这样,同一个操作名就与不同的实现方法,与不同的参数相联系.\n\n为了提供这个功能,OODBMS不能在编译时就把操作名联编到程序上,必须在运行时根据实际请求中的对象类型和操作来选择相应的程序,把操作名与它联编上(即把操作名转换成该程序的地址),这个推迟的转换称为滞后联编.\n\n6. 什么是OODB模式演进 为什么面向对象数据库模式的修改要比关系模式的修改复杂得多\n\n答案要点:\n\n面向对象数据库模式是类的集合.模式为适应需求的变化会随着时间而变化,这称为模式演进.模式演进包括创建新的类,删除旧的类,修改类的属性和操作等.\n\n面向对象数据库模式的修改要比关系模式的修改复杂的原因是:\n1) 模式改变频繁\n使用OODB系统的应用通常需要频繁地改变OODB数据库模式.例如OODB常运用于工程设计环境中,设计环境特征之一就是不断变化.\n2) 模式修改复杂\nOO模型具有很强的建模能力和丰富的语义,包括类本身的语义,类属性之间和类之间丰富的语义联系,这使得模式修改操作的类型复杂多样.\n3) OODB中模式演进往往是动态的,使得实现技术更加复杂.\n\n7. 什么是对象-关系数据库 它的主要特点是什么 常用的实现方法有哪些\n\n答案要点:\n\n对象-关系数据库系统是将关系数据库系统与面向对象数据库系统两方面的特征相结合,不仅支持核心的面向对象数据模型,而且支持传统数据库系统所具有的特征.\n\n主要特点有:\n1) 具有原来关系数据库的各种特点;\n2) 扩充数据类型;\n3) 支持复杂对象;\n4) 支持继承的概念;\n5) 提供通用的规则系统;\n\n实现对象-关系数据库系统的方法主要有以下五类.\n\n1) 从头开发对象-关系DBMS.\n\n2) 在现有的关系型DBMS基础上进行扩展.扩展方法有两种:\na) 对关系型DBMS核心进行扩充,逐渐增加对象特性.\nb) 不修改现有的关系型DBMS核心,而是在现有关系型DBMS外面加一个包装层.\n\n3) 将现有的关系型DBMS与其他厂商的对象-关系型DBMS连接在一起,使现有的关系型DBMS直接而迅速地具有了对象-关系特征.连接方法主要有两种:\na) 关系型DBMS使用网关技术与其他厂商的对象-关系型DBMS连接.\nb) 将对象-关系型引擎与关系型存储管理器结合起来,即以关系型DBMS作为系统的最底层,对象-关系型系统作为上层.\n4) 将现有的OO型DBMS与其他厂商的对象-关系型DBMS连接在一起,使现有的面向对象型DBMS直接而迅速地具有了对象-关系特征.\n\n5) 扩充现有的面向对象的DBMS,使之成为对象-关系型DBMS.\n\n# 第十四章 分布式数据库系统\n1. 什么样的数据库系统是分布式数据库系统 图14.1的系统配置在什么情况下只能算分散的数据库系统 在什么条件下才是分布式数据库系统\n\n答案要点:\n\n分布式数据库是由一组数据组成的,这组数据分布在计算机网络的不同计算机上,网络中的每个结点具有独立处理的能力(称为场地自治),可以执行局部应用.同时,每个结点也能通过网络通信子系统执行全局应用.\n\n分布式数据库定义的要点:分布性,逻辑整体性,自治性和协作性.\n\n解析:\n1) 分布性,数据库中的数据不是存储在同一场地上,这就可以和集中式数据库相区别.\n2) 逻辑整体性,这些数据逻辑上是互相联系的,是一个整体,逻辑上如同集中数据库.\n3) 自治性,分布数据库中每个结点上的DBMS具有独立处理的能力(如果没有连入网络,也是一个完整的DBMS).\n4) 协作性,分布数据库中各个结点上的DBMS能相互协调,执行全局应用.\n\n答案要点:\n\n《概论》图14.1中,如果用户既可以通过客户机对本地服务器中的数据库执行局部应用,也可以对两个或两个以上结点中的数据库执行全局应用,这样的系统是分布式数据库系统.不支持全局应用的系统不能称为分布式数据库系统,即只是分散的数据库系统.\n\n(详细说明参见《概论》14.1.1)\n\n2. 分布式数据库系统有什么特点\n\n答案要点:\n\n分布式数据库系统是在集中式数据库系统技术的基础上发展起来的,但不是简单地把集中式数据库分散地实现,它是具有自己的性质和特征的系统.\n数据独立性:除了数据的逻辑独立性与物理独立性外,还具有数据分布独立性亦称分布透明性.\n\n集中与自治相结合的控制结构:各局部的DBMS可以独立地管理局部数据库,具有自治的功能.同时又有集中控制机制,协调各局部DBMS的工作,执行全局应用.\n\n数据可以适当冗余以提高系统的可靠性,可用性和性能.\n\n全局的一致性,可串行性和可恢复性.分布式数据库系统中各局部数据库应满足集中式数据库的一致性,并发事务的可串行性和可恢复性.除此以外还应保证数据库的全局一致性,全局并发事务的可串行性和系统的全局可恢复性.\n\n(详细说明参见《概论》14.1.2).\n\n3. 试述研制分布式数据库系统的目的和动机.\n\n答案要点:研制分布式数据库系统的目的和动机,主要包括技术和组织两方面.\n\n适应部门分布的组织结构,降低费用;\n提高系统的可靠性和可用性;\n充分利用数据库资源,提高数据库的利用率和共享程度;\n逐步地扩展系统处理能力和系统规模.\n\n(详细说明参见《概论》14.1.3).\n\n4. 试述分布式数据库系统的模式结构.\n\n答案要点:\n\n分布式数据库系统的模式结构可以分为两大部分:集中式数据库系统的模式结构和分布式数据库系统增加的模式级别,其中包括:\n\n1) 全局外模式,它们是全局应用的用户视图,是全局概念模式的子集.\n2) 全局概念模式,它定义分布式数据库中数据的整体逻辑结构,使得数据如同没有分布一样.\n3) 分片模式,定义片段以及全局关系到片段的映象.\n4) 分布模式,定义片段的存放结点.分布模式的映象类型确定了分布式数据库是冗余的还是非冗余的.\n\n(详细可参考《概论》图14.3分布式数据库系统的模式结构).\n\n5. 什么是数据分片 有几种分片方式 数据分片的目的是什么 有什么优点\n\n答案要点:\n\n数据分片就是将数据表按照一定条件划分成若干子集,每个子集称为一个片段.\n分片的方式有多种,水平分片和垂直分片是两种基本的分片方式,混合分片和导出分片是较复杂的分片方式.\n\n水平分片是指按一定的条件将关系表按行(水平方向)分为若干不相交的子集,每个子集为关系的一个片段.\n\n垂直分片是指将关系按列(垂直方向)分为若干子集.垂直分片的各个片段都要包含关系的码.这样才能从各个片段重构原来的关系.\n\n导出分片是指导出水平分片,即水平分片的条件不是本身属性的条件而是其他关系的属性的条件.\n\n混合分片是指按上述三种分片方式得到的片段继续按另一种方式分片.\n\n数据分片的优点是:数据不是按照关系而是按片段来存放,有利于更好地根据用户需求来组织数据的分布,也有利于控制数据的冗余度.\n\n6. 试述分布透明性的内容.\n\n答案要点:\n\n分布透明性包括分片透明性,位置透明性和局部数据模型透明性.\n\n分片透明性指用户或应用程序只对全局关系进行操作而不必考虑关系的分片.当分片模式改变了,由于全局模式到分片模式的映象,全局模式不变,应用程序不必改写.\n\n位置透明性指用户或应用程序不必了解片段的存储场地,当存储场地改变了,由于分片模式到分布模式的映象,应用程序不必改变.同时,若片段的重复副本数目改变了,数据的冗余度改变了,用户也不必关心如何保持各副本的一致性,这就是重复副本的透明性.\n\n局部数据模型透明性指用户或用户程序不必了解局部场地上使用的是哪种数据模型.\n\n7. 什么是同构型D-DBMS 什么是异构型D-DBMS\n\n答案要点:\n\nD-DBMS的同构和异构可以有三级:硬件级,操作系统级和局部DBMS级.其中最主要的是局部DBMS这一级,因为硬件和操作系统的不同将由通信软件处理和管理.所以,同构型D-DBMS定义为:在分布数据库系统中若每个结点的局部数据库具有相同的DBMS则成为同构型D-DBMS;若各结点的局部数据库具有不同的DBMS,则成为异构型的D-DBMS.\n\n(详细说明参见《概论》14.2.4)\n\n8. 设在《概论》14.2.3节的分布式数据库系统例子中,还有全局关系SC(SNO,CNO,G),它具有两个导出分片SC_A,SC_B,分别存储理学院和文学院学生的选课记录.SC_A存放在场地4,SC_B存放在场地5.今有一个稍复杂的查询,从终端输入一个课程号,查找选修该课程的学生学号和姓名,并把它们显示在屏幕上.请写出具有不同层次分布透明性(类比例子中的三种情况)的应用程序.不必给出细节,只需写出算法思想.\n\n情况1 若系统具有分片透明性,则\n```sql\nScanf(〃% s〃,SCnumber); /*从终端读入课程号到变量SCnumber中 */\nEXEC SQL SELECT Sno,Sname INTO :SNO, :NAME\n/ * SNO,NAME为程序变量*/\nFROM SC,Student /*在全局关系SC,Student中查找*/\nWHERE SC.Cno =:SCnumber AND SC.Sno=Student.Sno;\nPrintf(〃% s,% s〃,SNO,NAME); /*把SNO,NAME输出在屏幕上*/\n```\n情况2 若系统具有位置透明性,但不具有分片透明性,则\n```sql\nScanf(〃% s〃,SCnumber);\nEXEC SQL SELECT Sno,Sname INTO :SNO, :NAME\nFROM SC_A,S_A\nWHERE SC_A.Cno =:SCnumber AND SC_A.Sno=S_A.Sno;\nIf(! FOUND){\nEXEC SQL SELECT Sno,Sname INTO :SNO, :NAME\nFROM SC_B,S_B\nWHERE SC_B.Cno =:SCnumber AND SC_B.Sno=S_B.Sno;\n}\nPrintf(〃% s,% s〃,SNO,NAME);\n```\n情况3 若系统只具有局部数据模型透明性,不具有位置透明性(当然也就不具有分片透明性),则\n```sql\nScanf(〃% s〃,SCnumber);\nEXEC SQL SELECT Sno,Sname INTO :SNO,:NAME\nFROM SC_A AT Site4, S_A AT Site1\n/*先在场地4的片段SC_A和场地1的片段S_A中查找*/\nWHERE SC_A.Cno =:SCnumber AND SC_A.Sno=S_A.Sno;\nIf(! FOUND){\nEXEC SQL SELECT Sno,Sname INTO :SNO,:NAME\nFROM SC_B AT Site5,S_B AT Site2\n/*再在场地5的片段SC_B和场地2的片段S_B中查找*/\n/*也可以在场地5的片段SC_B和场地3的片段S_B中查找*/\nWHERE SC_B.Cno =:SCnumber AND SC_B.Sno=S_B.Sno;\n}\nPrintf(〃% s,% s〃,SNO,NAME);\n```\n9. 试述下列概念:两段提交协议(2PC);分布事务的原子性;全局死锁.\n\n答案要点:\n2PC:2PC把一个分布事务的事务管理分为协调者和参与者.\n2PC的第一阶段:协调者向所有参与者发出\"准备提交\"信息.如果某个参与者准备提交,就回答\"就绪\"信息,否则回答\"撤销\"信息.参与者在回答前,应把有关信息写入自己的日志中.协调者在发出准备提交信息前也要把有关信息写入自己的日志中.如果在规定时间内协调者收到了所有参与者\"就绪\"的信息,则将作出提交的决定,否则将作出撤销的决定.\n\n2PC的第二阶段:协调者将有关决定的信息先写入日志,然后把这个决定发送给的所有的参与者.所有参与者收到命令之后首先往日志中写入\"收到提交(或撤销)\"决定的信息,并向协调者发送\"应答(ACK)\"消息,最后执行有关决定.协调者收到所有参与者的应答消息后,一个事务的执行到此结束,有关日志信息可以脱机保存.\n\n分布事务的原子性:分布事务的原子性就应该是:组成一个全局事务的所有子事务要么一致地全部提交,要么一致地全部滚回.\n\n全局死锁:全局事务执行时发生的涉及两个以上场地上的死锁.\n\n10. 在分布式数据库系统中,对多副本的封锁有几种解决方法\n\n处理多副本的封锁可采取如下几种方法:\n1) 对写操作,要申请对所有副本的X锁.对于读操作,只要申请对某个副本的S锁.\n2) 无论是写操作还是读操作都要对多数(大于半数)副本申请X锁或S锁.\n3) 规定某个场地上的副本为主副本,所有的读写操作均申请对主副本的封锁.\n\n# 第十五章 并行数据库系统\n1. 什么是并行数据库系统\n\n答案要点:\n并行数据库系统是在并行机上运行的具有并行处理能力的数据库系统.并行数据库系统是数据库技术与并行计算技术相结合的产物.\n\n2. 试述并行数据库系统的研制目标.\n\n答案要点:\n\n并行数据库系统该实现如下目标:\n1) 高性能\n并行数据库系统通过将数据库管理技术与并行处理技术有机结合,发挥多处理机结构的优势,提供比相应的大型机系统更高的性能价格比和可用性.\n2) 高可用性\n并行数据库系统可通过数据复制来增强数据库的可用性.\n3) 可扩充性\n系统通过增加处理和存储能力来平滑地扩展性能,应具有线性伸缩比和线性加速比.\n\n具体说明可参考《概论》15.2.\n\n3. 什么是并行数据库系统的伸缩比和加速比\n\n答案要点:\n\n线性伸缩比是指当任务扩大N倍,系统处理和存储能力也扩大N倍时系统性能不变.\n线性伸缩比=(小任务在小系统上的运行时间)/(大(N倍)任务在大任务上的运行时间)=1\n线性加速比是指当任务不变而系统处理和存储能力扩大N倍时,系统性能也提高N倍.\n线性加速比=(小系统上执行一个任务的时间)/(大(N倍)系统上执行同一任务的时间)=N\n\n4. 并行数据库系统有哪几种体系结构 试比较它们的特点.\n\n答案要点:\n从硬件结构来看,根据处理机与磁盘,内存的相互关系可以将并行计算机分为三种基本的体系结构:\n\n·共享内存结构(SM);\n·共享磁盘结构(SD);\n·无共享资源结构(SN).\n\n此外还有混合结构,即整个系统是Shared_Nothing结构而每个结点是Shared_Memory结构.这种结构综合了SM与SN的优点.\n\n1) SM并行结构\nSM并行结构由多个处理机,一个共享内存(主存储器)和多个磁盘存储器构成.多处理机和共享内存由高速通讯网络连接,每个处理机可直接存取一个或多个磁盘,即所有内存与磁盘为所有处理机共享.\n2) SD并行结构\nSD并行结构由多个具有独立内存的处理机和多个磁盘构成.每个处理机都可以读写任何磁盘.\n3) SN并行结构\nSN并行结构由多个处理节点构成.每个处理节点具有自己独立的处理机,内存和磁盘存储器.多个处理机结点由高速通信网络连接.\n\n5. 并行数据库系统中并行查询优化的必要性和困难何在\n\n答案要点:\n\n查询优化始终是数据库管理系统的重要组成部分,查询优化的目标在于提高执行效率.由于并行数据库环境中存在多个处理机,并行查询优化应尽可能地使每个操作并行处理,充分利用系统资源提高并行度来达到提高系统性能的目的.并行查询优化面临的两大困难在于:\n1) 执行计划的搜索空间十分庞大\n2) 执行时的某些系统参数比如CPU数目,内存大小在优化时是未知的.\n\n6. 试述数据划分在并行查询处理中的重要性.\n\n答案要点:\n\n数据划分是并行查询处理的重要基础.研究和实际表明,数据划分对于并行数据库系统的性能具有很大的影响.\n\n通过将每个关系的数据划分为小的片段,并把这些小片段均匀地分布在系统的多个磁盘驱动器上可以降低数据的聚集度,使得每个操作能够由多个处理机来承担,从而减少查询的响应时间并提高整个系统的吞吐量.若负载不均,往往会造成多个处理机结点能力的浪费.所以使用正确的数据分布算法以达到负载均衡是并行数据库中数据分布的关键问题.\n\n7.并行数据库系统中有哪几种常用的数据划分方法\n\n答案要点:\n\n划分数据时可以依据一个属性的值,也可以同时依据多个属性的值,前者称为一维数据划分,后者则称为多维数据划分.\n\n一维数据划分方法相对比较简单,常用的数据划分方法有:\n\n·轮转法\n·Hash法\n·值域划分法\n\n此外,还有用户定义的划分法,模式划分法,Hybrid_Range划分法等.\n\n8. 试述并行数据库系统与分布式数据库系统的区别.\n\n答案要点:\n\n分布式数据库系统与并行数据库系统特别是与SN结构的并行数据库系\n具有很多相似点:\n\n1) 它们都是用网络连接各个数据处理结点;\n2) 整个网络中的所有结点构成一个逻辑上统一的整体;\n3) 用户可以对各个结点上的数据进行透明存取等等.\n\n分布式数据库系统和并行数据库系统的应用目标和具体实现方法不同,使得它们具有很大的不同:\n\n4) 应用目标不同\n\n并行数据库系统的目标是充分发挥并行计算机的优势,利用各个处理机结点并行地完成任务,提高系统的整体性能.\n分布式数据库系统的目标是实现场地自治和数据的全局透明共享,而不要求利用网络中的各个结点来提高系统处理性能.\n\n5) 实现方式不同\n\n在并行数据库系统中各结点间采用高速网络互连,结点间的数据传输代价相对较低,因此当某些结点处于空闲状态时,可以将工作负载过大的结点上的部分任务通过高速网传送给空闲结点处理,从而实现系统的负载平衡.\n\n在分布式数据库系统中,各结点间一般采用局域网或广域网相连,网络带宽较低,点到点的通信开销较大,因此在查询处理时一般应尽量减少结点间的数据传输量.\n\n6) 各结点的地位不同\n\n在并行数据库系统中,不存在全局应用和局部应用的概念.各结点是非独立的.\n\n而在分布式数据库系统中,各结点除了能通过网络协同完成全局事务外,更重要的是各结点具有场地自治性.","tags":["SQL"],"categories":["Database"]},{"title":"SQL 范式","path":"/posts/SQLnfs.html","content":"SQL范式\n<!--more-->\n# 数据库基本概念\n要理解范式，首先必须对知道什么是关系数据库，简单的说：关系数据库就是用二维表来保存数据。\n\n概念\n- `实体`现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，不如说“老师与学校的关系”。\n- `字段` 就是一项数据，也就是我们平常所说的“列”。\n- `记录` 一个实体的一个实例所特有的相关数据项的集合，也就是我们平常所说的“行”。\n- ` 码` 表中可以唯一确定一个元组的某个属性（或者属性组），如果这    样的码有不止一个，那么大家都叫   候选码，我们从候选码中挑一个出    来做老大，它就叫主码。\n- `主码` 被数据库设计者选中的，用来在同一实体集中区分不同实体的>    候选码；此外，应该选择哪些从不或极少变化的属性；\n- `键` 可唯一标识一条记录的一个字段或字段集，有时翻译为“码”。\n-  `主键（primary key)`用于唯一标识一个表中的一条记录的键。每个主键应该具有下列特征：\n    - 唯一的。\n    - 最小 的（尽量选择最少键的组合）。\n    - 非空。\n    - 不可更新的（不能随时更改）\n-  `外键（foreign keys` 对连接父表和子表的相关记录的主键字段的复制。\n- `依赖表（dependent table)` 也称为弱实体（weak entity）是需要用父表标识的子表。\n- `关联表（associative table）` 是多对多关系中两个父表的子表。\n-  `实体完整性` 每个表必须有一个有效的主 键。\n-  `参照完整性` 没有不相匹配的外键值。\n- `属性` 教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。\n- `元组` 表中的一行就是一个元组。\n- `分量` 元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。\n- `候选码` 如果任意超码的真子集不能包括超码，则称其为候选码；超码包括候选码；\n- `候选码` 若关系中的某一属性或属性组的值能唯一的标识一个元组，>    而其任何真子集都不能再标识，则称该属性组为（超级码）候选码。\n- `全码` 如果一个码包含了所有的属性，这个码就是全码。\n- `主属性(码属性)` 一个属性只要在任何一个候选码中出现过，这个属性就是主属性。\n- `非主属性(非码属性)` 与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。\n- `超码` 一个或多个属性的集合，这些属性的组合可以使我们在一个实>    体集中唯一的标识一个实体。\n- `外部码` 一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。\n\n# 范式\n概念\n(数据库设计范式，数据库的设计范式）是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式。\n\n满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。\n\n## 第一范式(1NF)\n如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF（即R符合第一范式）。简单的说，就是每一个列（属性）只有一个，没有重复。\n\n特点\n- 有主键，且主键不能为空。\n- 字段不能再分。\n\n要求\n- 1.必须有主键来加以识别。\n- 2.每个字段只能存放单一的值并确保有数据没有重复的组。\n\n例如：\n\n|姓名|班级|课程|\n|:---|:---|:---|\n|小明|1班|数学,语文|\n|小红|2班|英语|\n|小明|2班|数学|\n\n---\n里面还有重复组并且没有存放单一的值，并不符合第一范式，给其增加主键学号加以区别：\n\n|学号|姓名|班级|课程|\n|:---|:---|:---|:---|\n|101|小明|1班|数学|\n|101|小明|1班|语文|\n|201|小红|2班|英语|\n|202|小明|2班|数学|\n\n---\n\n## 第二范式(2NF)\n概念\n1. 首先要满足第一范式。它的规则是要求数据表里的所有数据都要和该数据表的主键有完全依赖关系。\n2. 若关系模式R€1NF，并且每一个 `非主属性` 都 `完全函数依赖` 于 R 的 `候选吗`，则R€2NF。\n\n判断方法：\n是否存在某个非主属性，它部分依赖`候选码`，或者说依赖候选码的一部分，存在则属于2NF。\n\n特点\n1. 满足第一范式。\n2. 表中的每一个非主属性，必须完全依赖于本表码。\n3. 只有当一个表中，主码由两个或以上的属性组成的时候，才会出现不符合第二范式的情况\n\n例如有表：\n|货物|供应商ID|供应商|价格|供应商地址|\n|:---|:---|:---|:---|:---|:---|\n|毛巾|01|世纪联华|10.0|星光大道|\n|牙刷|01|世纪联华|5.0|星光大道|\n|毛巾|02|十足|12.0|月光大道|\n\n\n- 可知，这里的主键有货物和供应商ID，价格和两个主键都有关，可是供应商地址只和供应商ID有依赖关系。那么不符合第二范式，我们可以将其修改为两张表：\n\n---\n\n|供应商ID|供应商|供应商地址|\n|:---|:---|:---|\n|01|世纪联华|星光大道|\n|02|十足|月光大道|\n\n---\n\n|货物|供应商ID|价格|\n|:---|:---|:---|\n|毛巾|01|10.0|\n|牙刷|01|5.0|\n|毛巾|01|12.0|\n\n---\n- 这样就符合了第二范式要求的表内数据和表内主键完全依赖的关系。\n\n## 第三范式(3NF)\n概念\n1. 在第二范式的基础上，要求所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。\n2. 若关系模式R€1NF,并且每一个 `非主属性` 都` 非传递依赖` 于 `候选码`，R€3NF。\n\n判断方法：\n\n是否存在某个`非主属性`，它传递依赖`候选码`或者函数依赖某个`非主属性`，存在则不属于3NF，不存在则属于3NF。\n\n特点：\n1. 满足第二范式。\n2. 非主属性不能传递依赖于码\n\n从上述表来说，供应商和供应商地址是相关的，知道了供应商也就知道了供应商地址（不考虑一厂多址的情况）。可以分为：\n\n|供应商ID|供应商|\n|:---|:---|\n|01|世纪联华|\n|02|十足|\n\n---\n\n|供应商ID|供应商地址|\n|:---|:---|\n|01|星光大道|\n|02|月光大道|\n\n# BC范式(BCNF)\n概念\n1. BCNF是修正的第三范式。\n2. 若关系模式R€1NF，对每个非平凡的函数依赖X-->Y，X一定是`超码`（具有唯一性）\n\n判断方法：\n1. 能够找到平凡函数依赖 X--->Y，左边的X不是超码\n2. BCNF意味着在关系模式中每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了任何属性(不光是非主属性，2NF和3NF所限制的都是非主属性)对候选键的传递依赖与部分依赖。\n\n![例子](https://i.loli.net/2018/05/29/5b0d0900efe53.png)\n\n要求：\n:   在满足第三范式的基础上，且不允许主键的一部分被另一部分或其它部分决定。\n\n特点：\n1. 满足第三范式。\n2. 所有非主属性对每一个码都是完全函数依赖。\n3. 所有的主属性对每一个不包含它的码，也是完全函数依赖。\n4. 没有任何属性完全函数依赖于非码的任何一组属性。\n\n---\n**参考**\n- [转载来源1](https://www.jianshu.com/p/6e8254a99314)\n- [转载来源2](http://josh-persistence.iteye.com/blog/2200644)","tags":["SQL"],"categories":["Database"]},{"title":"SQL 函数赖与模式分解","path":"/posts/SQLfunDep.html","content":"# 函数依赖 Functional Dependency\n数据依赖的一种，它反映属性或属性组之间相依存，互相制约的关系，即反映现实世界的约束关系。\n\n<!--more-->\n\n定义\n设R(U)是属性U上的一个关系模式，X和Y均为U={A1，A2，…，An}的子集，r为R的任一关系，如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X，记为X→Y。\n\n例：\n```\n(sno-学生ID，tno-教师ID，cno-课程ID，\nsname-学生姓名，tname-教师姓名，cname-课程名称，grade-成绩）\nsno→sname, cno→cname,(sno,cno)→grade √\nsname→sno, tno→cno, sno→tname ×\n```\n函数依赖是语义范畴\n1. 语义：数据所反映的现实世界事物本质联系\n2. 根据语义来确定函数依赖性的存在与否\n3. 函数依赖反映属性之间的一般规律，必须在关系模式下的任一个关系r中都满足约束条件。\n\n# 属性间的联系决定函数依赖关系\n例子\n设X、Y均是U的子集\n1. X和Y间联系是1:1，则X→Y,Y→X。（相互依赖，可记作X←→Y）\n2. X和Y间联系是M:1(M)， 则X→Y。\n3. X和Y间联系是M:N(M,N)，则X、Y间不存在函数依赖。\n\n# 完全函数依赖和部分函数依赖\n\n函数依赖分为完全函数依赖和部分函数依赖\n\n定义\n\n在R(U)中，如果X→Y，并且对于X的任何真子集X'都有X'Y'，则称 Y 完全依赖于 X ，记作X→Y；否则，如果X→Y，且X中存在一个真子集X'，使得X'→Y成立，则称 Y 部分依赖 于 X。\n\n例\n```\n学生ID，学生姓名，所修课程ID，课程名称，成绩\n（学生ID，所修课程ID）→成绩\n成绩既不能单独依赖于学生ID，也不能单独依赖于所修课程ID，因此成绩完全函数依赖于关键字。\n（学生ID，所修课程ID）→学生姓名\n学生ID→学生姓名\n学生姓名可以依赖于关键字的一个主属性——学生ID，因此学生姓名部分函数依赖于（学生ID，所修课程ID）。\n```\n# 平凡函数依赖和非平凡函数依赖\n平凡函数依赖\n\n当关系中属性集合Y是属性集合X的子集时(Y?X)，存在函数依赖X→Y，即一组属性函数决定它的所有子集，这种函数依赖称为 `平凡函数依赖`\n\n非平凡函数依赖\n\n当关系中属性集合Y不是属性集合X的子集时，存在函数依赖X→Y，则称这种函数依赖为 `非平凡函数依赖`。\n\n设X，Y均为某关系上的属性集，且X→Y\n1. 若Y包含于X，则称X→Y为：平凡函数依赖；(Sno, Cno) → Sno  (Sno, Cno) → Cno\n2. 若Y不包含于X，则称X→Y为：非平凡函数依赖。(Sno, Cno) → Grade\nY包含于X内，W于X相交，与Y无直接交集。则：X→Y为平凡函数依赖X→W, W→Y为非平凡函数依赖\n\n# 传递函数依赖 X→Y，Y→Z 则Z传递函数依赖于X\n例1\n设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。\n- 函数依赖\n设R(U)是一个属性集U上的关系模式，X和Y是U的子集。\n若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。\nX称为这个函数依赖的决定属性集(Determinant)。\nY=f(x)\n  - 说明：\n    - 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。\n    - 函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。\n    例如“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立\n    - 数据库设计者可以对现实世界作强制的规定。例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝装入该元组。\n\n例2\nStudent(Sno, Sname, Ssex, Sage, Sdept)\n- 假设不允许重名，则有:\n```\nSno → Ssex， Sno → Sage , Sno → Sdept，\nSno ←→ Sname, Sname → Ssex， Sname → Sage\nSname → Sdept\n但Ssex －\\→Sage\n若X→Y，并且Y→X, 则记为X←→Y。\n若Y不函数依赖于X, 则记为X－\\→Y。\n```\n- 在关系模式R(U)中，对于U的子集X和Y，\n```\n如果X→Y，但Y 不为 X的子集，则称X→Y是非平凡的函数依赖\n若X→Y，但Y 为 X的子集, 则称X→Y是平凡的函数依赖\n```\n例3\n在关系SC(Sno, Cno, Grade)中\n1. 凡函数依赖:(Sno, Cno) → Grade\n2. 平凡函数依赖：(Sno, Cno) → Sno(Sno, Cno) → Cno\n3. 部分函数依赖：若x->y 并且，存在X的真子集x1，使得x1->y,则 y部分依赖于 x。\n4. 完全函数依赖：若x->y并且，对于x的任何一个真子集x1，都不在x1->y 则称y完全依赖于x\n\n# 传递与直接函数依赖\n概念\n设有两个非平凡函数依赖 X  → Y，Y → Z，当 X 不依赖于 Y，则称 Z` 传递`函数依赖于 X。\n-这里之所以规定\" X 不函数依赖于 Y”，是因为当 Y → X 时，X 与 Y 就一一对应了，在这种情况下 Z 就`直接`函数依赖于 X（而不是我们所说的传递函数依赖）。\n\n- Z 传递函数依赖于 X，表名 Z 间接依赖于 X，从而表明 X 和 Z 之间关联较弱。\n\n# 函数依赖的 Armstrong 公理\n无冗余的函数依赖集 和 函数依赖的完备集（闭包）是好的关系设计。由已知的函数依赖集可以推导出 无冗余的函数依赖集 和 函数依赖的完备集（闭包）。\n\n## 基本公理和推理规则：\n基本公理：\n- `自反律`如果 Y ∈ X∈ U，则 X → Y 成立。（平凡函数依赖）\n- `增广律`如果 X → Y 在 R(U)  成立，且 Z∈ U，则 XZ → XY\n- `传递律`如果 X → Y，Y → Z 成立，则 X → Z 成立。\n\n推理规则：\n- `合并规则`{X → Y，X → Z}，则 X → YZ\n- `分解规则`{X → Y，Z ∈ Y}，则 X → Z。（或：X → YZ，那么 X → Y，X → Z）\n- `伪传递规则` {X → Y,YW → Z}，则 WX → Z\n- `复合规则`{X → Y，W → Z},则 XW → YZ\n- `自积律规则`{X → YZ，Z → W}，则 X → YZW\n\n## 属性闭包\n概念\n\n设 F 是属性集合 U 上的一个函数依赖集，X ∈ U，称 X+ = { A|:\tA∈U,X → A 由 F 按照 Armstrong 公理系统推导得到 } 为属性集的 x 关于 F 的闭包。\n\n例子：\n设有关系模式 R（U，F），U = ABC，F={A→B，B → C}，则有 A 的闭包 A+ = ABC，B+=BC，C+=C。\n\n函数依赖闭包和属性集闭包\n\n一般来说，我们很少会求函数依赖闭包，因为这样会产生大量“无意义”或者意义不大的函数依赖。多数时候，我们关心的只是 F+ 的一个子集，常常伴随的问题是某函数依赖 X → Y 是否在 F+中。而求解这个问题的解决方式，通常是求在 F 下，属性集合 X 的闭包 X+（至于其证明，有兴趣的可以查阅一下相关资料）。\n\n - 如何求解 X 的属性闭包：\n  \t- 设置初始值：令X(0) = ?，X(1)= X，F’=?。\n    - 若X(0)≠X(1),令 X(0)=X(1)。否则转向 4）。\n  - 构造函数依赖集合 F’={Y→Z | (Y→Z)∈F∩Y∈X(1)}，令 F = F – F’,对于其中的每个函数依赖 Y→Z，令X(1) = X(1)∪Z，转向 2）。\n    - 输出 X(1),它就是X+\n\n# 最小函数依赖集\n概念\n对于函数集 F ，称函数集Fmin 为F 的最小函数依赖集，如果 Fmin满足一下条件：\n1. Fmin与 F等价：Fmin+=F+。\n2. Fmin中每个函数依赖 X→Y 的依赖因素为单元素集，即Y中只含有一个属性集合。\n3. Fmin中每个函数依赖 X→Y的决定因素不存在冗余，即既要删除X中任何一个属性，就会改变Fmin的闭包。\n4. Fmin中每个函数毒不是冗余的，即删除 Fmin 中任意一个函数依赖，就会改变Fmin 的闭包。\n\n# 无损分解\n概念\n\n无损分解指的是对关系模式分解时，原关系模型下任一合法的关系值在分解之后应能通过自然联接运算恢复起来。反之，则称为有损分解。\n\n这里解释一下：“损”代表了信息的丢失的丢失，可能发生的情况是：分解后的关系模式通过自然连接合并，原有元组丢失或增加了无意义的元组，此情况记为“损”。在实际应用当中，我们希望通过自然连接之后可恢复原有关系模式，既不减少也不增加新的元组。那如何才可以做到无损分解呢？？答案是：保持原有关系模式的函数依赖\n\n保持函数依赖的分解\n\n分解需要保持函数依赖，因为 F 中每一个函数依赖都代表数据库的一个约束。如果模式分解不保持函数依赖，那在模式分解中就会丢失一些函数依赖。注意：这里保持原有的函数依赖，包括了通过原有函数依赖推到出来的函数依赖，可以理解为保持原有函数的 F+\n---\n**Via**\n- [源地址](http://www.cnblogs.com/ndxsdhy/archive/2010/12/21/1913123.html)\n- [函数依赖与模式分解](http://blog.51cto.com/peiquan/1425012)","tags":["SQL"],"categories":["Database"]},{"title":"SQL 授权","path":"/posts/SQLgrant.html","content":"SQL授权\n<!--more-->\n# 授权命令\n语法\n```sql\ngrant <权限名>[ ,<权限名>] on <对象>\nto 用户1,用户2,... | public [with grant option]\n```\n- 对应不同对象,有不可权限,代表不同的操作(语句)。\n\t注音: All Privileges--對象上的所有权限的总和。\n- public --表示所有用户\n- 指定With grant option时,用户可以获得的权限转受给其他用户;否則,用户只能使用而不能转受。\n- SQL 标准允许具有with grant option 的用户把相应的权限或其子集传递授予其他用户,但不允许循环授权,即被授权者不能把权限再授回给授权者或其祖先.\n\nDBA 执行了如下语句:\n```sql\ngrant select, update on Student to Liming\nwith grant option\n```\n- 则 `DBA` 把对 `Student` (基本表或视图)的权限赋给用户 Liming,因为有`with grant option`,所以 Lining 可以把这个权限再转授给其他用户。\n\n用户 Liming 执行了如下语句:\n```sql\ngrant select(Sno, Sname), update (Sname)\non Student to U5\n```\n- 则 `Liming` 把对 `Student` 上某些列的权限赋给用户` U5`,但 U5不可以把这个权限再转授给其他用户。\n\nDBA 对表查询的权限授予所有用户\n```sql\ngrant select on SC to public\n```\nGrant 还可以实现数据库类型和模式类型权限管理,格式如下:\n\n```sql\ngrant 权限名[,...] to user1,user2,...\n| public[with grant option]\n```\n\n授予用户 Liming 具有创建数据表和图的权限\n```sql\ngrant create table, create view to Liming\n```\n\n# 收回权限\n语法\n```sql\nrevoke 权限名[ ,…] on 对象 form\n用户1,用户2,… | public\n```\n- 收回权限时,若该用户已将权限转授给其他用户，则这些转受的权限也一并收回。\n\nDBA 执行以下语句:\n```sql\nrevoke update on Student from Liming\n```\n- DBA 回收用户` Liming` 的对` Student` 的更新权限.理论上，Liming转受给用户U5的对Student某些列的更新权限也一并收回udent 某些列的更新权限也要一并收回\n\n收回所有用户对表 SC 的查询权\n```sql\nRevoke select on SC from public\n```\n- `revoke`还可以实现数据库类型和模式类型权限收回,格式如下\n\n```sql\nrevoke 权限名[ ,…] from 用户1,用户2,... | public\n```\n\n收回Liming 创建表的权限。\n```sql\nRevoke create table from Liming\n```","tags":["SQL"],"categories":["Database"]},{"title":"SQL 存储过程","path":"/posts/SQLprocedure.html","content":"SQL存储过程\n<!--more-->\n建立\n```sql\ncreate procedure lianxi66\n@arel char(20)\n@x1 int output,@x2 float output\nas\nselect @x1=count(*),@x2=avg(年龄)\nfrom S\nwhere 所在系=@arel\n```\n引用\n```\ndeclare @ok int, @ck float\nexec lianxi66 \"会计系\",@ok output,@ck output\nprint @ok\nprint @ck\n```\n---------------------------------------------------------\n\n建立\n```sql\nCREATE PROCEDURE lianxi3511\n\n@varl char(10), @var3 int output\nas\nselect @var3=S.年龄\nfrоm ѕ\nwhere s.学号=@varl\n```\n引用\n```sql\nDeclare @res int\nExecute liarixi3511 '101101', @res output\nPrint @res\n```\n----------------------------------------------------------\n建立\n```sql\nCREATE PROCEDURE lianxi2511\n@var1 int, @var2 int, var3 int output\nAs\nSet @var3 = @vari*@var2\n```\n引用\n```sql\nDeclare @res int\nExecute liarxi2511 5, 7, @res output\nPrint @res\n\nexec liarxi2511 3,4\n```\n----------------------------------------------------------\n建立\n```sql\nCREATE PROCEDURE lianxi1511\n@student_no char (10),\n@course_no char (20)\nAS\nSELECT S.姓名, S.学号,SC.课程号,C.课程名, SC.成绩\nFROM S JOIN SC  ON S.学号=SC.学号\nINNER JOIN C  ON C.课程号=SC.课程号\nWHERE S.学号=@student_no\nANO SC.课程号=@course_no\n```\n引用\n```sql\nexec lianxi1511 '101101','101'\n```\n-----------------------------------------------------------\n# 习题\n若输入的学号存在则删除\n- 创建\n```sql\ncreate procedure del_cno1\n@cno char(20)\nas\nbegin tran t1 --事件t1开始\ndelete from kcgx  where 课程号=@cno\nif exists (select  * from xkgx where 课程号=@cno)\nrollback tran t1\nelse\ncommit tran t1\n```\n- 引用与验证\n```sql\nexec del_cno1 '305'\nselect * from xkgx\nselect * from kcgx\n```\n# 存储过程使用事务\n实例\n```sql\nCreate Procedure  MyProcedure\nAS\nBegin\nSet    NOCOUNT    ON;\nSet XACT_ABORT ON;\nbegin   tran  ok  --开始一个事务OK\ndelete  from  rxqz  where qz=   'rx015 ' --删除数据\nsave   tran  bcd   --保存一个事务点命名为bcd\nupdate  sz  set   name='李丽s' where name= '李丽'--修改数据\nif  @@error<>0  --判断修改数据有没有出错\nbegin --如果出错\nrollback   tran  bcd  -- 回滚事务到BCD 的还原点\ncommit   tran  ok  --提交事务\nend\nelse  --没有出错\ncommit  tran ok --提交事务\nEnd\n```\n---\n```sql\ncreate proc 1\n@si chark20),@pi char(20),@Ji chark20),@shu int\ninsert into SPJ values(@si,@pi,@Ji,@shu)\nbdgin tran t1\nif exists (select * from p where Pno=@Pi)\ncommit tran t1\nelse\nrollback tran t1\n```","tags":["SQL"],"categories":["Database"]},{"title":"SQL 级联","path":"/posts/SQLconstraints.html","content":"SQL级联\n<!--more-->\n# 主键约束\n在创建表的时候创建主键约束。\n```sql\ncreate table customer(\ncustomerld int identity not null\nprimary key,  --创建主键约\nCustomerName nvarchar(30) not null)\n```\n\n在已存在的表上创建主键约\n```sql\nalter table person\nadd constraint PK_Employee_Id  --约束名称\nprimary key(personld) --personld 字段名\n```\n\n# 外键约束\n创建表的时候创建外\n```sql\ncreate table orders (\norderld int identity not null\nprimary key,\ncustomerld int not null\nforeign key references customer(customerid)\n--约束类型-外键引用表(例名)\n)\n```\n\n在已存在的表中添加一个外键\n\n假设上面的代码去掉了添加外键行,那么可以书写代码如下:\n```sql\nalter table orders\nadd constraint FK_Orders_Customerld\nforeign key(customerid)  references customer(customerld)\n--外键约束, 外键列名, 被引用列名\n```\n\n# 级联动\n语法\n```sql\nalter table orders\nadd constraint FK_Orders_Customerld  --添加约束 名称\nforeign key (customerid) references customer(customerld)\n--外揵约束, 外键列名 被引用 列名\non update no action --默认 修改时不级联更新子表\non delete cascade   --删除时級联删除依赖行\n```\n# CHECK约束\n语法\n```sql\nalter table Account\nadd constraint CN_AccountAge\ncheck (Account_Age>18)\n--插入年龄必须大于18\n```\n- 如果此时视,添加一条不满足的记录,将报如下错误:\n```sql\ninsert into Account values (22,'洪','17')\n```\n----------------------------------------------------------\n例子\n```sql\nalter table Aocount\nWITH NOCHECK\nadd constraint CN_AccountAge18\ncheck\n(Account_Age>18)\n--插入年龄心须大于18\n```\n---\n```sql\nbegin tran\nselect * from s with(holdlock) --holdlock人为加锁\nwhere 学号='001'\nwaitfor delay'00 00:35' --等待秒\ncommit tran\nupdate s set 姓名='平安夜'\nwhere  学号='001'\n```","tags":["SQL"],"categories":["Database"]},{"title":"BaiduPCS-Go","path":"/posts/BaiduPCS-Go.html","content":"> BaiduPCS-Go 为仿 Linux shell文件处理命令的百度网盘命令行客户端\n<!--more-->\n# 安装\n- [Github Release](https://github.com/iikira/BaiduPCS-Go/releases)\t选择自己系统平台版本\n - 参考项目 [wiki](https://github.com/iikira/BaiduPCS-Go/wiki) 安装即可\n\n# 运行登录\n```\ncd BaiduPCS-Go\n./BaiduPCS-Go\nlogin\n```\n\n# 下载文件\n```\nd 文件名\n```","tags":["Linux","Windows","Termux"],"categories":["Diary"]},{"title":"SSH 的使用","path":"/posts/SSH.html","content":"SSH的简单运用\n<!--more-->\n# 基础使用\nSSH 登录远程主机 host\n```sh\nssh root@host\n```\n\n- 本地用户名与远程用户名一致，登录时可以省略用户名。\n\n```sh\nssh host\n```\n\n- SSH 的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。\n\n```sh\nssh -p 2222 root@host\n```\n# 公钥登录\nssh-keygen 生成公钥\n```sh\nssh-keygen\n```\n\n- 运行结束以后，在`$HOME/.ssh/`目录下，会新生成两个文件 `id_rsa.pub`和`id_rsa`。前者是你的公钥，后者是你的私钥。\n- 将公钥传送到远程主机 host 上面\n\n```sh\nssh-copy-id user@host\n```\n\n- 如果还是不行，就打开远程主机的`/etc/ssh/sshd_config`这个文件，检查下面几行前面\"#\"注释是否取掉。\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n```\n\n重启远程主机的 ssh 服务\n\n- Ubuntu系统\n\n```sh\nservice ssh restart\n```\n\n- Debian 系统\n\n```sh\n/etc/init.d/ssh restart\n```","tags":["Linux","Ubuntu","Termux","SSH"],"categories":["Coding"]},{"title":"SQL 约束","path":"/posts/SQLconstraint.html","content":"SQL：约束\n<!--more-->\n# UNIQUE 约束\n各约束意义\n- `UNIQUE`约束唯一标识数据库表中的每条记录。\n- `UNIQUE`和`PRIMARY KEY`约束均为列或列集合提供了唯一性的保证。\n- `PRIMARY KEY`约束拥有自动定义的 UNIQUE 约束。\n- 请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。\n\n## CREATE TABLE 时的 UNIQUE 约束\n- 在 \"Persons\" 表创建时在 \"P_Id\" 列上创建 UNIQUE 约束\n- MySQL\n\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL,\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255),\nUNIQUE (P_Id)\n)\n```\n\n- SQL Server/Oracle/MS Access\n\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL UNIQUE,\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255)\n)\n```\n## 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束\n\n- MySQL/SQL Server/Oracle/MS Access\n\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL,\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255),\nCONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)\n)\n```\n\n## ALTER TABLE 时的 UNIQUE 约束\n语法\n\n- 当表已被创建时，如需在 \"P_Id\" 列创建 UNIQUE 约束\n\n```sql\nALTER TABLE Persons\nADD UNIQUE (P_Id)\n```\n## 如需命名 UNIQUE 约束，并添加 UNIQUE 约束，\n语法\n\nMySQL / SQL Server / Oracle / MS Access：\n\n```sql\nALTER TABLE Persons\nADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)\n```\n\n## 撤销 UNIQUE 约束\n撤销 UNIQUE 约束\nMySQL\n\n```sql\nALTER TABLE Persons\nDROP INDEX uc_PersonID\n```\n\nSQL Server / Oracle / MS Access：\n\n```sql\nALTER TABLE Persons\nDROP CONSTRAINT uc_PersonID\n```\n\n# PRIMARY KEY 约束\nPRIMARY KEY 约束唯一标识数据库表中的每条记录。\n  - 主键必须包含唯一的值。\n  - 主键列不能包含 NULL 值。\n  - 每个表都应该有一个主键，并且每个表只能有一个主键。\n\n## CREATE TABLE 时的 PRIMARY KEY 约束\n下面的 SQL 在 \"Persons\" 表创建时在 \"P_Id\" 列上创建 PRIMARY KEY 约束\n\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL,\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255),\nPRIMARY KEY (P_Id)\n)\n```\n\nSQL Server / Oracle / MS Access\n\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL PRIMARY KEY,\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255)\n)\n```\n\n- 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束\n\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL,\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255),\nCONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)\n)\n```\n- 注释：在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。\n\n## ALTER TABLE 时的 PRIMARY KEY 约束\n- 当表已被创建时，如需在 \"P_Id\" 列创建 PRIMARY KEY 约束\n\n```sql\nALTER TABLE Persons\nADD PRIMARY KEY (P_Id)\n```\n\n- 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束\n\n```sql\nALTER TABLE Persons\nADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)\n```\n注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。\n\n## 撤销 PRIMARY KEY 约束\nMySQL\n```sql\nALTER TABLE Persons\nDROP PRIMARY KEY\n```\nSQL Server / Oracle / MS Access\n```sql\nALTER TABLE Persons\nDROP CONSTRAINT pk_PersonID\n```\n\n# FOREIGN KEY 约束\n一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。\n## 解释外键\n|P_Id|LastName|FirstName|Address|City|\n|:---|:---|:---|:---|:---|\n|1|Hansen|Ola|Timoteivn|10|Sandnes|\n|2|Svendson|Tove|Borgvn|23|Sandnes|\n|3|Pettersen|Kari|Storgt|20|Stavanger|\n\n\n\"Orders\" \n\n|O_Id|OrderNo|P_Id|\n|:---|:---|:---|\n|1|77895|3|\n|2|44678|3|\n|3|22456|2|\n|4|24562|1|\n\n\n- 请注意，\"Orders\" 表中的 \"P_Id\" 列指向 \"Persons\" 表中的 \"P_Id\" 列。\n- \"Persons\" 表中的 \"P_Id\" 列是 \"Persons\" 表中的 PRIMARY KEY。\n- \"Orders\" 表中的 \"P_Id\" 列是 \"Orders\" 表中的 FOREIGN KEY。\n\n## FOREIGN KEY 约束用于预防破坏表之间连接的行为。\n作用: FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。\n\n- CREATE TABLE 时的 FOREIGN KEY 约束\n下面的 SQL 在 \"Orders\" 表创建时在 \"P_Id\" 列上创建 FOREIGN KEY 约束：\n\nMySQL：\n```sql\nCREATE TABLE Orders\n(\nO_Id int NOT NULL,\nOrderNo int NOT NULL,\nP_Id int,\nPRIMARY KEY (O_Id),\nFOREIGN KEY (P_Id) REFERENCES Persons(P_Id)\n)\n```\n\nSQL Server / Oracle / MS Access：\n```sql\nCREATE TABLE Orders\n(\nO_Id int NOT NULL PRIMARY KEY,\nOrderNo int NOT NULL,\nP_Id int FOREIGN KEY REFERENCES Persons(P_Id)\n)\n```\n\n- 如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束\n\n```sql\nCREATE TABLE Orders\n(\nO_Id int NOT NULL,\nOrderNo int NOT NULL,\nP_Id int,\nPRIMARY KEY (O_Id),\nCONSTRAINT fk_PerOrders FOREIGN KEY (P_Id)\nREFERENCES Persons(P_Id)\n)\n```\n\nALTER TABLE 时的 FOREIGN KEY 约束\n- 当 \"Orders\" 表已被创建时，如需在 \"P_Id\" 列创建 FOREIGN KEY 约束\n\n```sql\nALTER TABLE Orders\nADD FOREIGN KEY (P_Id)\nREFERENCES Persons(P_Id)\n```\n\n- 如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束\n\n```sql\nALTER TABLE Orders\nADD CONSTRAINT fk_PerOrders\nFOREIGN KEY (P_Id)\nREFERENCES Persons(P_Id)\n```\n## 撤销 FOREIGN KEY 约束\n撤销 FOREIGN KEY 约束：\n\n- MySQL\n\n```sql\nALTER TABLE Orders\nDROP FOREIGN KEY fk_PerOrders\n```\n- SQL Server / Oracle / MS Access\n```sql\nALTER TABLE Orders\nDROP CONSTRAINT fk_PerOrders\n```\n\n# CHECK 约束\n范围及作用\n- CHECK 约束用于限制列中的值的范围。\n- 如果对单个列定义 CHECK 约束，那么该列只允许特定的值。\n- 如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。\n\nCREATE TABLE 时的 CHECK 约束\n- 下面的 SQL 在 \"Persons\" 表创建时在 \"P_Id\" 列上创建 CHECK 约束。CHECK 约束规定 \"P_Id\" 列必须只包含大于 0 的整数。\n\n- MySQL\n\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL,\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255),\nCHECK (P_Id>0)\n)\n```\nSQL Server / Oracle / MS Access：\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL CHECK (P_Id>0),\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255)\n)\n```\n\n- 如需命名 CHECK 约束，并定义多个列的 CHECK 约束\n\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL,\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255),\nCONSTRAINT chk_Person CHECK (P_Id>0 AND City='Sandnes')\n)\n```\nALTER TABLE 时的 CHECK 约束\n\n- 当表已被创建时，如需在 \"P_Id\" 列创建 CHECK 约束，请使用下面的 SQL\n\nMySQL / SQL Server / Oracle / MS Access:\n```sql\nALTER TABLE Persons\nADD CHECK (P_Id>0)\n```\n\n- 如需命名 CHECK 约束，并定义多个列的 CHECK 约束\n\n```sql\nALTER TABLE Persons\nADD CONSTRAINT chk_Person CHECK (P_Id>0 AND City='Sandnes')\n```\n## 撤销 CHECK 约束\n撤销 CHECK 约束\nSQL Server / Oracle / MS Access：\n```sql\nALTER TABLE Persons\nDROP CONSTRAINT chk_Person\n```\nMySQL：\n```sql\nALTER TABLE Persons\nDROP CHECK chk_Person\n```\n\n# SQL DEFAULT 约束\n作用\n- DEFAULT 约束用于向列中插入默认值。\n- 如果没有规定其他的值，那么会将默认值添加到所有的新记录。\n\nCREATE TABLE 时的 DEFAULT 约束\n下面的 SQL 在 \"Persons\" 表创建时在 \"City\" 列上创建 DEFAULT 约束：\nMy SQL / SQL Server / Oracle / MS Access\n```sql\nCREATE TABLE Persons\n(\nP_Id int NOT NULL,\nLastName varchar(255) NOT NULL,\nFirstName varchar(255),\nAddress varchar(255),\nCity varchar(255) DEFAULT 'Sandnes'\n)\n```\n\n- 通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：\n\n```sql\nCREATE TABLE Orders\n(\nO_Id int NOT NULL,\nOrderNo int NOT NULL,\nP_Id int,\nOrderDate date DEFAULT GETDATE()\n)\n```\n\nALTER TABLE 时的 DEFAULT 约束\n- 当表已被创建时，如需在 \"City\" 列创建 DEFAULT 约束\n- MySQL\n\n```sql\nALTER TABLE Persons\nALTER City SET DEFAULT 'SANDNES'\n```\n\n- SQL Server / MS Access\n\n```sql\nALTER TABLE Persons\nALTER COLUMN City SET DEFAULT 'SANDNES'\n```\n\n- Oracle\n\n```sql\nALTER TABLE Persons\nMODIFY City DEFAULT 'SANDNES'\n```\n## 撤销 DEFAULT 约束\n撤销 DEFAULT 约束\n\n- MySQL\n\n```sql\nALTER TABLE Persons\nALTER City DROP DEFAULT\n```\n\n- SQL Server / Oracle / MS Access\n\n```sql\nALTER TABLE Persons\nALTER COLUMN City DROP DEFAULT\n```\n---\n**来源**\n- [菜鸟教材](http://www.runoob.com)","tags":["SQL"],"categories":["Database"]},{"title":"Win10 开热点给手机科学上网","path":"/posts/Win10-Share-WiFI.html","content":"> 在 Windows 10 中使用 \"飞机\" 工具共享热点给手机实现手机科学上网,解决刷机后开机登录 Google 账号等问题。\n\n# 方法\n## 电脑端\n\n1. 右键飞机托盘图标 --> 选项设置 --> 勾选 `允许来自局域网连接`\n2. CMD --> 输入 `ipconfig` 获取 `无线的IPV4地址`\n3. 正常开启热点\n<!--more-->\n\n## 手机端\n\n1. 长按连接的 WiFi 名,点修改网络\n2. 显示高级选项\n3. 代理\n4. 手动\n5. 服务器主机IP输入刚刚获取的 `IPV4地址`, 端口 `1080`\n6. 保存\n\n---\n\n# 跳过谷歌验证\n## 方法一\n\n即上述 Windows 10 开热点的方法\n\n## 方法二\n\n```adb\nadb shell settings put secure user_setup_complete 1\nadb shell settings put global device_provisioned 1\n```\n\n## 方法三\n\n开机前不插入 SIM 卡,开机后不连接 WIFI,在开机导向时可以有选择跳过登录 Google 账号\n\n## 方法四\n\n顺时针方向，从左上角开始,连点屏幕四角","tags":["Windows","Android"],"categories":["Diary"]},{"title":"Linux 基础命令","path":"/posts/Linux-Commands.html","content":"Linux 基础命令\n<!--more-->\n# 目录操作命令\n## ls\n```sh\n命令英文原意：list\n命令所在路径：/bin/ls\n执行权限：所有用户\n功能描述：显示目录文件\nls # 显示当前目录下文件\nls 目录名 # 显示指定目录下文件\nls -l # 长格式显示目录文件\nls -l 文件名 # 长格式显示指定文件\nls -a # 显示所有文件(包含隐藏文件)\nls -al # 长格式显示当前目录下所有文件)\nls -h # 文件大小显示为常见大小单位 B KB MB ...\nls -d # 显示目录本身，而不是里面的子文件\n```\n\n## cd\n```sh\n命令英文原意：change directory\n命令所在路径：shell内置命令\n执行权限：所有用户\n功能描述：切换所在目录\ncd /usr/local/src 切换到指定路径(使用绝对路径方式)\ncd ~ # 进入当前用户的家目录\ncd - # 进入上次目录\ncd .. # 进入上一级目录\ncd . # 进入当前目录\n绝对路径：cd ../usr/local 参照当前所在目录，进行查找。一定要先确定当前所在目录。\n相对路径：cd /usr/local 从根目录开始指定，一级一级递归查找。\n在任何目录下，都能进入指定位置。\n```\n## pwd\n```sh\n命令英文原意：print working directory\n命令所在路径：/bin/pwd\n执行权限：所有用户\n功能描述：显示当前所在目录(当前工作目录)\n```\n\n## mkdir\n```\n命令英文原意：make directories\n命令所在路径：/bin/mkdir\n执行权限：所有用户\n功能描述：建立目录\nmkdir test  # 创建名为test的目录\nmkdir -p test1/test2/test3 #递归创建\n```\n## rmdir\n```sh\n命令英文原意：remove empty directories\n命令所在路径：/bin/rmdir\n执行权限：所有用户\n功能描述：删除目录 (只能删除空目录)\n```\n\n# 文件操作命令\n## touch\n```sh\n命令所在路径：/bin/touch\n执行权限：所有用户\n功能描述：创建空文件 或 修改文件时间\ntouch test.py # 创建空文件，如果文件存在，则修改文件创建时间\n```\n## rm\n```sh\n命令英文原意：remove\n命令所在路径：/bin/rm\n执行权限：所有用户\n功能描述：删除\nrm 文件名 # 删除文件\nrm -r 目录名 # 递归删除文件和目录\nrm -f 文件名 # 强制删除\nrm -rf 目录名 # 强制删除目录和文件\n```\n## cat\n```sh\n命令所在路径：/bin/cat\n执行权限：所有用户\n功能描述：查看文件内容，从头到尾的内容。\ncat 文件名  # 查看文件内容内容\ncat -n 文件名 # 查看文件内容，并列出行号\n```\n\n## more\n```sh\n命令所在路径：/bin/more\n执行权限：所有用户\n功能描述：分屏显示文件内容\nmore 文件名    分屏显示文件内容\n向上翻页  空格键\n向下翻页  b键\n退出查看  q键\n```\n\n## head\n```\n命令所在路径：/usr/bin/head\n执行权限：所有用户\n功能描述：显示文件头\nhead 文件名 # 显示文件头几行(默认显示10行)\nhead -n 20 文件名 # 显示文件前20行\nhead -n -20 文件名 # 显示文件最后20行\nctrl + c # 强制终止查看模式\nctrl + l  # 清屏\n```\n\n## ln\n```sh\n命令英文原意：link\n命令所在路径：/bin/ln\n执行权限：所有用户\n功能描述：链接文件\n等同于Windows中的快捷方式\n新建的链接，占用不同的硬盘位置\n修改一个文件，两边都会改变\n删除源文件，软连接文件打不开\nln -s 源文件 目标文件 # 创建链接文件(文件名都必须写绝对路径)\n```\n# 文件和目录都能操作的命令\n## rm\n删除文件或目录\n\n## cp\n```sh\n命令英文原意：copy\n命令所在路径：/bin/cp\n执行权限：所有用户\n功能描述：复制文件或目录\ncp 源文件 目标位置  # 复制\n\ncp 源文件 目标位置/目标名称  # 复制并改名\ncp -r # 复制目录\ncp -p # 连带文件属性一起复制\ncp -d # 若源文件是链接文件，则复制链接属性\ncp -a # 相当于 cp -pdr\n```\n\n## mv\n```sh\n命令英文原意：move\n命令所在路径：/bin/mv\n执行权限：所有用户\nmv 源文件 目标位置\nmv /root/test /tmp/  \n# 将/root/下的test文件移动到/tmp/目录下\nmv /root/test /root/newtest   \n# 将/root/下的test文件改名为newtest\n```\n\n# 挂载命令\n## mount\n```\n命令所在路径：/bin/mount\n执行权限：所有用户\n功能描述：挂载\nlinux所有存储设备都必须挂载使用，包括硬盘\n```\n\n## 光盘挂载\n```\n/dev/sda1 # 第一个scsi硬盘的第一分区\n/dev/cdrom  # 光盘\n/dev/hdc  # fIDE硬盘 centos 5.5\n/dev/sr0  # 光盘      centos 6.x\nmount -t 文件系统 设备描述文件 挂载点（已经存在空目录）\nmount -t iso9660 /dev/cdrom /mnt/cdrom\n```\n\n## 光盘卸载\n```\numount /dev/cdrom\numount /mnt/cdrom      注意：退出挂载目录，才能卸载\nfdisk -l 查看设备名\nmount -t vfat /dev/sdb1 /mnt/usb\n```\n\n# 网络命令\n## ping\n```\n命令所在路径：/bin/ping\n执行权限：所有用户\n功能描述：测试网络畅通性\nping -c 次数 ip # 探测网络通畅\n```\n\n## ifconfig\n```\n命令英文原意：interface configure\n命令所在路径：/sbin/ifconfig\n执行权限：root\n功能描述：查询本机网络信息\n```\n\n# Linux 系统分类\n1. RedHat 系列：Redhat、Centos、Fedora 等\n    - RPM (Red Hat系)：CentOS、Fedora\n2. Debian 系列：Debian、Ubuntu 等\n    - Dpkg (Debian系)：Ubuntu LinuxMint\n3. ArchLinux\n    - ArchLinux、Manjaro、Antergos 等.\n\n## 软件包管理工具\n### Debian 系列\n1. 常见的安装包格式 deb 包，安装 deb 包的命令是`dpkg -选项 -xxx.deb`\n- 选项\n```\n-i：安装软件包\n-r：删除软件包\n-P：删除软件包的同时删除其配置文件\n-L：显示于软件包关联的文件\n-l：显示已安装软件包列表\n--unpack：解开软件包\n-c：显示软件包内文件列表\n--confiugre：配置软件包\n```\n2. 包管理工具 apt-get\n3. 支持 tar 包\n- dpkg 实例\n```bash\ndpkg -i package.deb #安装包\ndpkg -r package #删除包\ndpkg -P package #删除包（包括配置文件）\ndpkg -L package #列出与该包关联的文件\ndpkg -l package #显示该包的版本\ndpkg --unpack package.deb  #解开deb包的内容\ndpkg -S keyword #搜索所属的包内容\ndpkg -l #列出当前已安装的包\ndpkg -c package.deb#列出deb包的内容\ndpkg --configure package#配置包\n```\n- apt 包管理\n```\napt-get (选项)(参数)\n```\n- 实例\n```\napt-get update #更新源\napt-get upgrade #更新所有已安装的软件包\napt-get install packagename #安装软件包\napt-get remove packagename #卸载软件包(保留配置文件)\napt-get –purge remove packagename # 卸载软件包(删除配置文件)\napt-get autoclean apt #删除你已经删掉的软件\napt-get dist-upgrade #将系统升级到新版本\napt-get autoclean #清除已经卸载的软件包的.deb文件\n```\n\n## RedHat 系列\n1. 常见的安装包格式 rpm 包，安装rpm包的命令是`rpm -参数 [-rpm包]\n- 参数\n```\n-a：查询所有套件；\n-b<完成阶段><套件档>+或-t <完成阶段><套件档>+：设置包装套件的完成阶段，并指定套件档的文件名称；\n-c：只列出组态配置文件，本参数需配合\"-l\"参数使用；\n-d：只列出文本文件，本参数需配合\"-l\"参数使用；\n-e<套件档>或--erase<套件档>：删除指定的套件；\n-f<文件>+：查询拥有指定文件的套件；\n-h或--hash：套件安装时列出标记；\n-i：显示套件的相关信息；\n-i<套件档>或--install<套件档>：安装指定的套件档；\n-l：显示套件的文件列表；\n-p<套件档>+：查询指定的RPM套件档；\n-q：使用询问模式，当遇到任何问题时，rpm指令会先询问用户；\n-R：显示套件的关联性信息；\n-s：显示文件状态，本参数需配合\"-l\"参数使用；\n-U<套件档>或--upgrade<套件档>：升级指定的套件档；\n-v：显示指令执行过程；\n-vv：详细显示指令执行过程，便于排错。\n```\n2. 包管理工具`yum -选项 -参数`\n- 选项\n```\n-h：显示帮助信息；\n-y：对所有的提问都回答“yes”；\n-c：指定配置文件；\n-q：安静模式；\n-v：详细模式；\n-d：设置调试等级（0-10）；\n-e：设置错误等级（0-10）；\n-R：设置yum处理一个命令的最大等待时间；\n-C：完全从缓存中运行，而不去下载或者更新任何头文件。\n```\n- 参数\n```\ninstall：安装rpm软件包；\nupdate：更新rpm软件包；\ncheck-update：检查是否有可用的更新rpm软件包；\nremove：删除指定的rpm软件包；\nlist：显示软件包的信息；\nsearch：检查软件包的信息；\ninfo：显示指定的rpm软件包的描述信息和概要信息；\nclean：清理yum过期的缓存；\nshell：进入yum的shell提示符；\nresolvedep：显示rpm软件包的依赖关系；\nlocalinstall：安装本地的rpm软件包；\nlocalupdate：显示本地rpm软件包进行更新；\ndeplist：显示rpm软件包的所有依赖关系。\n```\n3. 支持 tar 包\n\n+ yum 实例\n- 安装\n```\nyum install #全部安装\nyum install package1 #安装指定的安装包package1\nyum groupinsall group1 #安装程序组group1\n```\n- 更新和升级\n```\nyum update #全部更新\nyum update package1 #更新指定程序包package1\nyum check-update #检查可更新的程序\nyum upgrade package1 #升级指定程序包package1\nyum groupupdate group1#升级程序组group1\n```\n- 查找和显示\n```\nyum info package1 #显示安装包信息package1\nyum list #显示所有已经安装和可以安装的程序包\nyum list package1 #显示指定程序包安装情况package1\n\tyum groupinfo group1#显示程序组group1信息yum search string 根据关键字string查找安装包\n```\n- 删除程序\n```\nyum remove &#124; erase package1  #删除程序包package1\nyum groupremove group1  #删除程序组group1\nyum deplist package1  #查看程序package1依赖情况\n```\n- 清除缓存\n```\nyum clean packages #清除缓存目录下的软件包\nyum clean headers #清除缓存目录下的 headers\nyum clean oldheaders #清除缓存目录下旧的 headers\n```\n**参考**\n- [Linux命令](http://man.linuxde.net/)\n\n# 查询命令\n## find\n```\nfind [搜索范围] [搜索文件]`\nfind / -name install.log\n避免大范围搜索,会非常耗费系统资源\nfind是在系统当中搜索符合条件的文件名,如果需要匹配 使用通配符匹配,通配符是完全匹配。\n\nfind /root -iname installlog #不区分大小写\nfind /root -user root #按照所有者搜索\nfind/root -nouser #查找没有所有者的文件\n```\n\n1.  find /var/log/ -mtime +10 #查找10天前修改的文件\n\n|-10 |10天内修改文件|\n|:---|:---|\n|10|10天当天修改的文件|\n|+10|10天前修改的文件|\n|atime|文件访问时间|ctime|改变文件属性|mtime|修改文件内容|\n\n\n2. find . -size #查找文件大小是25KB的文件\n\n|-25k|小于25KB的文件|\n|:---|:---|\n|25k|等于25KB的文件|\n|+25k|大于25KB的文件|\n\n\n3. find -inum 262422 #查找 节点是262422的文件\n4. find /etc -size +20k -a -size -50k #查找/etc/目录下,大于20KB并且小于50KB的文件\n- a and逻辑与,两个条件都满足 or 逻辑或,两个条件满足一个即可\n5. find /etc-size +20k-a-size-50k -exec ls-lh {} 1; #查找/etc/目录下,大于20KB并且小于50KB的文件,并显示详细信  #-exec/-ok命令() 对搜索结果执行操\n\n## 搜索字符串命令grep\n- grep [选项]字符串文件名\n在文件当中匹配符合条件的字符串\n选项: `-i` 忽略大小写 `-v`排除指定字符串\n\n## find命令与grep命令的区别\n-  find命令:在系统当中搜索符合条件的文件名,如果需要匹配 使用通配符匹配,通配符是完全匹配。\n- grep命令:在文件当中搜索符合条件的字符串,如果需要匹配 使用正则表达式进行匹配,正则表达式时包含匹配\n\n# man 命令\nman 命令 #获取指定命令的帮助  \nman ls  #查看ls的帮助\n\n- 查看命令拥有那个级别的帮助\nman -f 命令 相当于 whatis 命令\n\n举例:\n```\nman -5 passwd\nman -4 null\nman -8 ifconfig\n```\n\n- shell 内部命令帮助\nhelp shell 内部命令 #获取shell内部命令的帮助\n\n例如:\n```\nwhereis cd #确定是否是shell内部命令\nhelp cd #获取内部命令帮助\n```\n\n## 详细命令帮助info info命令\n回车|进入子帮助页面(带有`*`号标记)\n\n|:---:|:---:|\n|u|进入上层页面|\n|n|进入下一个帮助小节|\n|p|进入上一个帮助小节|\n|q|退出|\n\n\n# 压缩\n## zip格式压缩\n```\nzip 压缩文件名  源文件 #压缩文件\nzip -r 压缩文件名 源目录  #压缩目录\n```\n## gzip格式压缩\n```\ngzip 源文件  #压缩为.gz格式的压缩文件.源文件会消失\ngzip -c 源文件>压缩文件 # 压缩为.gzi格式,源文件保留\n```\n\n## gz格式解压缩\n```\ngzip -d 压缩文件 #解压缩文件\ngunzip 压缩文件  #解压缩文件\n```\n\n## bz2格式压缩\n```\nbzip2 源文件 #压缩为.bz2格式.不保留源文件\nbzip2 -k 源文件 #压缩之后保留源文件\n注意: bzip2命令不能压缩目录\n```\n# 打包\n## tar\n```\ntar -cvf 打包文件名 源文件\n选项: -c打包\n-v显示过程\n-f指定打包后的文件名\n```\n\n# 解打包命令\n```\ntar -xvf 打包文件名\n选项:\n-x解打包\n```\n\n## tar.gz压缩格式\n其实.tar.gz格式是先打包为.tar格式,再压缩为.gz格式\n1. tar -zcvf 压缩包名tar.gz 源文件\n- 选项: `-z`压缩为.tar.gz格式\n2. tar -zxvf 压缩包名tar.gz\n- 选项:`-x` 解压缩.tar.gz格式\n\n## tar.bz2压缩格式\n:1. tar -jcvf压缩包名.tar.bz2 源文件\n- 选项:`-z`压缩为.tar.bz2格式\n2. tar -jxvf 压缩包名·tar.bz2\n- 选项: `-x`解压缩.tar.bz2格式\n\n# shell命令\n## shutdown命令\n```\nshutdown [选项] 时间\n选项:\n-c 取消前一个关机命令\n-h 关机  \n-r 重启\n```\n\n## 其他关机命令\n```\nhalt\npoweroff\ninit 0\n重启命令\nreboot\ninit 6\n\n系统运行级别\n查看系统运行级别\ncat /etc/inittab\n程序员之路: Linux关机与重启\n退出登录\nlogout 切记,一般服务器只允许少量用户连接, 如果不正常退出会占用用户id\n```\n\n- 查询当前登录和过去登录的用户信息\nlast last #命令默认是读取/var/log/wtmp文件数据\n\n命令输出 -用户名 登录终端 登录IP 登录时间 退出时间(在线时间)\n\n## echo输出命令\necho [选项] [输出内容]\n- 选项: -e 支持反斜线控制的字符转换\n\n|控制字符|作用|\n|:---|:---|\n|\\a|输出警告音|\n|\\b|退格键，也就是向左删除键|\n|\\n|换行键|\n|\\r|回车键|\n|\\t|制表键，也就是Tab键|\n|\\v|垂直制表键|\n|\\Onnn|按照八进制ASCII码表输出字符。其中0表示数字0，nnn是三位八进制数|\n|\\xhh|按照16进制ASCII码表输出字符。其中hh是两位16进制数|\n\n\n## 脚本执行\n```\n赋予执行权限,直接运行\nchmod 755 hello.sh\n/hello.sh\nbash hello.sh\n```\n# 别名\n- 查看与设定别名\n1. alias #查看系统中所有的命令别名\n2. alias 别名=\"原命令\" #设定命令别名\n\n## 别名永久生效与删除别名\n```\nvi /.bashrc #写入环境变量配置文件\nunalias 别名 #删除别名\n```\n\n## shell常用快捷键\n|ctrl+c|强制终止当前命令|\n|:---:|:---:|\n|ctrl+l|清屏|\n|crtl+a|光标移动到命令行首|\n|ctrl+e|光标移动到命令行尾|\n|ctrl+u|从光标所在位置删除到行首|\n|ctrl+z|把命令放入后台|\n|ctrl+r|在历史命令中搜|\n\n## 历史命令\n```\nhistory [选项] [历史命令保存文件]\n选项:\n-c:清空历史命令\nw:把缓存中的历史命令写入历史命令保存文件~/.bash.history\n```\n\n# 输出重定向\n|类型|符号|作用|\n|:---|:---|:---|\n|标准输出重定向|命令>文件|以覆盖的方式,把命令的正确输出 输出到指定的文件或设备当中|\n|空|命令>>文件|以追加的方式,把命令的正确输出! 输出到指定的文件或设备当中|\n|准错误输出重定向|错误命令2>>文件|以覆盖的方式,把命令的错误输出 输出到指定的文件或设备当中。|      |空 |错误命令2>>文件|以追加的方式,把命令的错误输出输出到指定的文件或设备当|\n\n\n\n# 多命令顺序执行\n|多命令执行符|格式|作用|\n|:---|:---|:---|\n|:|命令1:命令2|多个命顺序执行,命令之间没有逻辑关系|\n|&&|命令1&&命令2|逻辑与当命令1正确执行,则命令2才会执行,1不正确，2不执行|\n|丨丨|命令1丨丨命令2|逻辑或，命令1不正确，2才执行，命令1正确，2不会执行|\n\n\n# 通配符\n|通配符|作用|\n|:---|:---|\n|?|匹配一个任意字符|\n|*|匹配0或任意多个任意符，也可以是匹配任何内容|\n|[]|匹配括号中的任意一个字符|\n|[-]|匹配括号中任意一个字符，-代表一个范围。［a-z］小写字母表|\n|[^]|逻辑非，表示匹配不是括号中的一个字符.［^0-9］不是数字的字符|\n\n# Bash中其他特殊符号\n|符号|作用|\n|:---|:---|\n|''|单引号。在单引号中所有的特俗符合，如“$”和“`”（反引号）都没特俗意义|\n|\"\"|双引号,在双引号中特殊符号都没有特殊含义,但是“S\" 、“.”和“\\\"是例外. 拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义|\n|\\``|反引号。反引号括起来的都是系统命令，在bash中会先执行和$()作用一样。不过推荐使用$(), 因为反引号非常容易看错|\n|$()|和反引号作用一样，用来引用系统命令|\n|#|shell中#开头的行代表注释|\n|$|用于调用变量的值，如要调用变量name的值时，需要用$name的方式得到变量的值|\n|`\\`|转义符，跟在\\后面的特俗符号失去特俗含义，变为普通字符，。如\\$将输出$符号，而不是变量引用|\n\n# 磁盘管理\n## df [参数] 查看磁盘分区使用状况\n```\n-l仅显示本地磁盘(默认)\n-a显示所有文件系统的磁盘使用情况,包含比如/proc/\n-h以1024进制计算最合适的单位显示磁盘容量\n-H以1000进制计算最合适的单位显示磁盘容量\n-T显示磁盘分区类型\n-t显示指定类型文件系统的磁盘分区\n-x不显示指定类型文件系统的磁盘分\n- du统计磁盘上的文件大小\n-b以byte为单位统计文件\n-k以KB为单位统计文件\n-m以MB为单位统计文件\n-h按照1024进制以最适合的单位统计文件\n-H按照1000进制以最适合的单位统计文件\n-s指定统计目标\n```\n\n# 权限\n## -rw-r--r--\n```\n文件类型(-文件d目录1软链接文件)\nrw- u所有者 r-- g所属组 r-- o其他人\nr 读  w 写 x 执行\n```\n\n## chmod 命令\n```\nchmod [选项] 模式 文件名\n选项 -R递归 模式 [ugoa][+-=][rwx]\n[mode=421]\n```\n## 修改权限\n```\nchmod u+x cangls.av\nchmod g+w,o+w furong.av\nchmod a=rwx fengjie.av\n```\n\n## 权限的数字表示\nr---4 w---2 x---1 rwxr-xr-x --- 755\n\n## 权限对文件的作用\n1. r:读取文件内容(cat more head tail)\n2. w:编辑、新增、修改文件内容( vi echo ) 但是不包含删除文件\n3. x:可执行\n\n## 权限对目录的作用\n1. r:可以查询目录下文件名 (ls)\n2. w:具有修改目录结构的权限。如新建文件和目录,删除此目录下文件和目录,重命名此目录下文件和目录,剪切(touch rm mv cp)\n3. x:可以进入目录 (cd)\n4. 对文件来讲: 最高权限是 x\n5. 对目录来讲:最高权限是 w\n\n## 修改文件的所有者\n```\nchown 用户名 文件名\n例如: chown ds h.c\n```\n\n## 修改文件的所属组\n```\nchgrp 组名 文件名\n例如: chgrp group1 h.c\n```\n## 查看默认权限的命令\n```\numask查看默认权限\n0022  第一位0 :文件特殊权限 022 :文件默认权限\n```\n\n>文件的默认权限 文件默认不能建立为执行文件,必须手工赋予执行权限 所以文件默认权限最大为666 默认权限需要换算成字母再相减 建立文件之后的默认权限,为666减去umask\n\n例如:\n\n文件默认最大权限666 umask值022\n\n-rw-rw-rw- 减去 ---- w--w-等于 -rw-r-r-\n\n例如: 文件默认最大权限666 umask值033\n\n-rw-rw-rw- 减去 ---- wx-wx 等于 -rw-r-r\n\n\n>目录的默认权限 目录默认权限最大为777 默认权限需要换算成字母再相减 建立文件之后的默认权限,为777减去umask值\n\n\n例如:\n\n目录默认最大权限为777 umask值022\n\n-rwxrwxrwx 减去 ----w--w- 等于 -rwxr-xr-x\n\n## 修改umask\n```\n临时修改 umask 0002\n永久修改  vi/etc/profile\n```\n\n# 进程\n- 查看所有进程\n```\nps aux #查看系统中所有进程,使用BSD操作系统格式\nps -le #查看系统中所有进程,使用Linux标准命令格式\n选项\na:显示一个终端的所有进程,除了会话引线\n-u:显示进程的归属用户及内存的使用情况\n-x:显示没有控制终端的进程\n-l:长格式显示,显示更加详细的信息\n-e:显示所有进程,和-A作用一致\n- ps命令的输出\nUSER:该进程是由哪个用户产生的\nPID:进程的ID号;\n%CPU:该进程占用CPU资源的百分比,占用越高,进程越耗费资源;\n%MEM:该进程占用物理内存的百分比,占用越高,进程越耗费资源\nVSZZ:该进程占用虚拟内存的大小,单位KB:\nRss:该进程占用实际物理内存的大小,单位KB:\nTTY:该进程是在哪个终端中运行的,其中tty1-tty7代表本地控制台 终端, tty1-tty6是本地的字符界面终端, 255代表虚拟终端。 tty7是图形终端. pts/0\n```\n\n```\nSTAT :进程状态,常见的状态有\nR:运行 S:睡眠 T:停止状态 -s:包含子进程 +:位于后台\nSTART:该进程的启动时间\nTIME:该进程占用CPU的运算时间, 不是系统时间\nCOMMAND:产生此进程的命令名\n```","tags":["Linux","Ubuntu","Termux"],"categories":["Linux"]},{"title":"Termux 安装 R","path":"/posts/Termux-R.html","content":"Termux 安装 R\n<!--more-->\n# 步骤\n建立 storage\n```bash\ntermux-setup-storage\n```\n\n添加镜像\n```bash\nexport EDITOR=vi\napt edit-sources\n```\n\n进入之后输入 i 进入编辑模式。\n\n- 添加如下源\n\n```bash\ndeb [trusted=yes] https://its-pointless.github.io/files/ termux extras\n```\n\n环境更新\n```bash\napt-get update\napt-get upgrade\n```\n\n安装 R\n```\npkg install r-cran\n```","tags":["Linux","Termux","R"],"categories":["Diary"]},{"title":"ADB 与 Fastboot 常用命令","path":"/posts/Adb.html","content":"Adb 与 Fastboot 常用命令\n<!--more-->\n# ADB\n## 刷机命令\n|解释|命令|\n|:---|:---|\n|启动 | adb server,adb start-server|\n|停止 | adb server,adb kill-server|\n|查看连接状态|adb devices|\n|重启命令|adb reboot|\n|重启到Rec|adb reboot recovery\n|重启到Fastboot|adb reboot bootloader|\n|推送ROM包|adb sideload <Rom包>|\n\n## 错误提示\n1. `offline` 设备未连接成功或无响应；\n2. `device` 设备已连接；\n3. `no device` 没有设备/模拟器连接；\n4. `List of devices attached` 设备/模拟器未连接到 adb 或无响应\n\n## 安装卸载\n|解释|命令|\n|:---|:---|\n|安装|adb install <package>|\n|卸载|adb uninstall <package>|\n|保留数据卸载|adb uninstall -k <package>|\n\n## 复制文件\n|解释|命令|\n|:---|:---|\n|复制设备到电脑|adb pull <设备文件路径> <电脑目录> 例如：adb pull /sdcard/1.txt E:\\|\n|复制电脑到设备|abd pull <电脑文件路径> <设备目录> 例如：adb pull E:\\1.txt /sdcard/|\n\n## 查看手机信息\n|解释|命令|\n|:---|:---|\n|查看设备型号|adb shell getprop ro.product.model|\n|获取IMEI|adb shell [回车] su [回车] service call iphonesubinfo 1\n|获取手机程序包名|adb shell pm list packages|\n|获取序列号|adb get-serialno|\n|查看所有应用列表|adb shell pm list packages|\n|查看系统应用列表|db shell pm list packages -s|\n|查看第三方应用列表|adb shell pm list packages -3|\n\n## 其他\n|解释|命令|\n|:---|:---|\n|查看log|adb logcat|\n|终止adb服务进程|adb kill-server|\n|重启adb服务进程|adb start-server|\n|获取机器MAC地址|adb shell  cat /sys/class/net/wlan0/address|\n|获取CPU序列号|adb shell cat /proc/cpuinfo|\n|安装APK|adb install <apkfile>|\n|卸载APK|adb uninstall <package>|\n|查看设备cpu和内存占用情况|adb shell top|\n|查询各进程内存使用情况|adb shell procrank|\n|查看wifi密码|adb shell cat /data/misc/wifi/*.conf|\n\n```shell\nadb install <参数> <apk_path>\n```\n- `-l` 将应用安装到保护目录 /mnt/asec\n- `-r` 允许覆盖安装；\n- `-t` 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=\"true\" 的应用\n- `-s` 将应用安装到 sdcard\n- `-d` 允许降级覆盖安装\n- `-g` 授予所有运行时权限\n\n```shell\nadb uninstall -k <PackageName>\n```\n- `-k` 卸载应用但保留数据和缓存目录,可选，\n\n# Fastboot\n|解释|命令|\n|:---|:---|\n|查看连接状态|fastboot devices|\n|解锁|fastboot flashing unlock OR fastboot oem unlock|\n|上锁|fastboot flashing lock OR fastboot oem lock|\n|重启|fastboot reboot|\n|重启到Fastboot|fastboot reboot-bootloader|\n|清除分区数据|fastboot erase <boot/system/data/cache/userdata/recovery>|\n|清除分区(四清)|fastboot erase system -w|\n|格式化分区数据|fastboot format <boot/system/data/cache/userdata/recovery>|\n|烧写分区|fastboot flash < boot/system /recovery/radio/bootloader/ splash1/> <*.img>|\n\n## 系统分区\nVia: [Android 分区](https://segmentfault.com/a/1190000021601415)\n\n|分区|介绍|\n|:---|:---|\n|boot|包含通过 mkbootimg 组合在一起的kernel镜像和 ramdisk。使能system-as-root后，该分区仅存放kernel镜像|\n|system|主要包含 Android 框架。使能system-as-root后，该分区会包含原始 system.img 和 ramdisk.img 的合并内容|\n|recovery|用于存储在 OTA 升级时使用的recovery系统。如果设备支持A/B更新，OTA升级可以通过ramdisk执行，该分区可以不需要|\n|cache|用于存储临时数据，OTA升级包也会下载到这个分区。如果设备使用 A/B 更新，则可以不要此分区|\n|misc|分区供recovery使用，存储空间不能小于 4KB|\n|userdata|存储用户安装的应用和数据|\n|metadata|如果设备被加密，则需要使用该分区，分区的存储空间不能小于 16MB|\n|vendor|包含所有不可分发给 Android 开源项目 (AOSP) 的二进制文件。如果没有专有信息，可以不要该分区|\n|radio|包含无线装置映像。只有包含无线装置的设备才需要此分区|\n|tos|用于存储 Trusty 操作系统的二进制映像文件，仅在设备包含 Trusty 时使用|\n|product|用于存放产品专用的配置和应用，以便OEM定制自己的系统。Android 9 及更高版本支持该分区。product分区是对system分区的扩展，必须同时升级这两个分区|\n|odm|用于ODM自定义自己的板级支持包。Android 10 开始支持该分区。odm分区是对vendor分区的扩展，必须同时升级这两个分区|\n\n## 常用 Fastboot 命令\n### 注意\n\nA/B 分区设备无 Recovery 分区,不能使用 `fastboot flash recovery`\n\n### 刷入临时 TWRP\n\n```sh bootloader 下\nfastboot boot twrp.img\n```\n\n### 输入镜像\n\n```sh\nfastboot flash recovery recovery.img\nfastboot flash system system.img\nfastboot flash boot boot.img\nfastboot reboot\n```\n\n# bootloader 识别不到设备\n安装 [Google USB Driver](./posts/UsbDriver.html) 即可解决。","tags":["Linux","Windows","Android","ADB"],"categories":["Diary"]},{"title":"SQL EXISTS","path":"/posts/SQL-Exists.html","content":"SQL 中 EXISTS\n<!--more-->\n# 三点概念\n概念\n- `EXISTS` 子查询找到的提交\n- `NOT EXISTS `子查询中 找不到的提交\n\n说明\n- 不要去翻译为存在和不存在，把脑袋搞晕。\n- `exists`代表存在量词`ョ`，该查询结果没有值，只有逻辑值真true和逻辑假false两个值。\n  - 建立程序循环的概念，这是一个动态的查询过程。如 FOR循环.\n  - `Exists`执行的流程`Exists`首先执行外层查询，再执行内存查询,与`IN`相反。 流程为首先取出外层中的第一元组，再执行内层查询，将外层表的第一元组代入,若内层查询为真，即有结果时。返回外层表中的第一元 组，接着取出第二元组，执行相同的算法。一直到扫描完外层整表。\n  ```SQL\n  for(int i =0;  i<>EOFout;i++)\n    {\n    for (int j = 0 ; j<EOFint,j++)\n    }\n  ```\n# 例子\n表\n学生表student (Sno,Sname)\n\n课程表course (Cno,Cname)\n\n选课表SC(Sno,Cno)\n\n要求查询出 ：选修了全部课程的学生姓名\n\n## 思路\n思路一\n首先学生的选课信息存在于SC表中， 要想知道某个学生是否选修了全部课程，至少我们需要知道一共有几门课程，这是首要的条件。其次，学生选修了与否，我们又要扫描SC全表，统计出选修了所有课程的学生号，最后在STUDENT表中根据学生号打出姓名 。\n- 语句如下：\n```SQL\n  select Sname from student\n  where Sno IN\n  (select Sno from SC\n  group by Sno\n   //根据Sno分组，统计每个学生选修了几门课程。如果等于course的总数，就是我们要找的Sno\n  having count(*) = (select count(*) from course ))\n  //统计course中共有几门课程\n```\n另一种思路：\n- 引入：将题目换为 查找学号为 00003 没有选修的科目\n  - 思路：我们可以将已知学号代入，把每一个科目代入（循环），这将形成`1*count(*)`种组合。将这组成作为条件，一一与SC表种进行比对，找不到匹配的我们提交.\n```SQL\nselect Cname from course  where\nnot exists  //找不到的组合，提交course\n(select * from SC where course.cno = cno and sno = ''00002'')\n//在SC中匹配\n```\n- 查找没有 没有选修科目的学生姓名\n  - 思路：\n    - 学号未知,科目未知，说明有两个未知变量。应该有两个EXISTS。我们可以扫描student 和 course共有 s * c 中组合，将这些组合与SC的每一项进行匹配，注意s*c组合已经包含所有可能。如果全部找到 ，就说明已经选修了全部课程。找不到就说明有课程没选修 。再将没选修的的提交给上一exists 循环 。若上一exists 不存在的再提交给外循环。\n    ```SQL\n    select Sname from student\n    where NOT exists        //\n    (select  * from course\n    where NOT exists      //不存在的提交给course\n    (select * from SC where\n    Sno = student.sno  and cno = Course.Cno))   // 代入两个未知变量\n    ```\n  - 选修了全部课程的学生姓名.\n  将这组成作为条件，一一与SC表种进行比对，找不到匹配的我们提交 。\n  ```SQL\n  select Cname from course where\n  not exists  //找不到的组合，提交course\n  (select * from SC where course.cno = cno and sno = ''00003'')\n  //在SC中匹配\n  ```\n  - 查找没有选修科目的学生姓名\n    - 思路：1. 学号未知 科目未知 说明有两个未知变量。2. 应该有两个`EXISTS`。我们可以扫描`student`和`course`共有` s*c `中组合，将这些组合与SC的每一项进行匹配，注意s*c组合已经包含所有可能。如果全部找到 ，就说明已经选修了全部课程。找不到就说明有课程没选修 。再将没选修的的提交给上一exists 循环 。若上一exists 不存在的再提交给外循环。\n\n  - 查询选修了全部课程的学生姓名。\n  ```SQL\n  SELECT Sname\n  FROM Student\n  WHERE NOT EXISTS\n  （SELECT *\n  FROM Course\n  WHERE NOT EXISTS\n  (SELECT *\n  FROM SC\n  WHERE Sno= Student.Sno\n  AND Cno= Course.Cno）\n  ```\n  - 查询所有选修了001课程的学生名单\n  ```SQL\n  select sname\n  from student a\n  where exists (\n  select *\n  from sc b\n  where a.sno=b.sno and cno='001')\n  ```\n  - 查询没有选修了001课程的学生名单\n  ```SQL\n  select sname\n  from student a\n  where not exists (\n  select *\n  from sc b\n  where a.sno=b.sno and cno='001')\n  ```\n  - 查询选修了所有课程的学生名单。\n\n  由于SQL中没有全称量词，可以这样理解：查询这样的学生，没有一门课程他没有选\n  ```SQL\n  select sname\n  from student a\n  where not exists (\n  select *\n  from course b\n  where not exists (\n  select *\n  from sc c\n  where a.sno=c.sno and c.cno=b.cno))\n  ```\n  注意：SQL没有蕴涵谓词，可以使用等价变换进行转换`p→q ≡ ┑p∨q`\n\n  - 查询至少选修了学生95002选修的全部课程的学生名单。\n\n  将查询进行变换： p表示的谓词：95002选修了课程y\n\n  q表示的谓词：学生x选修了课程y\n\n  该查询转换为：( y)p→q\n\n  进一步转换：( y)p→q ≡\n\n  ┑(ョy( ┑(p→q))) ≡ ┑(ョy( ┑(┑p∨q)))\n\n  ≡ ┑ョy(p∧q) 德模根定律\n\n  它所表达的含义为：不存在这样的课程y，95002选修了y而x没有选，SQL语句如下：\n  ```SQL\n  select sname,sno\n  from student a\n  where sno <> '95002' and not exists (\n  select *\n  from sc b\n  where sno='95002' and not exists (\n  select *\n  from sc c\n  where a.sno=c.sno and c.cno=b.cno))\n  ```\n\n[参考：](http://www.cnblogs.com/losesea/archive/2012/06/14/2549023.html)","tags":["SQL"],"categories":["Database"]},{"title":"Git Push 错误解决方法","path":"/posts/Git-error.html","content":"git push用法和常见问题分析\n<!--more-->\n# Git push\n```git\ngit push origin test:master\n// 提交本地test分支作为远程的master分支\ngit push origin test:test\n// 提交本地test分支作为远程的test分支\n```\n如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。\n\n```git\ngit push origin :test\n// 刚提交到远程的test将被删除，但是本地还会保存的，不用担心\n```\n举个例子:\n```git\ngit push origin  :origin/Android_HK_K501_77-W916\n//由于:前面为空所以本来在服务器上面存在的分支origin/Android_HK_K501_77-W916和Android_HK_K501_77-W916\n现在就只有一个了,因为分支origin/Android_HK_K501_77-W916被删除了,但是本地的还在\n git push ssh://git@dev.lemote.com/rt4ls.git master\n // 把本地仓库提交到远程仓库的master分支中\ngit remote add origin ssh://git@dev.lemote.com/rt4ls.git\ngit push origin master\n```\n这两个操作是等价的，第二个操作的第一行的意思是添加一个标记，让origin指向ssh://git@dev.lemote.com/rt4ls.git，也就是说你操 作origin的时候，实际上就是在操作ssh://git@dev.lemote.com/rt4ls.git。origin在这里完全可以理解为后者 的别名。\n\n    注意：需要说明的是，默认情况下这条语句等价于提交本地的master仓库到远程仓库，并作为远程的master分支。\n    如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。\n\n# 常见错误:\n- 1.error:failed to push some refs to ...\n\n当要push代码到git时，出现提示：\n```\nerror:failed to push some refs to ...\nDealing with “non-fast-forward” errors\nFrom time to time you may encounter this error while pushing:\ngit push origin master\n\nTo ../remote/\n\n ! [rejected]        master -> master (non-fast forward)\n\nerror: failed to push some refs to '../remote/'\n\nTo prevent you from losing history, non-fast-forward updates were rejected\n\nMerge the remote changes before pushing again.  See the 'non-fast forward'\n\nsection of 'git push --help' for details.\n\n```\n\n问题（Non-fast-forward）的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。于是你有2个选择方式：\n\n强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容\n```\ngit push -f\n```\n- 2. 先把git的东西fetch到你本地然后merge后再push\n```git\ngit fetch\ngit merge\n```\n这2句命令等价于`git pull`\n\n可是，这时候又出现了如下的问题：\n\n上面出现的 [branch \"master\"]是需要明确(.git/config)如下的内容\n```\n[branch \"master\"]\n\n    remote = origin\n\n    merge = refs/heads/master\n```\n这等于告诉git2件事:\n- 1，当你处于master branch, 默认的remote就是origin。\n- 2，当你在master branch上使用git pull时，没有指定remote和branch，那么git就会采用默认的remote（也就是origin）来merge在master branch上所有的改变\n\n如果不想或者不会编辑config文件的话，可以在bash上输入如下命令行：\n```\ngit config branch.master.remote origin\ngit config branch.master.merge refs/heads/master\n```\n之后再重新git pull下。最后git push你的代码.\n\n**参考**\n- [CSDN-Renkangke](http://www.cnblogs.com/renkangke/archive/2013/05/31/conquerAndroid.html)","tags":["Linux","Termux","Git"],"categories":["Diary"]},{"title":"SQL 上机实验题","path":"/posts/SQLexam.html","content":"SQL 上机习题与练习\n<!--more-->\n# 实验一   SQL SERVER 2008的基本知识与操作\n实验日期：\n\n## 实验目标：\n（1）\t以SQL Server2008为实验平台掌握SQL Server服务器的注册、启动、暂停、查看与设置服务器的属性等操作；\n\n（2）\t了解SQL Server Management Studio的功能\n\n（3）\t学习SQL Server2008所提供的系统数据库；\n\n（4）\t学习利用SQL Server Management Studio创建数据库。掌握数据库中这主数据文件、辅助数据文件、日志文件三类文件的作用；\n\n（5）\t学习利用SQL Server Management Studio数据库中创建表；创建表的字段、字段的数据类型、设置表的主键；\n\n（6）\t学习利用SQL Server Management Studio修改数据库中表的数据，删除表的数据、向表中插入数据；\n\n（7）\t利用SQL Server Management Studio删除数据库中的表；\n\n（8）\t利用SQL Server Management Studio删除数据库、分离数据库、附加数据库库。\n\n## 实验内容\nSQL Server 2008将数据保存在数据库中，并为用户提供了访问这些数据的接口。对数据库的基本操作包括创建、查看、修改和删除数据库等。在学习这些操作之前，先来了解一下数据库文件和SQL Server系统数据库。\n### 1.\t数据库文件\n在SQL Server中数据库文件是存储数据的文件，其可以分为三类。\n\n主数据文件：扩展名是.mdf，它包含数据库的启动信息以及数据库数据，每个数据库只能包含一个主数据文件。在SQL Server中数据的存储单位是页。\n\n辅助数据文件：扩展名是.ndf,因为有些数据库可能非常大，用一个主数据文件可能放不下，因此就需要有一个多个辅助数据文件存储这些数据，可以和主数据文件放在相同的位置也可以存放在不同的位置。\n\n日志文件：用来记录页的分配和释放以及对数据库数据的修改操作，扩展名为.ldf,包含用于恢复数据库的日志信息。每个数据库必须至少有一个日志文件，也可以有多个。\n\n创建数据库时，一个数据库至少包含一个主数据文件和一个或多个日志文件，还可能包含一些辅助数据文件。这些文件默认的位置为：\\program files\\Microsoft SQL Server\\MSSQL\\Data文件夹。\n\n### 2.\tSQL Server系统数据库\n在 SQL Server 2008有两类数据库：系统数据库和用户数据库。系统数据库存储有关SQL Server 的系统信息，它们是SQL Server 2008管理数据库的依据。如果系统数据库遭到破坏，那么SQL Server将不能正常启动。在安装了SQL Server 2008的系统共中将创建4个可见系统数据库。\n#### （1）master数据库\nmaster数据库是SQL Server中最重要的数据库，它是SQL Server的核心数据库，如果该数据库被损坏，SQL Server将无法正常工作，master数据库中包含所有的登录名或用户ID所属的角色、服务器中的数据库的名称及相关的信息、数据库的位置、SQL Server如何初始化四个方面的重要信息。\n#### （2）model数据库\n用户创建数据库时是以一套预定义的标准为模型。例如，若希望所有的数据库都有确定的初始大小，或者都有特定的信息集，那么可以吧这些信息放在model数据库中，以model数据库作为其他数据库的模板数据库。如果想要使用所有的数据库都有一个特定的表，可以把该表放在model数据库里。model数据库是tempdb数据库的基础。对model数据库的任何改动都将反映在tempdb数据库中，所以，在决定对model数据库有所改变时，必须预先考虑好。\n#### （3）msdb数据库\nmsdb数据库给SQL Server代理提供必要的信息来运行作业，其供SQL Server 2008代理程序调度警报作业以及记录操作时使用。\n#### （4）tempdb数据库\ntempdb数据库用作系统的临时存储空间，其主要作用是存储用户建立的临时表和临时存储过程，存储用户说明的全局变量值，为数据排序创建临时表，存储用户利用游标说明所筛选出来的数据。\n### 3.\t创建数据库\n选择开始菜单中→程序→【Management SQL Server 2008】→【SQL Server Management Studio】命令，打开【SQL Server Management Studio】窗口，并使用Windows或 SQL Server身份验证建立连接。\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fq55rpftisj20id0crq4i.jpg)\n\n图1.1 新建数据库\n\n在【对象资源管理器】窗口中展开服务器，然后选择【数据库】节点。右键单击【数据库】节点，从弹出来的快捷菜单中选择【新建数据库】命令。执行上述操作后，会弹出【新建数据库】对话框。在对话框、左侧有3个选项，分别是【常规】、【选项】和【文件组】。完成这三个选项中的设置会后，就完成了数据库的创建工作，在【数据库名称】文本框中输入要新建数据库的名称。例如，这里以“Students”。\n【数据库文件】列表中包括两行，一行是数据库文件，而另一行是日志文件。通过单击下面的【添加】、【删除】按钮添加或删除数据库文件，如图1.1。\n\n【逻辑名称】指定该文件的文件名。\n\n【文件类型】用于区别当前文件是数据文件还是日志文件。\n\n【文件组】显示当前数据库文件所属的文件组。一个数据只能存在一个文件组里。\n\n【初始大小】指定该文件的初始容量。默认值为3MB.日志默认值为1MB。\n\n【自动增长】用于设置文件的容量不够用时，文件根据何中增长方式自动增长。\n\n完成以上操作后，单击【确定】按钮关闭【新建数据库】对话框。至此“新建的数据”数据库创建成功。新建的数据库可以再【对象资源管理器】窗口看到，如下图1.2所示。\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fq55qxojyqj20bu090di5.jpg)\n\n图1.2建好后的数据库Students\n\n### 4.\t修改数据库\n建立一个数据库之后，可以根据需要对该数据库的结构进行修改。\n\n启动SSMS，在“对象资源管理器”窗格中展开数据库节点，右击要修改的数据库名称，在弹出的快捷菜单中选择“属性”命令，打开“数据库属性”对话框。可以通过修改数据库属性来修改数据库。修改数据库的操作包括增减数据库文件、修改文件属性（包括数据库的名称、大小和属性）、修改数据库选项等。\n\n### 5.\t删除数据库\n为了减少系统资源的消耗，对于不再需要的用户创建数据库，应当把它从数据库服务器中删除，从而将其所占的磁盘空间全部释放掉。\n删除数据库的具体操作如下：\n\n启动SSMS，在“对象资源管理器”窗格中展开数据库节点，右击要删除的数据库名称，在弹出的快捷菜单中选择“删除”命令，打开“删除对象”对话框，单击“确定”按钮，数据库就被删除。\n\n#### 1.\t分离和附件数据库\n当数据库需要从一台计算机移到另一台计算机，或者需要从一个物理磁盘移到另一个物理磁盘时，常要进行数据库的附加与分离操作。\n附加数据库是指将当前数据库以外的数据库附加到当前数据库服务器中。\n附加数据库的具体操作如下：\n\n启动SSMS，在“对象资源管理器”窗格中右击“数据库”节点在快捷菜单中选择“附加”命令，打开“附加数据库”对话框，如图1.3所示，单击“添加”按钮，打开“定位数据库文件”对话框，选择要附加的数据库主数据文件（.mdf），单击“确定”按钮，返回上述“附加数据库”对话框，单击“确定”按钮，完成数据库的附加操作。\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fq55sk9nhsj209v0b541h.jpg)\n\n图1.3 附加数据库\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fq55tj2m36j20bq0as41r.jpg)\n\n图1.4 分离数据库\n\n分离数据库就是讲数据库从SQLserver2008服务器中卸载，但依然保存数据库的数据文件和日志文件。需要时，分离的数据库，可以重新附加到SQL server2008服务器中。\n\n分离数据库的具体操作如下：\n\n启动SSMS，在“对象资源管理器”窗格中展开数据库节点，右击要分离的数据库名称，在弹出的快捷菜单中单击“任务”→“分离”命令，如图1.4所示，打开“分离数据库”对话框，单击“确定”按钮，实现数据库的分离。\n## 简答题：\n（1）打开SQL Server Management Studio时，怎样进行数据库的登录认证？\n\n答：\n  1. 打开 SQL Server Management Studio，以 Windows身份认证方式登录\n  2. 在对象资源管理器下，右键 Security ==> Logins ==> New Login \n  3. 点击图片中的Logins \n  4. 会显示SQL server 的所有用户\n\n（2）对象资源管理器的作用是什么？\n答：“对象资源管理器”是服务器中所有数据库对象的树视图。此树视图可以包括SQL Server Database Engine、Reporting Services、Analysis Services、Integration Services和SQL Server Mobile的数据库。对象资源管理器包括与其链接的所有服务器的信息。\n\n# 实验二   管理数据库操作\n实验日期：\n\n## 实验目标：\n\n（1）熟练掌握用SQL语句创建数据库的方法。\n\n（2）熟练掌握数据库属性的设置。\n\n（3）掌握数据库的修改和删除方法。\n\n## 实验内容：\n\n（1）利用SQL Server Management Studio创建一个”SM”的数据库，初始大小为3MB,最大为50MB，数据库自动增长，增长方式按10%；日志文件初始大小为2MB，最大值不受限制，按1MB增长。\n\n（2）通过SQL语句创建一个名为“学籍”的数据库，指定主文件名为“学籍_data”，存储路径为“d:\\example\\学籍_data.mdf”，该数据文件的初始大小为10MB，最大为100MB，增长方式按10MB增长；指定主日志文件名为“学籍_log”，存储路径为“d:\\example\\学籍_log.ldf”，该日志文件初始大小为20MB，最大为200MB，按10MB增长。\n\n①\t在工具栏单击“新建查询”按钮，打开代码编辑器，输入如下SQL语句。\n\n```sql\n   Create database 学籍\n   On  primary\n(name=学籍_data,\nFilename=’d:\\example\\学籍_data.mdf’,\nSize=10,\nMaxsize=100,\nFilegrowth=10)\nLog on\n(name=学籍_log,\nFilename=’d:\\example\\学籍_log.ldf’,\nSize=20,\nMaxsize=200,\nFilegrowth=10)\n```\n请执行该语句，即可创建“学籍”数据库。\n\n② 使用对象资源管理器，可以修改“学籍”数据库。选择“学籍”数据库的节点，点击右键，在弹出的快捷菜单中选择“属性”命令，打开“数据库属性”对话框，即可进行数据库的修改操作。\n\n③ 使用”SQL”语句，在“学籍”数据库中添加一个数据文件“学籍_data1”，指定其初始大小为4MB，最大不受限制，增长方式按10%增长。\n\n```sql\nAlter database 学籍\nAdd file\n(name=’学籍_data1’,\nFilename=’d:\\example\\学籍_data1.mdf’,\nSize=4,\nMaxsize=unlimited,\nFilegrowth=10%)\nGo\n```\n④\t使用SQL语句删除“学籍”数据库。\n```sql\nDrop database 学籍\nGO\n```\n提示：当数据库正在参与复制是不能删除，当数据库正在被复制时不能删除，当有用户正在使用数据库时不能删除。\n\n## 简答题：\n（1）SQL Server2008中的数据库能否只包含数据文件？\n\n\n# 实验三   用T-SQL创建与修改表的操作\n实验日期：\n\n## 实验目标：\n（1）熟练掌握各种数据类型。\n\n（2）熟练运用T-SQL（Transact-SQL）语句正确创建表。\n\n（3）掌握常用的数据完整性约束。\n\n## 实验内容：\n\n（1）创建“学籍”数据库，在该数据库中创建Student表。\n表3.1 Student表的结构\n\n|列名|数据类型|长度|字段说明|能否为空|是否主键|\n|:---:|:---:|:---:|:---:|:---:|:---:|\n|Sno|CHAR|10|学号|否|是|\n|Sname|CHAR|10|姓名|是|否|\n|Ssex|CHAR|2|性别|是|否|\n|Sage||TINYINT|年龄|是|否|\n|Sdept|CHAR|10|系|是|否|\n\n利用T-SQL命令创建Student表，表的结构如表3.1所示。\n代码如下：\n```sql\nCREATE  TABLE  Student\n( Sno  CHAR(10)  primary key,\n Sname  CHAR(10),\n Ssex  CHAR(2) check (Ssex in (‘男’,’女’)),\n Sage  TINYINT,\n Sdept  CHAR(10)\n  )\n```\n（2）利用T-SQL命令创建Course表，表的结构如表3.2所示。\n\n表3.2 Course表的结构\n\n|列名|数据类型|长度|字段说明|能否为空|是否主键|\n|:---:|:---:|:---:|:---:|:----:|:----:|\n|Cno|CHAR|5|课程号|否|是|\n|Cname|CHAR|10|课程名|否|否|\n|Credits|TINYINT||学分|是|否|\n|PCno|CHAR|5|先修课程号|是|否|\n\n代码如下：\n\n```sql\nCREATE TABLE Course (\nCno     char(5)  NOT NULL,\nCname   char(10)  NOT NULL,\n PCno    char(5),\nCredit  tinyint  CHECK (Credit > 0),\nPRIMARY KEY(Cno),\nFOREIGN KEY (PCno) REFERENCES Course(Cno),\n)\n```\n（3）为已经创建了的Student表创建一个约束，规定在Student表中，如果学生没有提供所在系，就写入默认值“计算机系”。df_dept为该约束的名。\n代码如下：\n\n```sql\nAlter table Student\nAdd constraint df_dept\nDefault  ‘计算机系’  for  Sdept\n```\n（4）利用T-SQL命令创建SC表，表的结构如表3.3所示。\n表3.3  SC表的结构\n\n|列名|数据类型|长度|字段说明|能否为空|是否主键|\n|:---:|:---:|:---:|:---:|:---:|:---:|\n|Sno|CHAR|10|学号|否|是|\n|Cno|CHAR|5|课程号|否|是|\n|Grade|TINYINT||成绩|是|否|\n\n代码如下：\n```sql\nCREATE  TABLE  SC(\nSno char(10) FOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE,\nCno char(5)  FOREIGN KEY(Cno) REFERENCES Course(Cno),\nGrade tinyint CHECK(grade<=100 and grade>=0),\nPRIMARY KEY(Sno,Cno)\n)\n```\n执行并思考Sno char(10) FOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE语句中ON DELETE CASCADE的含义与作用。\n## 问答题\n\n（1）T-SQL支持的数据类型有哪些？\n\n答：整数数据类型，浮点数据类型，字符型数据类型，日期和时间数据类型。\n\n（2）Tinyint数据类型定义的数据的取值范围是多少？\n\n存储0~255之间的整数\n\n（3）写出创建以下表3.4-3.6所示的表结构的SQL语句，要求在定义表的同时定义数据的完整性约束。\n\n```sql\nCreate table 图书表(  \n书号 nchar(6) primary key,   \n书名 nvarchar(30) not null,   \n第一作者 char(10) not null,   \n出版日期 smalldatetime,   \n价格：numeric(4,1) )\n```\n```sql\nCreate table 书店表(    \n书店编号 nchar(6) primary key,   \n店名 nvarchar(30) not null,    \n电话char(8) check(电话 like   ‘[0-9][0-9][0-9][0-9][0-9][0-9][0-9] [0-9]’),   \n地址 varchar(40),   \n邮政编码 char(6) ) \n```\n```sql\nCreate table 图书销售表(   \n书号 nchar(6) not null,    \n书店编号 nchar(6) not null,    \n销售日期 smalldatetime no tnull,\n销售数量 smalldatetime check(\n销售数量 >= 1) )\n```\n表3.4 图书表\n\n|列名|数据类型|约束|\n|:---:|:---:|:---:|\n|书号|统一字符编码定长类型，长度为6|主键|\n|书名|统一字符编码可变长类型，长度为30|非空|\n|第一作者|普通编码定长字符，长度为10|非空|\n|出版日期|小日期时间型|非空|\n|价格|定点小数，小数部分1位，整数部分3位|\n\n表3.5 书店表\n\n|列名|数据类型|约束|\n|:---:|:---:|:---:|\n|书店编号|统一字符编码定长类型，长度为6|主键|\n|店名|字符编码可变长类型，长度为30|非空|\n|电话|普通编码定长字符类型，长度为8|\n|地址|普通编码可变长字符类型，长度40|\n|邮政编码|普通编码定长字符类型，长度6|\n\n表3.6 销售表\n\n|列名|数据类型|约束|\n|:---:|:---:|:---:|\n|书号|统一字符编码定长类型，长度为6|主键，外键|\n|书店编号|统一字符编码定长类型，长度为6|主键，外键|\n|销售日期|小日期时间型|主键|\n|销售数量|小整型|\n|邮政编码|普通编码定长字符类型，长度6|\n\n（4）删除“销售表”中的“邮政编码”列；\n```sql\nalter table 书店表 Drop column 邮政编码\n```\n（5）将“销售表”中的“销售数量”列的数据类型改为整型\n```sql\nalter table 图书销售表 Alter column 销售数量 int \n```\n\n# 实验四   数据查询的操作（一）\n实验日期：\n\n## 实验目标：\n（1）掌握SELECT子句以及WHERE子句的使用方法。\n\n（2）学会应用ORDER BY子句。\n\n（3）掌握5种基本的聚合函数。\n\n（4）学会分组统计和二次查询。\n\n（5）学会数据的导入与导出的方法。\n\n## 实验内容：\n在SELECT语句中使用WHERE子句，在WHERE子句后跟一个条件式，就可以查询满足条件的行。\nWHERE子句的格式：WHERE〈条件〉。\n表4.1 常用的查询条件\n\n|查询条件|运算符|说明|\n|:---:|:---:|:---:|\n|比较|=、<、<=、>、>=、<>、!=、!<、!>|\n|范围谓词|BETWEEN   AND 、NOT  BETWEEN  AND|介于二者之间（包括两端）、不介于二者之间|\n|集合谓词|IN 、 NOT  IN|在集合中、不在集合中\n|字符匹配谓词|LIKE、NOT LIKE|匹配、不匹配|\n|空值|IS NULL 、IS NOT NULL|是空值、不是空值|\n|逻辑运算|NOT、AND、OR|逻辑非、逻辑与、逻辑或|\n\n打开对象资源管理器，创建一个名为”lianxi1”的数据库，在该数据库中导入以下的仓库表4.2和职工表4.3。\n表4.2 仓库表\n\n|仓库号|城市|面积|\n|:---:|:---:|:---:|\n|WH1|北京|370|\n|WH2|上海|500|\n|WH3|广州|200|\n|WH4|广州|300|\n|WH5|天津|340|\n|WH6|上海|350|\n|WH7|上海|600|\n|WH8|天津|300|\n\n\n注意：面积以平方为单位。\n\n表4.3 职工表\n\n|职工号|姓名|仓库号|月工资|性别|\n|:---:|:---:|:---:|:---:|:---:|\n|E1\t|朱迪|WH2|2220|女|\n|E2\t|牛丽丽|WH1|1810|女|\n|E4\t|李安|WH2|1850|男|\n|E5\t|王进步|WH3|1530|男|\n|E6\t|李光铭|WH1|1550|男|\n|E7\t|赵芙蓉|WH4|2300|女|\n|E8\t|刘山|WH4|2000|男|\n|E9\t|张尚琳|WH5|2050|女\n|E10|王玛丽|WH5|1900|女|\n|E11|胡尼克|WH6|2100|男|\n|E12|古梅|WH7|1700|女|\n|E15|胡俊|WH5|1780|男|\n|E16|胡轩|WH1|1600|男|\n\n用SQL语句完成以下的练习题：\n1.\t从职工关系中检索所有工资值。\n```sql\nselect 月工资\nfrom zg\n```\n\n2.\t检索仓库关系中的所有元组。\n ```sql\nselect *\nfrom ck\n```\n\n3.\t检索工资多于2000元的职工对应的职工号，姓名。\n```sql\n select  职工号,月工资 \n from zg \n where 月工资>2000\n ```\n\n4.\t检索哪些仓库的面积在400到550平方之间，列出仓库号和所在的城市。\n ```sql\n select 仓库号,城市 \n from ck \n where 面积<=550 \n and 面积>=400\n ```\n\n5.\t检索出有广州哪些仓库，列出仓库号。\n```sql\n select 仓库号\n from ck \n where 城市='广州'\n```\n\n6.\t检索出所在城市为广州的仓库的个数。\n```sql\nselect count(仓库号)\nfrom ck \nwhere 城市='广州'\n```\n7.\t检索出所有职工的平均工资。\n```sql\nselect avg(月工资) \nfrom zg\n ```\n8.\t检索出在WH5仓库工作的职工的人数。\n```sql\nselect count(职工号) \nfrom zg \nwhere 仓库号='WH5'\n```\n\n9.\t检索出职工表的所有的仓库号，去掉重复值。\n```sql\nselect distinct 仓库号 from zg\n```\n10.\t检索出每个仓库的人数。\n```sql\nselect 仓库号,count(*) as 人数 \nfrom zg \ngroup by 仓库号\n```\n11.\t检索出上海的仓库有哪些，列出仓库号、面积。查询结果按面积降序排列。\n```sql\nselect 仓库号,面积 \nfrom ck \nwhere 城市='上海' \norder by 面积\n```\n12.\t检索出哪些仓库女职工的人数达到了3人。\n ```sql\nselect 仓库号,count(职工号)人数\nfrom zg \nwhere 性别='女'\ngroup by 仓库号 \nhaving count(职工号)>3\n```\n13.\t检索出所有姓胡的职工的职工号、姓名、性别、工资。查询结果按性别排降序、工资排升序。\n```SQL\nselect 职工号,姓名,性别,月工资\nfrom zg\nwhere 姓名 like'胡%'\norder by 性别 desc,月工资 asc\n```\n14.\t检索出职工“王玛丽”的年工资。\n ```SQL\nselect 月工资*12 as 年薪\nfrom zg\nwhere 姓名='王玛丽'\n```\n15.\t检索出“WH1”和“WH2”两个仓库工作的职工的基本信息。\n```SQL\nselect *\nfrom zg\nwhere 仓库号='WH1'or 仓库号='WH2'\n\n```\n16.\t检索出年工资在24000以上的职工的姓名，年工资值。\n```SQL\nselect 姓名\nfrom zg\nwhere 月工资*12>24000\n```\n## 问答题：\n\n（1）WHERE子句与HAVING子句有和不同？\n\n答：Where子句--指定查询条件，having短语—选择出只有满足指定条件的组.\n\nwhere 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。\n\n  having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。\n\n（2）在WHERE子句中可以使用的运算符有哪些？WHERE子句中能不能使用聚集函数？\n\n答：in，not in；字符匹配：like，not like；空值：is null，is not null；多重条件：and，or。\nWhere子句中不能使用聚集函数。\n\n\n不能使用聚集函数\n \n# 实验五   数据查询的操作（二）\n实验日期：\n\n## 实验目标：\n（1）熟练掌握基本的连接操作，掌握内连接与外连接的方法，学会应用自身连接。\n\n（2）熟练掌握不相关子查询。\n\n（3）掌握相关子查询。\n\n（4）学会给表命别名。\n\n（5）学会数据的导入与导出的方法。\n\n### 实验内容：\n打开对象资源管理器，创建一个名为”lianxi2”的数据库，在该数据库中导入以下的仓库表5.1、职工表5.2、订购表5.3和供应商表5.4。\n\n表5.1仓库表\n\n|仓库号|城市|面积|\n|:---:|:---:|:----:|\n|WH1|北京|3700|\n|WH2|上海|5000|\n|WH3|广州|2000|\n|WH4|武汉|4000|\n|WH5|上海|4560|\n|WH6|广州|6700|\n|WH7|珠海|4800|\n\n表5.2职工表\n\n|仓库号|职工号|月工资|\n|:---:|:---:|:---:|\n|WH2|E1|2220|\n|WH1|E2|2210|\n|WH2|E3|4050|\n|WH3|E4|3230|\n|WH1|E5|3250|\n|WH1|E6|2300|\n|WH4|E7|5000|\n|WH5|E8|4000|\n|WH5|E9|3400|\n|WH6|E10|3800|\n\n\n表5.3 订购表\n\n|职工号|供应商号|订购单号|订购日期|\n|:---:|:---:|:---:|:---:|\n|E3|S7|OR091204|2009-12-4|\n|E1|S4|OR090101|2009-4-1|\n|E7|S4|OR100402|2010-4-2|\n|E6|S6|OR100121|2010-1-21|\n|E3|S4|OR091115|2009-11-15|\n|E1|S6|OR060201|2006-2-1|\n|E3|S6|OR100312|2010-3-12|\n|E3|S3|OR090302|2009-3-2|\n|E8|S7|OR100928|2010-9-28|\n|E6|S7|OR100712|2010-7-12|\n|E5|S3|OR100507|2010-5-7|\n\n表5.4 供应商表\n\n|供应商号|供应商名|地址|\n|:---:|:---:|:---:|\n|S3|振华电子厂|西安|\n|S4|华通电子公司|北京|\n|S6|607厂|郑州|\n|S7|爱华电子厂|北京|\n\n用SQL语句完成以下的练习题：\n\n1.\t查询每个城市的仓库总面积。\n```sql\nselect 城市,sum(面积) as 总面积\nfrom ck\ngroup by 城市\n```\n2.\t查询每个仓库的职工人数，如果该仓库没有职工，也要列出人数为0。\n```sql\nselect 仓库号,count(职工号) as 职工人数\nfrom zg\ngroup by 仓库号\nhaving count(职工号)>=0\n```\n```sql\nselect ck.仓库号,count(职工号)as 职工人数\nfrom ck left join zg on ck.仓库号=zg.仓库号\ngroup by ck.仓库号\n```\n3.\t查询在上海工作的职工有多少个。\n ```sql\nselect 城市,count(职工号) as 上海职工数\nfrom ck,zg\nwhere ck.仓库号=zg.仓库号\nand \nck.城市='上海'\ngroup by 城市\n```\n4.\t查询哪些职工在上海工作，列出他们的职工号，仓库号。\n```sql\nselect 职工号,zg.仓库号\nfrom ck,zg\nwhere ck.城市='上海' \nand \nck.仓库号=zg.仓库号\n```\n5.\t查询与E3号职工有订购业务联系的供应商号，供应商名。\n```sql\nselect dg.供应商号,gys.供应商名\nfrom dg,gys\nwhere 职工号='E3' and dg.供应商号=gys.供应商号\n```\n6.\t查询哪些职工与爱华电子厂有订购业务联系，列出他们的职工号，仓库号。\n```sql\nselect zg.职工号,zg.仓库号\nfrom zg,gy\nwhere gy.供应商名='爱华电子厂'\n```\n```sql\nselect zg.职工号,zg.仓库号\nfrom dg join gys on dg.供应商号=gys.供应商号\njoin zg on zg.职工号=dg.职工号\nwhere 供应商名='爱华电子厂'\n```\n7.\t查询每个供应商的订购单数目，列出供应商号和他们的订购单数目。\n```sql\nselect dg.供应商号,count(dg.订购单号) as 订购单数目\nfrom dg,gy\nwhere gy.供应商号=dg.供应商号\ngroup by gy.供应商名,dg.供应商号\n```\n```sql\nselect dg.供应商号,count(订购单号) 订购单数目\nfrom dg join gys on dg.供应商号=gys.供应商号\ngroup by dg.供应商号\n```\n\n8.\t查询工资在3000元以上，并在北京或上海工作的职工，列出他们的职工号和工资。\n```sql\nselect zg.职工号,zg.月工资\nfrom zg,ck\nwhere (ck.城市='北京' or ck.城市='上海')\nand zg.月工资>3000\n```\n```sql\nselect 职工号,月工资\nfrom ck join zg on ck.仓库号=zg.仓库号\nwhere (城市='北京'or 城市='上海') and 月工资>3000\n```\n9.\t查询与供应商为S3的供应商有业务联系的职工他们的职工号、订购单号、仓库号、城市。\n```sql\nselect dg.职工号,dg.订购单号,ck.仓库号,ck.城市\nfrom gys join dg on gys.供应商号=dg.供应商号\njoin zg on dg.职工号=zg.职工号\njoin ck on zg.仓库号=ck.仓库号\nwhere gys.供应商号='S3'\n```\n10.\t查询出哪些仓库没有分配职工。\n```sql\nselect ck.仓库号\nfrom ck left join zg on ck.仓库号=zg.仓库号\nwhere zg.职工号 is null\n```\n```sql\nselect ck.仓库号,count(zg.仓库号) 人数\nfrom ck left join zg on zg.仓库号 = ck.仓库号\ngroup by ck.仓库号\nhaving count(zg.仓库号)=0\n```\n```sql\nselect 仓库号\nfrom ck\nwhere 仓库号 not in (select distinct 仓库号 from zg)\n```\n11.\t查询出哪些职工的工资高于全体职工平均工资。\n```sql\nselect 职工号\nfrom zg\nwhere 月工资>(select avg(月工资) from zg )\n```\n12.\t查询出哪些职工的工资高于他所在仓库的职工的平均工资。\n```sql\nselect 职工号\nfrom zg join \n(select 仓库号 avg(月工资) as 平均工资\nfrom zg group by 仓库号) as a on zg.仓库号=ck.职工号\nwhere zg.月工资>a.avg(月工资)\n\n```\n```sql\nselect 职工号\nfrom zg a\nwhere 月工资>(select avg(月工资) \nfrom zg b\nwhere b.仓库号=a.仓库号)\n```\n```sql\nselect 职工号\nfrom zg as a join\n(select 仓库号,avg(月工资) as 平均工资 \nfrom zg group by 仓库号)\nas b on a.仓库号=b.仓库号\nwhere a.月工资> b.平均工资\n```\n13.\t求出哪个职工所发出的订购单最多。\n```sql\nselect  top 1 职工号,count(订购单号) as 订购单数\nfrom dg\ngroup by 职工号\norder by 订购单数 desc\n```\n```sql\nselect 职工号\nfrom dg\ngroup by 职工号\nhaving count(订购单号)=\n(select top 1 count(订购单号) as 订单数\nfrom dg\ngroup by 职工号\norder by 订单数 desc)\n```\n\n# 实验六   数据查询的操作（三）\n实验日期：\n\n## 实验目标：\n（1）熟练掌握基本的连接操作，掌握内连接与外连接的方法，学会应用自身连接。\n\n（2）熟练掌握不相关子查询。\n\n（3）掌握相关子查询。\n\n（4）学会给表命别名。\n\n（5）学会在FROM子句中派生关系，构造查询。\n\n## 实验内容：\n假设“教学管理”数据库中有4个基本表（关系）：\n\n学生关系：学生（学号，姓名，性别，所在系）\n\n课程关系：课程（课程号，课程名，开课学期，教师号）\n\n选课关系：选课（学号，课程号，成绩）\n\n教师关系：教师（教师号，姓名，职称，部门）\n\n每个关系的当前值分别如表所示。\n\n打开对象资源管理器，创建一个名为”教学管理”的数据库，在该数据库中导入以下的\n\n表6.1—6.4。\n\n表6.1 学生关系\n\n|学号|姓名|性别|年龄|所在系|\n|:---:|:---:|:---:|:---|:---:|\n|S101101|陈名军|男|18|计算机系|\n|S101102|吴小晴|女|19|计算机系|\n|S101103|王明燕|女|19|计算机系|\n|S101104|严利|男|20|计算机系|\n|S101105|朱欣|男|20|计算机系|\n|S101201|李国庆|男|21|信息系|\n|S101202|李祥|男|21|信息系|\n|S101203|孙渝研|男|20|信息系|\n|S101204|赵艳|女|18|信息系|\n|S101205|刘唯|女|19|信息系|\n|S101206|林玉霞|女|20|信息系|\n|S101207|王江|男|21|信息系|\n|S101301|王成|男|20|会计系|\n|S101302|张平安|男|18|会计系|\n|S101401|钟琴|女|19|会计系|\n|S101402|吴娟娟|女|21|会计系|\n|S101403|李月|女|22|会计系|\n|S101404|陈名军|男|23|会计系|\n|S101405|赵艳|女|21|会计系|\n\n表6.2课程关系\n\n|课程号|课程名|开课学期|学分|教师号|\n|:---:|:---:|:---:|:---:|:---:|\n|101|计算机基础|1|3|T1|\n|102|体育|2|4|T2|\n|201|英语|1|4|T3|\n|202|大学语文|3|4|T4|\n|305|操作系统|4|4|T5|\n|304|计算机原理|4|4|T5|\n|301|计算机网络|3|3|T6|\n|302|电子技术|3|4|T6|\n|303|数据库应用|4|3|T7|\n\n表6.3 选课关系\n\n|学号|课程号|成绩|\n|:---:|:---:|:---:|\n|S101101|101|60|\n|S101101|102|83|\n|S101101|201|78|\n|S101101|305|79|\n|S101101|202|87|\n|S101101|304|89|\n|S101101|303|64|\n|S101101|302|90|\n|S101102|101|84|\n|S101101|301|83|\n|S101102|102|75|\n|S101102|202|86|\n|S101102|303|67|\n|S101201|101|78|\n|S101201|102|72|\n|S101201|303|76|\n|S101201|201|50|\n|S101301|101|90|\n|S101302|101|90|\n|S101302|303|83|\n\n表6.4教师表\n\n|教师号|姓名|职称|部门\n|:---:|:---:|:---:|:---:|\n|T1|胡美丽|讲师|公共教学|\n|T2|王珊珊|讲师|公共教学|\n|T3|王新|讲师|公共教学|\n|T4|李再敏|副教授|公共教学|\n|T5|李红玉|教授|计算机系|\n|T6|周进|助教|计算机系|\n|T7|张丽丽|助教|计算机系|\n|T8|王晓舟|副教授|计算机系|\n|T9|周樱|讲师|信息系|\n\n1. 查询“101”课程成绩比“102”课程成绩高的所有学生的学号。\n提示：\n```sql\nselect a.学号\nFrom (select 学号,成绩 from xkgx where 课程号='101') a,\n(select 学号,成绩\nfrom xkgx where 课程号='102') b\nwhere a.成绩>b.成绩 and a.学号=b.学号\n```\n自然连接：\n```sql\nselect a.学号\nfrom xkgx a join xkgx b on a.学号=b.学号\nwhere a.课程号='101' and b.课程号='102' \nand a.成绩>b.成绩\n```\n2. 查询全部选修课程表中所有课的同学的学号、姓名。\n```sql\nselect 学号,姓名\nfrom xsgx\nwhere 学号 in\n(select 学号 from xkgx group by 学号 \n having count(课程号)=\n(select count(课程号) from kcgx))\n```\n3. 查询哪些老师没有教授任何课程。列出老师的全部列。（`not in`和` not EXISTS `两种方式实现）。\n```sql\nselect *\nfrom js\nwhere 教师号 not in\n(select 教师号 from xkgx join kcgx on \nxkgx.课程号=kcgx.课程号)\n```\n```sql\nselect *\nfrom js\nwhere 教师号 not in \n(select 教师号 from kcgx \nwhere kcgx.教师号=jsgx.教师号)\n```\n```sql\nselect *\nfrom js\nwhere NOT EXISTS\n(select distinct js.教师号  \nfrom kcgx \nwhere kcgx.教师号=js.教师号)\n```\n4. 查询出只选修了一门课程的学生的学号和姓名。\n```sql\nselect xsgx.学号,xsgx.姓名\nfrom xsgx\nwhere xsgx.学号 in\n(select xkgx.学号 from xkgx \ngroup by xkgx.学号 \nhaving count(xkgx.课程号)=1)\n```\n```sql\nselect xsgx.学号,姓名\nfrom xsgx join xkgx on xsgx.学号=xkgxx.学号\ngroup by xsgx.学号,xsgx.姓名\nhaving count(xkgx.课程号)=1\n```\n5. 查询张丽丽老师教过的学生的学号、姓名。\n```sql\nselect xsgx.学号,xsgx.姓名\nfrom xsgx\nwhere kcgx.课程号 in\n(select 课程号 from xkgx\nwhere kcgx.教师号 in(\nselect js.教师号\nfrom js\nwhere js.姓名='张丽丽')\n```\n```sql\nselect xsgx.学号,xsgx.姓名\nfrom xsgx,kcgx,xkgx,js\nwhere xsgx.学号=xkgx.学号 \nand \nkcgx.课程号=xkgx.课程号 \nand\njs.教师号=kcgx.教师号\nand \njs.姓名='张丽丽'\n```\n```sql\nselect sxgx.学号,s.姓名\nfrom js join kcgx on js.教师号=kcgx.教师号\njoin xkgx on kcgx.课程号=xkgx.课程号\njoin xsgx on xkgx.学号=xsgx.学号\nwhere t.姓名='张丽丽'\ngroup by xsgx.学号,xsgx.姓名\n```\n6. 查询相同姓名的学生，列出相同的姓名及相应的同名人数。（有几个学生同名）\n提示：考虑按姓名分组，分组内元组的个数。\n```sql\nselect *\nfrom xsgx\nwhere 姓名 in(select 姓名 from xsgx\ngroup by 姓名\nhaving count(*)>1)\n\n```\n\n7. 查询每门功成绩最好的前两名。\n\n提示：\n\n```sql\nSELECT t1.学号,t1.课程号,成绩\nFROM 选课 t1\nWHERE 成绩 IN (SELECT TOP 2 成绩\nFROM 选课\nWHERE 课程号= t1.课程号\nORDER BY 成绩 DESC\n)\n```\n```sql\nSELECT t1.学号,t1.课程号,成绩\nFROM xkgx t1\nWHERE 成绩 IN (SELECT TOP 2 成绩\nFROM xkgx\nWHERE 课程号= t1.课程号\nORDER BY 成绩 DESC)\nORDER BY 课程号 DESC\n```\n这道题每次父亲查询都提供课程号的值给子查询，其子查询的功能就是计算父查询对应课程的前两名。\n\n8. 查询学过“101”并且也学过编号“102”课程的同学的学号、姓名。\n```sql\nselect xsgx.学号,xsgx.姓名\nfrom xsgx\ngroup by xkgx.学号\nwhere 学号 in (select 学号 from xkgx\nwhere 课程号='101')\nand 学号 in (select 学号 from xkgx\nwhere 课程号='102')\n```\n9.查询没有选修课程表中所有课的同学的学号、姓名。\n```sql\nselect xsgx.学号,xsgx.姓名\nfrom xsgx\nwhere 学号 in\n(select 学号 from xkgx \ngroup by 学号\nhaving count(课程号)<(select count(课程号) from kcgx))\n```\n```sql\nselect xsgx.学号,xsgx.姓名\nfrom xsgx join xkgx on xsgx.学号=xkgx.学号\ngroup by xsgx.学号,xkgx.姓名\nhaving count(kcgs.课程号)<\n(select count (课程号) from kcgx )\n```\n或者\n```sql\nselect distinct kcgx.学号,xsgx.姓名\nfrom xkgx join xsgx on xkgx.学号=xsgx.学号\nwhere xkgx.学号 not in\n(select 学号 from xkgx\ngroup by 学号\nhaving count(课程号) =\n(select count (课程号) from kcgx))\n```\n10.查询全部学生都选修过的课程对应的课程号和课程名。\n提示：\n意味着该课程的选课人数与学生总人数相等。考虑按课程号分组，查询哪个分组中学号的个数与学生个数相等，得到这样的分组它的课程号。\n```sql\nselect kcgx.课程号,kcgx.课程名\nfrom kcgx\nwhere 课程号 in\n(select 课程号 from xkgx \ngroup by 课程号 \nhaving count(学号)=\n(select count(学号) from xsgx))\n```\n```sql\nselect 课程名,课程号\nfrom kcgx\nwhere kcgx.课程号 in (select 课程号\nfrom xkgx\ngroup by 课程号\nhaving count(学号) =\n(select count(学号)from xsgx))\n```\n\n11.查询没学过“李红玉”老师讲授的任一门课程的学生姓名。（not in不相关即可实现）\n\n```sql\nselect 姓名\nfrom xsgx\nwhere 学号 not in\n(select 学号 from xkgx,js,kcgx \nwhere xkgx.课程号=kcgx.课程号 \nand\nkcgx.教师号=js.教师号 \nand \njs.姓名='李红玉')\n```\n```sql\nselect 姓名\nfrom xsgx\nwhere 学号 not in\n(select 学号 from xkgx \njoin kcgx on xkgx.课程号=kcgx.课程号\njoin t on kcgx.教师号=xkgx.教师号\nwhere 姓名='李红玉')\n```\n\n# 实验七   视图与索引\n实验日期：\n\n## 实验目标：\n（1）掌握创建视图、删除视图；\n\n（2）查询视图。\n\n（3）更新视图、修改视图对应的数据。\n\n（4）理解索引的概念和索引的作用，学会使用索引。\n\n（5）了解聚簇索引和非聚簇索引。\n\n## 实验内容：\n假设“学生选课”数据库中有3个基本表（关系）：\n\n学生关系：学生（学号，姓名，性别，所在系）\n\n课程关系：课程（课程号，课程名，开课学期，教师号）\n\n选课关系：选课（学号，课程号，成绩）\n\n每个关系的当前值分别如表所示。\n\n打开对象资源管理器，创建一个名为”学生选课”的数据库，在该数据库中导入以下的\n\n表7.1—7.3。\n表7.1 学生关系\n\n|学号|姓名|性别|年龄|所在系|\n|:---:|:---:|:---:|:---:|:---:|\n|S101101|陈名军|男|18|计算机系|\n|S101102|吴小晴|女|19|计算机系|\n|S101103|王明燕|女|19|计算机系|\n|S101104|严利|男|20|计算机系|\n|S101105|朱欣|男|20|计算机系|\n|S101201|李国庆|男|21|信息系|\n|S101202|李祥|男|21|信息系|\n|S101203|孙渝研|男|20|信息系|\n|S101204|赵艳|女|18|信息系|\n|S101205|刘唯|女|19|信息系|\n|S101206|林玉霞|女|20|信息系|\n|S101207|王江|男|21|信息系|\n|S101301|王成|男|20|会计系|\n|S101302|张平安|男|18|会计系|\n|S101401|钟琴|女|19|会计系|\n|S101402|吴娟娟|女|21|会计系|\n|S101403|李月|女|22|会计系|\n|S101404|陈名军|男|23|会计系|\n|S101405|赵艳|女|21|会计系|\n\n表7.2课程关系\n\n|课程号|课程名|开课学期|学分|教师号|\n|:---:|:---:|:---:|:---:|:---:|\n|101|计算机基础|1|3|T1|\n|102|体育|2|4|T2|\n|201|英语|1|4|T3|\n|202|大学语文|3|4|T4|\n|305|操作系统|4|4|T5|\n|304|计算机原理|4|4|T5|\n|301|计算机网络|3|3|T6|\n|302|电子技术|3|4|T6|\n|303|数据库应用|4|3|T7|\n\n表7.3 选课关系\n\n|学号|课程号|成绩|\n|:---:|:---:|:---:|\n|S101101|102|83|\n|S101101|101|60|\n|S101101|201|78|\n|S101101|202|87|\n|S101101|305|79|\n|S101101|304|89|\n|S101101|303|64|\n|S101101|302|90|\n|S101101|301|83|\n|S101102|101|84|\n|S101102|102|75|\n|S101102|202|86|\n|S101102|303|67|\n|S101201|101|78|\n|S101201|102|72|\n|S101201|303|76|\n|S101201|201|50|\n|S101301|101|90|\n|S101302|101|90|\n|S101302|303|83|\n\n\n用学生、课程、选课这三张表，利用SQL语句完成以下练习题。\n\n（1）创建V1视图，学生的学号、姓名、所在系、课程号、课程名、课程学分的视图。\n```sql\ncreate view V1\t\nas\nselect xs.学号,姓名,所在系,xk.课程号,kc.课程名,学分\nfrom xs \njoin xk on xs.学号=xk.学号 \njoin kc on xk.课程号=kc.课程号\n```\n（2）创建V2视图，查个学生的平均成绩的视图，要求列出学生学号及平均成绩。\n```sql\ncreate view V2\nas\nselect 学号,avg(成绩) as 平均成绩\nfrom xk\ngroup by 学号\n```\n（3）创建V3视图，每个学生的修课学分的视图，要求列出学生学号及总学分。\n```sql\ncreate view V3\nas\nselect 学号,sum(学分) as 总学分\nfrom xk join  kc on xk.课程号=kc.课程号\ngroup by 学号\n```\n（4）上面的视图V3能否对其总学分对应的数据进行修改？\n```sql\nupdate V3 set 总学分=10 where 学号='S101101'\nselect * from V3\n```\n对视图或函数 'V3' 的更新或插入失败，因其包含派生域或常量域。\n\n（5）创建V4视图，计算机系的学生基本信息的视图。该视图能否更新学生的姓名？（无需选课的信息）。\n```sql\ncreate view V4\nas\nselect *\nfrom xs\nwhere 所在系='计算机系'\n\nupdate V4 set 姓名='陈大军' \nwhere 姓名='陈名军'\n```\n可以更新\n\n（6）创建V5视图，每个学生获得的最高成绩，要求列出学号和最高成绩\n```sql\ncreate view V5\nas\nselect 学号,max(成绩) as 最高成绩\nfrom xk\ngroup by 学号\n```\n（7）借助视图V5，实现该查询，对每个学生找出他获得最高成绩的课程号。\n```sql\nselect V5.学号,课程号\nfrom V5 join xk on V5.学号=xk.学号\nwhere 成绩=top 1\ngroup by xk.课程号\n```\n（8）删除视图V1。\n```sql\ndrop view V1\n```\n（9）为学生关系的姓名列创建一个非聚簇索引。\n```sql\ncreate nonclustered index 非聚簇索引 on xs(姓名)\n```\n（10）为课程表的课程名创建一个聚簇索引。\n```sql\ncreate clustered index 聚簇索引 on kc(课程名)\n```\n## 简答题\n\n1. 视图可以加快数据的查询速度，这句话对吗？为什么？\n- 不对，因为通过视图查询数据时，比直接针对基本表查询数据多了一个转换过程，即从外模式到模式的转换。                                       \n2. 视图可以简化查询，这句话对吗？为什么？\n- 对，简化操作\n3. 视图是一个虚表，数据库中只存放视图的定义，而不存放视图包含的数据，这些数据仍存放在原来基本表中。这句话对吗？\n- 对\n4. 基本表中的数据如果发生变化，视图中查询出数据也随之变化。这句话对吗？\n- 对\n5. 索引是否越多越好？\n- 否\n- 索引需要在内存和物理磁盘驱动器上使用更多的存储空间。在执行插入声明的过程中可能会在一定程度上导致系统性能的下降，因为在插入数据的时候是需要根据索引的顺序插入，而不是在第一个可用的位置直接插入数据，这样一来，存在的索引越多将导致插入或者更新声明所需要的时间就越多。\n- 1)索引影响DML操作,任何DML操作都要更新INDEX, 这是代价。\n- 2)任何方便都是有代价的，select的时候方便，insert、update、delete的时候就要维护index。\n- 3)索引多了, 执行计划的制定要费更多的资源。\n- 4)创建和维护索引是有成本的。\n- 5)索引能够极大的提高数据检索效率，也能够改善排序分组操作的性能，但是我们不能忽略的 一个问题就  是索引是完全独立于基础数据之外的一部分数据。\n6. 哪些视图不能更新？\n- 若视图的属性来自集函数、表达式，则该视图肯定是不可以更新的\n- 若视图是由两个以上基本表导出的，则次视图不允许更新。-- 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。\n- 若视图的字段来自集函数，则此视图不允许更新。\n- 若视图定义中含有GROUP BY子句，则此视图不允许更新若视图中含有DISTINCT短语，则此视图不允许更新\n- 若视图定义中有嵌套查询，并且内层查询FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。\n- 一个不允许更新的视图上定义的视图也不允许更新。\n7. 聚簇索引和非聚簇索引有何区别，为什么每个表只能有一个聚簇索引？\n\n答：聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。一个表只能有一个聚簇索引，因为数据一旦存储，顺序只能有一种。\n\n- 聚簇索引\n\n(1) 一个索引项直接对应实际数据记录的存储页，可谓“直达”\n\n(2) 主键缺省使用它\n\n(3) 索引项的排序和数据行的存储排序完全一致，利用这一点，想修改数据的存储顺序，可以通过改变主键的方法（撤销原有主键，另找也能满足主键要求的一个字段或一组字段，重建主键）\n\n(4) 一个表只能有一个聚簇索引（理由：数据一旦存储，顺序只能有一种）\n- 非聚簇索引\n\n(1) 不能“直达”，可能链式地访问多级页表后，才能定位到数据页\n\n(2)一个表可以有多个非聚簇索引\n- 聚簇索引的顺序就是数据的物理存储顺序，而对非聚簇索引的解释是:索引顺序与数据物理排列顺序无关。正式因为如此，所以一个表最多只能有一个聚簇索引。\n\n# 实验八   数据操作\n实验日期：\n\n## 实验目标：\n（1）掌握插入数据到表中。\n\n（2）掌握删除表中的数据。\n\n（3）掌握修改表中的数据。\n\n## 实验内容：\n建立一个名叫“仓库职工”的数据库，接下来请利用实验五的数据，将表中的数据导入到“仓库职工”数据库中。用T-SQL语句完成以下练习题。\n1. 查询每个城市的仓库的总面积，将查询的结果插入到新表t1中，该表需要自己创建。\n创建表t1的代码如下：\n```sql\nCreate table t1\n(cityname char(20),\nSumarea int\n)\n```\n运行代码创建了表t1。\n接下来向t1中插入数据，其中数据为某个子查询的结果。代码提示如下：\n\n```sql\nInsert into t1\nSelect 城市,sum(面积)\nFrom 仓库\nGroup by 城市\n ```\n2. 插入一个新的供应商元组（S9，智通公司，沈阳）\n```sql\ninsert into 供应商表\nvalues ('S9','智通公司','沈阳')\n```\n3. 北京的所有仓库增加100M2的面积。\n```sql\n update ck set 面积=面积+100 where 城市='北京'\n```\n4. 给低于所有职工平均工资的职工提高5%（注意要用0.05表示5%）的工资。\n```sql\nupdate 职工表\nset 月工资=月工资*(1+0.005)\nwhere 月工资<\n(select avg(月工资) from 职工表)\n```\n5. 给北京的职工加900元工资。（相关子查询，不相关子查询，多表三种方法实现 ）。\n- 用相关子查询实现的代码如下：\n```sql\nUpdate 职工\nSet 月工资=月工资+900\nWhere ‘北京’=(select  城市\nFrom 仓库\nWhere 仓库.仓库号=职工.仓库号)\n```\n- 用不相关子查询实现的代码如下：\n```sql\nUpdate 职工\nSet 月工资=月工资+900\nWhere 仓库号=(select  仓库号\nFrom 仓库\nWhere 城市=’北京’)\n```\n6．\t删除目前没有任何订购单的供应商。\n```sql\ndelete  from  供应商表\nwhere 供应商号 not in\n(select 供应商号 from 订购表)\n```\n7．\t删除由在上海仓库工作的职工发出的所有订购单。\n```sql\ndelete from 订购表\nwhere 职工号 in\n(select 职工号 from 职工表 where 仓库号 in\n( select 仓库号 from 仓库表 where 城市='上海'))\n```\n\n\n# 实验九   流程控制语句（选做）\n实验日期：\n\n## 实验目标：\n- （1）掌握流程控制关键字。\n- （2）查询流程控制关键字的使用方法。\n实验内容：\n流程控制语句是指那些用来控制程序执行和流程分支的语句，在SQL Server 2008中，流程控制语句用来控制SQL语句、语句块或者存储过程的执行流程。\n\nTransact-SQL 语言使用的流程控制命令与常见的程序设计语言类似，主要有以下几种控制命令。\n\n假设有“学生选课”的数据库，数据如实验七。\n\n（1）使用IF...ELSE 语句\n`IF...ELSE`语句是条件判断语句，其中，`ELSE子句`是可选的，最简单的IF语句没有ELSE子句部分。IF...ELSE语句用来判断当某一条件成立时执行某段程序，条件不成立时执行另一段程序。SQL Server允许嵌套使用IF...ELSE语句，而且嵌套层数没有限制。\nIF...ELSE语句的语法形式为：\n```sql\nIF <布尔表达式>\n           <SQL语句>|<语句块>\n     [ELSE\n          <SQL语句>|<语句块>]\n```\n例 在Student表中查询是否有‘张力’这个学生。如果有，则显示这个学生的姓名和系，否则显示没有此人。\n```sql\nUSE 学生选课\nGO\nDECLARE @message VARCHAR(20)\nIF EXISTS(SELECT * FROM Student WHERE SNAME='张力')\n    SELECT SNAME,SDEPT FROM Student WHERE SNAME='张力'\nELSE  \nBEGIN\n    SET @message='没有此人'\n    PRINT @message\nEND\n```\n\n例 在SC表中查询是否有成绩大于90分的学生，有则输出有学生的成绩高于90分，否则输出没有学生的成绩高于90分。\n```sql\nUSE STUDENTS\nGO\nDECLARE @message VARCHAR(20)\nIF EXISTS(SELECT * FROM SC WHERE GRADE>90)\n    PRINT '有学生的成绩高于90分'\nELSE  \nBEGIN\n    SET @message='抱歉，没有学生的成绩高于90分'               PRINT @message\nEND\n```\n（2）使用`BEGIN...END` 语句\n在控制流程中需要执行两条或两条以上的语句，应该将这些语句定义为一个语句块（称为复合语句）。BEGIN和END必须成对实现。\n语法格式：\n```sql\nBEGIN\n <SQL语句>|<语句块>\n END\n ```\n（3）使用CASE语句\nCASE结构提供比`IF……ELSE`结构更多的选择和判断的机会。使用CASE表达式可以很方便的实现多重选择的情况，从而可以避免编写多重的IF……ELSE嵌套循环。CASE语句按照使用形式不同，可以分为简单CASE语句和搜索CASE语句，它们的语法形式分别为：\n1.\t简单CASE函数：\n```sql\nCASE <表达式>\nWHEN <表达式> THEN <表达式>\n…\nWHEN <表达式> THEN <表达式>\n[ELSE <表达式>]\nEND\n```\n例 从学生表Student中，选取SNO，SSEX，如果SSEX为“男”则输出“M”，如果为“女”输出“F”。\n```sql\nSELECT SNO,SSEX=\nCASE SSEX\n\t\t WHEN '男' THEN 'M'\n\t\t WHEN '女' THEN 'F'\n  END\nFROM Student\n```\n运行结果如图8.10所示。\n2.\tCASE搜索函数：\n```sql\nCASE\n   WHEN <条件表达式> THEN <表达式>\n\t…\nWHEN <条件表达式>                                      \nTHEN <表达式>                                  \n   [ELSE <表达式>]\nEND\n```\n例 从SC表中查询所有同学选课成绩情况，凡成绩为空者输出“未考”、小于60分输出“不及格”、60分至70分输出“及格”、70分至90分输出“良好”、大于或等于90分时输出“优秀”。\n```sql\nSELECT SNO,CNO,GRADE,\nGRADE=CASE  \n  WHEN GRADE IS NULL THEN '未考'\n  WHEN GRADE<60 THEN '不及格'\n  WHEN GRADE>=60 AND GRADE<70 THEN '及格'\n WHEN GRADE>=70 AND GRADE<90 THEN '良好'\n  WHEN GRADE>=90 THEN '优秀'\n      END\nFROM SC\n```\n（4）使用循环：`WHILE语句`\nWHILE语句用来处理循环。在条件为`TRUE`的时候，重复执行一条或一个包含多条T-SQL语句的语句块，直到条件表达式为FALSE时退出循环体.\n其语法如下：\n```sql\nWHILE <条件表达式>\n\t [BEGIN]\n\t    <程序块>\n\t     [BREAK]\n\t   [CONTINUE]\n\t    [程序块]\n\t [END]\n   ```\n说明：CONTINUE 命令可以让程序跳过CONTINUE 命令之后的语句，回到WHILE 循环的第一行，继续进行下一次循环。BREAK 命令则让程序完全跳出循环，结束WHILE 命令的执行。`WHILE `语句也可以嵌套。\n例 编程求1到100的和。\n```sql\ndeclare @i int\ndeclare @sum int\nset @i=1\nset @sum =0\nwhile @i<=100\nbegin\n    set @sum =@sum+@i\n    set @i=@i+1\nend\nselect @sum as 合计 ,@i as 循环数  \n```\n图9.1运行结果如图9.1所示。\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fq5dx9sxmlj203o01uq2q.jpg)\n\n请读下列程序并回答下列程序的功能。\n```sql\nDECLARE @i INT\nSET @i = 1\nWHILE (@i < 11)    \n  BEGIN                      \n    IF(@i < 5)            \n    BEGIN               \n\t\tSET @i = @i + 1                                 \t\t \nCONTINUE\n    END       \n    PRINT @i\n    SET @i = @i + 1\n  END\n```\n（5）使用GOTO 语句\n`GOTO`：可以将执行流程改变到由标签指定的位置。系统跳过GOTO关键字之后的语句，并在GOTO 语句中指定的标签处继续执行操作。\n语法：\nGOTO  标识符\n求1＋2＋3＋…＋10的总和。\n```sql\nDECLARE @S SMALLINT,@I SMALLINT\nSET @I=1\nSET @S=0\nBEG:\nIF (@I<=10)\n   BEGIN\n       SET @S=@S+@I\n       SET @I=@I+1\n       GOTO BEG\n   END\nPRINT @S\n```\n运行结果如图9.2所示。\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fq5dzhztndj204t01la9t.jpg)\n\n（6）调度执行：WAIT  FOR\n该语句可以指定它以后的语句在某个时间间隔之后执行，或未来的某一时间执行。\n语法如下：\n```sql\nWAIT  FOR{DELAY 'time'|TIME 'time'}\n```\n参数含义：\n`DELAY  'time'`是指定SQL Server 等待的时间间隔，最长可达24小时。\n`TIME  'time'`是指定SQL Server等待到某一时刻。\n例 若变量`“@等待”`的值等于“间隔”，查询Studnet表是在等待2分钟后执行，否则在下午2:10执行。\n```sql\nDECLARE @等待 CHAR(10)\nSET @等待= '间隔'\nIF @等待= '间隔'\n\tBEGIN  \n\t\tWAITFOR DELAY '00:02:00'\n\t\tSELECT * FROM STUDENT\n\tEND\nELSE\n\tBEGIN\n\t\tWAITFOR TIME '14:10:00'\n\t\tSELECT * FROM STUDENT\n\tEND\n```\n\n\n\n# 实验十  SQL SERVER事务设计（选做）\n实验时间：\n## 实验目的：\n- （1）通过实验理解事务的概念、特性，掌握事务的设计思想和事务创建、执行的方法；\n- （2）掌握事务的提交COMMIT；\n- （3）掌握事务的回滚ROLLBACK；\n- （4）了解事务的锁。\n## 实验内容：\n创建一个名为“仓库职工”的数据库，导入以下的四张表到该数据库中，完成以下各题\n仓库表\n\n|仓库号|城市|面积|\n|:---:|:---|:---:|\n|WH1|北京|370|\n|WH2|上海|500|\n|WH3|广州|200|\n|WH4|武汉|400|\n\n职工表\n\n|仓库号|职工号|工资|\n|:---:|:---:|:---:|\n|WH2|E1|1220|\n|WH1|E2|1210|\n|WH2|E3|1250|\n|WH3|E4|1230|\n|WH1|E5|1250|\n|WH3|E6|2000|\n|WH1|E7|2080|\n\n订购表\n\n|职工号|供应商号|订购单号|订购日期|\n|:---:|:---:|:---:|:---:|\n|E3|S7|OR67|2009-12-4|\n|E1|S4|OR73|2009-4-1|\n|E7|S4|OR76|2009-4-2|\n|E6|S6|OR77|2009-1-21|\n|E3|S4|OR79|2009-11-15|\n|E1|S6|OR80|2009-2-1|\n|E3|S6|OR90|2009-3-12|\n|E3|S3|OR91|2009-3-2|\n\n供应商表\n\n|供应商号|供应商名|地址|\n|:---:|:---:|:---:|\n|S3|振华电子厂|西安|\n|S4|华通电子公司|北京|\n|S6|607厂|郑州|\n|S7|爱华电子厂|北京|\n|S8|胖熊公司|广州|\n|S9|巧姑娘日化|北京|\n\n1.\t创建事务,并执行。功能为实现广州的职工加10%的工资.\n```sql\nBegin transaction\nUse cangku\nGo\nUpdate 职工    set 工资=工资*1.1\nFrom 职工,仓库       \nWhere 职工.仓库号=仓库.仓库号   and  城市=’广州’\nGo\nCommit\nGo\n```\n（2）在select 语句中加锁，悲观锁定职工表。\n```sql\nBegin transaction\nSelect  * From职工表with(xlock)\nInsert into 职工表(仓库号,职工号)  values(‘WH2’,’E10’)\nUpdate  职工表  set 工资=2980\nWhere 仓库号=‘WH2’ and 职工号=‘E10’\nCommit transaction\n```\n（3）使用HOLDLOCK对供应商表加共享锁。\n```sql\nBegin transaction t2\nSelect  供应商号  From  供应商表with(holdlock)\nSelect  count(供应商号)  From  供应商表\nCommit\n```\n## 思考题：\n1. 什么是事务？事务和程序是一个概念吗？\n\n事务是由一系列访问和更新操作组成的程序执行单元\n\n事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\n\n不是同一概念\n \n2. 解释语句rollback和commit的作用。\n\nCommit是提交事务，即提交某个事务的所有的操作；具体地说，就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。\n\nRollback表示回滚，即将事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始的状态。\n3. 为何使用事务？\n\n答：通过事务，SQL Server能将逻辑相关的一组操作绑定在一起，以便服务器保持数据的完整性。主要用于一些对操作过程的完整性比较高的程序。比如银行系统，用户在转账的过程中程序出现错误，但是这个转账操作没有完成。那么这个操作就被退回。\n\n4. 乐观锁和悲观锁的优缺点各是什么？\n\n答：\n乐观锁: \n优势是:乐观锁机制避免了长事务中的数据库加锁解锁开销，大大提升了大并发量下的系统整体性能表现； \n\n劣势是，只能在提交数据时才发现业务事务将要失败，如果系统的冲突非常的多，而且一旦冲突就要因为重新计算提交而造成较大的代价的话，乐观锁也会带来很大的问题，在某些情况下，发现失败太迟的代价会非常的大。而且乐观锁也无法解决读”脏”数据的问题。\n\n悲观锁: \n\n优势是，能避免冲突的发生；\n\n劣势是，开销较大，而且加锁时间较长，对于并发的访问性支持不好。 \n\n\n# 实验十一  SQL SERVER的存储过程（选做）\n实验时间：\n## 实验目的：\n（1）掌握存储过程的定义；\n（2）掌握存储过程的有点；\n（3）掌握定义带输入与输出参数的存储过程；\n（4）调用存储过程。\n（5）删除存储过程\n## 实验内容：\n注意：这次实验的示例数据库为学生选课数据库，请运行例题中的代码。\n\n存储过程（procedure）类似于C语言中的函数，JAVA的方法。它可以重复调用。当存储过程执行一次后，可以将语句缓存中，这样下次执行的时候直接使用缓存中的语句。这样就可以提高存储过程的性能。\n存储过程是一组编译在单个执行计划中的Transact-SQL语句，将一些固定的操作集中起来交给SQL Server数据库服务器完成，以实现某个任务。\n### 存储过程的优点：\n（1）与其他应用程序共享应用程序逻辑，因而确保了数据访问和修改的一致性。\n\n（2）防止数据库中表的细节暴露给用户。\n\n（3）提供安全机制。\n\n（4）改进性能。\n\n（5）减少网络流量。\n\n#### 1．存储过程的分类\n（1) 用户定义的存储过程\n\n用户定义的`Transact-SQL`存储过程中包含一组`Transact-SQL` 语句集合，可以接受和返回用户提供的参数。\n\n（2）扩展存储过程\n\n扩展存储过程是指` Microsoft SQL Server `的实例可以动态加载和运行的 DLL，是由用户使用编程语言（例如C）创建的自己的外部例程，扩展存储过程一般使用`sp_`或`xp_`前缀。\n\n（3）系统存储过程\n\n由系统提供的存储过程，可以作为命令执行各种操作。系统存储过程定义在系统数据库master中，其前缀是sp_，例如常用的显示系统信息的sp_help存储过程。\n\n#### 2．如何创建存储过程\n创建简单的存储过程的语法:\n```sql\nCREATE  PROC[EDURE]  存储过程名\n[WITH  ENCRYPTION]\n[WITH  RECOMPILE]\nAS\n```\nSQL语句\n说明：`WITH  ENCRYPTION`--对存储过程进行加密，加密的存储过程用sp_helptext查看不到存储过程的原码；`WITH  RECOMPILE`--对存储过程重新编译。\n执行存储过程的语法：\nEXEC 存储过程名\n例 创建一个名为GetInfo存储过程，用于获取所有学生信息。\n```sql\nCREATE PROCEDURE GetInfo\nAS  \nSELECT * FROM Student\n执行存储过程：\nEXEC GetInfo\n```\n接下来学习编写带参数的存储过程。上例中的存储过程可以获取所有学生信息，如果要获取指定学生的信息怎么做？这里就需要创建带参数的存储过程。\n\n存储过程的参数分两种：输入参数和输出参数。输入参数用于向存储过程传入值，类似C语言的按值传递；输出参数用于在调用存储过程后返回结果，类似C语言的按引用传递；\n\n带参数的存储过程的语法：\n```sql\nCREATE  PROC[EDURE]  存储过程名\n@参数1  数据类型 = 默认值[OUTPUT],\n  …,\n@参数n  数据类型 = 默认值 [OUTPUT]\nAS\n```\n SQL语句\n\n例 创建一个带输入参数的存储过程，要求用于获取指定学生的信息。\n```sql\nCREATE PROCEDURE StuInfo\n@name CHAR(10)\nAS\n   SELECT * FROM STUDENT WHERE SNAME=@name\n执行存储过程\nEXEC StuInfo @name='李晨'\n或按位置传递参数值\nEXEC StuInfo '李晨'\n```\n执行完毕的结果如图11.1所示：\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fq5e0nh2yvj20730213yc.jpg)\n\n图11.1执行存储过程结果\n例 创建一个带输入和输出参数的存储过程GetScore，获取指定课程的平均成绩、最高成绩、最低成绩，并返回结果。\n```sql\nCREATE PROCEDURE GetScore\n@kcID CHAR(10),@AVGScore INT OUTPUT,\n@MAXScore INT OUTPUT,@MINScore INT OUTPUT\nAS\nSELECT    @AVGScore=AVG(Grade),@MAXScore=MAX(Grade),@MINScore=MIN(Grade)\n FROM SC\n WHERE Cno=@kcID\n SELECT  @AVGScore as 平均成绩,@MAXScore as 最高成绩,@MINScore as 最低成绩\n执行存储过程\nDECLARE @kcID CHAR(10),@AVGScore INT,@MAXScore INT,@MINScore INT\nSET @kcID='C001'\nEXEC GetScore @kcID,@AVGScore,@MAXScore,@MINScore\n```\n执行完毕的结果如图8.20所示：\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fq5e29ufetj206u023mwz.jpg)\n\n图11.2 执行存储过程结果\n3．查看存储过程\n在SQL Server中，根据不同需要，可以使用`sp_helptext、sp_help`、`sp_depends`系统存储过程来查看用户自定义函数的不同信息。\n例29. 查看Students数据库中存储过程GetInfo信息。\n代码如下：\n```sql\nEXEC sp_helptext GetInfo\nEXEC sp_help GetInfo\nEXEC sp_depends GetInfo\n```\n运行后得到存储过程的定义、参数和依赖信息。\n4．存储过程的修改\n修改存储过程是由ALTER语句来完成的，其语法如下：\n```sql\nALTER PROCEDURE procedure_name\n[WITH ENCRYPTION]\n[WITH RECOMPILE]\nAS\nSql_statement\n```\n例 修改存储过程StuInfo，根据用户提供的系名进行统计这个系的人数，并要求加密。\n```sql\nALTER PROCEDURE StuInfo\n@dept CHAR(10),\n@num INT OUTPUT\nWITH ENCRYPTION\nAS\nSELECT @num=COUNT(*) FROM Student WHERE SDEPT=@dept\nPRINT @num\n```\n执行存储过程\n```sql\nDECLARE @dept CHAR(10),@num INT\nSET @dept='CS'\nEXEC StuInfo @dept,@num\n```\n5．存储过程的删除\n\n存储过程的删除是通过DROP语句来实现的。\n\n例31. 使用Transact-SQL语句来删除存储过程StuInfo。\n```sql\nDROP PROCEDURE StuInfo\n```","tags":["SQL"],"categories":["Database"]},{"title":"Ubuntu 美化","path":"/posts/Ubuntu-Theme.html","content":"Ubuntu美化\n<!--more-->\n# 主题\nunity-tweak-tool\n```sh\nsudo apt-get install unity-tweak-tool\n```\n\nFlatabulous 主题\n```sh\nsudo add-apt-repository ppa:noobslab/themes\nsudo apt-get update\nsudo apt-get install flatabulous-theme\n```\n配套的图标\n```sh\nsudo add-apt-repository ppa:noobslab/icons\nsudo apt-get update\nsudo apt-get install ultra-flat-icons\n```\n# oh-my-zsh\n```sh\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\nchsh -s zsh\n```\n## 问题错误\nagnoster 主题不正常\n- 修改字体即可\n\n- 错误提示\n\n```sh\nzsh compinit: insecure directories, run compaudit for list.\nIgnore insecure directories and continue [y] or abort compinit [n]?\n```\n\n- 解决方法\n\n```\ncompaudit\n//会显示如下内容\nThere are insecure directories:\n  usr/local/share/zsh/site-functions\n//\ncd cd /usr/local/share/zsh\nsudo chown -R root:root ./site-functions\ncd /usr/local/share/\nsudo chmod -R 755 zsh\nsudo chown -R root:staff zsh\n```\n---\n**参考**\n- [zsh compinit: insecure directories](https://stackoverflow.com/questions/13762280/zsh-compinit-insecure-directories)","tags":["Linux"],"categories":["Linux"]},{"title":"Ubuntu 下 Node.Js 安装与版本升级","path":"/posts/Ubuntu-Nodejs.html","content":"Ubuntu 下 nodejs 安装与版本升级\n<!--more-->\n## 在Github上获取 Node.Js 源码\n```sh\nsudo git clone https://github.com/nodejs/node.git　nodejs\n```\n## 安装\n```\nsudo chmod -R 755 node\n//修改目录权限\ncd node\n//进入node目录\nsudo ./configure\n使用 ./configure 创建编译文件\nsudo make\n//下一步，可能时间有点长，耐心等待\nsudo make install\n$ node -v\n```\n\n- 如果 Node 不是最新的，Node 有一个模块叫 Npm，是专门用来管理 Node.Js的版本的。使用 npm安装 Npm 模块\n\n```sh\nsudo npm install -g n\n```\n\n- 然后，升级node.js到最新稳定版\n\n```sh\nsudo n stable\n```\n\n- 旧版本的 npm，也可以很容易地通过 npm 命令来升级，命令如下：\n\n```sh\nsudo npm install npm -g\n```\n\n## 将 Node 和 Npm 设置为全局\n```sh\nsudo ln /opt/nodejs/bin/node(安装目录) /usr/local/bin/node\nsudo ln /opt/nodejs/bin/npm（安装目录） /usr/local/bin/npm\n```\n\n## 几个 Npm 常用命令\n|命令|解析|\n|:---|:---|\n|npm -v|显示版本，检查npm 是否正确安装|\n|npm install -g express|全局安装express模块|\n|npm list|列出已安装模块|\n|npm show express|显示模块详情|\n|npm update|升级当前目录下的项目的所有模块|\n|npm update express|升级当前目录下的项目的指定模块|\n|npm update -g express|升级全局安装的express模块|\n|npm uninstall express|删除指定的模块|\n\n---\n**参考**\n- [\nubuntu下nodejs安装与版本升级](https://blog.csdn.net/lss_csdn/article/details/52165652)","tags":["Linux","Ubuntu","Node.Js"],"categories":["Linux"]},{"title":"Vim 基础","path":"/posts/Vim.html","content":"Vim 基础\n<!--more-->\n# Vim 基础\n指令图\n![指令图](https://i.loli.net/2018/04/06/5ac73a8e7333f.png)\n\nVim（ViImproved）编辑器是vi的扩展版，比vi功能更加强大，是功能强大的跨平台文本文件编辑工具，可以利用它可以建立、修改文本文件等。Vim有三种操作模式，分别称为 编辑模式、插入模式 和 命令模式，当运行Vim时，首会进入命令模式。\n\n#  命令模式\nVim命令模式下可以进行很多操作，例如光标跳动到指定的单词、行；复制、删除某行甚至很多行以及全文都可以，反正功能真的太强大了，以下就作出详解：\n\n## 小范围\n1. 如果键盘上有上、下、左、右箭头的导航键，就由这些键来完成光标的移动。另外，可以用下面的键完成同样的 按字符移动 功能：\n\n|命令|说明|\n|:---|:---|\n|k|向上移动|\n|j|向下移动|\n|h|向左移动|\n|l|向右移动|\n|30j |向下移动30行|\n|0 |到行首|\n|^ |到行首第一个字符，如果前面有空格的话|\n|$ |到行尾|\n|gg |快速到文件头|\n|G |快速到文件尾|\n|100G | 跳转到第100行|\n\n  ---\n\n## 稍大范围移动光标的命令\n|命令|说明|\n|:---|:---|\n|ctrl+f|向文件尾部翻一屏|\n|ctrl+b|向文件首部翻一屏|\n|ctrl+d|向文件尾部翻半屏|\n|ctrl+u|向文件首部翻半屏|\n\n  ---\n\n## 指定某行大范围移动\n|命令|说明|\n|:---|:---|\n|G|光标跳到文件尾行|\n|gg|光标跳到文件首行|\n|#G|“#”指数字，输入随意一个数字就会调到指定的行数|\n\n  ---\n\n## 跳转字母\n|命令|说明|\n|:---|:---|\n|H|光标跳到当前一页的首行的第一个字母|\n|M|光标跳到当前一页的中间行的第一个字母|\n|L|光标跳到当前一页的尾行的第一个字母|\n\n ---\n\nH M L 命令还可以加数字。如`2H`表示将光标移到屏幕的第2行；3M 表示将光标移动到中间行的上面第三行；3L 表示将光标移到屏幕的倒数第3行。\n\n## 行内移动\n|命令|说明|\n|:---|:---|\n|w|右移光标到下一个字的开头|\n|e|右移光标到一个字的末尾|\n|b|左移光标到前一个字的开头|\n|^|移动光标，到本行的第一个非空字符|\n|$|右移光标，到本行的末尾|\n|0|数字０，左移光标到本行的开始|\n\n  ---\n\n# 搜索匹配\nvim除了在命令模式下进行光标移动外，还提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。\n\n## 搜索方法\n键入字符 `/` 后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入 n 命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符 `?` 取代 `/` ，可以实现反向搜索（朝文件开头方向）例如：\n\n|命令|说明|\n|:---|:---|\n|/root|正向搜索字符串root|\n|n|继续搜索，找出root下次出现在的位置|\n|N|继续搜索，找出root上次出现在的位置|\n|?root|反向搜索字符串root|\n\n---\n\n# 字符编辑、替换\nVim常规的删除命令是d、x(前者删除行后者删除字符),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如：\n\n|命令|说明|\n|:---|:---|\n|x|删除光标处的字符|\n|#x|删除光标处起始的#个字符|\n|xp|交换光标所在处的字符及其后面字符的位置|\n|~|转换大小写|\n|J|删除当前行后的换行符\n|r|替换光标所在处的字符|\n|R|切换成REPLACE模式|\n\n# 复制、粘贴、剪切、删除\n## 黏贴\n从正文中删除的内容（如字符、字或行）并没有真正丢失，而是被剪切并复制到了一个内存缓冲区中。用户可将其粘贴到正文中的指定位置。完成这一操作的命令是：\n\n|命令|说明|\n|:---|:---|\n|p |粘贴复制或剪切的内容|\n|p|小写字母 p，将缓冲区的内容粘贴到光标的后面|\n|P|大写字母 P，将缓冲区的内容粘贴到光标的前面|\n|3p |将复制或剪切的内容粘贴三次|\n\n  ---\n\n## 复制\n有时需要复制一段正文到新位置，同时保留原有位置的内容。这种情况下，首先应当把指定内容复制（而不是剪切）到内存缓冲区。完成这一操作的命令是：\n\n|命令|说明|\n|:---|:---|\n|y|复制整行；同时y后面还可以和w,e,b,$,^,等符号连用，例如：yw表示复制光标所在处的一个单词|\n|10yy |向下复制10行|\n|yw |复制光标开始的一个单词|\n|y$ |复制光标到行尾|\n|yfB |复制光标到第一个大写B中间的内容|\n|y2fB |复制光标到第二个大写B中间的内容|\n|yy|复制行|\n|#yy|\"#\"表示数字也就是复制几行\n|#\"tyy|“#”表示任何数，“t“表示T这个寄容器，linux中有36个剪寄容器，即a-z，0-9；复制行数可以选择放到任何这36个寄容器上；粘贴的话\"tp表示将t寄存器内容粘贴到文件中。|\n\n\n## 剪切\n|命令|说明|\n|:---|:---|\n|x |向剪切一个一个字符，如果是在行尾，则为向前剪切|\n|3x |剪切三个|\n|xp |非行尾交换两个字符，如从bs变成sb|\n\n## 删除\n删除的内容会放到剪贴板，按 p 即可粘贴到其他地方\n\n|命令|说明|\n|:---|:---|\n|dd |删除一行|\n|%d|删除全文|\n|200dd| 删除200行|\n|dw |删除一个单词 （最喜欢啦）|\n|df” |删除到出现的第一个双引|\n\n## 撤销和重复\n在编辑文档的过程中，为消除某个错误的编辑命令造成的后果，可以用撤消命令。另外，如果用户希望在新的光标位置重复前面执行过的编辑命令，可用重复命令。\n\n|命令|说明|\n|:---|:---|\n|u|撤消前一条命令的结果，可以和数字连用|\n|.|重复最后一条修改正文的命令|\n\n  ---\n\n# 插入模式(Insert)（编辑模式）\n- 进入插入模式\n在编辑模式下正确定位光标之后，可用以下命令切换到插入模式：\n\n|命令|说明|\n|:---|:---|\n|i|在光标左侧插入正文|\n|a|在光标右侧插入正文|\n|o|在光标所在行的下一行增添新行|\n|I|在光标所在行的末尾插入|\n|A|在光标所在行的末尾插入|\n|O|在光标所在行的上一行增添新行|\n\n- 退出插入模式\n退出插入模式的方法是，按 `ESC` 退出插入模式之后，将会进入编辑模式 。\n\n# 扩展命令模式(extended command )\n在 Vim 的命令模式下，可以使用复杂的命令。在命令模式下按 `shift+ ：`并显示冒号，此时已进入命令模式。命令模式又称末行模式，用户输入的内容均显示在屏幕的最后一行，按回车键，Vim 执行命令。\n\n## 打开、保存、退出\n|命令|说明|\n|:---|:---|\n|：！file|在打开的vim中，如果想看一个文件可以：！后面跟文件|\n|：r！file|将打开的文件读入到vim中|\n|：w|file将当前文件另存为|\n\n  ---\n\n## 字符串搜索\n如果希望进行正向搜索，将待搜索的字符串置于两个 / 之间；如果希望反向搜索，则将字符串放在两个 ? 之间。\n\n|命令|说明|\n|:---|:---|\n|n|查找下一个匹配|\n|N |查找上一个匹配|\n|2n |查找下面第二个匹配|\n|:/root/|正向搜索，将光标移到下一个包含字符串 root 的行|\n|:?root?|反向搜索，将光标移到上一个包含字符串 root 的行|\n|:/root/w file|正向搜索，并将第一个包含字符串 root的行写入 file 文件|\n|/str1/,str2/w file|正向搜索，并将包含字符串 str1 的行至包含字符串 str2 的行写|\n\n  ---\n\n## 正文替换\n利用 `：s` 命令可以实现字符串的替换。具体的用法包括：\n\n|命令|说明|\n|:---|:---|\n|:%s/str1/str2/|用字符串 str2 替换行中首次出现的字符串 str1|\n|:s/str1/str2/|用字符串 str2 替换行中所有出现的字符串 str1|\n|`:.,$ s/str1/str2/g`|用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1|\n|:1,$ s/str1/str2/g|用字符串 str2 替换正文中所有出现的字符串 str1|\n|:g/str1/s//str2/g|功能同上|\n|:m,ns/str1/str2/g|将从m行到n行的str1替换成str2|\n\n---\n- 从上述例子中可以总结这些：\n- `g` 放在命令末尾，表示对搜索字符串的每次出现进行替换,不止匹配每行中的第一次出现；不加 `g`，表示只对搜索字符串的首次出现进行替换；`g` 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作\n- 表示后面跟着一串替换的命令\n- 表示替换范围是所有行，即全文\n\n# 分屏管理\n普通的Vim模式，打开一个Vim程序只能查看一个文件，如果想同时查看多个文件，就需要用到Vim分屏与标签页功能。\n\n## 多文件分割\n- vim -o|-O FILE1 FILE2 ...\n    - -o：水平分割\n    - -O：垂直分割\n\n## 单文件窗口分割：\n|命令|说明|\n|:---|:---|\n|Ctrl+w,s|水平分割|\n|Ctrl+w,v|垂直分割|\n|Ctrl+w,q|取消相邻窗口|\n|Ctrl+w,o|取消全部相邻窗口|\n|wqall|退出|\n\n---\n**Via**\n- [Vimi基础](http://blog.51cto.com/19940919/1953791)","tags":["Linux","Windows","ArchLinux","Ubuntu","Vim"],"categories":["Coding"]},{"title":"Termux 安装 Openjdk","path":"/posts/Termux-Openjdk.html","content":"Termux 安装 Openjdk\n<!--more-->\n# 下载 Openjdk\nJDK1.8\n- [aarch64谷歌云盘](https://drive.google.com/file/d/1PdNqmLrhFlBoRlpCW-mC6CHbVS_Lva9D/view?usp=drivesdk)\n- [aarch64百度云盘密码:ryea](https://pan.baidu.com/s/14T-2L2j3gZaxfbwkZxJxqg)\n\nJDK1.9\n- ~~[aarch64下载](https://mega.nz/#!aZgwVQpD!o8qNcQmObEEKn7qb5MZaDKbT3PUCAoCLwbHtAjDIKho)~~\n\n# 安装 Openjdk\n```sh\ncd storage/downloads\ndpkg -i openjdk9_9.2017.8.20_aarch64.deb\n```\n![](https://s1.ax1x.com/2018/04/01/9zmkW9.png)","tags":["Linux","Termux","Java"],"categories":["Diary"]},{"title":"Linux 中 .deb 相关","path":"/posts/Linux-Deb.html","content":"Lineu中 `.deb` 包的使用，修改。\n<!--more-->\n# 为何物\n.deb 是 Unix系统(其实主要是Linux)下的安装包，基于 `tar` 包，因此本身会记录文件的权限(读/写/可执行)以及所有者/用户组。\n\n# 怎么用\n## 制作.deb包\n- 原理\n1) deb包通常包含两部分：控制信息(DEBIAN目录)、安装内容(模拟\"/\"目录)\n2) 通过解开已有的 deb 包看其中内容\n    - 释放安装内容到dirname目录中\n    ```sh\n    dpkg -X xxx.deb dirname\n    ```\n    - 释放控制信息到当前目录下的DEBIAN子目录中\n    ```sh\n    dpkg -e xxx.deb\n    ```\n## 准备\n```sh\nsudo apt-get install dh-make checkinstall\n```\n\n## 下载软件源码包\n- 使用checkinstall方法创建deb包\n    - checkinstall 不仅可以生成 deb 包，还可以生成 rpm 包，使用简单。\n```sh\ntar xvjf fceu-0.98.12.src.tar.bz2 # 解包\ncd fceu;./configure;make # 编译\ncheckinstall -D -install=no --pkgversion=0.98 --pkgname=fceuxy make install\n# 制作deb包 此时当前目录下生成了deb包。\n```\n- 使用dpkg方法创建deb包\n  - dpkg是最基本的制作deb包的方法，推荐使用\n  ```sh\n  tar xvjf fceu-0.98.12.src.tar.bz2 # 解包\n  mv fceu fceu-0.98 # 改目录名为 包名-版本号\n  cd fceu-0.98\n  dh_make -f ../fceu-0.98.12.src.tar.bz2\n  # 生成制作deb包所需的默认信息\n  ```\n  此时当前目录下生成了debian目录，此时通常修改两个文件： 1. 修改debian/control文件，配置你的信息，具体字段见参考资料部分 2. 修改debian/rules脚本，它决定编译参数(也可以不改)\n  ```sh\n  :::bash\n  dpkg-buildpackage -rfakeroot\n  ```\n  此时可以看到，上层目录中已建立了deb包。\n\n\n\n## 修改已有deb包\n- 自己创建deb所需目录结构(控制信息和安装内容)，然后打包，一般使用这种方法来修改已有的deb包，而不是新建deb包，命令如下：\n```sh\nmkdir -p test\ndpkg -X xxx.deb test # 解包安装内容\ncd test\ndpkg -e ../xxx.deb # 解包控制信息\n```\n- 修改DEBIAN目录下的内容，然后重新打包：\n```sh\ncd ../\ndpkg -b test xxx_new.deb # 重新打包\n```\n- 修改DEBIAN目录下的内容，然后重新打包：\n```linux\ncd ../\ndpkg -b test xxx_new.deb # 重新打包\n```\n# deb包常用命令\n- 查看deb包含有哪些文件\n```sh\ndpkg -c xxx.deb # 安装前根据deb文件查看\ndpkg -L debname # 安装后根据包名查看\n```\n\n- 查看某个文件属于哪个deb包\n```sh\ndpkg -S filefullpath\n```\n- 根据软件包名模糊检索\n```sh\ndpkg -l|grep xxx\n# 在已安装的软件包列表中搜索\napt-cache search xxx\n# 在源中的所有软件包列表中搜索\n```\n\n- 下载源码包\n```sh\napt-get source packagename\n```\n\n# 安装\n- 安装deb包\n```sh\ndpkg -i xxx.deb\n```\n## 卸载\n- 卸载deb包\n```sh\ndpkg -r debname\n```\n\n- 完全卸载deb包（包含配置文件)\n```sh\ndpkg -P debname\n```\n\n---\n**Via**\n- [从源代码制作deb包的两种方法以及修改已有deb包](http://yysfire.github.io/linux/building-deb-package-from-source-and-modify-deb-package.html)","tags":["Linux","Ubuntu","Termux"],"categories":["Linux"]},{"title":"Oh-My-zsh 主题","path":"/posts/Oh-My-ZSH-Theme.html","content":"自定义主题shell提示符.\n<!--more-->\n# 修改oh-my-zsh主题\n## 主题目录\n```bash\ncd ~/.oh-my-zsh/themes\nvim theme-name\n```\n\n## 主题提示符\n|代码|解释|\n|:---:|:---:|\n|%T|系统时间(时：分)|\n|%*|系统时间(时：分：秒)|\n|%D|系统日期(年-月-日)|\n|%n|你的用户名|\n|%B - %b|开始到结束使用粗体打印|\n|%U - %u|开始到结束使用下划线打印|\n|%d|你目前的工作目录|\n|%~|你目前的工作目录相对于～的相对路径|\n|%M|计算机的主机名|\n|%m|计算机的主机名(在第一个句号之前截断)|\n|%l|你当前的tty|\n|%n|登录名|\n\n\n## 顏色語法\n1. \"%{$fg[cyan]%}XXX\"\n2. \"%{$fg[yellow]%}和%{$reset_color%}\"\n3. 上面是一对的中间夹的文字会用 yellow 颜色显示，颜色要用小写。\n\n# 事例\n- Before\n```\nPROMPT=\"\n%{$terminfo[bold]$fg[blue]%}#%{$reset_color%} \\\n%(#,%{$bg[yellow]%}%{$fg[black]%}%n%{$reset_color%},%{$fg[cyan]%}%n) \\\n%{$fg[white]%}@ \\\n%{$fg[green]%}%m \\\n%{$fg[white]%}in \\\n%{$terminfo[bold]$fg[yellow]%}%~%{$reset_color%}\\\n${hg_info}\\\n${git_info}\\\n \\\n%{$fg[white]%}[%*] $exit_code\n%{$terminfo[bold]$fg[red]%}$ %{$reset_color%}\"\n```\n- Affter\n```\nPROMPT=\"%{$terminfo[bold]$fg[blue]%}#%{$reset_color%} \\\n%(#,%{$bg[yellow]%}%{$fg[black]%}%n%{$reset_color%},%{$fg[cyan]%}% Vitan) \\\n%{$fg[white]%}@ \\\n%{$fg[green]%}% OnePlus \\\n%{$fg[white]%}in \\\n%{$terminfo[bold]$fg[yellow]%}%~%{$reset_color%}\\\n${hg_info}\\\n${git_info}\\\n\\\n%{$fg[white]%} [%*] $exit_code\n%{$terminfo[bold]$fg[red]%}➜ %{$reset_color%}\"\n```","tags":["Linux","Ubuntu","Termux"],"categories":["Linux"]},{"title":"分屏&游戏","path":"/posts/Termux-game-tools.html","content":"分屏与游戏。\n<!--more-->\n# 游戏\n月球车\n```bash\npkg install moon-buggy\n```\n- Start:`moon-buggy`\n\nfortz\n```bash\npkg install fortz\n```\n- start: `zgames`\n\n# tmux 分屏\n- 在ubuntu系统中使用 `sudo apt-get install tmux` \n- ArchLinux `yacman -S tmux`\n- Termux安装：\n```bash\npkg install tumx\n```\n  \ntmux主要包括以下几个模块\n\n|名词|含义|解析|\n|:----:|:----:|:----|\n|session|会话|一个服务器可以包含多个会话|\n|window\t|窗口|一个会话可以包含多个窗口|\n|pane\t|面板|一个窗口可以包含多个面板[强悍的分屏]\n\n\n- 输入命令 tmux 使用工具\n\n|命令|分屏状态|\n|:------|:------|\n|Ctrl+b ? |显示快捷键帮助|\n|Ctrl+b C-o |调换窗口位置，类似与vim 里的C-w|\n|Ctrl+b 空格键 |采用下一个内置布局|\n|Ctrl+b ! |把当前窗口变为新窗口|\n|Ctrl+b “| 横向分隔窗口|\n|Ctrl+b % |纵向分隔窗口|\n|Ctrl+b q| 显示分隔窗口的编号|\n|Ctrl+b o| 跳到下一个分隔窗口|\n|Ctrl+b 上下键 |上一个及下一个分隔窗口|\n|Ctrl+b C-方向键 |调整分隔窗口大小|\n|Ctrl+b c |创建新窗口|\n|Ctrl+b 0~9 |选择几号窗口|\n|Ctrl+b c| 创建新窗口|\n|Ctrl+b n |选择下一个窗口|\n|Ctrl+b l |切换到最后使用的窗口|\n|Ctrl+b p |选择前一个窗口|\n|Ctrl+b w| 以菜单方式显示及选择窗口|\n|Ctrl+b t |显示时钟|\n|Ctrl+b ; |切换到最后一个使用的面板|\n|Ctrl+b x| 关闭面板|\n|Ctrl+b & |关闭窗口|\n|Ctrl+b s |以菜单方式显示和选择会话\n|Ctrl+b d |退出tumx，并保存当前会话，这时，tmux仍在后台运行，可以通过tmux attach进入 到指定的会话|","tags":["Linux","Termux"],"categories":["Diary"]},{"title":"Markdown 表格","path":"/posts/Markdown-table.html","content":"Markdown 建表格。\n<!--more-->\n # 单元格和表头\n## 表头和其他行\n- 使用` | `来分隔不同的单元格，使用 `- `来分隔表头和其他行：\n```\nname| ge\n----|---\nLearnShare|12\nMike|32\n```\nname|age\n----|---\nLearnShare|12\nMike| 32\n\n- 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界：\n```\n|name|age|\n|----------|---|\n|LearnShare|12|\n|Mike|32|\n```\n\n|name|age|\n|----------|---|\n|LearnShare|12|\n|Mike|32|\n\n- 为了使 Markdown 更清晰，`|` 和` - `两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。\n\n## 对齐\n在表头下方的分隔线标记中加入`:`，即可标记下方单元格内容的对齐方式：\n- `:--- `代表左对齐\n- `:--: `代表居中对齐\n- `---: `代表右对齐\n\n```\n| left | center | right |\n| :--- | :----: | ----: |\n| aaaa | bbbbbb | ccccc |\n| a    | b      | c     |\n```\n\n| left | center | right |\n| :--- | :----: | ----: |\n| aaaa | bbbbbb | ccccc |\n| a    | b      | c     |                                      \n\n---\n如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现）。\n\n## 插入其他内容\n表格中可以插入其他 Markdown 中的行内标记：","tags":["Linux","Ubuntu","Termux","Markdown"],"categories":["Diary"]},{"title":"SQL Select 语句","path":"/posts/SQL-Select.html","content":"SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。\n<!--more-->\n# SELECT语法\n```sql\nSELECT column_name,column_name\nFROM table_name;\n```\n```sql\nSELECT * FROM table_name;\n```\nSELECT Column 实例\n下面的 SQL 语句从 \"Websites\" 表中选取 \"name\" 和 \"country\" 列：\n```sql\nSELECT name,country FROM Websites;\n```\n\n# SQL SELECT DISTINCT 语句\n在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。\n\nSELECT DISTINCT 语法\n```sql\nSELECT DISTINCT column_name,column_name\nFROM table_name;\n```\n\nSELECT DISTINCT 实例\n下面的 SQL 语句仅从 \"Websites\" 表的 \"country\" 列中选取唯一不同的值，也就是去掉 \"country\" 列重复值：\n```sql\nSELECT DISTINCT country FROM Websites\n```\n\n# SQL WHERE 子句\nWHERE 子句用于提取那些满足指定标准的记录。\n\nSQL WHERE 语法\n```sql\nSELECT column_name,column_name\nFROM table_name\nWHERE column_name operator value;\n```\n\nWHERE 子句实例\n下面的 SQL 语句从 \"Websites\" 表中选取国家为 \"CN\" 的所有网站：\n```sql\nSELECT * FROM Websites WHERE country='CN';\n```\n\nWHERE 子句中的运算符\n下面的运算符可以在 WHERE 子句中使用：\n\n| 运算符 | 描述 |\n|:----|:---|\n| = | 等于|     \n| <> | 不等于 注释:在SQL的一些版本中该操作符可被写成!=|    \n| > | 大于|      \n| < | 小于|      \n| >= | 大于等于|    \n| <= | 小于等于|     \n| BETWEEN | 在某个范围内|     \n| LIKE | 搜索某种模式|   \n| IN | 指定针对某个列的多个可能值|       \n\n\n# SQL AND & OR 运算符\nAND & OR 运算符用于基于一个以上的条件对记录进行过滤。\nAND & OR 运算符\n1. 如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。\n2. 如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。\n\n从 \"Websites\" 表中选取国家为 \"CN\" 且alexa排名大于 \"50\" 的所有网站：\n```sql\nSELECT * FROM Websites\nWHERE country='CN'\nAND alexa > 50;\n```\n从 \"Websites\" 表中选取国家为 \"USA\" 或者 \"CN\" 的所有客户：\n```sql\nSELECT * FROM Websites\nWHERE country='USA'\nOR country='CN';\n```\n\n# SQL ORDER BY 关键字\nORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。\n\nORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，可以使用 DESC 关键字。\n\nSQL ORDER BY 语法\n```sql\nSELECT column_name,column_name\nFROM table_name\nORDER BY column_name,column_name ASC|DESC;\n```\n\n从 \"Websites\" 表中选取所有网站，并按照 \"alexa\" 列排序：\n```sql\nSELECT * FROM Websites\nORDER BY alexa;\n```\n\nORDER BY DESC 实例\n下面的 SQL 语句从 \"Websites\" 表中选取所有网站，并按照 \"alexa\" 列降序排序：\n```sql\nSELECT * FROM Websites\nORDER BY alexa DESC;\n```\nORDER BY 多列\n下面的 SQL 语句从 \"Websites\" 表中选取所有网站，并按照 \"country\" 和 \"alexa\" 列排序：\n```sql\nSELECT * FROM Websites\nORDER BY country,alexa;\n```\n\n# SQL INSERT INTO 语句\nINSERT INTO 语句用于向表中插入新记录。\n\nSQL INSERT INTO 语法\nINSERT INTO 语句可以有两种编写形式。\n1. 第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：\n```sql\nINSERT INTO table_name\nVALUES (value1,value2,value3,...);\n```\n2. 需要指定列名及被插入的值：\n```sql\nINSERT INTO table_name (column1,column2,column3,...)\nVALUES (value1,value2,value3,...);\n```\n\nINSERT INTO 实例\n假设我们要向 \"Websites\" 表中插入一个新行。\n```sql\nINSERT INTO Websites (name, url, alexa, country)\nVALUES ('百度','https://www.baidu.com/','4','CN');\n```\n\n在指定的列插入数据\n下面的 SQL 语句将插入一个新行，但是只在 \"name\"、\"url\" 和 \"country\" 列插入数据（id 字段会自动更新）：\n```sql\nINSERT INTO Websites (name, url, country)\nVALUES ('stackoverflow', 'http://stackoverflow.com/', 'IND');\n```\n\n# SQL LIKE 操作符\nLIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。\n\nSQL LIKE 语法\n```sql\nSELECT column_name(s)\nFROM table_name\nWHERE column_name LIKE pattern;\n```\n\nSQL LIKE 操作符实例\n下面的 SQL 语句选取 name 以字母 \"G\" 开始的所有客户：\n```sql\nSELECT * FROM Websites\nWHERE name LIKE 'G%';\n```\n提示：\"%\" 符号用于在模式的前后定义通配符（缺省字母）。您将在下一章中学习更多有关通配符的知识。\n\n选取 name 以字母 \"k\" 结尾的所有客户：\n```sql\nSELECT * FROM Websites\nWHERE name LIKE '%k';\n```\n通过使用 NOT 关键字，您可以选取不匹配模式的记录。\n\n下面的 SQL 语句选取 name 不包含模式 \"oo\" 的所有客户\n```sql\nSELECT * FROM Websites\nWHERE name NOT LIKE '%oo%';\n```\n\n# SQL 连接(JOIN)\nSQL join 用于把来自两个或多个表的行结合起来。\nSQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。\n\n最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。\n```sql\nSELECT Websites.id, Websites.name, access_log.count, access_log.date\nFROM Websites\nINNER JOIN access_log\nON Websites.id=access_log.site_id;\n```\n\n## 不同的 SQL JOIN\nJOIN 类型：\n1. INNER JOIN：如果表中有至少一个匹配，则返回行\n2. LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行\n3. RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行\n4. FULL JOIN：只要其中一个表中存在匹配，则返回行\n\nSQL INNER JOIN 语法,INNER JOIN 与 JOIN 是相同的。\n```sql\nSELECT column_name(s)\nFROM table1\nINNER JOIN table2\nON table1.column_name=table2.column_name;\n```\n或：\n```sql\nSELECT column_name(s)\nFROM table1\nJOIN table2\nON table1.column_name=table2.column_name;\n```\n\n##  LEFT JOIN \nLEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。\n\nSQL LEFT JOIN 语法\n```sql\nSELECT column_name(s)\nFROM table1\nLEFT JOIN table2\n\tON table1.column_name=table2.column_name;\n```\n或：\n```sql\nSELECT column_name(s)\nFROM table1\nLEFT OUTER JOIN table2\nON table1.column_name=table2.column_name;\n```\n## SQL RIGHT JOIN \nRIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。\n```sql\nSELECT column_name(s)\nFROM table1\nRIGHT JOIN table2\nON table1.column_name=table2.column_name;\n```\n或：\n```sql\nSELECT column_name(s)\nFROM table1\nRIGHT OUTER JOIN table2\nON table1.column_name=table2.column_name;\n```\n## FULL OUTER JOIN 关键字\nFULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.\nFULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。\n```sql\nSQL FULL OUTER JOIN 语法\nSELECT column_name(s)\nFROM table1\nFULL OUTER JOIN table2\nON table1.column_name=table2.column_name;\n```\n\n# SQL UNION 操作符\nSQL UNION 操作符合并两个或多个 SELECT 语句的结果。\n\nUNION 操作符用于合并两个或多个 SELECT 语句的结果集。\n\t\n请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。\n```sql\nSELECT column_name(s) FROM table1\nUNION\nSELECT column_name(s) FROM table2;\n```\n注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\n\nSQL UNION ALL 语法\n```sql\nSELECT column_name(s) FROM table1\nUNION ALL\nSELECT column_name(s) FROM table2;\n```\n注释：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。\n\n带有 WHERE 的 SQL UNION ALL\n下面的 SQL 语句使用 UNION ALL 从 \"Websites\" 和 \"apps\" 表中选取所有的中国(CN)的数据（也有重复的值）：\n```sql\nSELECT country, name FROM Websites\nWHERE country='CN'\nUNION ALL\nSELECT country, app_name FROM apps\nWHERE country='CN'\nORDER BY country;\n```","tags":["SQL"],"categories":["Database"]},{"title":"SQL 经典语句","path":"/posts/SQL-Command.html","content":"经典SQL语句大全\n<!--more-->\n\n# 基础\n创建数据库\n```sql\nCREATE DATABASE database-name\n```\n删除数据库\n```sql\ndrop database dbname\n```\n## 备份sql server\n创建备份数据的 device\n```sql\nUSE master\nEXEC sp_addumpdevice 'disk', 'testBack', 'c:\\mssql7backup\\MyNwind_1.dat'\n```\n开始备份\n ```sql\nBACKUP DATABASE pubs TO testBack\n创建新表\ncreate table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)\n```\n## 根据已有的表创建新表：\n\n>A：create table tab_new like tab_old (使用旧表创建新表)\nB：create table tab_new as select col1,col2… from tab_old definition only\n\n删除新表\n```sql\ndrop table tabname\n    ```\n增加一个列\n```sql\nAlter table tabname add column col type\n```\n注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。\n\n添加主键\n```sql\nAlter table tabname add primary key(col)\n```\n说明：删除主键： Alter table tabname drop primary key(col)\n\n创建索引\n```sql\ncreate [unique] index idxname on tabname(col….)\n```\n\n删除索引：\n```sql\ndrop index idxname\n```\n注：索引是不可更改的，想更改必须删除重新建。\n\n创建视图\n```sql\ncreate view viewname as select statement\n```\n\n删除视图\n```sql\ndrop view viewname\n```\n## 几个简单的基本的 SQL 语句\n语句\n```sql\n  选择：select * from table1 where 范围\n  插入：insert into table1(field1,field2) values(value1,value2)\n  删除：delete from table1 where 范围\n  更新：update table1 set field1=value1 where 范围\n  查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!\n  排序：select * from table1 order by field1,field2 [desc]\n  总数：select count as totalcount from table1\n  求和：select sum(field1) as sumvalue from table1\n  平均：select avg(field1) as avgvalue from table1\n  最大：select max(field1) as maxvalue from table1\n  最小：select min(field1) as minvalue from table1\n```\n## 几个高级查询运算词\nUNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。\n\n\nEXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。\n\n\n`INTERSECT ` 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。\n\n注：使用运算词的几个查询结果行必须是一致的。\n\n## 使用外连接\nleft （outer） join\n- 左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。\n- SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c\n\nright （outer） join\n右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。\n\nfull/cross （outer） join\n全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。\n\n## 分组:Group by\n一张表，一旦分组完成后，查询后只能得到组相关的信息。\n\n组相关的信息\n统计信息） count,sum,max,min,avg  分组的标准)SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据,在selecte统计函数中的字段，不能和普通的字段放在一起对数据库进行操作\n\n分离数据库\nsp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名\n\n如何修改数据: 库的名称\n```sql\nsp_renamedb 'old_name', 'new_name'\n```\n\n# 提升\n复制表(只复制结构,源表名：a 新表名：b)\n- 法一：`select * into b from a where 1<>1`（仅用于SQlServer）\n- 法二：`select top 0 * into b from a`\n\n拷贝表(拷贝数据,源表名：a 目标表名：b)\n```sql\ninsert into b(a, b, c) select d,e,f from b\n```\n\n跨数据库之间表的拷贝(具体数据使用绝对路径)\n```sql\ninsert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件\n```\n- 例子：..from b in '\"&Server.MapPath(\".\")&\"\\data.mdb\" &\"' where..\n\n子查询(表名1：a 表名2：b)\n```sql\nselect a,b,c from a where a IN (select d from b )\n```\n- 或者\n```sql\n  select a,b,c from a where a IN (1,2,3)\n```\n\n显示文章、提交人和最后回复时间\n```sql\nselect a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b\n```\n\n外连接查询(表名1：a 表名2：b)\n```sql\nselect a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c\n```\n## 第二部分\n在线视图查询(表名1：a )\n```sql\n`select * from (SELECT a,b,c FROM a) T where t.a > 1\n```\n\nbetween的用法,between限制查询数据范围时包括了边界值,not between不包括\n```sql\nselect * from table1 where time between time1 and time2\nselect a,b,c, from table1 where a not between 数值1 and 数值2\n```\n\nin 的使用方法\n```sql\nselect * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)\n```\n\n两张关联表，删除主表中已经在副表中没有的信息\n```sql\ndelete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )\n```\n\n四表联查问题\n```sql\nselect * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where .....\n```\n\n日程安排提前五分钟提醒\n```sql\nSQL: select * from 日程安排 where datediff('minute',f开始时间,getdate())>5\n```\n\n一条sql 语句搞定数据库分页\n```sql\nselect top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段\n```\n- 具体实现：\n- 关于数据库分页\n\n```sql\n    declare @start int,@end int\n    @sql  nvarchar(600)\n    set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid>-1)’\n    exec sp_executesql @sql\n```\n  - 注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）\n\n## 第三部分\n前10条记录\n```sql\nselect top 10 * form table1 where 范围\n```\n\n选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)\n```sql\nselect a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)\n```\n包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表\n```sql\n(select a from tableA ) except (select a from tableB) except (select a from tableC)\n```\n\n随机取出10条数据\n```sql\nselect top 10 * from tablename order by newid()\n```\n\n随机选择记录\n```sql\nselect newid()\n```\n\n删除重复记录\n```sql\ndelete from tablename where id not in (select max(id) from tablename group by col1,col2,...)\nselect distinct * into temp from tablename\ndelete from tablename\ninsert into tablename select * from temp\n```\n- 评价：这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作\n- 例如:在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段\n\n```\nalter table tablename\n```\n\n- 加一个自增列\n\n```sql\n  add  column_b int identity(1,1)\n   delete from tablename where column_b not in(\n  select max(column_b)  from tablename group by column1,column2,...)\n  alter table tablename drop column column_b\n```\n## 第四部分\n列出数据库里所有的表名\n```sql\nselect name from sysobjects where type='U' // U代表用户\n```\n\n列出表里的所有的列名\n```sql\nselect name from syscolumns where id=object_id('TableName')\n```\n列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case\n```sql\nselect type,sum(case vender when 'A' then pcs else 0 end),sum(case vender when 'C' then pcs else 0 end),sum(case vender when 'B' then pcs else 0 end) FROM tablename group by type\n```\n- 显示结果：\n>type vender pcs\n  电脑 A 1\n  电脑 A 1\n  光盘 B 2\n  光盘 A 2\n  手机 B 3\n  手机 C 3\n\n初始化表table1\n```sql\nTRUNCATE TABLE table1\n```\n选择从10到15的记录\n```sql\nselect top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc\n```\n- 技巧\n- 1=1，1=2的使用，在SQL语句组合时用的较多\n- “where 1=1” 是表示选择全部    “where 1=2”全部不选，如：\n\n```sql\n    if @strWhere !=''\n    begin\n    set @strSQL = 'select count(*) as Total from [' + @tblName + '] where ' + @strWhere\n    end\n    else\n    begin\n    set @strSQL = 'select count(*) as Total from [' + @tblName + ']'\n    end\n  ```\n  我们可以直接写成\n\n  错误！未找到目录项。\n```sql\nset @strSQL = 'select count(*) as Total from [' + @tblName + '] where 1=1 安定 '+ @strWhere 2、收缩数据库\n```\n## 第五部分\n1. 重建索引\n```sql\nDBCC REINDEX\nDBCC INDEXDEFRAG\n```\n2.  收缩数据和日志\n```sql\nDBCC SHRINKDB\nDBCC SHRINKFILE\n```\n3. 压缩数据库\n```sql\ndbcc shrinkdatabase(dbname)\n```\n4. 转移数据库  给新用户以已存在用户权限\n```sql\nexec sp_change_users_login 'update_one','newname','oldname'\ngo\n```\n5. 检查备份集\n```sql\nRESTORE VERIFYONLY from disk='E:\\dvbbs.bak'\n```\n6. 修复数据库\n```sql\n  ALTER DATABASE [dvbbs] SET SINGLE_USER\n  GO\n  DBCC CHECKDB('dvbbs',repair_allow_data_loss) WITH TABLOCK\n  GO\n  ALTER DATABASE [dvbbs] SET MULTI_USER\n  GO\n```\n7. 日志清除\n```sql\n  SET NOCOUNT ON\n  DECLARE @LogicalFileName sysname,\n   @MaxMinutes INT,\n   @NewSize INT\n\n  USE tablename -- 要操作的数据库名\n  SELECT  @LogicalFileName = 'tablename_log', -- 日志文件名\n  @MaxMinutes = 10, -- Limit on time allowed to wrap log.\n   @NewSize = 1  -- 你想设定的日志文件的大小(M)\n  Setup / initialize\n  DECLARE @OriginalSize int\n  SELECT @OriginalSize = size\n   FROM sysfiles\n   WHERE name = @LogicalFileName\n  SELECT 'Original Size of ' + db_name() + ' LOG is ' +\n   CONVERT(VARCHAR(30),@OriginalSize) + ' 8K pages or ' +\n   CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + 'MB'\n   FROM sysfiles\n   WHERE name = @LogicalFileName\n  CREATE TABLE DummyTrans\n   (DummyColumn char (8000) not null)\n\n  DECLARE @Counter    INT,\n   @StartTime DATETIME,\n   @TruncLog   VARCHAR(255)\n  SELECT @StartTime = GETDATE(),\n   @TruncLog = 'BACKUP LOG ' + db_name() + ' WITH TRUNCATE_ONLY'\n  DBCC SHRINKFILE (@LogicalFileName, @NewSize)\n  EXEC (@TruncLog)\n  -- Wrap the log if necessary.\n  WHILE @MaxMinutes > DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired\n   AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName)\n   AND (@OriginalSize * 8 /1024) > @NewSize\n   BEGIN -- Outer loop.\n  SELECT @Counter = 0\n   WHILE   ((@Counter < @OriginalSize / 16) AND (@Counter < 50000))\n   BEGIN -- update\n   INSERT DummyTrans VALUES ('Fill Log') DELETE DummyTrans\n   SELECT @Counter = @Counter + 1\n   END\n   EXEC (@TruncLog)\n   END\n  SELECT 'Final Size of ' + db_name() + ' LOG is ' +\n   CONVERT(VARCHAR(30),size) + ' 8K pages or ' +\n   CONVERT(VARCHAR(30),(size*8/1024)) + 'MB'\n   FROM sysfiles\n   WHERE name = @LogicalFileName\n  DROP TABLE DummyTrans\n  SET NOCOUNT OFF\n```\n8. 说明：更改某个表\n```sql\nexec sp_changeobjectowner 'tablename','dbo'\n```\n9. 存储更改全部表\n```sql\n  CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch\n  @OldOwner as NVARCHAR(128),\n  @NewOwner as NVARCHAR(128)\n  AS\n  DECLARE @Name    as NVARCHAR(128)\n  DECLARE @Owner   as NVARCHAR(128)\n  DECLARE @OwnerName   as NVARCHAR(128)\n  DECLARE curObject CURSOR FOR\n  select 'Name'    = name,\n     'Owner'    = user_name(uid)\n  from sysobjects\n  where user_name(uid)=@OldOwner\n  order by name\n  OPEN   curObject\n  FETCH NEXT FROM curObject INTO @Name, @Owner\n  WHILE(@@FETCH_STATUS=0)\n  BEGIN\n  if @Owner=@OldOwner\n  begin\n     set @OwnerName = @OldOwner + '.' + rtrim(@Name)\n     exec sp_changeobjectowner @OwnerName, @NewOwner\n  end\n  -- select @name,@NewOwner,@OldOwner\n  FETCH NEXT FROM curObject INTO @Name, @Owner\n  END\n  close curObject\n  deallocate curObject\n  GO\n```\n10. SQL SERVER中直接循环写入数据\n```sql\n  declare @i int\n  set @i=1\n  while @i<30\n  begin\n      insert into test (userid) values(@i)\n      set @i=@i+1\n  end\n```\n- 案例：有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:\n\n|Name|score|\n|:---|:---|\n|Zhangshan |80|\n|Lishi  | 59|\n|Wangwu  |  50|\n|Songquan |69|\n\n---\n```sql\n  while((select min(score) from tb_table)<60)\n  begin\n  update tb_table set score =score*1.01\n  where score<60\n  if  (select min(score) from tb_table)>60\n    break\n   else\n      continue\n  end\n```\n\n# 数据开发-经典\n1. 按姓氏笔画排序:\n```sql\n  Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多\n```\n2. 数据库加密:\n```sql\n  select encrypt('原始密码')\n  select pwdencrypt('原始密码')\n  select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同 encrypt('原始密码')\n  select pwdencrypt('原始密码')\n  select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同\n```\n3. 取回表中字段:\n```sql\n  declare @list varchar(1000),\n  @sql nvarchar(1000)\n  select @list=@list+','+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name='表A'\n  set @sql='select '+right(@list,len(@list)-1)+' from 表A'\n  exec (@sql)\n```\n4. 查看硬盘分区:\n```sql\n  EXEC master..xp_fixeddrives\n```\n5. 比较A,B表是否相等:\n```sql\n  if (select checksum_agg(binary_checksum(*)) from A)\n       =\n      (select checksum_agg(binary_checksum(*)) from B)\n  print '相等'\n  else\n  print '不相等'\n```\n6. 杀掉所有的事件探察器进程:\n```sql\n  DECLARE hcforeach CURSOR GLOBAL FOR SELECT 'kill '+RTRIM(spid) FROM master.dbo.sysprocesses\n  WHERE program_name IN('SQL profiler',N'SQL 事件探查器')\n  EXEC sp_msforeach_worker '?'\n```\n7. 记录搜索:\n```\n开头到N条记录\nSelect Top N * From 表\n-------------------------------\nN到M条记录(要有主索引ID)\nSelect Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID   Desc\n----------------------------------\nN到结尾记录\n```\n```sql\nSelect Top N * From 表 Order by ID Desc\n```\n- 案例\n  - 例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段，写一个SQL语句， 找出表的第31到第40个记录。\n\n  ```sql\n  select top 10 recid from A where recid not  in(select top 30 recid from A)\n  ```\n  分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。` select top 10 recid from A where……`是从索引中查找，而后面的`select top 30 recid from A`则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。\n- 解决方案\n  - 用`order by select top 30 recid from A order by ricid `如果该字段不是自增长，就会出现问题\n  - 在那个子查询中也加条件：`select top 30 recid from A where recid>-1`\n- 例2：查询表中的最后以条记录，并不知道这个表共有多少数据,以及表结构。\n\n```sql\nset @s = 'select top 1 * from T   where pid not in (select top ' + str(@count-1) + ' pid  from  T)'\nprint @s      exec  sp_executesql  @s\n```\n9. 获取当前数据库中的所有用户表\n```sql\nselect Name from sysobjects where xtype='u' and status>=0\n```\n10. 获取某一个表的所有字段\n```sql\nselect name from syscolumns where id=object_id('表名')\nselect name from syscolumns where id in (select id from sysobjects where type = 'u' and name = '表名')\n```\n两种方式的效果相同\n\n11. 查看与某一个表相关的视图、存储过程、函数\n```sql\nselect a.* from sysobjects a, syscomments b where a.id = b.id and b.text like '%表名%'\n```\n12. 查看当前数据库中所有存储过程\n```sql\nselect name as 存储过程名称 from sysobjects where xtype='P'\n```\n13. 查询用户创建的所有数据库\n```sqk\nselect * from master..sysdatabases D where sid not in(select sid from master..syslogins where name='sa')\n```\n- 或者\n```sql\nselect dbid, name AS DB_NAME from master..sysdatabases where sid <> 0x01\n```\n14. 查询某一个表的字段和数据类型\n```sql\nselect column_name,data_type from information_schema.columns\nwhere table_name = '表名'\n```\n15. 不同服务器数据库之间的数据操作\n- 创建链接服务器\n```sql\nexec sp_addlinkedserver   'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 '\nexec sp_addlinkedsrvlogin  'ITSV ', 'false ',null, '用户名 ', '密码 '\n```\n  - 查询示例\n\n  ```sql\n  select * from ITSV.数据库名.dbo.表名\n  ```\n\n  - 导入示例\n\n  ```sql\n  select * into 表 from ITSV.数据库名.dbo.表名\n  ```\n  - 以后不再使用时删除链接服务器\n\n  ```sql\n  exec sp_dropserver  'ITSV ', 'droplogins '\n  ```\n\n  - 连接远程/局域网数据(openrowset/openquery/opendatasource)\n\n  --1、openrowset\n\n  - 查询示例\n\n  ```sql\n  select * from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)\n  ```\n\n  - 生成本地表\n\n  ```sql\n  select * into 表 from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)\n  ```\n\n  - 把本地表导入远程表\n\n  ```sql\n  insert openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)\n  select *from 本地表\n  ```\n\n  - 更新本地表\n\n  ```sql\n  update b\n  set b.列A=a.列A\n  from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)as a inner join 本地表 b\n  on a.column1=b.column1\n  ```\n\n  - openquery用法需要创建一个连接\n\n  ```sql\n  --首先创建一个连接创建链接服务器\n  exec sp_addlinkedserver   'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 '\n  ```\n\n  - 查询\n\n  ```sql\n  select *\n  FROM openquery(ITSV,  'SELECT *  FROM 数据库.dbo.表名 ')\n  ```\n\n  --把本地表导入远程表\n\n  ```sql\n  insert openquery(ITSV,  'SELECT *  FROM 数据库.dbo.表名 ')\n  select * from 本地表\n  ```\n\n  - 更新本地表\n\n  ```sqk\n    update b\n    set b.列B=a.列B\n    FROM openquery(ITSV,  'SELECT * FROM 数据库.dbo.表名 ') as a\n    inner join 本地表 b on a.列A=b.列A\n  ```\n  - 3、opendatasource/openrowset\n\n  ```sql\n    SELECT   *\n    FROM   opendatasource( 'SQLOLEDB ',  'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ' ).test.dbo.roy_ta\n  ```\n\n  - 把本地表导入远程表\n  \n  ```sql\n    insert opendatasource( 'SQLOLEDB ',  'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ').数据库.dbo.表名\n    select * from 本地表\n    SQL Server基本函数\n    SQL Server基本函数\n  ```\n\n# 字符串函数 长度与分析用\n例子\n```sql\ndatalength(Char_expr)\n```\n返回字符串包含字符数,但不包含后面的空格\n\n```sql\nsubstring(expression,start,length)\n```\n取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度\n```sql\nright(char_expr,int_expr)\n```\n返回字符串右边第int_expr个字符，还用left于之相反\n```sql\nisnull( check_expression , replacement_value )\n```\n如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类\n```sql\nSp_addtype\n--自定義數據類型\n```\n例如：\n```sql\nEXEC sp_addtype birthday, datetime, 'NULL'\n```\n\n```sql\nset nocount {on|off}\n```\n使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。\n\n- SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。\n- SET NOCOUNT 为 OFF 时，返回计数\n\n# 常识\nSQL中\n1.在SQL查询中：from后最多可以跟多少张表或视图：256\n2. 在SQL语句中出现 Order by,查询时，先排序，后取\n3. 在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。\n\n# SQLServer2000同步复制技术实现步骤\n\n## 预备工作\n创建一个同名的 windows 用户\n1. 发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户\n```\n  --管理工具\n  --计算机管理\n  --用户和组\n  --右键用户\n  --新建用户\n  --建立一个隶属于administrator组的登陆windows的用户（SynUser）\n```\n2. 在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作:\n```\n  我的电脑--D:\\ 新建一个目录,名为: PUB\n  --右键这个新建的目录\n  --属性--共享\n  --选择\"共享该文件夹\"\n  --通过\"权限\"按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser) 具有对该文件夹的所有权限\n  --确定\n```\n3. 设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布/订阅服务器均做此设置)\n```\n  开始--程序--管理工具--服务\n  --右键SQLSERVERAGENT\n  --属性--登陆--选择\"此账户\"\n  --输入或者选择第一步中创建的windows登录用户名（SynUser）\n  --\"密码\"中输入该用户的密码\n```\n4. 设置SQL Server身份验证模式,解决连接时的权限问题(发布/订阅服务器均做此设置)\n```\n  企业管理器\n  --右键SQL实例--属性\n  --安全性--身份验证\n  --选择\"SQL Server 和 Windows\"\n  --确定\n```\n5. 在发布服务器和订阅服务器上互相注册企业管理器\n  ```\n  --右键SQL Server组\n  --新建SQL Server注册...\n  --下一步--可用的服务器中,输入你要注册的远程服务器名 --添加\n  --下一步--连接使用,选择第二个\"SQL Server身份验证\"\n  --下一步--输入用户名和密码（SynUser）\n  --下一步--选择SQL Server组,也可以创建一个新组\n  --下一步--完成\n```\n6. 对于只能用IP,不能用计算机名的,为其注册服务器别名（此步在实施中没用到）(在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP)\n```\n  开始--程序--Microsoft SQL Server--客户端网络实用工具\n  --别名--添加\n  --网络库选择\"tcp/ip\"--服务器别名输入SQL服务器名\n  --连接参数--服务器名称中输入SQL服务器ip地址\n  --如果你修改了SQL的端口,取消选择\"动态决定端口\",并输入对应的端口号\n```\n## 正式配置\n### 配置发布服务器\n打开企业管理器，在发布服务器（B、C、D）上执行以下步骤:\n1.  从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导\n2. [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器（选择自己）\n3. [下一步] 设置快照文件夹 采用默认\\\\servername\\Pub\n4. [下一步] 自定义配置\n\n可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置\n否,使用下列默认设置（推荐）\n\n5. [下一步] 设置分发数据库名称和位置 采用默认值\n6. [下一步] 启用发布服务器 选择作为发布的服务器\n7. [下一步] 选择需要发布的数据库和发布类型\n8. [下一步] 选择注册订阅服务器\n9. [下一步] 完成配置\n\n### 创建出版物\n发布服务器B、C、D上\n1. 从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令\n2. 选择要创建出版物的数据库，然后单击[创建发布]\n3. 在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助)\n4. 单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型,\n\nSQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。\n但是在这里我们选择运行\"SQL SERVER 2000\"的数据库服务器\n\n5. 单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表\n\n注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表\n\n6. 选择发布名称和描述\n7. 自定义发布属性 向导提供的选择:\n  - 是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性\n  - 否 根据指定方式创建发布 （建议采用自定义的方式）\n\n8. [下一步] 选择筛选发布的方式\n9. [下一步] 可以选择是否允许匿名订阅\n\n如果选择署名订阅,则需要在发布服务器上添加订阅服务器\n1. [工具]->[复制]->[配置发布、订阅服务器和分发的属性]->[订阅服务器] 中添加\n- 否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅\n\n如果仍然需要匿名订阅则用以下解决办法\n[企业管理器]->[复制]->[发布内容]->[属性]->[订阅选项] 选择允许匿名请求订阅\n\n如果选择匿名订阅,则配置订阅服务器时不会出现以上提示\n[下一步] 设置快照 代理程序调度\n\n[下一步] 完成配置\n\n当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库\n\n有数据\n```sql\nsrv1.库名..author有字段:id,name,phone,\nsrv2.库名..author有字段:id,name,telphone,adress\n```\n\n要求：\n```\nsrv1.库名..author增加记录则srv1.库名..author记录增加\n\nrv1.库名..author的phone字段更新，则srv1.库名..author对应字段t>elphone更新\n*/\n\n```\n## 大致的处理步\n创建连接服务器\n1. 在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步\n```sql\nexec sp_addlinkedserver 'srv2','','SQLOLEDB','srv2的sql实例名或ip'\nexec sp_addlinkedsrvlogin 'srv2','false',null,'用户名','密码'\ngo\n```\n1. 在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动\n\n我的电脑--控制面板--管理工具--服务--右键 Distributed Transaction Coordinator--属性--启动--并将启动类型设置为自动启动\ngo\n\n- 然后创建一个作业定时调用上面的同步处理存储过程就行了\n\n企业管理器\n```\n  --管理\n  --SQL Server代理\n  --右键作业\n  --新建作业\n  --\"常规\"项中输入作业名称\n  --\"步骤\"项\n  --新建\n  --\"步骤名\"中输入步骤名\n  --\"类型\"中选择\"Transact-SQL 脚本(TSQL)\"\n  --\"数据库\"选择执行命令的数据库\n  --\"命令\"中输入要执行的语句: exec p_process\n  --确定\n  --\"调度\"项\n  --新建调度\n  --\"名称\"中输入调度名称\n  --\"调度类型\"中选择你的作业执行安排\n  --如果选择\"反复出现\"\n  --点\"更改\"来设置你的时间安排\n\n```\n然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行\n\n- 设置方法:\n\n   我的电脑--控制面板--管理工具--服务--右键 SQLSERVERAGENT--属性--启动类型--选择\"自动启动\"--确定.\n\n-3.实现同步处理的方法2,定时同步\n\n- 在srv1中创建如下的同步处理存储过程\n```\ncreate proc p_process\nas\n````\n- 更新修改过的数据\n```sql\nupdate b set name=i.name,telphone=i.telphone\nfrom srv2.库名.dbo.author b,author i\nwhere b.id=i.id and\n(b.name <> i.name or b.telphone <> i.telphone)\n```\n\n- 插入新增的数据\n```sql\n  insert srv2.库名.dbo.author(id,name,telphone)\n  select id,name,telphone from author i\n  where not exists(\n  select * from srv2.库名.dbo.author where id=i.id)\n  ```\n  - 删除已经删除的数据(如果需要的话)\n  ```sql\n  delete b\n  from srv2.库名.dbo.author b\n  where not exists(\n  select * from author where id=b.id)\n  go\n```","tags":["SQL"],"categories":["Database"]},{"title":"Java 变量类型","path":"/posts/Java-variable-types.html","content":"Java 变量类型\n<!--more-->\n# Java变量类型\n\n在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：\n>type identifier [ = value][, identifier [= value] ...] ;\n格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。\n\n以下列出了一些变量的声明实例。注意有些包含了初始化过程。\n```Java\nint a, b, c;         // 声明三个int型整数：a、 b、c\nint d = 3, e = 4, f = 5; // 声明三个整数并赋予初值\nbyte z = 22;         // 声明并初始化 z\nString s = \"runoob\";  // 声明并初始化字符串 s\ndouble pi = 3.14159; // 声明了双精度浮点型变量 pi\nchar x = 'x';        // 声明变量 x 的值是字符 'x'。\n```\n# Java语言支持的变量类型有\n- 类变量：独立于方法之外的变量，用 static 修饰。\n- 实例变量：独立于方法之外的变量，不过没有 static 修饰。\n- 局部变量：类的方法中的变量。\n- 实例\n```Java\npublic class Variable{\n    static int allClicks=0;    // 类变量\n\n    String str=\"hello world\";  // 实例变量\n\n    public void method(){\n\n        int i =0;  // 局部变量\n\n    }\n}\n```\n# Java 局部变量\n- 局部变量声明在方法、构造方法或者语句块中；\n- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；\n- 访问修饰符不能用于局部变量；\n- 局部变量只在声明它的方法、构造方法或者语句块中可见；\n- 局部变量是在栈上分配的。\n- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。\n-\n实例 1\n\n在以下实例中age是一个局部变量。定义在pupAge()方法中，它的作用域就限制在这个方法中。\n```Java\npackage com.runoob.test;\n\npublic class Test{\n   public void pupAge(){\n      int age = 0;\n      age = age + 7;\n      System.out.println(\"小狗的年龄是: \" + age);\n   }\n\n   public static void main(String args[]){\n      Test test = new Test();\n      test.pupAge();\n   }\n}\n```\n以上实例编译运行结果如下:\n>小狗的年龄是: 7\n\n实例 2\n\n在下面的例子中 age 变量没有初始化，所以在编译时会出错：\n```Java\npackage com.runoob.test;\n\npublic class Test{\n   public void pupAge(){\n      int age;\n      age = age + 7;\n      System.out.println(\"小狗的年龄是 : \" + age);\n   }\n\n   public static void main(String args[]){\n      Test test = new Test();\n      test.pupAge();\n   }\n}\n```\n以上实例编译运行结果如下:\n>Test.java:4:variable number might not have been initialized\n>age = age + 7;\n>         ^\n>1 error\n\n# 实例变量\n- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n- 当一个对象被实例化之后，每个实例变量的值就跟着确定；\n- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n- 实例变量可以声明在使用前或者使用后；\n- 访问修饰符可以修饰实例变量；\n- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n实例\n```Java\nEmployee.java 文件代码：\nimport java.io.*;\npublic class Employee{\n   // 这个实例变量对子类可见\n   public String name;\n   // 私有变量，仅在该类可见\n   private double salary;\n   //在构造器中对name赋值\n   public Employee (String empName){\n      name = empName;\n   }\n   //设定salary的值\n   public void setSalary(double empSal){\n      salary = empSal;\n   }\n   // 打印信息\n   public void printEmp(){\n      System.out.println(\"名字 : \" + name );\n      System.out.println(\"薪水 : \" + salary);\n   }\n\n   public static void main(String args[]){\n      Employee empOne = new Employee(\"RUNOOB\");\n      empOne.setSalary(1000);\n      empOne.printEmp();\n   }\n}\n```\n以上实例编译运行结果如下:\n>$ javac Employee.java\n>$ java Employee\n>名字 : RUNOOB\n>薪水 : 1000.0\n\n# 类变量（静态变量）\n- 类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。\n- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n- 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。\n- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。\n- 静态变量在程序开始时创建，在程序结束时销毁。\n- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。\n- 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n- 静态变量可以通过：ClassName.VariableName的方式访问。\n- 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。\n\n实例：\n```Java\nEmployee.java 文件代码：\nimport java.io.*;\n\npublic class Employee {\n    //salary是静态的私有变量\n    private static double salary;\n    // DEPARTMENT是一个常量\n    public static final String DEPARTMENT = \"开发人员\";\n    public static void main(String args[]){\n    salary = 10000;\n        System.out.println(DEPARTMENT+\"平均工资:\"+salary);\n    }\n}\n```\n以上实例编译运行结果如下:\n>开发人员平均工资:10000.0\n\n注意：如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT。","tags":["Java"],"categories":["Coding","Java"]},{"title":"Java 基本数据类型","path":"/posts/Java-basic-datatypes.html","content":"Java基本数据类型。\n<!--more-->\n# Java 的两大数据类型:\n\n- 内置数据类型\n- 引用数据类型\n\n\n# **内置数据类型**\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\n\n## **byte：**\n\n- byte 数据类型是8位、有符号的，以二进制补码表示的整数；\n- 最小值是` -128（-2^7`；\n- 最大值是` 127（2^7-1)`；\n- 默认值是` 0`；\n- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n- 例子：byte a = 100，byte b = -50。\n\n## **short：**\n- short 数据类型是 16 位、有符号的以二进制补码表示的整数\n- 最小值是` -32768（-2^15）`；\n- 最大值是` 32767（2^15 - 1)`；\n- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n- 默认值是` 0`；\n- 例子：short s = 1000，short r = -20000。\n\n##  **int：**\n\n- int 数据类型是32位、有符号的以二进制补码表示的整数；\n- 最小值是` -2,147,483,648（-2^31）`；\n- 最大值是`2,147,483,647（2^31 - 1)`；\n- 一般地整型变量默认为 int 类型；\n- 默认值是 `0` ；\n- 例子：int a = 100000, int b = -200000。\n\n## **long：**\n- long 数据类型是 64 位、有符号的以二进制补码表示的整数；\n- 最小值是` -9,223,372,036,854,775,808（-2^63）`；\n- 最大值是`9,223,372,036,854,775,807（2^63 -1)`；\n- 这种类型主要使用在需要比较大整数的系统上；\n- 默认值是 `0L`；\n- 例子： long a = 100000L，Long b = -200000L。\n- \"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。\n\n## **float：**\n- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\n- float 在储存大型浮点数组的时候可节省内存空间；\n- 默认值是` 0.0f`；\n- 浮点数不能用来表示精确的值，如货币；\n例子：float f1 = 234.5f。\n\n## **double：**\n- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n- 浮点数的默认类型为double类型；\n- double类型同样不能表示精确的值，如货币；\n- 默认值是` 0.0d`；\n- 例子：double d1 = 123.4。\n\n## **boolean:**\n- boolean数据类型表示一位的信息；\n- 只有两个取值：`true` 和 `false`；\n- 这种类型只作为一种标志来记录 true/false 情况；\n- 默认值是 false；\n例子：boolean one = true。\n\n## **char：**\n- char类型是一个单一的 16 位 Unicode 字符；\n- 最小值是` \\u0000`（即为0）`；\n- 最大值是` \\uffff`（即为65,535）；\n- char 数据类型可以储存任何字符；\n- 例子：char letter = 'A';。\n\n# **引用类型**\n- 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。\n- 对象、数组都是引用数据类型。\n- 所有引用类型的默认值都是null。\n- 一个引用变量可以用来引用任何与之兼容的类型。\n- 例子：Site site = new Site(\"Runoob\")。\n\n# **Java 常量**\n- 常量在程序运行时是不能被修改的。\n\n- 在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：\nfinal double PI = 3.1415927;\n- 虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。\n- 字面量可以赋给任何内置类型的变量。例如：\n```Java\nbyte a = 68;\nchar a = 'A'\n```\nbyte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。\n\n当使用常量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：\n```Java\nint decimal = 100;\nint octal = 0144;\nint hexa =  0x64;\n```\n和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：\n```Java\n\"Hello World\"\n\"two\\nlines\"\n\"\\\"This is in quotes\\\"\"\n```\n字符串常量和字符常量都可以包含任何Unicode字符。例如：\n```Java\nchar a = '\\u0001';\nString a = \"\\u0001\";\n```\n\n# **自动类型转换**\n整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。\n\n转换从低级到高级。\n\n>低  ------------------------------------>  高\n>byte,short,char—> int —> long—> float —> double\n\n数据类型转换必须满足如下规则：\n- 1. 不能对boolean类型进行类型转换。\n- 2. 不能把对象类型转换成不相关类的对象。\n- 3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n- 4. 转换过程中可能导致溢出或损失精度，例如：\n```Java\nint i =128;\nbyte b = (byte)i;\n因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。\n```\n- 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：\n```Java\n(int)23.7 == 23;\n(int)-45.89f == -45\n```\n\n# **自动类型转换**\n必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。\n\n实例\n```Java\npublic class ZiDongLeiZhuan{\n        public static void main(String[] args){\n            char c1='a';//定义一个char类型\n            int i1 = c1;//char自动类型转换为int\n            System.out.println(\"char自动类型转换为int后的值等于\"+i1);\n            char c2 = 'A';//定义一个char类型\n            int i2 = c2+1;//char 类型和 int 类型计算\n            System.out.println(\"char类型和int计算后的值等于\"+i2);\n        }\n}\n```\n运行结果为:\n>char自动类型转换为int后的值等于97\n>char类型和int计算后的值等于66\n\n解析：c1的值为字符'a',查ascii码表可知对应的int类型值为97，'A'对应值为65，所以i2=65+1=66。\n\n\n# **强制类型转换**\n- 1. 条件是转换的数据类型必须是兼容的。\n- 2. 格式：(type)value type是要强制类型转换后的数据类型 实例：\n\n实例\n```Java\npublic class QiangZhiZhuanHuan{\n    public static void main(String[] args){\n        int i1 = 123;\n        byte b = (byte)i1;//强制类型转换为byte\n        System.out.println(\"int强制类型转换为byte后的值等于\"+b);\n    }\n}\n```\n运行结果：\n>int强制类型转换为byte后的值等于123\n\n# **隐含强制类型转换**\n- 1. 整数的默认类型是 int。\n- 2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。","tags":["Java"],"categories":["Coding","Java"]},{"title":"Java 中 String 方法","path":"/posts/JavaString.html","content":"Java 中 Srting 常用方法。\n<!--more-->\n#  `length()`字符串长度\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String Str1 = new String(\"www\");\n        String Str2 = new String(\"github\" );\n\n        System.out.print(\"字符串 Str1 长度 :\");\n        System.out.println(Str1.length());\n        System.out.print(\"字符串 Str2 长度 :\");\n        System.out.println(Str2.length());\n    }\n}\n```\n\n# `charAt()`截取一个字符\n\n```Java\npublic class Test {\n\n    public static void main(String args[]) {\n        String s = \"www.qq.com\";\n        char result = s.charAt(8);\n        System.out.println(result);\n    }\n}\n```\n结果：c\n\n```Java\nchar ch:\nch=\"abc\".charAt(1); //返回b\n```\n\n#  `getChars()`截取多个字符\n语法\n```Java\npublic void getChars(int srcBegin, int srcEnd, char[] dst,  int dstBegin)\n```\n参数:\n\nsrcBegin -- 字符串中要复制的第一个字符的索引。\n\nsrcEnd -- 字符串中要复制的最后一个字符之后的索引。\n\ndst -- 目标数组。\n\ndstBegin -- 目标数组中的起始偏移量。\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String Str1 = new String(\"www.runoob.com\");\n        char[] Str2 = new char[6];\n\n        try {\n            Str1.getChars(4, 10, Str2, 0);\n            System.out.print(\"拷贝的字符串为：\" );\n            System.out.println(Str2 );\n        } catch( Exception ex) {\n            System.out.println(\"触发异常...\");\n        }\n    }\n}\n```\n以上程序执行结果为：拷贝的字符串为：runoob\n\nsourceStart指定了子串开始字符的下标，sourceEnd指定了子串结束后的下一个字符的下标。因此， 子串包含从sourceStart到sourceEnd-1的字符。接收字符的数组由target指定，target中开始复制子串的下标值是targetStart。\n```Java\nString s=\"this is a demo of the getChars method.\";\n　　　　char buf[]=new char[20];\n　　　　s.getChars(10,14,buf,0);\n```\n\n# `getBytes()`\n替代getChars()的一种方法是将字符存储在字节数组中，该方法即getBytes()。\ngetBytes() 方法有两种形式：\n\ngetBytes(String charsetName): 使用指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。\n\ngetBytes(): 使用平台的默认字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。\n\n语法\n```\npublic byte[] getBytes(String charsetName) throws UnsupportedEncodingException\n```\n或\n```\npublic byte[] getBytes()\n```\n参数:\ncharsetName -- 支持的字符集名称。\n\n返回值:返回 byte 数组。\n\n实例\n```Java\nimport java.io.*;\n\npublic class Test {\n    public static void main(String args[]) {\n        String Str1 = new String(\"runoob\");\n\n        try{\n            byte[] Str2 = Str1.getBytes();\n            System.out.println(\"返回值：\" + Str2 );\n\n            Str2 = Str1.getBytes( \"UTF-8\" );\n            System.out.println(\"返回值：\" + Str2 );\n\n            Str2 = Str1.getBytes( \"ISO-8859-1\" );\n            System.out.println(\"返回值：\" + Str2 );\n        } catch ( UnsupportedEncodingException e){\n            System.out.println(\"不支持的字符集\");\n        }\n    }\n}\n```\n以上程序执行结果为：\n```\n返回值：[B@7852e922\n返回值：[B@4e25154f\n返回值：[B@70dea4e\n```\n\n# toCharArray()\n`public char[] toCharArray()`\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String Str = new String(\"vitan.xyzm\");\n\n        System.out.print(\"返回值 :\" );\n        System.out.println( Str.toCharArray() );\n    }\n}\n```\n# `equals()`和`equalsIgnoreCase()` 比较两个字符串\nString.equals()对大小写敏感，而String.equalsIgnoreCase()忽略大小写.\n\n例如：\n```Java\n\"ABC\".equals(\"abc\")//是false\n\"ABC\".equalsIgnoreCase(\"abc\")//为ture\n```\n#  `regionMatches()` regionMatches()\n方法用于检测两个字符串在一个区域内是否相等。\n\n语法:\n```Java\npublic boolean regionMatches(int toffset,String other, int ooffset,int len)\n```\nor\n\n```Java\npublic boolean regionMatches(boolean ignoreCase,int toffset, String other,int ooffset,int len)\n```\n参数：\n\nignoreCase -- 如果为 true，则比较字符时忽略大小写。\n\ntoffset -- 此字符串中子区域的起始偏移量。\n\nother -- 字符串参数。\n\nooffset -- 字符串参数中子区域的起始偏移量。\n\nlen -- 要比较的字符数。\n\n\n用于比较一个字符串中特定区域与另一特定区域，它有一个重载的形式允许在比较中忽略大小写。\n```java\n　　boolean regionMatches(int startIndex,String str2,int str2StartIndex,int numChars)\n　　boolean regionMatches(boolean ignoreCase,int startIndex,String str2,int str2StartIndex,int numChars)\n```\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String Str1 = new String(\"www.runoob.com\");\n        String Str2 = new String(\"runoob\");\n        String Str3 = new String(\"RUNOOB\");\n\n        System.out.print(\"返回值 :\" );\n        System.out.println(Str1.regionMatches(4, Str2, 0, 5));\n\n        System.out.print(\"返回值 :\" );\n        System.out.println(Str1.regionMatches(4, Str3, 0, 5));\n\n        System.out.print(\"返回值 :\" );\n        System.out.println(Str1.regionMatches(true, 4, Str3, 0, 5));\n    }\n}\n```\n以上程序执行结果为：\n```\n返回值 :true\n返回值 :false\n返回值 :true\n```\n# `startsWith()`和`endsWith()`\nstartsWith()方法决定是否以特定字符串开始，endWith()方法决定是否以特定字符串结束\n```Java\npublic class StringDemo{\npublic static void main(String args[]){\n      String s1=\"this is my original string\";\n      String sd=\"original\";\n      if (s1.startsWith(sd)) //startsWith()方法判断字符串s1是否从字符串sd开始\n         s1=s1.substring(sd.length());\n      else\n         if(s1.endsWith(sd)) //endWith()方法判断字符串s1是否从字符串sd结尾\n             s1=s1.substring(0,s1.length()-sd.length());\n         else\n         {\n               int index=s1.indexOf(sd); //indexOf()搜索字符或子字符串首次出现，这里的index等于11\n               if(index!=-1)\n               {\n                  String s2=s1.substring(0,index); //从字符串s1的首字符开始，取index个字符\n                  String s3=s1.substring(index+sd.length());//取字符串s1的第19个字符后面的字符串\n                  s1=s2+s3;\n               }\n               else\n               System.out.println(\"string /\"\"+sd+\"/\" not found\");\n         }\n         System.out.println(s1);\n      }\n}\n```\n# `equals()`和`==equals()`\n方法比较字符串对象中的字符，==运算符比较两个对象是否引用同一实例。\n```Java\nString s1=\"Hello\";\n　　　　String s2=new String(s1);\n　　　　s1.eauals(s2);    //true\n　　　　s1==s2;          //false\n```\n\n# `compareTo()`和`compareToIgnoreCase()`比较字符串\ncompareTo()\n\n字符串与对象进行比较。\n\n按字典顺序比较两个字符串。\n\n语法;\n`int compareTo(Object o)`或`int compareTo(String anotherString)`\n参数:\n o -- 要比较的对象。anotherString -- 要比较的字符串。\n返回值:\n\n返回值是整型,它是先比较对应字符的大小(ASCII码顺序),如果第一个字符和参数的第一个字符不等,结束比较,返回他们之间的差值,如果第一个字符和参数的第一个字符相等,则以第二个字符和参数的第二个字符做比较,以此类推,直至比较的字符或被比较的字符有一方。\n\n如果参数字符串等于此字符串，则返回值 0；\n\n如果此字符串小于字符串参数，则返回一个小于 0 的值；\n\n如果此字符串大于字符串参数，则返回一个大于 0 的值。\n\n实例:\n```Java\npublic class Test {\n\n    public static void main(String args[]) {\n        String str1 = \"Strings\";\n        String str2 = \"Strings\";\n        String str3 = \"Strings123\";\n\n        int result = str1.compareTo( str2 );\n        System.out.println(result);\n\n        result = str2.compareTo( str3 );\n        System.out.println(result);\n\n        result = str3.compareTo( str1 );\n        System.out.println(result);\n    }\n}\n```\n以上程序执行结果为：\n```\n0\n-3\n3\n```\n`compareToIgnoreCase()` 方法用于按字典顺序比较两个字符串，不考虑大小写。\n\n参数:\n\nstr -- 要比较的字符串。\n\n返回值:\n\n如果参数字符串等于此字符串，则返回值 0；\n\n如果此字符串小于字符串参数，则返回一个小于 0 的值；\n\n如果此字符串大于字符串参数，则返回一个大于 0 的值。\n\n```Java\npublic class Test {\n\n    public static void main(String args[]) {\n        String str1 = \"STRINGS\";\n        String str2 = \"Strings\";\n        String str3 = \"Strings123\";\n\n        int result = str1.compareToIgnoreCase( str2 );\n        System.out.println(result);\n\n        result = str2.compareToIgnoreCase( str3 );\n        System.out.println(result);\n\n        result = str3.compareToIgnoreCase( str1 );\n        System.out.println(result);\n    }\n}\n```\n\n# `indexOf()`和`lastIndexOf()`\n\nindexOf() 查找字符或者子串第一次出现的地方。\n\nindexOf() 方法有以下四种形式：\n\npublic int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\npublic int indexOf(int ch, int fromIndex): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\nint indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\nint indexOf(String str, int fromIndex): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1\n\n语法:\n```java\npublic int indexOf(int ch )\n```\n或\n```java\npublic int indexOf(int ch, int fromIndex)\n```\n或\n```java\nint indexOf(String str)\n```\n或\n```java\nint indexOf(String str, int fromIndex)\n```\n参数:\nch -- 字符。fromIndex -- 开始搜索的索引位置。str -- 要搜索的子字符串。\n\n返回值:\n\n指定子字符串在字符串中第一次出现处的索引，从指定的索引开始。\n\n实例:\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String Str = new String(\"菜鸟教程:www.runoob.com\");\n        String SubStr1 = new String(\"runoob\");\n        String SubStr2 = new String(\"com\");\n\n        System.out.print(\"查找字符 o 第一次出现的位置 :\" );\n        System.out.println(Str.indexOf( 'o' ));\n        System.out.print(\"从第14个位置查找字符 o 第一次出现的位置 :\" );\n        System.out.println(Str.indexOf( 'o', 14 ));\n        System.out.print(\"子字符串 SubStr1 第一次出现的位置:\" );\n        System.out.println( Str.indexOf( SubStr1 ));\n        System.out.print(\"从第十五个位置开始搜索子字符串 SubStr1 第一次出现的位置 :\" );\n        System.out.println( Str.indexOf( SubStr1, 15 ));\n        System.out.print(\"子字符串 SubStr2 第一次出现的位置 :\" );\n        System.out.println(Str.indexOf( SubStr2 ));\n    }\n}\n```\n以上程序执行结果为：\n```\n查找字符 o 第一次出现的位置 :12\n从第14个位置查找字符 o 第一次出现的位置 :17\n子字符串 SubStr1 第一次出现的位置:9\n从第十五个位置开始搜索子字符串 SubStr1 第一次出现的位置 :-1\n子字符串 SubStr2 第一次出现的位置 :16。\n```\n\n# `lastIndexOf()`\n查找字符或者子串是后一次出现的地方。\n\nlastIndexOf() 方法有以下四种形式：\n\npublic int lastIndexOf(int ch): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\npublic int lastIndexOf(int ch, int fromIndex): 返返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\npublic int lastIndexOf(String str): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\npublic int lastIndexOf(String str, int fromIndex): 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\n语法:\n```\npublic int lastIndexOf(int ch)\n\n或\n\npublic int lastIndexOf(int ch, int fromIndex)\n\n或\n\npublic int lastIndexOf(String str)\n\n或\n\npublic int lastIndexOf(String str, int fromIndex)\n```\n参数:\nch -- 字符。fromIndex -- 开始搜索的索引位置。str -- 要搜索的子字符串。\n\n返回值\n指定子字符串在字符串中第一次出现处的索引值。\n\n实例\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String Str = new String(\"菜鸟教程:www.runoob.com\");\n        String SubStr1 = new String(\"runoob\");\n        String SubStr2 = new String(\"com\");\n\n        System.out.print(\"查找字符 o 最后出现的位置 :\" );\n        System.out.println(Str.lastIndexOf( 'o' ));\n        System.out.print(\"从第14个位置查找字符 o 最后出现的位置 :\" );\n        System.out.println(Str.lastIndexOf( 'o', 14 ));\n        System.out.print(\"子字符串 SubStr1 最后出现的位置:\" );\n        System.out.println( Str.lastIndexOf( SubStr1 ));\n        System.out.print(\"从第十五个位置开始搜索子字符串 SubStr1最后出现的位置 :\" );\n        System.out.println( Str.lastIndexOf( SubStr1, 15 ));\n        System.out.print(\"子字符串 SubStr2 最后出现的位置 :\" );\n        System.out.println(Str.lastIndexOf( SubStr2 ));\n    }\n}\n```\n以上程序执行结果为：\n```\n查找字符 o 最后出现的位置 :17\n从第14个位置查找字符 o 最后出现的位置 :13\n子字符串 SubStr1 最后出现的位置:9\n从第十五个位置开始搜索子字符串 SubStr1最后出现的位置 :9\n子字符串 SubStr2 最后出现的位置 :16\n```\n\n# `substring()`\n它有两种形\n\n第一种是：public String substring(int startIndex)\n\n第二种是：public String substring(int startIndex,int endIndex)\n\n参数:\n\nbeginIndex -- 起始索引（包括）。\n\nendIndex -- 结束索引（不包括）。\n\n返回值\n\n子字符串。\n\n实例\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String Str = new String(\"www.runoob.com\");\n\n        System.out.print(\"返回值 :\" );\n        System.out.println(Str.substring(4) );\n\n        System.out.print(\"返回值 :\" );\n        System.out.println(Str.substring(4, 10) );\n    }\n}\n```\n以上程序执行结果为：\n```\n返回值 :runoob.com\n返回值 :runoob\n```\n\n- `concat()` 连接两个字符串\n语法: public String concat(String s)\n参数:   s -- 要连接的字符串。\n\n返回值:\n返回连接后的新字符串。\n\n实例\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String s = \"你好：\";\n        s = s.concat(\"Hellom\");\n        System.out.println(s);\n    }\n}\n```\n以上程序执行结果为：\n你好：Hello\n\n\n#  `replace()`替换\nreplace() 方法通过用 newChar 字符替换字符串中出现的所有 oldChar 字符，并返回替换后的新字符串。\n\n语法:public String replace(char oldChar, char newChar)\n参数:oldChar -- 原字符。newChar -- 新字符。\n\n返回值:\n\n替换后生成的新字符串。\n\n实例:\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String Str = new String(\"hello\");\n\n        System.out.print(\"返回值 :\" );\n        System.out.println(Str.replace('o', 'T'));\n\n        System.out.print(\"返回值 :\" );\n        System.out.println(Str.replace('l', 'D'));\n    }\n}\n```\n以上程序执行结果为：\n```\n返回值 :hellT\n返回值 :heDDo\n```\n\n# `trim()` 去掉起始和结尾的空格\n```Java\nString s=\" abc \";\nString s2=s.trim();\ns2=\"abc\"\n```\n\n# `valueOf()`\n===\n\nvalueOf() 方法用于返回给定参数的原生 Number 对象值，参数可以是原生数据类型, String等。\n该方法是静态方法。该方法可以接收两个参数一个是字符串，一个是基数。\n\n语法:\n\n该方法有以下几种语法格式：\n```\nstatic Integer valueOf(int i)\nstatic Integer valueOf(String s)\nstatic Integer valueOf(String s, int radix)\n```\n参数\n\ni -- Integer 对象的整数。\n\ns -- Integer 对象的字符串。\n\nradix --在解析字符串 s 时使用的基数，用于指定使用的进制数。\n\n返回值\n\nInteger valueOf(int i)：返回一个表示指定的 int 值的 Integer 实例。\n\nInteger valueOf(String s):返回保存指定的 String 的值的Integer 对象。\n\nInteger valueOf(String s, int radix): 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。\n\n实例\n```\npublic class Test{\npublic static void main(String args[]){\n        Integer x =Integer.valueOf(9);\n        Double c = Double.valueOf(5);\n        Float a = Float.valueOf(\"80\");\n\n        Integer b = Integer.valueOf(\"444\",16);   // 使用 16 进制\n\n        System.out.println(x);\n        System.out.println(c);\n        System.out.println(a);\n        System.out.println(b);\n    }\n}\n```\n输出结果为：\n```\n9\n5.0\n80.0\n1092\n```\n\n# `toLowerCase()`\n转换为小写\n\ntoLowerCase() 方法将字符串转换为小写。\n\n语法\n```java\npublic String toLowerCase()\n```\n或\n```java\npublic String toLowerCase(Locale locale)\n```\n返回值\n\n转换为小写的字符串。\n\n实例\n```Java\npublic class Test {\n    public static void main(String args[]) {\n        String Str = new String(\"VITAN\");\n\n        System.out.print(\"返回值 :\" );\n        System.out.println( Str.toLowerCase() );\n    }\n}\n```\n以上程序执行结果为：返回值 :vitan\n\n- `toUpperCase()` 转换为大写\n- `StringBuffer`构造函数\n\n**Via**\n- [参考](https://m.runoob.com/java/java-stringbuffer.html)","tags":["Java"],"categories":["Coding","Java"]},{"title":"oh-my-zsh 插件","path":"/posts/Oh-My-ZSH-complete.html","content":"Oh-my-zsh插件\n<!--more-->\n# 使用方法\n```\nvim ~/.zshrc\n//找到下面这句，添加相应的插件 插件之间用空格分隔\nplugins=(git z zsh-syntax-highlighting zsh-autosuggestions)\n//使配置文件生效\nsource ~/.zshrc\n```\n\n# Git 默认已开启\n- 可以使用各种 git 命令缩写。比如\n```\ngit add --all ===> gaa\ngit commit -m ===> gcmsg\n```\n- 看所有 git 命令缩写\n```sh\ncat ~/.oh-my-zsh/plugins/git/git.plugin.zsh\n```\n\n# autojump\n- [Hithub Rpo](https://github.com/wting/autojump)\n- 已经内置了，直接在` .zshrc` 配置文件添加即可。\n- 目录间快速跳转,不用再一直 cd 了\n\n## 使用\n- 使用 ` autojump`  的缩写 `j`\n- `cd` 命令进入` ~/user/github/Noye` 文件夹，下一次再想进入Notr 文件夹的时候,直接` j Note` 即可,或者只输入 Note 的一部分 Not 都行.\n- 删除无效路径\n  - `j --purge 无效路径`类似组件` Z` (也内置了,直接改配置文件即可)删除无效路径它的命令更短`z -x 无效路径`\n\n\n# zscrh-syntax-highlighting\n- [Github Rpo](https://github.com/zsh-users/zsh-syntax-highlighting)\n\n- 作用:平常用的 `ls`  `cd` 等命令输入正确会绿色高亮显示，输入错误会显示其他的颜色。\n\n## 安装\n- 克隆项目\n```sh\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git\necho \"source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" >> ${ZDOTDIR:-$HOME}/.zshrc\n```\n- 在 `~/.zshrc` 中配置\n```sh\nplugins=(zsh-syntax-highlighting)\n```\n\n# zsh-autosuggestions\n输入命令时，会给出建议的命令\n\n## 安装\n- 克隆项目\n```\ngit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n```\n- 在 `~/.zshrc` 中配置\n```sh\nplugins=(zsh-autosuggestions)\n```\n\n# incr\n- Ubuntu sudo\n```sh\napt-get install zsh\n```\n- ArchLinux\n```sh\nyacman -S #!/usr/bin/env zsh\n    ```\n- 安装完成后执行：\n```sh\nchsh -s /bin/zsh\n```\n\n# 安装 oh my zsh\n- 自动安装：\n```\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n```\n- 手动安装：\n```\ngit clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.zshrc ~/.zshrc.orig\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\nchsh -s /bin/zsh\n```\n\n## 下载 incr\n:\t[下载地址](http://mimosa-pudica.net/zsh-incremental.html)\n\n- 代码摘录如下：\n```\n  # Incremental completion for zsh\n  # by y.fujii <y-fujii at mimosa-pudica.net>, public domain\n\n\n  autoload -U compinit\n  zle -N self-insert self-insert-incr\n  zle -N vi-cmd-mode-incr\n  zle -N vi-backward-delete-char-incr\n  zle -N backward-delete-char-incr\n  zle -N expand-or-complete-prefix-incr\n  compinit\n\n  bindkey -M viins '^[' vi-cmd-mode-incr\n  bindkey -M viins '^h' vi-backward-delete-char-incr\n  bindkey -M viins '^?' vi-backward-delete-char-incr\n  bindkey -M viins '^i' expand-or-complete-prefix-incr\n  bindkey -M emacs '^h' backward-delete-char-incr\n  bindkey -M emacs '^?' backward-delete-char-incr\n  bindkey -M emacs '^i' expand-or-complete-prefix-incr\n\n  unsetopt automenu\n  compdef -d scp\n  compdef -d tar\n  compdef -d make\n  compdef -d java\n  compdef -d svn\n  compdef -d cvs\n\n  # TODO:\n  #     cp dir/\n\n  now_predict=0\n\n  function limit-completion\n  {\n  \tif ((compstate[nmatches] <= 1)); then\n  \t\tzle -M \"\"\n  \telif ((compstate[list_lines] > 6)); then\n  \t\tcompstate[list]=\"\"\n  \t\tzle -M \"too many matches.\"\n  \tfi\n  }\n\n  function correct-prediction\n  {\n  \tif ((now_predict == 1)); then\n  \t\tif [[ \"$BUFFER\" != \"$buffer_prd\" ]] || ((CURSOR != cursor_org)); then\n  \t\t\tnow_predict=0\n  \t\tfi\n  \tfi\n  }\n\n  function remove-prediction\n  {\n  \tif ((now_predict == 1)); then\n  \t\tBUFFER=\"$buffer_org\"\n  \t\tnow_predict=0\n  \tfi\n  }\n\n  function show-prediction\n  {\n  \t# assert(now_predict == 0)\n  \tif\n  \t\t((PENDING == 0)) &&\n  \t\t((CURSOR > 1)) &&\n  \t\t[[ \"$PREBUFFER\" == \"\" ]] &&\n  \t\t[[ \"$BUFFER[CURSOR]\" != \" \" ]]\n  \tthen\n  \t\tcursor_org=\"$CURSOR\"\n  \t\tbuffer_org=\"$BUFFER\"\n  \t\tcomppostfuncs=(limit-completion)\n  \t\tzle complete-word\n  \t\tcursor_prd=\"$CURSOR\"\n  \t\tbuffer_prd=\"$BUFFER\"\n  \t\tif [[ \"$buffer_org[1,cursor_org]\" == \"$buffer_prd[1,cursor_org]\" ]]; then\n  \t\t\tCURSOR=\"$cursor_org\"\n  \t\t\tif [[ \"$buffer_org\" != \"$buffer_prd\" ]] || ((cursor_org != cursor_prd)); then\n  \t\t\t\tnow_predict=1\n  \t\t\tfi\n  \t\telse\n  \t\t\tBUFFER=\"$buffer_org\"\n  \t\t\tCURSOR=\"$cursor_org\"\n  \t\tfi\n  \t\techo -n \"\\e[32m\"\n  \telse\n  \t\tzle -M \"\"\n  \tfi\n  }\n\n  function preexec\n  {\n  \techo -n \"\\e[39m\"\n  }\n\n  function vi-cmd-mode-incr\n  {\n  \tcorrect-prediction\n  \tremove-prediction\n  \tzle vi-cmd-mode\n  }\n\n  function self-insert-incr\n  {\n  \tcorrect-prediction\n  \tremove-prediction\n  \tif zle .self-insert; then\n  \t\tshow-prediction\n  \tfi\n  }\n\n  function vi-backward-delete-char-incr\n  {\n  \tcorrect-prediction\n  \tremove-prediction\n  \tif zle vi-backward-delete-char; then\n  \t\tshow-prediction\n  \tfi\n  }\n\n  function backward-delete-char-incr\n  {\n  \tcorrect-prediction\n  \tremove-prediction\n  \tif zle backward-delete-char; then\n  \t\tshow-prediction\n  \tfi\n  }\n\n  function expand-or-complete-prefix-incr\n  {\n  \tcorrect-prediction\n  \tif ((now_predict == 1)); then\n  \t\tCURSOR=\"$cursor_prd\"\n  \t\tnow_predict=0\n  \t\tcomppostfuncs=(limit-completion)\n  \t\tzle list-choices\n  \telse\n  \t\tremove-prediction\n  \t\tzle expand-or-complete-prefix\n  \tfi\n  }\n```\n\n- 执行如下命令：\n```\ncd ~/.oh-my-zsh/plugins/\nmkdir -p incr\ncd incr\nvim incr-0.2.zsh //（将代码复制粘贴到incr-0.2.zsh文件中）\nchmod 777 incr-0.2.zsh\n```\n\n## 配置 .zshrc 文件\n1. vim ~/.zshrc\n末尾加入\n2. ource ~/.oh-my-zsh/plugins/incr/incr*.zsh\n3. source ~/.zshrc #使其立即生效","tags":["Linux","ArchLinux","Ubuntu","Termux"],"categories":["Linux"]},{"title":"SQL 笔记","path":"/posts/SQL-Note.html","content":"SQL笔记\n<!--more-->\n1. 从职工关系中检索所有工资值。\n```sql\nselect 月工资\nfrom zg\n```\n2. 检索仓库关系中的所有元组。\n```sql\nselect *\nfrom ck\n```\n3. 检索工资多于2000元的职工对应的职工号，姓名。\n```sql\nselect  职工号,月工资 from zg\nwhere 月工资>2000\n```\n4. 检索哪些仓库的面积在400到550平方之间，列出仓库号和所在的城市。\n```sql\n select 仓库号,城市\n from ck\n where 面积>400 and 面积<550\n```\n5. 检索出有广州哪些仓库，列出仓库号。\n```sql\n select 仓库号 from ck\n where 城市='广州'\n ```\n 6. 检索出所在城市为广州的仓库的个数。\n```sql\n select count(仓库号)\n from ck\n where 城市='广州'\n```\n7. 检索出所有职工的平均工资。\n```sql\nselect avg(月工资)\nfrom zg\n```\n8. 检索出在WH5仓库工作的职工的人数。\n```sql\nselect count(仓库号) from zg\nwhere 仓库号='WH5'\n```\n9. 检索出职工表的所有的仓库号，去掉重复值。\n```sql\nselect distinct 仓库号\nfrom zg\n```\n10. 检索出每个仓库的人数。\n```sql\nselect 仓库号,count(*)人数\n from zg\ngroup by 仓库号\n```\n11. 检索出上海的仓库有哪些，列出仓库号、面积。查询结果按面积降序排列。\n```sql\nselect 仓库号,面积\n from ck\nwhere 城市='上海'\norder by 面积 desc\n```\n12. 检索出哪些仓库女职工的人数达到了3人。\n```sql\n select 仓库号,count(职工号)人数\nfrom zg where 性别='女'\ngroup by 仓库号 having count(职工号)>3\n```\n13. 检索出所有姓胡的职工的职工号、姓名、性别、工资。查询结果按性别排降序、工资排升序。\n```sql\nselect 职工号,姓名,性别,月工资\nfrom zg\nwhere 姓名 like'胡%'\norder by 性别 desc,月工资 asc\n```\n14. 检索出职工“王玛丽”的年工资。\n```sql\nselect sum(月工资*12) as 年薪\nfrom zg\nwhere 姓名='王玛丽'\n```\n15. 检索出“WH1”和“WH2”两个仓库工作的职工的基本信息。\n```sql\nselect *\nfrom zg\nwhere 仓库号='WH1'or 仓库号='WH2'\n```\n16. 检索出年工资在24000以上的职工的姓名，年工资值。\n```sql\n select 姓名,月工资*12 as 年工资\n```","tags":["SQL"],"categories":["Database"]},{"title":"Java 控制语句","path":"/posts/JavaControl.html","content":"Java控制语句\n<!--more-->\n# 简介\nJava流程控制语句（顺序结构、if条件语句、switch条件语句、循环语句与跳转语句）\n\n# 顺序语句\n## 表达式语句\n```Java\ni++;\ni--;\nx=10;\nsum=sum+1;\nnew JFrame(); //实例化对象\nthis.setVisible(true); //方法调用\n```\n\n## 空语句\n```Java\nfor(int i=0;i<10;i++); //空语句一个分号\n```\n```Java\nint x=6;; //两连续分号，第二个是空语句\n```\n```Java\nif (a>b) {\n         ;   //条件为真，执行空语句\n}\nelse {\n\n            //条件为假，执行本部分\n}\n```\n\n## 复合语句\n```Java\n{\n    int i=5;//又称代码块语句，一对大括号括起来的语句，中间可有多个变量或语句\n    int a;\n    a=i;\n    System.out.orint(a);\n}\n```\n\n# 选择语句\n## if语句\n```Java\n/*\n * \"if条件语句\"示例代码\n * 功能：输入三个数，输出最大值\n */\n\nimport java.util.Scanner;\npublic class Program {\n\tpublic static void main(String [] args) {\n\t\tint num1,num2,num3,max;\n\t\tScanner input = new Scanner(System.in);\n\t\tSystem.out.println(\"请输入第一个数：\");\n\t\tnum1=input.nextInt();\n\t\tSystem.out.println(\"请输入第二个数：\");\n\t\tnum2=input.nextInt();\n\t\tSystem.out.println(\"请输入第三个数：\");\n\t\tnum3=input.nextInt();\n\t\tmax=num1;\n\t\tif(num2>max)\n\t\t\tmax=num2;\n\t\tif (num3>max)\n\t\t\tmax=num3;\n\t\tSystem.out.println(\"max=\"+max);\n\t\tinput.close();\n\t}\n}\n```\n\n## switch语句\n```Java\nimport java.unit.Scanner;\npublic class Switchweek\n    public static void main(String[]args) {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"请输入1-7的整数\");\n        int day = input.nextInt(); //对象调用方法获取数据\n        switch (day)\n        {\n            case 7: System.out.println(\"星期日\"); break;\n            case 1: System.out.println(\"星期一\"); break;\n            case 2: System.out.println(\"星期二\"); break;\n            case 3: System.out.println(\"星期三\"); break;\n            case 4: System.out.println(\"星期四\"); break;\n            case 5: System.out.println(\"星期五\"); break;\n            case 6: System.out.println(\"星期六\"); break;\n            default: Syatem.out.println(\"你输入的日期不在有效范围内！\");\n            }\n      }\n}\n```\n\n```Java\npublic class Switch{\n    public static void main(String[] args) {\n\t\tchar today='日';\n\t\tswitch(today){\n            case '一':\n            case '三':\n            case '五':\n                System.out.println(\"早餐吃包子\");\n                break;\n            case '二':\n            case '四':\n            case '六':\n                System.out.println(\"早餐吃油条\");\n                break;\n            default:\n                System.out.println(\"吃主席套餐\");\n\t\t}\n\t}\n}\n```\n\n# 循环语句(主要有while/do-while/for和foreach)\n## while\n```Java\nwhile(判断条件)\n{\n    语句;\n}\n```\n\n## 扩展格式\n```java\n初始化语句;\nwhile(判断条件语句) {\n      循环体语句;\n      控制条件语句;\n    }\n\n    通过这个格式，我们就可以看到其实和for循环是差不多的。\n        for(初始化语句;判断条件语句;控制条件语句) {\n            循环体语句;\n        }\n```\n```Java\npublic class WhileSun {\n    public static void main(String[] args) {\n        int i = 1;\n        int n = 10;\n        int sum = 0;\n        while(i<=n) {\n            sum+=i;\n            i++;\n        }\n        System.out.println(\"1加到10但和是:\"+sum);\n        System.out.println(\"循环后变量i但值是:\"+i);\n    }\n}\n```\n\n## do-while\n1. 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\n2. do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。\n```java\ndo {\n       //代码语句\n}while(布尔表达式);\n```\n\n注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。\n```Java\npublic class Test {\n   public static void main(String args[]){\n      int x = 10;\n      do{\n         System.out.print(\"value of x : \" + x );\n         x++;\n         System.out.print(\"\\n\");\n      }while( x < 20 );\n   }\n}\n```\n\n## for循环\n```\nfor(初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n```\n\n最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。\n执行一次循环后，更新循环控制变量。\n再次检测布尔表达式。循环执行上面的过程。\n\n```Java\npublic class Test {\n   public static void main(String args[]) {\n      for(int x = 10; x < 20; x = x+1) {\n         System.out.print(\"value of x : \" + x );\n         System.out.print(\"\\n\");\n      }\n   }\n}\n```\n# Java 增强 for 循环\nJava5 引入了一种主要用于数组的增强型 for 循环。\n\nJava 增强 for 循环语法格式如下:\n```\nfor(声明语句 : 表达式)\n{\n   //代码句子\n}\n```\n明语句：\n\n声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n\n表达式：表达式是要访问的数组名，或者是返回值为数组的方法\n\n```Java\npublic class Test {\n   public static void main(String args[]){\n      int [] numbers = {10, 20, 30, 40, 50};\n\n      for(int x : numbers ){\n         System.out.print( x );\n         System.out.print(\",\");\n      }\n      System.out.print(\"\\n\");\n      String [] names ={\"James\", \"Larry\", \"Tom\", \"Lacy\"};\n      for( String name : names ) {\n         System.out.print( name );\n         System.out.print(\",\");\n      }\n   }\n}\n```\n\n## break 关键字\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n语法:break 的用法很简单，就是循环结构中的一条语句：\n`break;`\n\n```Java\npublic class Test {\n   public static void main(String args[]) {\n      int [] numbers = {10, 20, 30, 40, 50};\n\n      for(int x : numbers ) {\n         // x 等于 30 时跳出循环\n         if( x == 30 ) {\n            break;\n         }\n         System.out.print( x );\n         System.out.print(\"\\n\");\n      }\n   }\n}\n```\n\n```Java\n/*\n * \"实战——九九乘法口诀表\"*/\n\npublic class Program {\n\tpublic static void main(String [] args) {\n\t\tSystem.out.println(\"九九乘法口诀表：\");\n\t\tfor (int i=1;i<=9;i++){\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tSystem.out.print(j+\"*\"+i+\"=\"+j*i+\"\\t\");\n\t\t\t}\n//\t\t\t注意print与println的区别\n\t\t\tSystem.out.print(\"\\n\");\n//\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n\n```\n\n## continue 关键字\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n\n在 for 循环中，continue 语句使程序立即跳转到更新语句。\n\n在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。\n语法\n\ncontinue 就是循环体中一条简单的语句：\n\n`continue;`\n\n```Java\npublic class Test {\n   public static void main(String args[]) {\n      int [] numbers = {10, 20, 30, 40, 50};\n      for(int x : numbers ) {\n         if( x == 30 ) {\n        continue;\n         }\n         System.out.print( x );\n         System.out.print(\"\\n\");\n      }\n   }\n}\n```","tags":["Java"],"categories":["Coding","Java"]},{"title":"Vim 设置默认中文并加行数","path":"/posts/Vim-utf-8.html","content":"Vim 设置默认中文并加行数\n<!--more-->\n# .vimrc\n配置文件\n\n ```vim\n    \" 设置行号显示\n    set number\n\n    \" 将行号设置为相对行号\n    set relativenumber\n\n    \"显示标尺\n    set ruler\n\n    \"编码\n    set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1\n    set enc=utf8\n    set fencs=utf8,gbk,gb2312,gb18030\n\n    \" 语法高亮\n    syntax enable\n    syntax on\n\n    \" 高亮字符，让其不受100列限制\n    :highlight OverLength ctermbg=red ctermfg=white guibg=red guifg=white\n    :match OverLength '\\%101v.*'\n\n    \" 状态行颜色\n    highlight StatusLine guifg=SlateBlue guibg=Yellow\n    highlight StatusLineNC guifg=Gray guibg=White\n\n    \" 增强模式中的命令行自动完成操作\n    set wildmenu\n\n    \" 我的状态行显示的内容（包括文件类型和解码）\n    set statusline=%F%m%r%h%w\\[POS=%l,%v][%p%%]\\%{strftime(\\\"%d/%m/%y\\ -\\ %H:%M\\\")}\n\n    \" 总是显示状态行\n    set laststatus=2\n\n    \"命令行补全参数\n    set wildmenu\n\n    \"设置tab键空4格\n    set tabstop=4\n\n    \"自动检测文件类型\n    filetype plugin indent on\n\n    \"开启自动缩进，智能缩进\n    set autoindent\n    set cindent\n    set smartindent\n    set shiftwidth=4\n    \n    \"插件安装列表\n    set rtp+=~/.vim/bundle/Vundle.vim\n    call vundle#begin()\n    Plugin 'godlygeek/tabular'\n    Plugin 'plasticboy/vim-markdown'\n    call vundle#end()\n```\n\n# Vim 设置默认中文编码\n.vimrc 添加下面内容即可\n\n```vim\nset encoding=utf-8\nset fileencodings=ucs-bom,utf-8,cp936\nset fileencoding=gb2312\nset termencoding=utf-8\n```\n# 设置行数\n```vim\nset nu\nset nobackup\nset noswapfile\nsyntax on\nset tabstop=4\nset shiftwidth:4\nset expandtab\nset smarttab\nset hlsearch\nset showmatch\nset matchtime=2\n```","tags":["Linux","ArchLinux","Ubuntu","Vim"],"categories":["Coding"]},{"title":"Ubuntu 常用命令","path":"/posts/UbuntuCommand.html","content":"Ununtu常用命令。\n<!--more-->\n# 磁盘目录\n\n|目录|作用|\n|:---|:---|\n|/|根目录|\n|/bin|存放必要的命令|\n|/boot|存放内核以及启动所需的文件等|\n|/dev|存放设备文件|\n|/etc|存放系统的配置文件|\n|/home|用户文件的主目录，用户数据存放在其主目录中|\n|/lib|存放必要的运行库|\n|/mnt|存放临时的映射文件系统，我们常把软驱和光驱挂装在这里的floppy和cdrom子目录下|\n|/proc|存放存储进程和系统信息|\n|/root|超级用户的主目录|\n|/sbin|存放系统管理程序|\n|/tmp|存放临时文件的目录|\n|/usr|包含了一般不需要修改的应用程序，命令程序文件、程序库、手册和其它文档|\n|/var|包含系统产生的经常变化的文件|\n\n# 文件/文件夹管理\n\n|命令|作用|\n|:---|:---|\n|ls|列出当前目录下的所有文件（不显示隐藏文件） |\n|ls -a  |列出当前目录下的所有文件（显示隐藏文件） |\n|ls -l |列出当前目录下所有文件的详细信息 |\n|cd 或者 cd ~ |进入用户主目录 |\n|cd .. |回到上一级目录 |\n|cd - |返回进入此目录之前所在的目录 |\n|mkdir dirname  |新建目录 |\n|rmdir dirname  |删除空目录 |\n|rm filename  |删除文件 |\n|rm -rf dirname | 删除非空目录及其包含的所有文件 |\n|mv file1 file2 |将文件1重命名为文件2 |\n|mv file1 dir1  |将文件1移动到目录1中 |\n|find 路径 -name “字符串” |查找路径所在范围内满足字符串匹配的文件和目录 |\n\n\n# 程序安装与卸载\n\n|命令|作用|\n|:---|:---|\n|apt-get +|程序安装与卸载命令的标志，需要管理员权限|\n| install|安装指定程序，举例：`sudo apt-get install vim|\n|remove|卸载指定的程序，一般最好加上`--purge`执行清除式卸并在程序名称后添加*号。举例 sudo apt-get remove--purge nvidia *卸载 nvidia 的驱动及其配置文件|\n|update|更新本地软件源文件，需要管理员权限，举例：sudo apt-get update|\n\n# 打包/解压\n- 参数\n\n|参数|含义|\n|:---|:---|\n|-c|建立压缩档案|\n|-z|有gzip属性的|\n|-t|查看内容|\n|-j|有bz2属性的|\n|-u|更新原压缩包中的文件|\n|-Z|有compress属性的|\n|-x|解压|\n|-v|显示所有过程|\n|-r|向压缩归档文件末尾追加文件|\n|-O|将文件解开到标准输出|\n    \n - 参数是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。右边五个参数是根据需要在压缩或解压时可选的。\n\n# 压缩\n\n|命令|作用|\n|:---|:---|\n|tar -cvf jpg.tar *.jpg|将目录里所有jpg文件打包成tar.jpg|\n|tar -czf jpg.tar.gz *.jpg| 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz|\n|tar -cjf jpg.tar.bz2 *.jpg|将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2|\n|tar -cZf jpg.tar.Z *.jpg|将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z|\n|rar a jpg.rar *.jpg rar|格式的压缩，需要先下载rar for linux|\n|zip jpg.zip *.jpg zip|格式的压缩，需要先下载zip for linux|\n\n## 解压\n\n|命令|作用|\n|:---|:---|\n|tar -xvf file.tar| 解压 tar包|\n|tar -xzvf file.tar.gz|解压 tar.gz|\n|tar -xjvf file.tar.bz2|解压 tar.bz2|\n|tar -xZvf file.tar.Z| 解压 tar.Z|\n|unrar e file.rar| 解压 rar|\n|unzip file.zip|解压 zip|\n\n- 总结\n   - `.tar `用 `tar -xvf` 解压\n   -  `.gz` 用 `gzip -d`或者`gunzip` 解压\n   -  `.tar.gz`和`.tg`z 用` tar -xzf` 解压\n   -  `.bz2` 用` bzip2 -d`或者用`bunzip2 `解压\n   -  `.tar.bz2`用`tar -xjf` 解压\n   -  `.Z` 用 `uncompress` 解压\n   -  `.tar.Z` 用`tar -xZf` 解压\n   -  `rar` 用 `unrar e`解压\n   -  `.zi`p 用 `unzip` 解压\n\n\n# 用户管理\n\n|命令|作用|\n|:---|:---|\n|sudo useradd username|创建一个新的用户username|\n|sudo passwd username| 设置用户username的密码|\n|sudo groupadd groupname|创建一个新的组groupname|\n|sudo usermod -g groupname username|把用户username加入到组groupname中|\n|sudo chown username:groupname dirname|将指定文件的拥有者改为指定的用户或组|\n\n\n# 系统管理\n\n|命令|作用|\n|:---|:---|\n|uname -a|查看内核版本|\n|cat /etc/issue| 查看ubuntu版本|\n|sudo fdisk -l| 查看磁盘信息|\n|df -h|查看硬盘剩余空间|\n|free -m|查看当前的内存使用情况|\n|ps -A| 查看当前有哪些进程|\n|kill 进程号 或者 killall 进程名 |杀死进程|\n|kill -9 进程号|强制杀死进程|","tags":["Linux","Ubuntu"],"categories":["Linux"]},{"title":"解决 \"npm err! cannot read property 'length' of undefined\"","path":"/posts/Termux-Npm-Error.html","content":"解决 Termux出现npm err! cannot read property 'length' of undefined 问题\n<!--more-->\n# 方法\n- 复制以下内容\n\n```js\n(require('os').cpus() || { length: 1 }).length\n```\n\n- 编辑\n\n```bash\nvim ../usr/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js\n```\n\n- 修改如下保存即可\n\n![修改.jpg](https://s1.ax1x.com/2018/03/11/9WmxIA.jpg)\n\n# 已知问题\n- Npm 无法升级。","tags":["Linux","Android","Termux"],"categories":["Diary"]},{"title":"Ubuntu 安装 Android Studio","path":"/posts/UbuntuAndroidStudio.html","content":"Ubuntu安装Android Studio\n<!--more-->\n\n# SDK\n## 安装 Android SDK\n- 下载SDK[传送门](https://developer.android.com/studio/index.html?hl=zh-cn)\n- 解压并移动到指定目录`tar -zxvf android-sdk-linux.tgz -C /usr/local/andriod-sdk`\nsudo mv -r /usr/local/ android-sdk-linux\n- 更改属主、属组\n ·cd /usr/local/·\n ·sudo chown -R vitan:vitan android-sdk/\n \n## 配置SDK环境变量\n- `vim /etc/profile`后添加\n\n```\nset sdk environment\nexport SDK_HOME=/usr/local/android-sdk-linux\nexport PATH=$SDK_HOME/tools:$SDK_HOME/platform-tools:$PATH\n```\n- `source /etc/profile` 使上面的配置立即生效。\n\n\n# Studio 步骤\n1.下载Android Studio [传送门](http://www.android-studio.org/)\n\n2.解压到指定目录\n`sudo tar zxvf android-studio-ide-171.4443003-linux.zip /opt/Android-Studio/`\n\n3.安装\n- cd /opt/Android-Studio/bin\n- sh ./studio.sh\n\n4.Android SDK Location选择SDK目录/usr/local/android-sdk-linux","tags":["Linux","Android","Ubuntu"],"categories":["Linux"]},{"title":"Ubuntu 安装 Eclipse","path":"/posts/UbuntuEclipse.html","content":"Ubuntu 安装 Eclipse\n<!--more-->\n**前提**\n已经安装Java JDK\n# **下载**\n[连接](http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/oxygen2)\n\n## **安装**\n- cd到文件目录\n- `tar zxvf eclipse-java-oxygen-2-linux-gtk-x86_64.tar.gz  /opt/eclipse`\n- 创建Dash Home图标\n`sudo vim /usr/share/applications/eclipse.desktop`\n\n复制下面内容\n```\n[Desktop Entry]\nEncoding=UTF-8\nVersion=1.0\nType=Application\nName=eclipse\nIcon=/opt/eclipse/icon.xpm\nExec=/opt/eclipse/eclipse\nStartupNotify=false\nStartupWMClass=eclipse\nOnlyShowIn=Unity;\nX-UnityGenerated=true\n```","tags":["Linux","Eclipse","Java"],"categories":["Linux"]},{"title":"Ubuntu 安装并配置 Java 环境","path":"/posts/UbuntuJava.html","content":"Ubuntu 安装并配置 java 环境\n<!--more-->\n# 下载\n\n[链接](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.htm)\n\n## 安装 JDK\n\n在usr目录下建立java安装目录\n```\ncd /usr\nsudo mkdir java\n```\n将jdk文件移动到java目录下并解压\n\n```\ncd /home/download\nsudo mv dk-8u161-linux-x64.tar.gz /usr/java #移动\ncd /usr/java\ntar -zxvf dk-8u161-linux-x64.tar.gz #解压\nln -s /usr/java/jdk1.8.0_121/ /usr/jdk #创建快捷方式\n```\n\n# 环境配置\n- `sudo vim /etc/profile`\n- 在最后加入\n\n```\nexport JAVA_HOME=/usr/jdk\nexport CLASSPATH=.:$JAVA_HOME/lib/\nexport PATH=$PATH:$JAVA_HOME/bin\nexport JAVA_HOME PATH CLASSPATH\n```\n- 保存退出\n- 加载配置信息`source /etc/profile`\n-  验证`java version`","tags":["Linux","Java"],"categories":["Linux"]},{"title":"Git 闯关游戏","path":"/posts/GitGame.html","content":"Git闯关游戏\n<!--more-->\n# 安装\n```\napt install ruby\ngem install githug\n```\n\n# 基本命令\n`githug play` - 默认命令，检查是否过关\n\n`githug hint` - 显示过关提示\n\n`githug reset` - 重启本关，或者重启到指定的某关\n\n`githug levels` - 显示关卡列表\n\n## 第一关（Init）\n\n紧接着，马上进入到了第一个关卡, 按照提示初始化这个这个 githug 文件夹为仓库。完成关卡可以通过调用 `githug play` 验证操作，成功则会进入下一个关卡\n\n```\ncd git_hug\ngit init\n```\n相关:\n`cd` （Change Directory），跳转目录、切换路径。\n\n`git init`在当前目录新建一个Git代码库\n\n\n\n## 第二关（Config）\n\n设置 Git 用户名和邮箱，为了不影响全局的配置，我设置的是仓库级别的。\n\n```\ngit config [--global] user.name \"[name]\"\ngit config [--global] user.email \"[email address]\"\n```\n相关:\n\n`git config git` 的设置文件为.gitconfig,他可以在全局配置（加上--global），也可以项目配置。\n\n另：\n\n`git config --lis`t 显示当前的git配置\n\n`git config -e [--global]` 编辑git的配置文件\n\n## 第三关 （Add）\n\n使用 add 命令将 README 文件添加到 staging area.\n\n```\ngit add .README\n```\n相关\n\n`git add`将所有修改过的工作文件提交暂存区\n\n将所有文件添加到暂存区`git add .`或者`git add -`A\n\ngit add .和git add -A的区别\n- `git add .`会监控工作区的状态树，使它会把工作时的所有变化提交到暂存区，包括文件内容修改（modified）以及新文件（new），但不包括被删除的文件。\n- `git add -u`（git add --update的缩写）仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u不会提交新文件（untracked file）。\n- `git add -A`（git add --all的缩写）是上面两个功能的合集。即包括修改的文件、删除的文件以及新文件。\n\n\n\n## 第四关 （Commit）\n\n提交 README 文件，记得每次 commit 使用 -m 参数加上备注是个好习惯\n```\ngit commit -m 'message'\n```\n相关:\n\n`git commit -m [message]`提交暂存区到仓库区;还可以提交暂存区的指定文件到仓库区`git commit [file1] [file2] ... -m [message]`。\n\n同时，必须要写 Commit message(提交说明),否则就不允许提交。\n\n\n- `git commit -a`提交工作区自上次commit之后的变化，直接到仓库区\n- `git commit -v`提交时显示所有diff信息,-v参数表示可以看commit的差异\n- `git commit --amend -m [message]`使用一次新的commit，替代上一次提交。如果代码没有任何新变化，则用来改写上一次commit的提交信息\n- `git commit --amend [file1] [file2] ...`重做上一次commit，并包括指定文件的新变化\n\n## 第五关（Clone)\n\n克隆一个仓库，默认的文件夹名是远端的仓库名\n```\ngit clone https://github.com/Gazler/cloneme\n```\n相关:\n\ngit clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。\n```\ngit clone http[s]://example.com/path/to/repo.git/\ngit clone ssh://example.com/path/to/repo.git/\ngit clone git://example.com/path/to/repo.git/\ngit clone /opt/git/project.git\ngit clone file:///opt/git/project.git\ngit clone ftp[s]://example.com/path/to/repo.git/\ngit clone rsync://example.com/path/to/repo.git/\n```\nSSH协议的另一种写法\n\n`git clone [user@]example.com:path/to/repo.git/`\n\n\n## 第六关（Clone to folder）\n\n同样是克隆一个仓库，不同的是可以指定一个文件夹名\n```\ngit clone https://github.com/Gazler/cloneme my_cloned_repo\n```\n相关\n\n`git clone `<版本库的网址> <本地目录名> 该命令会在本地主机生成一个目录。如果不指定目录名，则与远程主机的版本库同名。\n\n## 第七关（Ignore)\n\n忽略所有 .swp 后缀名的文件。这里使用 vim 编辑器打开 .gitignore，这个文件记录了 git 忽略文件的规则, 不会 vim 的同学可以用自己熟悉的编辑。\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fobpbvnwqlj20fr07kjt3.jpg)\n\n```\ntouch .gitignore  \necho '*.swp'>>.gitignore\n```\n\n使用正则(glob 模式)匹配所有的 .swp 文件，然后保存并退出\n\n```\n.progile.yml\n.gitignore\n*.swp\n```\n相关:\n\n忽略掉某个文件，需要修改.gitignore文件的方法。可以在你的用户目录下创建 `~/.gitignoreglobal` 文件中设置全局。\n\n1. 需要执行 git config --global core.excludesfile ~/.gitignoreglobal来使得它生效。\n- `*.a` 忽略所有 .a 结尾的文件\n- `!lib.a` 但 lib.a 除外\n-` /TODO `仅仅忽略项目根目录下的 TODO 文件，但不包括 subdir/TODO\n- `build/` 忽略 build/ 目录下的所有文件\n- `doo/*.txt` 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\n\n2. `.gitignore`只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。\n正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。\n- `git update-index --assume-unchanged PATH` 在PATH处输入要忽略的文件。\n- `git update-index --no-assume-unchanged PATH` 还原。\n\n3. 另外 git 还提供了另一种` exclude `的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去，用来保存的是公共的需要排除的文件。\n而` .git/info/exclude` 这里设置的则是你自己本地需要排除的文件。他不会影响到其他人。也不会提交到版本库中去。\n\n## 第八关（Include\n\n除了 `lib.a `文件，其他所有的 .a 后缀名的文件都忽略。和上一关的操作一样，修改 `.gitignore` 文件\n```\necho '*.a'>>.gitignore\necho '!lib.a'>>.gitignore\n```\n其中 `#` 开头的是注释，用`*.a` 匹配所有 `.a` 文件，`!` 开头代表不要忽略\n```\n.profile.yml\n.gitignore\n\n# ignore all file with \".a\" extensions expect \"lib.a\" file\n*.a\n!lib.a\n```\n## 第九关（Status)\n\n查看所有处于` untracked `状态的文件。使用` git status` 查看当前仓库的状态，可以看到红色部分就是 `untracked` 状态的文件\n```\ngit status\n```\n答案：`database.yml`\n\n相关:`git status` 显示有变更的文件\n\n## 第十关（Number of files committed）\n\n其实就是查看处于 staged 状态的文件，图中黄色部分就是，所以个数就是2\n\n```\ngit status\n```\n\n相关\n\n`git status`命令可以列出当前目录所有还没有被git管理的文件和被git管理且被修改但还未提交(git commit)的文件。\n\n- 命令中”Changes to be committed“中所列的内容是在Index中的内容，commit之后进入Git Directory。\n- 命令中“Changed but not updated”中所列的内容是在Working Directory中的内容，add之后将进入Index。\n- 命令中“Untracked files”中所列的内容是尚未被Git跟踪的内容，add之后进入Index\n\n## 第十一关（rm）\n\n有一个文件从硬盘中删除了，但是并未从 git 仓库中删除，找到它并从 git 仓库中删除。删除也是修改的一种，提交这个修改就好了\n```\ngit status\ngit rm deleteme.rb\n```\n\n相关:\n`git rm [file1] [file2] ...`删除工作区文件，并且将这次删除放入暂存区。\n\n## 第十二关（rm cached）\n\n讲一个新文件从 `staging area` 中删除。按照要求，不应该直接从硬盘上删除这个文件，只是从 Git 中删除而已。加上` --cache` 可以是文件只是从 `staging area` 中移除，不会真正的删除物理文件，如果要连这个物理文件也一起删除，请使用 `-f` 选项\n```\ngit status\ngit rm --cached deleteme.rb\n```\n\n相关:\n\n`git rm --cached [file]` 停止追踪指定文件，但该文件会保留在工作区。\n\n\n## 第十三关（stash）\n\n临时提交某个文件。这个操作在需要临时保存修改，而又不想提交的时候特别好用！而且 git 中维护了一个栈来保存，所以支持提交多次。如果需要恢复某次提交，使用 git stash apply 即可。\n```\ngit status\ngit stash\ngit status\n```\n相关:\n\n- `git stash` 用于保存和恢复工作进度。\n- `git stash` 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存。\n- `git stash list` 显示进度列表。\n- `git stash pop` [--index] [<stash>] 如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。\n如果提供<stash>参数（来自git stash list显示的列表），则从该<stash>中恢复。恢复完毕 也将从进度列表中删除<stash>。选项--index除了恢复工作区的文件外，还尝试恢复暂存区。\n- `git stash [save [--patch] [-k|--[no]keep-index] [-q|--quiet] [<message>]]` 这是第一条命令的完整版。\n- 使用参数`--patch`会显示工作区和HEAD的差异，通过对差异文件的编辑决定在进度中最终要保存的工作区的内容，通过编辑差异文件可以在进度中排除无关内容。\n- 使用`-k`或者`--keep-index`参数，在保存进度后不会将暂存区重置。默认会将暂存区和工作区强制重置。\n- `git stash apply [--index] [<stash>]` 除了不删除恢复的进度之外，其余和git stash pop 命令一样。\n- `git stash drop [<stash>]` 删除一个存储的进度。默认删除最新的进度。\n-` git stash clear `删除所有存储的进度。\n-` git stash branch <branchname> <stash>` 基于进度创建分支。\n\n\n\n## 第十四关（Rename)\n\n重命名文件。首先这个文件需要是已经是已追踪状态，才可以使用` git mv` 命令，操作完成后自动处于 `staging` 状态\n```\ngit mv oldfile.txt newfile.txt\n```\n相关:`git mv` 重命名文件\n\n## 第十五关（Restructure）\n\n移动所有 `.html` 文件到 `src` 文件夹。`git mv` 后面的第二个参数可以接受文件或目录，如果是目录，则文件会直接放入目录内，可以使用正则（glob模式）匹配所有 `.html` 文件\n```\nmkdir src\ngit mv *.html src/\n```\n相关:\n\n- mkdir(make directory) Mkdir 是一个用来在 Linux 系统下创建目录的命令。此命令属于内建命令。\n\n- `mkdir test1` 默认情况下不带任何参数运行mkdir命令会在当前目录下创建目录。\n- `mkdir test2[ test22 test222]` 创建多个目录。\n- `mkdir -p test3/test33` 递归创建多个目录。例如创建的目录包含子目录，如果找不到父目录，那么这个参数会首先帮助创建父目录。\n- `mkdir -m=r test4` 使用-m参数，给生成的新目录设置权限。参考：工作中常用Linux命令：mkdir命令\n- `mkdir -v test5` 创建目录显示信息。\n\n## 第十六关（Log）\n\n找到最新的 commit 的 hash 值。使用 git log 查看历史提交记录, 找到最新的 commit 的 hash 值，记录下来用户回答问题\n```\ngit log\n```\n答案为：`34b2fd7(commit`后 前7位)\n\n\n这里是按照倒叙排列的，最新的在最前面，`commit` 关键字后面跟着的就是这个 `commit` 的` hash`值\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fobq12k0igj20fs03ft9a.jpg)\n\n相关:\n\ngit log 显示当前分支的版本历史。\n- ` git log --stat` 显示commit历史，以及每次commit发生变更的文件\n- `git log -s [keyword]` 搜索提交历史，根据关键词\n- `git log -p [file]` 显示指定文件相关的每一次diff\n- `git log -5 --pretty --oneline` 显示过去5次提交\n- `git log --follow [file`]\n` git whatchanged [file]` 显示某个文件的版本历史，包括文件改名\n- `git log [tag] HEAD --pretty-format:%s` 显示某个commit之后的所有变动，每个commit占据一行\n- `git log [tag] HEAD --grep feature` 显示某个commit之后的所有变动，其“提交说明”必须符合搜索条件\n\n\n\n\n## 第十七关（Tag）\n\n为最新的 commit 打 `tag`。不加额外参数就是为当前 `commit` 记录` tag`, 当然可以为特定的 `commit` 打\n```\ngit tag new_tag\n```\n相关:\n- `git tag` 列出所有的tag，在控制台打印出当前仓库的所有标签\n- `git tag [tag]` 新建一个tag在当前commit\n- `git tag [tag] [commit]` 新建一个tag在指定commit\n- `git tag d [tag]` 删除本地tag\n\n## 第十八关（Push tags）\n\n将所有本地 tag 都推送到远端。--tags 参数代表将所有的 tags 都推送到远端\n```\ngit push --tags origin master\n```\n相关：\n\n默认 `git push` 不会罢 tag 标签传送到远端服务器上，只有通过显示命令才能分享标签到远端仓库。\n- ` git push origin [tagname] push` 单个 tag\n- `git push [origin] --tags push` 所有 tag\n\n\n## 第十九关（Commit amend）\n\n某个文件在上次提交中遗漏了，在那次提交中补上这个文件。 其实，使用` git commit --amend` 会进入编辑界面修改备注信息，我这里直接 `:wq` 保存并退出\n```\ngit status\ngit add forgotten_file.rb\ngit commit --amend -m 'message'\n```\n相关:\n\n`git commit --amend` 合并缓存区的修改和最近的一次commit, 然后用生成的新的commit替换掉老的. 如果缓存区没有内容, 那么利用amend可以修改上一次commit的描述.\n\n## 第二十关（Commit in feature）\n\n 为提交指定一个未来的时间。\n ```\n git commit --date 2016.10.08 -m 'message'\n #或者\n git commit --date=05.01.2018T14:00:00\n ```\n 相关:`git commit --date <date> `修改提交时间\n\n\n## 第二十一关（Reset）\n\n两个文件都被添加到了 staging area, 但是只想提交其中一个。使用 git reset 可以用仓库中的版本覆盖 `staging area` 的版本。\n```\ngit status\ngit reset HEAD to_commit_second.rb\n```\n- `git reset `使用仓库中的版本覆盖 `staging area` 中的，如果 `working directory` 该文件没有其他修改，则 `staging area` 中的修改将应用到 `working directory` 中。反之`working directory` 中的版本将被保留，丢弃 `staging area `中的修改。\n- `git checkout` 则是使用 `staging area` 的中的版本覆盖 `working directory`。\n\n相关:\nreset 命令移动 HEAD 到当前分支的一个 commit， 这可以用来撤销当前分支的一些 commit\n\n- `git reset [-q] [commit] [--] <paths>` 第一种用法是不会重置引用的，即不会修改master文件。\n- `git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [<commit>]`\n第二种用法不使用< paths > 则会重置引用，并且参数不同决定是否覆盖暂存区和工作区：\n- `git reset -mixed` 此为默认方式，不带任何参数的git reset，会退到某个版本只保留源码，回退commit和index信息，staged snapshot 被更新， working directory 未被更改。\n- `git reset -soft` 回退到某个版本，只回退了commit信息，staged snapshot 和 working directory 都未被改变 (建议在命令行执行后，再输入 git status 查看状态)\n- `git reset -hard `彻底回退到某个版本，本地的源码也会变为上一个版本的内容，即staged snapshot 和 working directory 都将回退\n\n例子：\n```\n#回退所有内容到上一版本 HEAD^的意思是最近一次的提交\ngit reset HEAD^\n#回退a.py这个文件的版本到上一个版本\ngit reset HEAD^ a.py\n#向前回退到第3个版本\ngit reset –soft HEAD~3\n#将本地的状态回退到和远程的一样\ngit reset –hard origin/master\n#回退到某个版本\ngit reset 38679ed\n#回退到上一次提交的状态，按照某一次的commit完全反向的进行一次commit\ngit revert HEAD\n```\n## 第二十二关（Reset soft）\n\n撤销上一次提交。\n```\n git reset --soft HEAD^1\n```\n相关：\n- `--soft` 参数将上一次的修改放入 staging area\n- `--mixed `参数将上一次的修改放入 working directory\n- `--hard` 参数直接将上一次的修改抛弃\n\n\n## 第二十三关（Checkout file）\n\n抛弃某一次的修改，使用上次提交的版本。checkout 和 reset 的区别参照第二十一关\n```\ngit checkout config.rb\n```\n相关:\n`git checkou`t 检出。\n\n- 创建分支` git branch branchName`\n- 切换分支`git checkout branchName`\n- 上面两个命令可以合成一个命令 `git checkout -b branchName`\n\n## 第二十四关（Remote）\n\n查看远端仓库。其实可以不加`-v`参数，加这个参数只是可以将地址也一起输出(没想到下一关就是考察这个参数，平常习惯加这个参数了。)\n```\ngit remote -v\n```\n答案：my_remote_repo\n\n相关:\n- `git remote` 不带参数，列出已经存在的远程分支\n- `git remote -v --verbose` 列出详细信息，在每个名字后面\n- `git clone -o jQuery https://github.com/jquery/jquery.git`\n`git remote` 想用其他的主机名 需要用 git clone命令的 -o 选项指定\n- `git remote show <主机名> `可以查看主机的详细信息\n- `git remote add <主机名> <网址>` 添加远程主机\n- `git remote rm <主机名>` 删除远程主机\n- `git remore rename <原主机名> <新主机名>` 远程主机的改名\n- `tail .git/config` 查看remote信息。\n\n## 第二十五关（remote url）\n\n查看远端仓库的 URL\n ```\n git remote -v\n ```\n答案：`https://github.com/githug/not_a_repo`\n\n\n## 第二十六关（pull）\n\n拉取远端仓库。\n```\ngit pull origin master\n```\n相关:\n- git push origin master 的意思就是上传本地当前分支代码到master分支\n其实可以指定分支，格式如下\n- `git pull origin remote : local`\n对应的推送的格式如下\n- `git push origin local : remote`\n需要注意的两个操作的分支顺序是相反的，记忆的方法很简单，拉取是从远端到本地，所以远端在前，而推送是从本地到远端，所以本地在前。\n\n## 第二十七关（Remote add）\n\n添加一个远端仓库\n```\ngit remote add origin https://github.com/githug/githug\n```\n\n## 第二十八关（Push）\n\n推送本地修改到远端\n```\ngit rebase origin master\ngit push origin master\n```\n相关:\n`git rebase`用于把一个分支的修改合并到当前分支。\n\n## 第二十九关（Diff）\n```\ngit diff app.rb\n```\n答案：26\n\n相关：\n- `git diff app.rb`查看文件改动\n查看 `staging area` 和 `working directory` 中文件的差异。\n- `git diff`: 查看 working directory 与 staging area 之间的差异\n- `git diff --cached`: 查看 repository 与 staging area 之间的差异\n- `git diff HEAD`: 查看 working directory 与 repository 之间的差异\n\n\n## 第三十关（Blame）\n\n查看某个文件的修改人。这个命令简直邪恶，锅终于有人背了！！！\n```\ngit blame config.rb\n```\n答案：Spider Man\n\n相关:\ngit blame得到整个文件的每一行的详细修改信息:包括SHA串,日期和作者。\n\n## 第三十一关（Branch）\n\n创建一个分支\n```\ngit branch test_code\ngit branch\n```\n\n## 第三十二关（Checkout）\n\n创建一个分支，并切换过去。其实，`git checkout -b my_branch` 就是创建一个分支，并切换过去，而且这种方法更方便，平常用的更多\n```\ngit checkout -b my_branch\n```\n\n## 第三十三关（Checkout tag）\n\n切换到某个特定的 tag\n```\ngit tag\ngit checkout v1.2\n```\n相关:\n标签可以针对某一时间点的版本做标记，常用于版本发布。\n\n列出标签\n- `Git tag` 在控制台打印出当前仓库的所有标签\n- `git tag -l 'v0.1.*'` 搜索符合模式的标签\n打标签 git标签分为两种类型：轻量标签和附注标签。轻量标签是指向提交对象的引用，标注标签则是仓库中的一个独立对象。建议使用附注标签。\n- `git tag v0.1.2-light`创建轻量标签\n- `git tag -a v0.1.2 -m \"0.1.2`版本\"创建附注标签\n- `git tag -a v0.1.1 9fbc3d0 `给指定的commit打标签\n切换到标签\n- `git checkout [tagname] `查看标签信息\n- `git show v0.1.2 `查看标签的版本信息\n删除标签\n- `git tag -d v0.1.2` 删除标签\n标签发布 git push 不会将标签对象提交到git服务器，我们需要进行显示的操作：\n- `git push origin v0.1.2 `将标签提交到git服务器\n- `git push origin -tags `将本地所有标签一次性提交到git服务器\n\n\n## 第三十四关（Checkout tag over branch）\n\n切换到某个特定的分支，但是分支名和标签名重叠了\n```\ngit checkout tags/v1.2\n```\n相关:\n`git checkout tags/v1.2` 当标签和分支名相同时，需要指定标签检出\n\n## 第三十五关（branch at）\n\n根据一个特定的提交创建新分支\n\n一种方法：\n```\ngit branch test_branch HEAD^1\n```\n第二种方法：\n```\ngit log\ngit branch test_branch -v 00740b4\n```\n找到第二条的id，输入前7位\n\n## 第三十六关（delete branch）\n\n删除一个分支\n```\ngit branch -d delete_me\n```\n\n## 第三十七关（Push branch）\n\n将分支推送到远端仓库\n```\ngit branch\ngit push origin test_branch\n```\n相关:\n- `git push origin master` 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。\n- `git push origin :maste`r省略本地的分支名,则表示删除指定的远程分支，因为这等同与推送一个空的本地分支到远程分支。等同于：git push origin --delete master\n- `git push origin `如果当前分支与远程分支直接存在追踪关系，则本地分支和远程分支都可以省略\n- `git push` 如果当前分支只有一个追踪分支，那么主机名都可以省略\n- `git push -u origin master` 如果当前分支和多个主机存在追踪关系，则可以使用 -u 选项指定一个默认主机，这样后面就可以不加任何参数使用 git push\n- `git push --all origin `不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机。\n- `git push origin --tags git push` 不会推送标签（tag），除非使用 -tags 选项\n\n\n## 第三十八关（merge）\n\n合并分支。为了简化分支模型，可以使用 `rebase` 代替，后续关卡会遇到。\n```\ngit merge feature\n```\n相关:\n`git merge`合并分支\n\n## 第三十九关（fetch）\n\n获取远端的修改，但是并不合并到当前分支。其实，`git pull` 就是 `git fetch` 和 `git merge` 组成的。\n```\ngit fetch origin\n```\n相关:\n`git fetch origin master `取回origin主机的master分支\n\n## 第四十关（rebase）\n\n```\ngit checkout feature\ngit rebase master\n```\n相关：\n- 其实不知道怎么翻译 git rebase 这个命令。大概意思是从某个提交分化出两个分支，然后其中一个分支需要将另一个分支的修改合并过来，但是又不想在提交记录上留下两个分支合并的痕迹，只留下一个分支以前后顺序记录两边的修改。\n- `git rebase` 一个分支的所有修改在另一个分支上重新应用一遍，所以在提交记录上看，会发现一个分支的所有提交在另一个分支之前或者之后。然后删除另一个被合并的分支，保持分支简洁。\n- `git rebase master feature `表示将 `feature` 上的修改在 `master` 上重新应用一遍\n- git rebase 命令主要用在从上游分支获取commit信息，并有机的将当前分支和上游分支进行合并\n\n`git rebase [-i | --interactive] [options] [--onto ] []`\n\n`git rebase [-i | --interactive] [options] –onto –root []`\n\n`git rebase –continue | –skip | –abort`\n\n## 第四十一关（rebase_onto）\n\n将版本库未打包的松散对象打包\n```\ngit rebase --onto master wrong_branch\n```\n相关:\n`git rebase --onto A B C A `代表的是你实际想要将切片放到哪个分支，B代表切片开始分支（一定要注意的问题是 B 的开闭问题，这里 rebase --onto 的机制是左开右闭）。\n\n`git rebase --onto A B~1 temp` 如果想要保留A和C的历史，就需要先在切片的末尾建立一个分支temp。这就代表把B到c之间的历史移到了A上，并且当前temp分支的历史状态就是窝想要的。\n\n## 第四十二关（repack）\n\n应用某一个提交的修改。\n```\ngit repack -d\n```\n相关:\ng`it repack [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [--window=<n>] [--depth=<n>]`\n\n`git repack -d `包装后，如果新创建的包使一些现有的包冗余，删除多余的包。同时运行 `git prune-packed` 去除多余的松散对象文件。\n\n## 第四十三关 （cherry-pick\n\n```\ngit branch\ngit log new-feature\n$git cherry-pick ca32a6da\n```\n相关:\n`Git cherry-pick` 可以选择某一个分支中的一个或几个commit来进行操作\n\n`git grep`支持各种条件搜索及正则表达式，平时用的不多，但感觉功能强大。\n\n## 第四十四关（grep）\n\n```\ngit grep TODO\n```\n相关:\n- `git grep` 查找git库里面的某段文字\n- `git grep xmmap` 查看git里面这个仓库里每个使用 ‘xmmap’ 函数的地方。\n- `git grep -n xmmap` 显示行号。\n- `git grep --name-only xmmap` 只显示文件名。\n- `git grep -c xmmap` 查看每个文件里有多少行匹配内容（line matches）。\n- `git grep xmmap v1.5.0` 查找git仓库里某个特定版本里的内容，在命令行末尾加上表签名（tag reference）。\n- `git grep -e '#define' --and -e SORT_DIRENT` 组合搜索条件：查找在仓库的哪些地方定义了‘SORT_DIRENT’。\n- `git grep --all-match -e '#define' -e SORT_DIRENT `进行或条件搜索。\n\n## 第四十五关（rename commit）\n\n重命名提交。当涉及提交修改时，应该想到 `git rebase -i` 命令，它接受可以一个参数（提交的哈希值），它将罗列出此提交之后的所有提交，然后可以对个个提交做对应的操作。\n```\ngit log master\ngit rebase -i HEAD~2\n```\n查看历史提交记录，看到需要修改的为倒数第二个，进入编辑页面，将需要改动的行的·改为·。保存退出后在弹出的第二个窗口里修改拼写错误 `commmit` 改为 `commit`\n\n## 第四十六关（squash）\n\n合并多个提交。\n```\ngit rebase -i HEAD~4\n```\n将后三个改为s\n\n\n为新的提交修改备注\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fobqvy1midj20fu07b0tz.jpg)\n\n## 第四十七关（merge squash）\n\n将某个分支上的所有修改都应用成一个提交。默认修改都将进入暂存区\n```\ngit status\ngit merge --squash long-feature-branch\ngit commit -m 'message\n```\n相关:\n`--squash` 选项的含义是：本地文件内容与不使用该选项的合并结果相同，但是不提交、不移动 HEAD ,因此需要一条额外的commit命令。其效果相当于将 another 分支上的多个 commit 合并成一个，放在当前分支上，原来的 commit 历史则没有拿过来。\n\n## 第四十八关(reorder()\n\n重新排列提交顺序。\n```\ngit log\ngit rebase -i HEAD~2\n```\n查看历史记录发现提交顺序错误，将前两行顺序调换。\n\n## 第四十九关(bisect)\n\n使用 `git log` 查看所有的提交记录，太长我就不全贴出来了，找到最开始的提交`git bisect start master f608824888b83`\n```\ngit log --reverse -p prog.rb\ngit bisect start master f6088248\ngit bisect run make test\n```\n查看最初一次为正确提交，得到版本号。执行完毕后日志里找到 “is the first bad commit” ,得到 18ed2ac。\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fobqyexrrfj20g90a60uy.jpg)\n\n`git bisect start master f608824888b83`中，master 是有 bug 的节点，`f608824888b83 `是没有 bug 的节点。\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fobr0w8f7yj20g90m8q62.jpg)\n\n相关:\n- `git bisect start`\n- `git bisect good fb088248`\n- `git bisect bad master`\n- `git bisect run make test`\n- `git bisect reset` 回到之前执行 `git bisect start` 的状态。\n\n# 第五十关（Stage lines）\n\n其实，提交文件的部分修改这种需求平时还是比较常见的，不过平时都是用 Source Tree 来操作的，但是看到这题之后，好像又开启了一扇大门。\n```\ngit status\ngit add -p feature.rb\ngit diff\ngit status\n```\n输入i编辑提交内容，删除第二个。\n\n## 第五十一关（Find old branch）\n\ngit reflog 可以列出所有的操作记录，所以找到之前忘记的信息并不是什么难事\n```\ngit reflog\ngit checkout solve_world_hunger\n```\n相关:\n- `reflog` 是 git 用来记录引用变化的一种机制。\n- `git reflog` 命令可以对 git 误操作进行数据恢复。\n\n## 第五十二关（Revert）\n\n与 `reset` 不同的是，`revert` 只会撤销当前的 `commit`，而之后的 `commit` 操作的修改还会保留，但是`reset` 还会将之后的所有` commit` 操作的修改全部退回 `staging area `或丢弃。\n```\ngit log\ngit revert HEAD^1\n```\n相关:\n\n修复提交文件中的错误：\n- `git reset --hard HEAD` 把工作目录中所有未提交的内容清空。\n- `git checkout `恢复一个文件\n- `git revert HEAD` 撤销一次提交\n\n## 第五十三关（Restore）\n\n根据之前的经验，`git reflog` 可以查看所有的操作记录，所以只要能找到误操作之前的 `commit id`，一样能够恢复现场。\n```\ngit reflog\ngit checkout bdbe33d\n```\n相关:\n\n恢复已修改的文件：\n\n## 第五十四关（Conflict）\n\n冲突处理在平常的协同工作中真是再常见不过了，需要注意的是存在冲突的文件是在 `working directory` 中的，在解决完冲突之后需要添加到 `staging area` 并提交。\n```\ngit branch\ngit merge mybranch\nvim poem.txt\ngit add poem.txt\ngit commit -m 'message\n```\n相关：\n\n其实冲突解决完成的图片丢失了，只能口述了。\n\n`<<<<<<< HEAD` 到 `=======` 之间的内容代表 `master` 分支的修改，`=======` 到 `>>>>>> mybranch` 之间的内容代表 `mybranch` 分支的修改，保留 `mybranch` 分支的修改，删除`master` 分支的修改即可，当然这些特殊符号所在行也要一并删除。\n\n![](https://ws1.sinaimg.cn/large/d71f8b2fgy1fobr4vbhrwj20fu04ut90.jpg)\n\n## 第五十五关（Submodule）\n\n`submodule `是一个很方便的将一个仓库分解成多个子模块的命令，特别是项目比较大且依赖其他 Git 项目的时候，比如 `Cocos2d-x`。虽然好用，但是门槛也相对高点，如果维护好 `submodule `还是需要好好研究一下。\n```\ngit submodule add http://github.com/jackmaney/githug-include-me\n```\n相关:\n- `git submodule add` 子模块仓库地址 路径\n\n## 第五十六关（Contribute）\n\n其实到这里已经可以算是通关，如果感兴趣的话可以到 GitHub 为这个项目贡献代码。\n\n\n参考：\n[Ryeeeeee](http://ryeeeeee.com/2016/01/04/Githug-Guide/)\n[风花花](https://www.jianshu.com/p/e8e6358e81e0)","tags":["Linux","Termux","Git"],"categories":["Diary"]},{"title":"Termux 安装 Linux","path":"/posts/TermuxLinux.html","content":"Termux安装Linux\n<!-- more -->\n\n# 安装脚本\n添加源\n```bash\necho \"deb [trusted=yes] https://yadominjinta.github.io/files/ termux    extras\" >> $PREFIX/etc/apt/sources.list\n```\n\n安装\n```bash\npkg install atilo-cn -y\n```\n\n# 使用\n```bash    \natilo [命令] [参数]\n```\n\n安装 Linux\n```bash\natilo ubuntu\n```\n\n运行 linux\n```bash\nstartubuntu\n```\n\n## 设置中文\n修改/etc/locale.gen\n```bash\nlocale-gen zh_CN.UTF-8\nexport LC_ALL=\"zh_CN.UTF-8\"\n```","tags":["Linux","Termux"],"categories":["Diary"]},{"title":"Hexo 多设备源码同步","path":"/posts/HexoDevices.html","content":"Hexo 多设备源码同步\n<!--more-->\n# 主设备操作\n## 部署 Hexo\n\n```bash\n# 在本地博客根目录下安装 hexo\nnpm install -g  hexo-cli\n# 初始化hexo\nnpm init\n# 安装依赖\nnpm install\n# 安装部署相关的配置\nnpm install hexo-deployer-git\n```\n\n## Push 源码\n\n- 新建分支后,在本地博客根目录下使用 git 指令上传项目到 Github\n\n```bash\n# git初始化\ngit init\n# 添加仓库地址\ngit remote add origin https://github.com/iVitan/ivitan.github.io.git\n# 新建分支并切换到新建的分支\ngit checkout -b hexo\n# 添加所有本地文件到git\ngit add .\n# git提交\ngit commit -m \"\"\n# 文件推送到hexo分支\ngit push origin hexo\n```\n\n# 其他设备操作\n克隆Github分支上的文件:\n\n```bash\ngit clone -b hexo  https://github.com/iVitan/ivitan.github.io.git\n```\n\n安装 Hexo\n\n```bash\n# 安装hexo\nnpm install -g hexo-cli\n# 注意这里不需要hexo初始化：hexo init；否则之前的hexo配置参数会重置\n# 安装依赖库\nnpm install\n# 安装部署相关配置\nnpm install hexo-deployer-git\n```\n\n主题 cutie\n- [下载](https://github.com/qutang/hexo-theme-cutie/releases/latest)\n\n- 相关 npm\n\n```bash\nnpm un hexo-renderer-marked --save\nnpm i hexo-renderer-markdown-it --save\nnpm i markdown-it-emoji --save\nnpm i markdown-it-mark --save\nnpm i markdown-it-deflist --save\nnpm i markdown-it-container --save\n```\n\n更新文章\n\n```bash\nhexo new \"tittle\"\n```\n\n- 分别同步到master,hexo分支\n\n\n## 后续 Push\n```bash\n# 添加源文件\ngit add .\n# Git 提交\ngit commit -m \"\"\n# 先拉原来Github分支上的源文件到本地，进行合并\n# 分支名后面的“--allow-unrelated-histories”是为了弹出“fatal: refusing to merge unrelated histories.”的错误\ngit pull origin hexo --allow-unrelated-histories\n# 比较解决前后版本冲突后，push源文件到Github的分支\ngit push origin hexo\n```\n\n# 问题\n无法Push\n\n1. 强制 Push\n\n```bash\ngit push -f origin hexo\n```\n\n2. 根目录的.gitconfig文件一般写上需要忽略的文件及文件夹\n\n```bash\n.DS_Store      \nThumbs.db      \ndb.json      \n*.log      \nnode_modules/      \npublic/      \n.deploy*/\n```","tags":["Linux","Windows","Termux","Hexo"],"categories":["Diary"]},{"title":"Git 笔记","path":"/posts/GitNote.html","content":"Git 配置笔记。\n<!--more-->\n# 基础命令\n- 文件管理\n\n|命令|解析|\n|:---|:---|\n|pwd|查看当前文件目录|\n|mkdir|创建文件|\n|touch xxx.xx|创建文件|\n|git rm xxx|从git删除文件|\n\n# 设置 SSH Key\n- 配置github账户信息\n```sh\ngit config --global user.name \"Vitan\"\ngit config --global user.email \"vitan.me@gmail.com\"\n```\n\n- 创建 SSH\n```sh\nssh-keygen -t rsa -C \"vitan.me@gmail.com\"\n```\n```sh\nssh-keygen -t rsa -C \"vitan.me@gmail.com\" -f ~/.ssh/vitan-github\n```\n- 参数含义：\n  - t 指定密钥类型，默认即 rsa ，可以省略\n  - C 设置注释文字，比如你的邮箱\n  - f 指定密钥文件存储文件名，会生成 vitan-github 和 vitan-github.pub 两个密钥文件\n\n- 复制 Key\n```sh\ncd ~/.ssh\ncat id_rsa.pub\n```\n\n- 验证 SSH\n```sh\nssh -T git@github.com\ngit config --list  #查看key配置\n```\n\n- 查看 Git 配置\n```sh\ngit config --list\n```\n\n# 其他\n```sh\ngit clone xxxx\n#克隆项目\ngit init\n# 初始化本地git仓库（创建新仓库）\ngit config --global user.name \"xxx\"\n# 配置用户名\ngit config --global user.email \"xxx@xxx.com\"\n# 配置邮件\ngit config --global color.ui true\n# git status等命令自动着色\ngit config --global color.status auto\ngit config --global color.diff auto\ngit config --global color.branch auto\ngit config --global color.interactive auto\ngit config --global --unset http.proxy\n# remove  proxy configuration on git\ngit clone git+ssh://git@192.168.53.168/VT.git\n# clone远程仓库\ngit status\n# 查看当前版本状态（是否修改）\ngit add xyz\n# 添加xyz文件至index\ngit add .\n# 增加当前子目录下所有更改过的文件至index\ngit commit -m 'xxx'\n# 提交\ngit commit --amend -m 'xxx'\n# 合并上一次提交（用于反复修改）\ngit commit -am 'xxx'\n# 将add和commit合为一步\ngit rm xxx\n# 删除index中的文件\ngit rm -r *\n# 递归删除\ngit log\n# 显示提交日志\ngit log -1\n# 显示1行日志 -n为n行\ngit log -5\ngit log --stat\n# 显示提交日志及相关变动文件\ngit log -p -m\ngit show dfb02e6e4f2f7b573337763e5c0013802e392818\n# 显示某个提交的详细内容\ngit show dfb02\n# 可只用commitid的前几位\ngit show HEAD\n# 显示HEAD提交日志\ngit show HEAD^\n# 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本\ngit tag\n# 显示已存在的tag\ngit tag -a v2.0 -m 'xxx'\n# 增加v2.0的tag\ngit show v2.0\n# 显示v2.0的日志及详细内容\ngit log v2.0\n# 显示v2.0的日志\ngit diff\n# 显示所有未添加至index的变更\ngit diff --cached\n# 显示所有已添加index但还未commit的变更\ngit diff HEAD^\n# 比较与上一个版本的差异\ngit diff HEAD -- ./lib\n# 比较与HEAD版本lib目录的差异\ngit diff origin/master..master\n# 比较远程分支master上有本地分支master上没有的\ngit diff origin/master..master --stat\n# 只显示差异的文件，不显示具体内容\ngit remote add origin git+ssh://git@192.168.53.168/VT.git\n# 增加远程定义（用于push/pull/fetch）\ngit branch\n# 显示本地分支\ngit branch --contains 50089\n# 显示包含提交50089的分支\ngit branch -a\n# 显示所有分支\ngit branch -r\n# 显示所有原创分支\ngit branch --merged\n# 显示所有已合并到当前分支的分支\ngit branch --no-merged\n# 显示所有未合并到当前分支的分支\ngit branch -m master master_copy\n# 本地分支改名\ngit checkout -b master_copy\n# 从当前分支创建新分支master_copy并检出\ngit checkout -b master master_copy\n# 上面的完整版\ngit checkout features/performance\n# 检出已存在的features/performance分支\ngit checkout --track hotfixes/BJVEP933\n# 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支\ngit checkout v2.0\n# 检出版本v2.0\ngit checkout -b devel origin/develop\n# 从远程分支develop创建新本地分支devel并检出\ngit checkout -- README\n# 检出head版本的README文件（可用于修改错误回退）\ngit merge origin/master\n# 合并远程master分支至当前分支\ngit cherry-pick ff44785404a8e\n# 合并提交ff44785404a8e的修改\ngit push origin master\n# 将当前分支push到远程master分支\ngit push origin :hotfixes/BJVEP933\n# 删除远程仓库的hotfixes/BJVEP933分支\ngit push --tags\n# 把所有tag推送到远程仓库\ngit fetch\n# 获取所有远程分支（不更新本地分支，另需merge）\ngit fetch --prune\n# 获取所有原创分支并清除服务器上已删掉的分支\ngit pull origin master\n# 获取远程分支master并merge到当前分支\ngit mv README README2\n# 重命名文件README为README2\ngit reset --hard HEAD\n# 将当前版本重置为HEAD（通常用于merge失败回退）\ngit rebase\ngit branch -d hotfixes/BJVEP933\n# 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）\ngit branch -D hotfixes/BJVEP933\n# 强制删除分支hotfixes/BJVEP933\ngit ls-files\n# 列出git index包含的文件\ngit show-branch\n# 图示当前分支历史\ngit show-branch --all\n# 图示所有分支历史\ngit whatchanged\n# 显示提交历史对应的文件修改\ngit revert dfb02e6e4f2f7b573337763e5c0013802e392818\n# 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818\ngit ls-tree HEAD\n# 内部命令：显示某个git对象\ngit rev-parse v2.0\n# 内部命令：显示某个ref对于的SHA1 HASH\ngit reflog\n# 显示所有提交，包括孤立节点\ngit show HEAD@{5}\ngit show master@{yesterday}\n# 显示master分支昨天的状态\ngit log --pretty=format:'%h %s' --graph\n# 图示提交日志\ngit show HEAD~3\ngit show -s --pretty=raw 2be7fcb476\ngit stash\n# 暂存当前修改，将所有至为HEAD状态\ngit stash list\n# 查看所有暂存\ngit stash show -p stash@{0}\n# 参考第一次暂存\ngit stash apply stash@{0}\n# 应用第一次暂存\ngit grep \"delete from\"\n# 文件中搜索文本“delete from”\ngit grep -e '#define' --and -e SORT_DIRENT\ngit gc\ngit fsck\n```","tags":["Linux","Termux","Git"],"categories":["Diary"]},{"title":"Termux 折腾记","path":"/posts/TermuxNote.html","content":"Termux oh-my-zsh 主题设置，去欢迎字等。\n<!--more-->\n\n# 软件下载\n- [官网](https://termux.com)\n- [Google Play](https://play.google.com/store/apps/details?id=com.termux)\n- [CoolApk](https://www.coolapk.com/apk/com.termux)\n- [百度网盘]( https://pan.baidu.com/s/1zNrdz8Doed0wIob7bftXwQ)密码: 7eyf\n\n# 常用快捷键\n音量-键模拟（Ctrl）键\n```\n    音量-键(Ctrl)+L 清除屏幕内容\n    音量-键(Ctrl)+C 终止当前操作\n    音量-键(Ctrl)D 退出当前会话session\n    音量+键+D Tab键（可自动补全命令或文件名）\n    音量+键+W 方向键 上（可显示前一条命令）\n    音量+键+S 方向键 下（可显示后一条命令）\n    音量+键+A 方向键 左（可左移动光标）\n    音量+键+D 方向键 右（可右移动光标）\n    音量+键+Q 显示或关闭扩展键（ESC、插入链接CTR、ALT、TAB、-、/、|以及左滑扩展键一栏可切换到全功能支持手机输入法的输入框）\n```\n\n# 常用命令\n更新\n```bash\n    termux-setup-storage 挂载Storage\n    apt update 更新源\n    apt search <query> 全文搜索可安装包\n    apt install <package> 安装软件包\n    apt upgrade 升级软件包\n    apt show <package> 显示软件包的信息\n    apt list [--installed] 列出所有（或已安装）的软件包信息\n    apt remove <package> 删除软件包\n    chmod 修改文件权限\n    chown 修改文件归属\n```\ncd 命令\n```\n    cd\n    # 你当前在 /root目录中，使用这个命令会进入 /root/bash目录，这是相对路径\n    cd bash\n    # 如果你不在 /root目录中的话，就不能用上面的相对路径了，就需要绝对路径\n    cd /root/bash\n    # 假设你当前在 /root/bash目录中，使用相对路径，你可以用这个命令进入上一级 /root目录， `..` 代表相对路径 上级目录\n    cd ..\n    # 当然你也可以用绝对路径来进入上一级 /root目录\n    cd /root\n    路径的输入zsh有个方\n```\n\nls 命令\n```bash\n    # 显示当前目录下的所有文件\n    ls -a\n    ls -a bash/log\n    # 相对路径，当前目录是 /root ，欲查看的目录是 /root/bash/log\n    ls -a /root/bash/log\n    # 绝对路径， 当前目录是 /root ，欲查看的目录是 /root/bash/log\n    #更多的命令可以用 ls --help 来查看。\n```\n\ntree 包命令\n```bash\n    # 复制当前目录内的 log.txt文件到 /var目录\n    cp log.txt /var/log.txt\n    # 复制当前目录内的 bash文件夹到 /home目录\n    cp -R bash /home/bash\n    ———————————————————————————————————————————————\n    # 复制当前目录内的所有.txt后缀的文件到 /var/log目录\n    cp *.txt /var/log\n    # 复制当前目录内的所有以 doubi开头的文件到 /var/log目录\n    cp doubi* /var/log\n    # 复制当前目录内的所有以 doubi开头 以.txt后缀结尾的文件到 /var/log目录\n    cp doubi*.txt /var/log\n    ———————————————————————————————————————————————\n    # 假设当前目录是 /root/doubi/log，要把这个目录中的所有.txt后缀的文件复制到上一级目录 /root/doubi，那么这样做\n    cp *.txt ..\n    # .. 就是相对路径，代表上一级目录，��然你也可以用绝对路径，这样更不容易出错\n    cp *.txt /root/doubi\n    ——————————————————————————————————————————————\n    # 重命名当前目录内的 log.txt文件为 log2.txt\n    cp log.txt log2.txt\n    # 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txt\n    cp log.txt /var/log1.txt\n    # 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2\n    cp -R bash /home/bash2\n    ——————————————————————————————————————————————\n    #复制当前目录内的 log.txt文件到 /var目录，但是 /var 目录中已经存着 log.txt，那么会提示 cp: overwrite `/var/log.txt'? 可以用 -f 强制覆盖\n    cp -f log /var/log.txt\n    # 复制当前目录内的 log.txt log1.txt log2.txt文件和 log233目录到 /home/log目录中\n    cp -R log.txt log1.txt log2.txt log233 /home/log\n    #更多的命令可以用 cp --help 查看。\n```\n\n# 去欢迎字\n```bash\ntouch ~/.hushlogin\n```\n\n# oh-my-zsh\n```bash\napt install git curl zsh -y\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\nchsh -s zsh\n```\n\n带字体，配色管理版\n```bash\nsh -c \"$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\" //安装\n~/.termux/colors.sh   //修改配色\n~/.termux/fonts.sh    //修改字体\n```\n\n# ssh\n```bash\napt install openssh -y\n```\n\n连接\n```bash \nssh -p443 root@主机ip\n```\n\n\n# hexo博客\ninstall\n```bash\napt update\napt install git openssh nodejs make python2 vim\nmkdir blog\ncd blog\nnpm install -g hexo\nhexo init\nnpm install\nnpm install hexo-deployer-git –save\n```\n\n- 在站点配置文件_config.yml的Deployment字段处添加并修改\n\n```bash\ndeploy:\ntype: git\nrepo: git@github.com:username/username.github.io.git\nbranch: master\n```\n\n创建ssh密钥\n```bash\ngit config –global user.name “Vitan”\ngit config –global user.email “ivitan95@gmailcom”\nssh-keygen -t rsa -C “ivitan@gmail.com”\n```\n\n添加本地私钥文件\n```bash\ncat ~/.ssh/id_rsa.pub\n```\n- 添加到 Github\n\n测试并发布 GithubPage 上\n```bash\ncd ~/blog\nhexo g\nhexo d\n```","tags":["Linux","Termux"],"categories":["Diary"]},{"title":"Hexo 常用命令","path":"/posts/Hexo-Command.html","content":"Hexo 常用命令\n<!--more-->\n# Hexo 用命令\n1. [新建文章]`hexo new \"my blog\"`\n新建的文件在hexo/source/_posts/my-blog.md\n\n2. 编译`hexo generate`\n一般部署上去的时候都需要编译一下，编译后，会出现一个public文件夹，将所有的md文件编译成html文件\n\n3. 开启本地服务`hexo server`\n这个命令，我之前已经用过了，开启本地hexo服务用的\n\n4. 部署 `hexo deploy`\n部署到git上的时候，需要用这个命令，下一篇中，我们会使用到这个命令\n\n5. 清除`publichexo clean`\n\n6. 版本更新`npm update -g`\n\n7. 主题更新\n```\ncd themes/indigo\ngit pull\n```","tags":["Linux","Termux","Hexo"],"categories":["Diary"]},{"title":"Markdown 语法","path":"/posts/Markdown.html","content":"Markdown 语法.\n <!--more-->\n# 文章开头\n```\n---\ntitle: Hexo\ndate: 2018-01-18 8:18:38\ntags: [Markdown,教程]\ncategories: 学习\ndescription: 摘要\ntoc: true\nmathjax: true\n---\n```\n\n# 如何设置文章摘要\n``<!-- more -->``\n```\n---\n  这是摘要\n<!-- more -->\n这是正文\n```\n\n## 斜体和粗体\n- 使用`` * ``和 ``**`` 表示斜体和粗体，格式如下：\n```\n*斜体*\n**粗体**\n```\n*斜体*   **粗体**\n\n# 标题\n```\n这是一个一级标题\n============================\n这是一个二级标题\n----------------------------\n### 这是一个三级标题\n```\n\n# 列表\n## 无序列表\n- 使用 `*`，`+`，`-` 表示无序列表。\n```\n+ 无序列表项 一\n\t- 子无序列表 一\n\t- 子无序列表 二\n\t\t* 子无序列表 三\n+ 无序列表项 二\n+ 无序列表项 三\n```\n\n+ 无序列表项 一\n\t- 子无序列表 一\n\t- 子无序列表 二\n\t\t* 子无序列表 三\n+ 无序列表项 二\n+ 无序列表项 三\n\n## 有序列表\n- 使用数字和点表示有序列表。\n```\n1. 有序列表项 一\n\t1. 子有序列表项 一\n\t2. 子有序列表项 二\n2. 有序列表项 二\n3. 有序列表项 三\n```\n\n1. 有序列表项 一\n\t1. 子有序列表项 一\n\t2. 子有序列表项 二\n2. 有序列表项 二\n3. 有序列表项 三\n\n# 注释\n用 `\\ `表示注释，`\\ `后面的文字解析为纯文本格式。\n\n# 分割线\n在单独的一行使用` ***` 或者 `--- `表示分割线\n\n# 删除线\n使用` ~~` 表示删除线\n\n# 绘制表格\n 绘制表格格式如下，`| `控制分列，`- `控制分行，`:` 控制对齐方式。\n```\n| Item     | Value     | Qty   |\n| :------- | --------: | :---: |\n| Computer | 1600 USD  | 5     |\n| Phone    | 12 USD    | 12    |\n| Pipe     | 1 USD     | 234   |\n```\n\n| Item     | Value     | Qty   |\n| :------- | --------: | :---: |\n| Computer | 1600 USD  | 5     |\n| Phone    | 12 USD    | 12    |\n| Pipe     | 1 USD     | 234   |\n\n\n\n#  其他\n1. 分段： ``两个回车``\n2. 换行 ``两个空格 + 回车``\n3. 标题`` #~###### ``井号的个数表示几级标题，即Markdown可以表示一级标题到六级标题\n4. 引用 ``>``\n5. 列表`` *``，``+``，``-``，``1.``，``选其中之一，注意后面有个空格\n6. 代码区块 ``四个空格开头``\n7. 链接 ``[文字](链接地址)``\n8. 图片 ``![图片说明](图片地址)``，图片地址可以是本地路劲，也可以是网络地址\n9. 强调 ``**文字**``，``__文字__``，``_文字_``，``*文字*``\n10. 图片大小\n```\n<img src=\"链接\" width =\"256\" height=256 /> //固定大小\n<img src=\"链接\" width =\"50%\" height=\"50%\" /> //一定比列\n<img src=\"链接\" width = \"450\" alt=\"图片描述\" align=center />\n```\n其中width和height后面的50%就是根据窗口的大小以一定的比例显示图片。值得一说的是，这种按照百分比显示方法，是以width方向为准，并保持纵横比的，换句话说，把设置width的部分去掉，height的值改为任意百分比，显示的图像都是原图大小（个人觉得这根博客窗口有关，毕竟现实截面的宽度相对是固定的，而高度/长度却是变化着的）。因此用此方法的时候，可以把height设置缺省。","tags":["Linux","Ubuntu","Termux","Markdown"],"categories":["Diary"]},{"title":"Hexo 安装笔记","path":"/posts/HexoInstall.html","content":"Hexo 从零开始到搭建完整\n<!--more-->\n# 准备\n## 安装 Git Bash\n[下载链接](https://git-scm.com)\n安装好后，打开 GitBash，查看版本：\n命令：`git version`  或者 `git -v`\n\n## 安装NodeJs\nHexo是基于 NodeJS 环境的静态博客，里面的npm工具很有用[下载地址](https://nodejs.org/zh-cn/)(说明：LTS为长期支持版，Current为当前最新版)\n下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量）\n\n## npm 换源\n```bash\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n# 安装hexo\n```bash\nmkdir hexo\ncd d:\\hexo\nnpm install hexo-cli -g\nnpm install\nhexo init\nnpm install hexo-deployer-git --save\n```\n\n## Github\n1. 创建一个 repo，名称为 ivitan.github.io, 其中 ivitan 是你的 Github 用户名。\n2. 回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）\n\n\n### 将博客与 Github 关联\n打开本地文件夹项目内的`_config.yml`配置文件，将其中的 type 设置为 git\n```bash\ndeploy:\ntype: git\nrepository: https://github.com/用户名/用户名.github.io.git\nbranch: master\n```\n\n## 创建 SSH Key\n```bash\ngit config --global user.name \"Vitan\"\ngit config --global user.email \"ivitan95@gmail.com\"\nssh-keygen -t rsa -C \"ivtan95@gmail.com\"\n```\n- 复制 `id_rsa.pub` 内的密匙添加到 GitHub\n\t- 验证是否添加成功：`ssh -T git@github.com`\n\n## 修改_config.yml\n```bash\ndeploy:\ntype: git\nrepo: https://github.com/YourgithubName/YourgithubName.github.io.git\nbranch: master\n```\n\n# GitBash进入blog 目录\n```bash\nhexo clean\nhexo g\nhexo s\nhexo d\n```\n- 浏览器：http://localhost:4000","tags":["Linux","Termux","Hexo"],"categories":["Diary"]},{"title":"404 Not Found","path":"//404.html","content":"<a href=\"/\"><img src=\"/img/404.svg\" title=\"返回首页\"></a>"},{"path":"/about/index.html","content":"<img height=\"45px\" alt=\"VITAN\" src=\"/assets/logo/ming.svg\">{% navbar订阅 邮箱Github网盘 %}Github"},{"title":"Dotfiles","path":"/wiki/Dotfiles/index.html","content":"<div align=\"right\">\n<a href=\"#macos\">macOS</a> · <a href=\"#windows\">Windows</a> · <a href=\"#linux\">Linux</a> · <a href=\"#scripts\">Scripts</a>\n</div>\n\n# DotFiles\n\n![](https://flat.badgen.net/badge/platform/macOS,Windows,Linux,Termux?list=|)\n\n## Windows\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/images/20200620100620.png)\n\n### PowerShell\n\n| Configurations                     | What I use                                                                                                                                                              |\n| :--------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Prompt theme engine                | [oh-my-posh](https://github.com/JanDeDobbeleer/oh-my-posh)                                                                                                              |\n| Prompt theme                       | [SpencerTechy.psm1](./Windows/SpencerTechy.psm1)                                                                                                                        |\n| Font                               | [JetBrains Mono Nerd Font](https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono)、[Sarasa Gothic](https://github.com/be5invis/Sarasa-Gothic) |\n| Color theme (for Windows Terminal) | [Snazzy](https://github.com/mbadolato/iTerm2-Color-Schemes/blob/master/windowsterminal/Snazzy.json)                                                                     |\n\nGo to [oh-my-posh](https://github.com/JanDeDobbeleer/oh-my-posh) for information on how to install. After installing, you can take a look at your oh-my-posh's profile with:\n\n```PowerShell\n$ThemeSettings\n```\n\n![](https://i.loli.net/2020/02/09/XqNatS79hdCyY1v.png)\n\nWe are looking for the directory where oh-my-posh stores all your themes. Navigate to that very directory, and put [SpencerTechy.psm1](./Windows/SpencerTechy.psm1) there. Now, you can enable this theme with:\n\n```PowerShell\nSet-Theme SpencerTechy\n```\n\nAlso, here's my PowerShell configuration profile: [ps_profile.ps1](./Windows/ps_profile.ps1) for reference. I use:\n\n- [`Get-ChildItemColor`](https://github.com/joonro/Get-ChildItemColor) for better colored `ls`\n- `scoop` as Window's package manager\n\nAnd I removed PowerShell's default alias of `curl` via:\n\n```powershell\n# Remove curl alias\nIf (Test-Path Alias:curl) {Remove-Item Alias:curl}\nIf (Test-Path Alias:curl) {Remove-Item Alias:curl}\n```\n\nSee [ps_profile.ps1](./Windows/ps_profile.ps1) for detailed information.\n\n### Windows Terminal\n\n<h6>❗ You cannot use <code>colortool</code> to apply a theme to Windows Terminal. Instead, you'll need to manually add the theme (which is in <code>JSON</code>) to Windows Terminal's configuration.</h6>\n\n- Dark variant - defined in Windows Terminal settings:\n\n  ```json\n  \"requestedTheme\" : \"dark\"\n  ```\n\n- Windows Terminal themes: [Windows Terminal Themes](https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/windowsterminal) at iTerm Color Schemes.\n\nFor more information, see [wt_profiles.json](./Windows/wt_profiles.json).\n\n## Linux\n### Termux (Andriod Terminal)\nConfig files: [`zshrc`](./Linux/Termux/zshrc)\n\n```sh\nbash -c \"$(curl -fsSL https://raw.githubusercontent.com/ivitan/DotFiles/master/Scripts/Termux.sh)\"\n```\n\n![](https://fastly.jsdelivr.net/gh/ivitan/Picture@master/imagesTermuxDotfile.png)\n\n### Arch Linux WSL (for use on Windows)\n\nConfig files: [`wsl_zshrc`](./Windows/wsl_zshrc)\n\n![](https://i.loli.net/2019/08/21/ZMhu2zobPDNWiYw.png)\n\n<details>\n\n### ArchLinux/Manjaro\n\n- ZSH config files: [`arch_zshrc`](./Linux/ArchLinux/zshrc)\n- Hyper config files: [`hyper.js`](./Linux/hyper.js)\n\n![](https://i.loli.net/2018/12/31/5c29a4c819cab.png)\n\n</details>\n\n## macOS\n\n### iTerm2\n\n<h6>🔺WARNING: Please upgrade iTerm2 to the latest 3.3 version in order to achieve the customizable \"Minimal Titlebar\" and \"Status bar\".</h6>\n\n![](https://i.loli.net/2019/08/16/DpztirnBE6yvqh7.png)\n\n- Color Scheme: [manta.itermcolors](./macOS/manta.itermcolors)\n- Set \"Tab bar height (points) for minimal theme\" to 22, under \"Preference - Advanced\".\n\n  ![](https://i.loli.net/2019/08/16/dr7Kp2SvsW6xGDt.png)\n\n- Set \"Transparency\" to near \"Opaque\", under \"Preference - Profiles - Default - Window\".\n\n### Hyper\n\n![](https://i.loli.net/2019/08/15/Nt9HMKlpJxLaE3Y.png)\n\nFully customized color scheme, see [hyper_macos.js](./macOS/hyper_macos.js)\n\n- Shell: [Oh-My-Zsh](https://ohmyz.sh/)\n- ZSH Themes: [Powerlevel10k](https://github.com/romkatv/powerlevel10k), [Pure](https://github.com/sindresorhus/pure)\n\n<h6>🔺 NOTICE: Powerlevel10k can generate the same prompt as Pure given the right configuration options. But P10K is able to deal with large git repositories much much faster. See: <a href=\"https://gist.github.com/romkatv/7cbab80dcbc639003066bb68b9ae0bbf\">romkatv/Pure style for Powerlevel10k.md</a></h6>\n\n### Window Manager - yabai\n\n![](https://i.loli.net/2019/08/15/PcK2W8JXs4xQgdw.png)\n\n[Yabai](https://github.com/koekeishiya/yabai) - a macOS Tiling WM.\n\n- [.yabairc](./macOS/yabairc)\n- [.skhdrc](./macOS/skhdrc)\n\n### Bitbar Scripts\n\n**Bitbar**: put the output from any script or program in your macOS menu bar. Scripts I use are available at: [bitbar](./macOS/bitbar)\n\n|                    Colorful battery                    |                       CPU Stats                        |\n| :----------------------------------------------------: | :----------------------------------------------------: |\n| ![](https://i.loli.net/2020/02/02/iC1olKmTRWfuBzb.png) | ![](https://i.loli.net/2020/02/02/k7cIl6vroGASYh9.png) |\n\n## Scripts\n\n<h6>Handy scripts for ricing screenshots.</h6>\n\n### Neofetch\n\n<h6>Fetch system information (with <code>--iterm2</code> option to display wallpaper.)</h6>\n\n```shell\nneofetch --iterm2\n```\n\n![](https://i.loli.net/2019/08/16/bDNKLBGAok65xZ9.png)\n\nDepends on `imagemagick`, only works with Terminals who support displaying inline images.\n\n### Colortest - [pablopunk/colortest](https://github.com/pablopunk/colortest)\n\n<h6>Quickly show all your terminal colors</h6>\n\n```shell\ncurl -s https://raw.githubusercontent.com/pablopunk/colortest/master/colortest | bash\n```\n\n![](https://i.loli.net/2019/08/16/rHUa3Qs6bDFv7LV.png)\n\n### `color.sh` - [color.sh](./scripts/color.sh)\n\n<h6>Minimal script to show terminal colors.</h6>\n\n```shell\ncurl -s https://raw.githubusercontent.com/ivitan/UnixConfig/master/scripts/color.sh | bash\n```\n\n![](https://i.loli.net/2019/08/16/ZOnMBPUSQcIrsk5.png)\n\n### 256 Color Test\n\n<h6>Print out all 256 colors in your console. See: <a href=\"https://askubuntu.com/questions/821157/print-a-256-color-test-pattern-in-the-terminal/821163#821163\">Print a 256-color test pattern in the terminal</a></h6>\n\n```shell\ncurl -s https://gist.githubusercontent.com/HaleTom/89ffe32783f89f403bba96bd7bcd1263/raw/ | bash\n```\n\n![](https://i.loli.net/2019/08/16/ZzWE4xriOKXUB6e.png)\n\n### ytop\n\n<h6>Terminal based task manager.</h6>\n\nGitHub: [cjbassi/ytop: Another TUI based system monitor, this time in Rust!](https://github.com/cjbassi/ytop)\n\n![](https://i.loli.net/2019/08/16/7dyNAfjPQgeRsl3.png)\n\n### tty-clock\n\n<h6>Terminal based clock.</h6>\n\nGitHub: [xorg62/tty-clock](https://github.com/xorg62/tty-clock)\n\n![](https://i.loli.net/2019/08/16/eRdUtOZcIa31Gf2.png)\n\n## Special Thanks\n- [github/spencerwoo98](https://github.com/spencerwoo98)\n- [elenapan/dotfiles](https://github.com/elenapan/dotfiles)\n- [reddit/r/unixporn](https://www.reddit.com/r/unixporn/)\n\n## This project base on [spencerwoo98/dotfiles](https://github.com/spencerwooo/dotfiles)\n\n## License\n\nThis is published via the [MIT License](https://github.com/ivitan/DotFiles/blob/master/LICENSE).\n\n---\n\n[@Blog](https://ivitan.com/) · [@GitHub](https://github.com/ivitan)\n\n---\n\n![visitors](https://visitor-badge.glitch.me/badge?page_id=ivitan.DotFiles)"},{"title":"Shell","path":"/wiki/Shell/index.html","content":"<p align=\"center\" class=\"has-mb-6\">\n<img class=\"not-gallery-item\" height=\"48\" src=\"/assets/logo/favicon.svg\">\n<br>\n<h2 align=\"center\">Vitan's Shell Scripts</h2>\n</p>\n\n## Termux Config\n### via curl\n```bash\nbash -c \"$(curl -fsSL https://raw.githubusercontent.com/ivitan/Shell/master/Termux/Termux.sh)\"\n```\n\n### via wget\n```bash\nbash -c \"$(wget -O- https://raw.githubusercontent.com/ivitan/Shell/master/Termux/Termux.sh)\"\n```"},{"title":"wnmp","path":"/wiki/wnmp/index.html","content":"<p align=\"center\" class=\"has-mb-6\">\n<img class=\"not-gallery-item\" height=\"48\" src=\"/assets/logo/favicon.svg\">\n<br>\n<h2 align=\"center\">WNMP</h2>\n<p align=\"center\">Windows + Nginx1.1 + PHP7.2 + MySql5.7</p>\n</p>\n\n## 结构\n```\n├─logs  ----------------- nginx日志目录 （必须有可写权限）\n├─mysql  ---------------- mysql目录\n│  ├─data  -------------- mysql数据库数据存储目录（必须有可写权限）\n├─nginx   --------------- nginx目录\n│  ├─conf  -------------- nginx配置目录\n│  │  └─vhost ----------- 虚拟站点配置目录（自动加载里面的*.conf）\n├─php ------------------- php7目录\n├─temp  ----------------- nginx temp目录 （必须有可写权限）\n└─web   ----------------- 配置站点主目录\n    ├─testphp5  --------- 测试php5站点目录\n    ├─testphp7  --------- 测试php7站点目录\n    └─phpMyAdmin  ------- phpMyAdmin站点目录\n```\n\n## 使用\n运行：Start.bat\n停止：Stop.bat"}]